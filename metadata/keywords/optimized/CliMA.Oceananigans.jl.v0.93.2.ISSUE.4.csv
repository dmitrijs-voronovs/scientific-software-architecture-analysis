quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:489,adapt,adapted,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['adapt'],['adapted']
Energy Efficiency,"@simone-silvestri . I made the change you suggested and do not allow any bathymetry within the top 100 meters, using the following lines of code. ```; bat = file_bathymetry[""bathymetry""]; bat[bat .> -100] .= 0; ```. When I plot a slice through the same region as before, we see that the bathymetry now reaches the surface, as you can see below. . I wonder whether having one point at the surface still causes problems? If the highest most point was lowered to the same level as the two points to the right, do you think this would be better behaved?. ![bat_slice_closeup1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/2e084fb3-7df5-44d3-8073-edc4a10a905f)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2009407432:103,meter,meters,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2009407432,1,['meter'],['meters']
Energy Efficiency,"@simone-silvestri : I wanted to confirm that when I try turning on topography, I get `NaN` after 30 minutes. This is with a time step of 20 seconds. When I reduce the time step by a factor of 2, it still happens at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129065140:156,reduce,reduce,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129065140,1,['reduce'],['reduce']
Energy Efficiency,"@simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this, ; ```; ∇⋅(ν∇⃗ u⃗); ```; which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way. In the future I think it would be better to have something like this, . ```; 1/h ∇⋅(ν h ∇⃗ u⃗); ```. since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936:474,reduce,reduce,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936,1,['reduce'],['reduce']
Energy Efficiency,"@simone-silvestri I plot here how the metric look for a series of overlapping conformal cubed sphere panels constructed with this PR. ```Julia; using Oceananigans; using Oceananigans.Grids; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 8, 8; H = 4. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). function plot_series_ossg(grid, filename); j_index = 2. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(grid.Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""an ossg""); lines!(ax, range_with_offset(Nx, H, 1), parent(grid.Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""another ossg""); lines!(ax, range_with_offset(Nx, H, 2), parent(grid.Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:blue, 0.5), label=""another ossg""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); save(filename, fig). return fig; end. grid = conformal_cubed_sphere_panel(size=(Nx, Ny, 1), z=(-1, 0), halo=(H, H, 1)); plot_series_ossg(grid, ""metric_test_ossg_bounded.png""). grid = conformal_cubed_sphere_panel(size=(Nx, Ny, 1), z=(-1, 0), halo=(H, H, 1), topology=(Periodic, Periodic, Bounded)); plot_series_ossg(grid, ""metric_test_ossg_periodic.png""); ```. For `Bounded` topology:. ![metric_test_ossg_bounded](https://github.com/CliMA/Oceananigans.jl/assets/7112768/39ae83dd-48af-4d95-851f-840b114fac29). For `Periodic` topology:. ![metric_test_ossg_periodic](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9c096c35-da0d-46cd-b9f4-fabc12eb3532). Isn't this what you were trying to imply they should look like?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3239#issuecomment-1711319187:575,green,green,575,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3239#issuecomment-1711319187,1,['green'],['green']
Energy Efficiency,"@simone-silvestri Will do!. At the moment I am using `momentum_advection = VectorInvariant()`. If it goes unstable I will try the one you suggested on the other PR. I also tried what you suggested on the other PR,. ```; VectorInvariant(vorticity_scheme = WENO(), kinetic_energy_gradient_scheme = WENO()); ```. This failed because of the error below. Any idea what I need to do to fix this?. ```; ERROR: LoadError: MethodError: no method matching _symmetric_interpolate_yᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{…}, ::EnergyConserving{…}, ::typeof(Oceananigans.Advection.δx_v²), ::Field{…}, ::Field{…}). Closest candidates are:; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{2}, Centered{3}, Centered{4}, Centered{5}, Centered{6}, UpwindBiased{2}, UpwindBiased{3}, UpwindBiased{4}, UpwindBiased{5}, UpwindBiased{6}, WENO}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:210; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{1}, UpwindBiased{1}}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:207; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::Any, ::VectorInvariant{<:Any, <:Any, true}, ::Any, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/Advection/vector_invariant_advection.jl:250; ... ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233:530,Energy,EnergyConserving,530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233,1,['Energy'],['EnergyConserving']
Energy Efficiency,"@simone-silvestri and I replaced a hardcoded `0.5` with `/2` as the former caused a type instability which eventually crashed the baroclinic adjustment setup after 13 days. How exactly that happened we don't know, but it definitely caused a cascade to Float64 - we believe even into the whole tendency - we shouldn't happen. With this little change Float32 runs stable even with 9th order WENO V-scheme (velocities used for smoothness estimation when reconstructing vorticity) which is Simone's preferred scheme also for global simulations. . Simone can you throw in the video and the kinetic energy comparison to Float64?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212:593,energy,energy,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212,1,['energy'],['energy']
Energy Efficiency,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244:80,adapt,adapts,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244,1,['adapt'],['adapts']
Energy Efficiency,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:815,adapt,adapt,815,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,1,['adapt'],['adapt']
Energy Efficiency,"@simone-silvestri do you have any formula for computing the local energy dissipation rate due to numerical viscosity? For the global dissipation I think evaluating the time evolution of the total KE is a good route, but I'm less sure the best method for obtaining the local dissipation rate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906:66,energy,energy,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906,1,['energy'],['energy']
Energy Efficiency,"@simone-silvestri if we accept the explanation that these numerics are motivated by the ""energy conserving form"" of the vertical advection therm, then I think we can't ignore that areas should also be invoked here:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Advection/vector_invariant_advection.jl#L153-L154. otherwise this argument is not correct. These means that. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Advection/upwind_biased_advective_fluxes.jl#L36-L43. would become. ```julia; @inline function advective_momentum_flux_Wu(i, j, k, grid, scheme::UpwindScheme, W, u) ; ; w̃ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, Az_qᶜᶜᶠ, W) / Azᶠᶜᶜ(i, j, k, grid); uᴸ = _left_biased_interpolate_zᵃᵃᶠ(i, j, k, grid, scheme, u) ; uᴿ = _right_biased_interpolate_zᵃᵃᶠ(i, j, k, grid, scheme, u) ; ; return Azᶠᶜᶠ(i, j, k, grid) * upwind_biased_product(w̃, uᴸ, uᴿ) ; end ; ```. or something? Perhaps the division should occur outside the flux, unclear. More broadly it'd be nice to see the discrete math on these written more explicitly to understand in more detail the impact of the different discretizations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529079517:89,energy,energy,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529079517,1,['energy'],['energy']
Energy Efficiency,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:277,energy,energy,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,3,"['energy', 'sustainab']","['energy', 'sustainable']"
Energy Efficiency,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:217,Reduce,Reduce,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,2,"['Reduce', 'reduce']","['Reduce', 'reduced']"
Energy Efficiency,"@tomchor After this PR, I believe there are no issues.; Except we currently have to manually adjust the actuation to match the correct value based on the pre-pickup simulation during setup. ; For example, we have to do something like this: ; ```julia; # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, window_nΔt, interval_nΔt, stride, true); run!(simulation); checkpointed_wta = simulation.output_writers[:single_output_time_average].outputs[""c1""]; checkpointed_actuations = checkpointed_wta.schedule.actuations. # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, window_nΔt, interval_nΔt, stride, false); simulation.output_writers[:single_output_time_average].outputs[""c1""].schedule.actuations = checkpointed_actuations; run!(simulation, pickup=checkpoint); ```. The point is to ensure that the actuation after the pickup matches the actuation value from before the checkpoint.; ```julia; simulation.output_writers[:single_output_time_average].outputs[""c1""].schedule.actuations = checkpointed_actuations; ```. Sorry for the confusion, [test_netcdf_timeaverage.jl](https://github.com/CliMA/Oceananigans.jl/pull/3721/files/eb7d6dac13694e830f118e19225e5b00b3de84c7#diff-60f3eb03acc634682fc82a022d0a0b32382d1e890be3057750545a3d0ada1c09) is just my minimum working example, which is modified from [test_netcdf_output_writer.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_netcdf_output_writer.jl#L639 ). So I believe that MWE I created is not really needed (it's not the original test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433135360:532,schedul,schedule,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433135360,3,['schedul'],['schedule']
Energy Efficiency,"@tomchor I think your solution might help RK3, but as you noted there is _also_ a problem with AB2:. > In this particular MWE if I switch the time-stepper to Adams-Bashforth the issue seemingly goes away (even though there's an initial jump in the pressure that I wouldn't expect), but it does persist (albeit more mildly) in more complex simulations. There's an issue somewhere in. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Simulations/run.jl#L41-L56. I'm also wondering if one issue is that we need to change the line. ```julia; aligned_Δt = schedule_aligned_Δt(sim, aligned_Δt); ```. and maybe instead have an interface where callbacks return the next time of actuation. `TimeInterval` may also need to be redesigned... the fact that we compute the next actuation time b. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Utils/schedules.jl#L65. maybe invites round-off error. To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on `TimeInterval` which should, in theory, work perfectly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147:921,schedul,schedules,921,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147,1,['schedul'],['schedules']
Energy Efficiency,@tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?. Looks like `ScalarBiharmonicDiffusivity` needed it here: https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113. Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100:58,adapt,adapting,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100,2,['adapt'],['adapting']
Energy Efficiency,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:60,reduce,reduce,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"@tomchor check out my changes to the tilted bottom boundary layer example: https://github.com/CliMA/Oceananigans.jl/pull/2333/commits/d8b455ffe1eabac34e9ef1c21ec70731eae03a74. The most important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:413,reduce,reduced,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"@tomchor does this result occur with just one OutputWriter, or do you have more than one OutputWriter being used at the same time?. Averaging collection is finalized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L179-L187. when `run_diagnostic!(wta::WindowedTimeAverage, model)` is called. But the criterion that triggers output is. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L38-L52. I have to say I don't understand why we special case `time == schedule.previous_actuation_time + schedule.interval`, since `rem(time, schedule.interval)` should be 0 and the algorithm should still work. Or am I missing something? It does seem to assume that `0` is the initial time (we could avoid that maybe by saving the initial `model.clock.time`...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535:521,schedul,schedules,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535,4,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"@tomchor suggested that the increased error might be due to errors from low-order numerics piling up over many iterations. Indeed, switching to WENO-5 + RK3 reduces the error by an order of magnitude!. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660230615917627e-6, Δ = 2.3421926760073770e-11 at t = 10 hours with θ=60 # WENO5 + RK3; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00003008535181e-6, Δ = -3.0085351809812464e-11 at t = 10 hours with θ=60 # WENO5 + RK3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828:157,reduce,reduces,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828,1,['reduce'],['reduces']
Energy Efficiency,"@tomchor this is the report from Shu deriving ENO coefficients for a finite volume scheme https://www3.nd.edu/~zxu2/acms60790S13/Shu-WENO-notes.pdf (In particular equation 2.20 which becomes equation 2.21 for uniform grids and reduces to the coefficient we used before) I can add some documentation on the WENO. . By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?. @francispoulin Cool! I'll check the convergence then. What I mean in the comments is that I use a Nonhydrostatic model which computes pressure and there is no infrastructure in Nonhydrostratic.jl for a pressure solver on a non-uniform horizontal grid (it will throw an error ""no method Pressuresolver(grid::RectilinearGrid)"". I maybe should change that test to an hydrostatic model...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386:227,reduce,reduces,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386,1,['reduce'],['reduces']
Energy Efficiency,"@tomchor, it adds up. We should try to reduce the repo file size. It’s already big.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-874992879:39,reduce,reduce,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-874992879,1,['reduce'],['reduce']
Energy Efficiency,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:183,Adapt,Adapt,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616,1,['Adapt'],['Adapt']
Energy Efficiency,"@vchuravy suggested using if-else statements instead of; ```julia; @inline incmod1(a, n) = a == n ? one(a) : a + 1; @inline decmod1(a, n) = a == 1 ? n : a - 1; ```; as it might be faster on the GPU. Also worth checking out Julia's `mod1(x, y)` function. I'll test a bunch of different mod1 functions once we have the algorithm fully working on the GPU. See also: [/r/Julia/Efficient wrap-around with 1-based indexing?](https://www.reddit.com/r/Julia/comments/6hhryc/efficient_wraparound_with_1based_indexing/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/57:373,Efficient,Efficient,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57,1,['Efficient'],['Efficient']
Energy Efficiency,"@views allocates because it creates a new view every time it runs. Not sure if that’s the issue. To avoid this we have to preallocate the view, somehow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595615905:7,allocate,allocates,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595615905,1,['allocate'],['allocates']
Energy Efficiency,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:3,schedul,schedule,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,5,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:44,schedul,schedule,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,3,['schedul'],['schedule']
Energy Efficiency,"A few additional thoughts:. This problem could be solved if we ever figure out how to adapt fields to work on the GPU (#746). We can then define `lastindex` for fields ~~properly~~ in a special way. A second solution is to define a thin wrapper `FieldData` around `OffsetArray` with a special `lastindex` method that covers the same purpose, but does not contain pointers to `grid` or `boundary_conditions` (therefore being more likely to work on the GPU, unlike `Field`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691062002:86,adapt,adapt,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691062002,1,['adapt'],['adapt']
Energy Efficiency,"A few more comments:. * Perhaps we can name `SomethingBiogeochemistry` ""BasicBiogeochemistry"". I think this is appropriate communication about the purpose of this object; large, sophisticated packages should implement their own models from the ground up.; * I think `light_attenuation_model` is too specific for `BasicBiogeochemistry`. For example, it only pertains to biology; however some models are chemistry-only. @jagoosw do you mind if I address these, and also adapt `test_biogeochemistry.jl` into a form that's close to merge-ready?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022:468,adapt,adapt,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022,1,['adapt'],['adapt']
Energy Efficiency,"A high priority on the to-do list right now is writing LES closures. I'd like to discuss the implementation here before we open a PR. I propose that we view a ""closure"" as the addition of a viscosity/diffusivity, even a constant isotropic 'molecular' diffusivity. Moving the implementation of viscosity/diffusivity to the closure will make it less painful to write closures that modify boundary conditions, as they sometimes do. In addition, we may need to implement special time-stepping methods that apply both to LES closures and diffusivities (as discussed with @jm-c, @ali-ramadhan and @SandreOuza and in #95). We may also want/need to implement LES closures that add additional 'tracers' (like subgrid scale turbulent kinetic energy) that have their own evolution equations. We'll do the easy 'eddy diffusivity' closures first, but we must keep in mind that including optional evolution equations for closure-specific tracers requires an implementation of an abstraction for equations (as discussed in #110). For now, (and for example) we can implement something like. ```julia; struct TurbulentDiffusivity{P}; u::Function; v::Function; w::Function; c::Function; params::P; end; ```; and add a field to `Model` called `closure` (perhaps). The fields of `TurbulentDiffusivity` are functions that compute stress/flux divergence for momentum and tracers at `i`, `j`, `k` (and we need them to have a common function signature to call in the time-stepping loop). In the case of constant but anisotropic diffusivity (which is currently implemented), for example, we could have. ```julia; @inline function 𝜈∇²u(closure, u, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); (; closure.params.𝜈h/Δx^2 * δx²_f2c2f(u, Nx, i, j, k); + closure.params.𝜈h/Δy^2 * δy²_f2e2f(u, Ny, i, j, k) ; + closure.params.𝜈v/Δz^2 * δz²_f2e2f(u, Nz, i, j, k); ); end. params = AnisotropicDiffusion(𝜈h, 𝜈v, ...); closure = TurbulentDiffusivity(𝜈∇²u, ..., params); ```. and then, in the time_stepping,. ```julia; ...; # u-momentum equation; @i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120:732,energy,energy,732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120,1,['energy'],['energy']
Energy Efficiency,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2012:27,efficient,efficient,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012,1,['efficient'],['efficient']
Energy Efficiency,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:156,schedul,schedules,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280,4,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"A simple fix to manage to output $\eta$ will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; ```; simulation.output_writers[:surface] = JLD2OutputWriter(model, ; (η=eta,),; indices=(:,:,,1-grid.Hz),; schedule = TimeInterval(200),; filename = ""surface"",; with_halos = false,; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259:223,schedul,schedule,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259,1,['schedul'],['schedule']
Energy Efficiency,"A simpler (but less general) solution than what is proposed above is simply to introduce a new struct:. ```julia; struct BoussinesqEquations{A, B, C, D, F, P} <: AbstractEquation; advection :: A; buoyancy :: B; coriolis :: C; diffusivity :: D; forcing :: F; pressure :: P; end; ```. This will reduce the number of fields in `Model`. We can also implement new equations 'types' that dispatch to different solvers if need be. This may also dramatically clean up the time-stepping functionality since we can pass `eq::Equation` in bulk rather than each parameter struct individually. Less general than a tuple of tendency kernels, but probably sufficient for anything we want to do in the forseeable future. We can then have a function eg `required_halo_size(eq::AbstractEquation)` that calculates the halo size according to the maximum halo size required by each of its 'terms'. Could also have an independent struct for tracer equations (or tuple of structs for each tracer). By the way, the more I think about it, the more I think that 'closure' should actually be called 'diffusivity', for clarity... cc @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-546944544:293,reduce,reduce,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-546944544,1,['reduce'],['reduce']
Energy Efficiency,"A vaguely related feature that could be addressed in this PR are ""`update_state!` callbacks"" that are called at the end of `update_state!` (rather than called at the end of a time-step on some `schedule` as `simulation.callbacks` would be). This could be used to implement hacks like overwriting `model.diffusivities`, which is a use-case discussed at . https://github.com/CliMA/Oceananigans.jl/discussions/1361. cc @tomchor @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-779845817:194,schedul,schedule,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-779845817,1,['schedul'],['schedule']
Energy Efficiency,AbstractSchedules for scheduling output and diagnostics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:22,schedul,scheduling,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,1,['schedul'],['scheduling']
Energy Efficiency,"Abstraction for ""equation"" for performance, code clarity, memory footprint reduction, and powerful user interface",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:90,power,powerful,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['power'],['powerful']
Energy Efficiency,"Actually `Array` and `CuArray` aren't `isbits`. But from what I understand, I think CUDAnative uses Adapt.jl to convert a `CuArray` to something like a `CuDeviceArray` which is `isbits` when passing arguments to CUDA kernels, which is what we would have to do to convert our `Field` structs to be `isbits`. But yeah, definitely agree about avoiding abstract and unspecified types. Comes with learning Julia I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970:100,Adapt,Adapt,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970,1,['Adapt'],['Adapt']
Energy Efficiency,"Adapt Field, AveragedField, and ComputedField for GPU, round 2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,1,['Adapt'],['Adapt']
Energy Efficiency,Adapt `DiscreteForcing` for the GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1642:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1642,1,['Adapt'],['Adapt']
Energy Efficiency,Adapt cell_advection_timescale for ShallowWaterModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307,1,['Adapt'],['Adapt']
Energy Efficiency,Adapt for `ImmersedBoundaryCondition`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2564:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2564,1,['Adapt'],['Adapt']
Energy Efficiency,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028,2,['Adapt'],['Adapt']
Energy Efficiency,"Adapt.jl isn't relevant here, that's for CPU->GPU conversions. This is a tuple operation not getting inferred properly, leading to a dynamic call to a runtime function. Those aren't supported. With 1.5, there's been a bunch of latency optimizations that have affected inference quality, e.g., when not forcing specialization on functions with `::F where F`. Your best bet here would be to step through using Cthulhu and figure out which code isn't inferring properly. If it's tough code to get though, you could always add the call to `Cthulhu.descend_code_warntype` at the place where the InvalidIRError is thrown.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673479769:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673479769,1,['Adapt'],['Adapt']
Energy Efficiency,Adapting BoundaryCondition with AbstractArray to play nice with CUDA,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/205:0,Adapt,Adapting,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/205,1,['Adapt'],['Adapting']
Energy Efficiency,"Adapting Smagorinsky seems an easy avenue. . In terms of Implicit LES, you could try using just WENO without any closure, but if you are in a true LES regime it would probably be too dissipative. A Smagorinsky viscosity combined with an energy-conserving advection scheme has been found to be less dissipative although noisier (here is an example applied to Burgers equation https://reader.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:0,Adapt,Adapting,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,2,"['Adapt', 'energy']","['Adapting', 'energy-conserving']"
Energy Efficiency,Adaptive (CFL-based) time step in the SplitExplicit solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3145:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3145,1,['Adapt'],['Adaptive']
Energy Efficiency,Adaptive time stepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/189:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189,1,['Adapt'],['Adaptive']
Energy Efficiency,Adaptive time stepping for VerticallyStretchedRectilinearGrid( ),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741,1,['Adapt'],['Adaptive']
Energy Efficiency,Adaptive time stepping through wizardry,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297,1,['Adapt'],['Adaptive']
Energy Efficiency,"Adaptive time-stepping is useful for a wide class of problems. The general strategy is to use the CFL number to compute a stable time-step. This is especially useful in problems with lots of time variability --- for example, LES of a seasonal cycle. In addition, the CFL computation can be used to stabilize the spin-up of a model, during which a transition to turbulence occurs. Some complexity is introduced by the fact that we use Adams-Bashforth time stepping (as opposed to a RK-method, which is more common and more stable), since it means we need to re-initialize the ""previous source terms"" with a forward Euler step when the time step is changed. I have been using adaptive time-stepping in my work, which along with a strategy for handling model spinup / transition to turbulence, has proven to be an important practical feature that makes running experimental simulations under different conditions much easier, since all I need to do is set my boundary conditions, and let the model run. I am then able to start dozens of LES per day (if I want to) without having to choose my time step size through a mistake-prone and time-consuming trial-and-error process --- and I am guaranteed not to waste resources with a too-short time-step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505551358:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505551358,2,"['Adapt', 'adapt']","['Adaptive', 'adaptive']"
Energy Efficiency,Adaptive time-stepping on all grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['Adapt'],['Adaptive']
Energy Efficiency,Added adapt method for scalar and scalar biharmonic diffusvity + test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3401:6,adapt,adapt,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401,1,['adapt'],['adapt']
Energy Efficiency,"Adding a Manifest + Project toml files in each validation scripts directory is a good idea!; However, if we do it while we are working on them in a PR, then the Manifest comes with an Oceananigans dependency that points to the branch, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/Manifest.toml#L1202. and the branch gets deleted after the PR is merged. . So what one would need to do is to make another PR with a Manifest pointing to the specific commit on `main` or to the next tagged release? Sounds like too much work to be sustainable...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915:600,sustainab,sustainable,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915,1,['sustainab'],['sustainable']
Energy Efficiency,Adds explanatory remark on KH power-method,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1298:30,power,power-method,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1298,1,['power'],['power-method']
Energy Efficiency,"After one iteration, the CPU and GPU u and v fields match everywhere except at; 1. north and south halos for `k=0` (bottom halo region); 2. `k = Nz` (entire level including east, west, north, south halos); 3. `k = Nz+1` (entire level excluding east, west, north, south halos). As for the w fields, they match everywhere at `k = Nz` (entire level including east, west, north, south halos). It seems like there's a difference between the CPU and GPU in filling north and south halos for u and v at `k = 0` (they're corner halos) so this could be a scheduling issue (halos are being filled in different order). But with our current numerical algorithm I don't see how a difference in the bottom corners would lead to different velocities in the topmost vertical level (leaving the interior completely untouched). The bigger issue seems to be that u, v, w all don't match at `k = Nz` (entire level including east, west, north, south halos). For this I don't really have any ideas why... # Comparing u. ```; julia> u₁_gpu .- u₁_cpu; 52×252×27 Array{Float32,3}:; [:, :, 1] =; 0.0 -2.1735f-12 1.55519f-11 -1.01398f-11 4.51001f-12 … 7.79226f-12 -5.71063f-12 -1.28999f-11 9.6465f-12 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ⋮ ⋱ ⋮ ; 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-725834361:546,schedul,scheduling,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-725834361,1,['schedul'],['scheduling']
Energy Efficiency,"After thinking about LES closures a bit more, I think your `TurbulentDiffusivity` struct with functions is really nice. . Just had a quick look at Smagorinsky in the MITgcm manual and I'm pretty sure no intermediate storage is required. For example, element-wise horizontal Smagorinsky for momentum would roughly look like; ```julia; @inline smagorinsky_νh(grid, u, v) = (νS*Δ)^2 * sqrt((δx_f2c(u)/Δx - δy_f2c(v)/Δy)^2 + (δy_f2e(u)/Δy + δx_f2c(v)/Δx)^2); ```. I think doing anisotropic minimum dissipation (AMD) would be similar (just more terms), and might make sense to do all the computations on-the-fly with no intermediate computations to reduce memory usage on a GPU. Not actually working on this issue. Just procrastinating and thinking about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-484121298:644,reduce,reduce,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-484121298,1,['reduce'],['reduce']
Energy Efficiency,"Ah #35, our second oldest open issue. I used to think it would be hard to implement but yeah if we just dispatch on `Flat` then it might be pretty easy!. Setting halo size to 0 along `Flat` dimensions should ensure we don't allocate more memory than needed. Would be interesting to benchmark 1D and 2D models before and after. Can't think of anything you missed... Don't think the pressure solver needs to change but might hit a problem there. There are plenty of 0D, 1D, and 2D tests that could be converted to use `Flat` dimensions and act as tests for eliding operations. Unit tests are always useful too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/902#issuecomment-686454471:224,allocate,allocate,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/902#issuecomment-686454471,1,['allocate'],['allocate']
Energy Efficiency,"Ah I see, would be interesting to see if it does better than an LES closure seeing as AMD can get computationally expensive (but maybe not too expensive if efficiently implemented on a GPU). I added a ""Higher-order advection schemes"" milestone which we can prioritize as necessary. I'm sure which advection schemes to use/implement will be a hot topic but for now I'm thinking these might be interesting:; * Centered 4th-order: good to have a formal higher-order scheme. May require bi-harmonic diffusion to be used effectively. We already have an implementation for tracers (#76).; * 3rd order direct space-time (DST): I think it's pretty good for passive tracers and keeping them positive, i.e. popular for biogeochemical tracers. May require us to calculate the Courant number at every time step? We have a partial implementation. (#183); * WENO? Sounds interesting/useful for LES.; * Prather?? Apparently very good and a favorite around here but requires intermediate storage and is DG in spirit, so not sure if we'll use it, especially if we move towards DG anyways. cc @sandreza this issue may of interest to you.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-486644911:156,efficient,efficiently,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-486644911,1,['efficient'],['efficiently']
Energy Efficiency,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494:522,reduce,reduce,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494,2,['reduce'],['reduce']
Energy Efficiency,"Ah neat result @navidcy, thanks for posting your solution! Indeed I doubt I set it up correctly. I went back and tried to play around with the setup a bit but no luck. Perhaps I misunderstood how to reduce down to Burgers equation but might try again a bit later with fresh eyes... Out of curiosity what numerical method did you use? That's a super clean shock!. > Also, @ali-ramadhan in your solution above I see noise forming for negative parts of the solution first. This might hint some biased in the scheme towards certain-sign velocities?. Yeah that weirded me out as well. Wasn't sure what to make of it but I decided to ignore it since I wasn't solving the right equation (or the setup was just wrong). I didn't notice any discrepency between periodic advection of a square waveform with positive and negative velocities, but I only checked using my unreliable eyeball norm. It's using the same advection schemes as Oceananigans.jl (which we've tested for convergence using positive and negative velocities). But because the prognostic variable is ρu there's an extra division by ρ since it computes fluxes of ρuu as (ρu)*(ρu)/ρ. So maybe I should be doing something like `WENO(ρ)*WENO(ρ)/WENO(ρ)` instead of just `WENO(ρ)*WENO(ρ)/ρ`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-716459705:199,reduce,reduce,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-716459705,1,['reduce'],['reduce']
Energy Efficiency,"Ah not sure we can plot `GaussianMask` since it's a struct. But yeah,. > relax velocity fields to zero [...] in the bottom 1/10th of the domain. might not be the best description of `GaussianMask` since `width` is the standard deviation of the Gaussian sponge (so the sponge decays over a lengthscale `width`). I guess if you want to reduce the spatial effect of the sponge you could reduce the `width`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733144088:334,reduce,reduce,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733144088,2,['reduce'],['reduce']
Energy Efficiency,Ah sorry I had the old benchmarks open in a different tab and forgot to copy paste them here: https://github.com/CliMA/Oceananigans.jl/pull/869#issuecomment-682190586. ```; Tartarus: Julia 1.5.0 + Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; 1 thread: 34.60 s; 4 threads: 12.00 s (2.88x); 8 threads: 7.00 s (4.94x); 16 threads: 4.93 s (7.02x); 24 threads: 4.59 s (7.54x); 32 threads: 4.25 s (8.14x); 40 threads: 4.06 s (8.52x); 48 threads: 4.19 s (8.26x) [some of the 48 cores were in use]. Satori: Julia 1.4.1 + IBM Power System AC922 (8335-GTH); 1 thread: 47.20 s; 4 threads: 21.70 s (2.18x); 8 threads: 11.30 s (4.18x); 16 threads: 7.16 s (6.59x); 32 threads: 5.40 s (8.74x); 64 threads: 4.29 s (11.0x); 128 threads: 4.14 s (11.4x); 160 threads: 4.02 s (11.7x); ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732536537:516,Power,Power,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732536537,1,['Power'],['Power']
Energy Efficiency,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:321,schedul,schedule,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825,1,['schedul'],['schedule']
Energy Efficiency,"Ah true. I suppose if you're gonna do something quick and dirty, then better be conservative than lenient. Might be nice to have a proper kernel that computes CFL but we have to reduce over the whole grid which will require an extra field to store CFL values for each grid point so maybe it's just better to do a quick conservative estimate for CFL, seeing as an accurate estimate might even be that useful as @kburns pointed out it varies a lot based on the model setup and the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-738992225:178,reduce,reduce,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-738992225,1,['reduce'],['reduce']
Energy Efficiency,"Ah yeah no that's a good question. Initially it's just because the CPUs on Buildkite (running on our machine) are more powerful than the ones on Travis so we can reduce documentation build times from 30~40 minutes down to ~20 minutes. But we also want to run higher-resolution examples and more of them, which is where more powerful CPUs is helpful, and since we have many cores available we can hopefully run/test/build many examples in parallel (#1053). And yeah maybe at some point we'll also have MPI (+ GPU?) examples which would have to run on more powerful machines that we can probably access through Buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1051#issuecomment-708042089:119,power,powerful,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1051#issuecomment-708042089,4,"['power', 'reduce']","['powerful', 'reduce']"
Energy Efficiency,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:629,adapt,adapt,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100,1,['adapt'],['adapt']
Energy Efficiency,"Ah, I see why before it was working, I was doing the reshaping under the hood from the allocated array inside the `solve!` function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139072099:87,allocate,allocated,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139072099,1,['allocate'],['allocated']
Energy Efficiency,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:196,schedul,schedule,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['schedul'],['schedule']
Energy Efficiency,"Ah, sorry that I missed that. I see that the four tendances (what I would call fluxes) are defined there as inline functions. Very nice and readable!. I agree that we need to define different calculate_tendencies. Two thoughts come to mind. 1. Can define a folder TimeSteppers_SW in the same folder as TimeSteppers and then define the corresponding tendendcies and the like for SW. This seems doable but maybe not incredibly efficient as we would need to redefine AB2 and RK3. . 2. Define ShallowWater_tendencies.jl and calculate_tendencies_ShallowWater.jl (or SW) in the src folder. That way we can use the time steppers but just have to make sure they can deal wtih both types of tendencies. I think this is doable, and maybe slightly more desirable to me. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-724898647:425,efficient,efficient,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-724898647,1,['efficient'],['efficient']
Energy Efficiency,"Ah, the arguments are transposed: you want to reduce _to_ a `view`, from some `AbstractArray` that has a GPU-able `getindex`. The type of the object _being_ reduced may not be the issue here (it's not `SubArray`; it's `AbstractField`). The purpose of our custom mapreduce functions is to unwrap the ""reduced"" target array, called `r` here:. https://github.com/CliMA/Oceananigans.jl/blob/d170d4bd369cc3ff43fc986db6d540cdf6af6350/src/Fields/mapreduce_abstract_fields.jl#L14. We don't touch `a`, because we don't need to --- as long as we can call `getindex` on the GPU on `a` we are good, I believe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845612822:46,reduce,reduce,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845612822,3,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"Ah, we just need `Adapt` for `ContinuousForcing`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010#issuecomment-701447763:18,Adapt,Adapt,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010#issuecomment-701447763,1,['Adapt'],['Adapt']
Energy Efficiency,"Ahh I see now, thank you very much! That is very clear. May I ask why you have implemented it this way? Wouldn't it be easier to add and subtract the term off each diagonal element rather than deep copy the constructors? It certainly simplifies the `update_diag!` function but is it more efficient overall?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989:288,efficient,efficient,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989,1,['efficient'],['efficient']
Energy Efficiency,"Ali and Greg, thanks for your comments. I found the exchange very; enlightening. John. On Tue, Jun 25, 2019, 7:49 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Adaptive time-stepping is useful for a wide class of problems. The general; > strategy is to use the CFL number to compute a stable time-step. This is; > especially useful in problems with lots of time variability --- for; > example, LES of a seasonal cycle. In addition, the CFL computation can be; > used to stabilize the spin-up of a model, during which a transition to; > turbulence occurs.; >; > Some complexity is introduced by the fact that we use Adams-Bashforth time; > stepping (as opposed to a RK-method, which is more common and more stable),; > since it means we need to re-initialize the ""previous source terms"" with a; > forward Euler step when the time step is changed.; >; > I have been using adaptive time-stepping in my work, which along with a; > strategy for handling model spinup / transition to turbulence, has proven; > to be an important practical feature that makes running experimental; > simulations under different conditions much easier, since all I need to do; > is set my boundary conditions, and let the model run. I am then able to; > start dozens of LES per day (if I want to) without having to choose my time; > step size through a mistake-prone and time-consuming trial-and-error; > process --- and I am guaranteed not to waste resources with a too-short; > time-step.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQVQYODJTMVZ46AOA3TP4JLCFA5CNFSM4H3I7NT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODYRBT7Q#issuecomment-505551358>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQS54XWGGG7MKQWZZELP4JLCFANCNFSM4H3I7NTQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505609983:173,Adapt,Adaptive,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505609983,2,"['Adapt', 'adapt']","['Adaptive', 'adaptive']"
Energy Efficiency,"Ali, can I think of this as a shallow water model that knows about reduced; gravity? John. On Wed, Apr 21, 2021, 1:45 PM Ali Ramadhan ***@***.***> wrote:. > This PR adds an eddying aquaplanet validation experiment that's still a; > work-in-progress (early stage PR).; >; > The idea is to force a HydrostaticFreeSurfaceModel on a CubedSphereGrid; > with a ""tradewind-like"" zonal wind stress pattern akin to Marshall et al.; > (2007); > <https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSphere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:67,reduce,reduced,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['reduce'],['reduced']
Energy Efficiency,"Ali,. The non rotating case looks great !; Congrats !. Jean-Michel. On Thu, Apr 08, 2021 at 03:57:28PM -0700, Ali Ramadhan wrote:; > Some nice surface gravity waves without rotation!; > ; > https://user-images.githubusercontent.com/20099589/114105606-0cfa1180-989b-11eb-8650-695d056f7140.mp4; > ; > With Coriolis the corner looks like it's complaining (I tried both energy and enstrophy conserving Coriolis)...; > ; > https://user-images.githubusercontent.com/20099589/114106008-e4bee280-989b-11eb-9a12-7846c21500f4.mp4; > ; > @christophernhill had some suggestions for things to double check:; > ; > > In the ""flux form"" then it would be good to double check if averaging is barj(bari(u)) and bari(barj(v)) - those are well defined.; > > These; > > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-cdscheme-gu; > > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-gu-fv; > > show the two forms....; > ; > ; > -- ; > You are receiving this because you were mentioned.; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816284063",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816324866:366,energy,energy,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816324866,1,['energy'],['energy']
Energy Efficiency,"Ali,; changes to; - Poisson (div v etc) and; - diagnosing w from continuity instead of stepping forward the vertical mtm; equation; are major algorithmic changes.; Important to do an extended integration to make sure nothing is broken.; Free convection?; Did the divide or multiply by del_t get sorted out?; John. On Thu, May 23, 2019 at 8:50 PM Ali Ramadhan <notifications@github.com>; wrote:. > Now that the velocity field is truly incompressible in time.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/233; > Commit Summary; >; > - Update thermal bubble golden master output.; >; > File Changes; >; > - *M* test/thermal_bubble_golden_master_10.nc; > <https://github.com/climate-machine/Oceananigans.jl/pull/233/files#diff-0>; > (0); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/233.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/233.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/233?email_source=notifications&email_token=AKXUEQXNYO4M3IXQPZJTXITPW43ULA5CNFSM4HPLKXNKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVS43WA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTT25U7Q4S3UQHKFGTPW43ULANCNFSM4HPLKXNA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495690445:1557,Green,Green,1557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495690445,1,['Green'],['Green']
Energy Efficiency,"All of that said, I suspect that the changes in this PR are important --- it's just that we need to clarify the difference between a `Field` that is _sliced_ in a certain direction, and a `Field` with a `Nothing` location. My only point is that I don't think we should conflate these concepts. I can't figure out if this PR is conflating these or not. One consequence is: the free surface will _not_ be a reduced field. This design was the primary motivation for PR https://github.com/CliMA/Oceananigans.jl/pull/2246.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248244264:405,reduce,reduced,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248244264,1,['reduce'],['reduced']
Energy Efficiency,AllSchedule for combining scheduling criteria and avoiding checkpointing with NaNs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:26,schedul,scheduling,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,1,['schedul'],['scheduling']
Energy Efficiency,Alright I think `WENO5` is fully working now and good to be merged. Some comments about the contents of this PR:; 1. For now we have a fast and accurate `WENO5` implementation.; 2. We can look at optimizing the `WENO{N}` schemes down the road. They are currently are very experimental since they allocate tons of memory and only define the left-biased interpolants. I'll need to think a bit to get both left- and right-biased interpolants working so I'm proposing merging `weno_nth_order.jl` as-is. It still works and looks good if you run `periodic_advection.jl` with `WENO{N}` with positive velocities.; 3. I added a _temporary_ thermal bubble verification to quickly test whether advection schemes behave responsible near boundaries. We can remove it when we have a better (and more rigorous) test/verification.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699497422:296,allocate,allocate,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699497422,1,['allocate'],['allocate']
Energy Efficiency,"Alright so I decided to compromise so the NaN checker is always correct. Now it goes back to checking for NaNs in the entire field (halos included). But to reduce the performance impact, the simulation's default NaN checker only checks once every 100 iterations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-732960955:156,reduce,reduce,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-732960955,1,['reduce'],['reduce']
Energy Efficiency,"Also something that confused me initially was why the arrays are dimension 4. That's explained by this line:. https://github.com/JuliaGPU/CUDA.jl/blob/92f1001861641cb173af49454b05c91728cbfc3d/src/mapreduce.jl#L167. ```julia; # allocate an additional, empty dimension to write the reduced value to.; # this does not affect the actual location in memory of the final values,; # but allows us to write a generalized kernel supporting partial reductions.; R′ = reshape(R, (size(R)..., 1)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845601283:227,allocate,allocate,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845601283,2,"['allocate', 'reduce']","['allocate', 'reduced']"
Energy Efficiency,"Also this doesn't blow up, right? I think with increasing energy, eventually nonlinearities and numerical diffusion would kick in. The integrated KE might exhibit oscillatory behavior on long time-scales. (The example in the OP only blows up because the `TimeStepWizard` increases the time step too much.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762:58,energy,energy,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762,1,['energy'],['energy']
Energy Efficiency,"Also, do we want to add documentation about this to the output writers? It could surprise some users that their time-step is forcibly changed by output. For people using adaptive time-stepping this is a non-issue (their time-step is constantly changing anyways), but for people with constant time-steps, the effect of alignment is more noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-736141239:170,adapt,adaptive,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-736141239,1,['adapt'],['adaptive']
Energy Efficiency,Amazing! I hadn't appreciated how powerful `add_callback!` was until now!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2097000301:34,power,powerful,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2097000301,1,['power'],['powerful']
Energy Efficiency,"An alternative solution is to make `Clock` an immutable struct then redefine `tick!(clock, Δt)` to `tick!(model, Δt)` which creates a new clock and assigns it to `model.clock`. This allocates memory would could become an issue for 1D models though (but maybe we're fine with that for now as 1D models have much large inefficiencies). But if we end up going back to `time, iteration` function signatures, then we'll end up introducing a second breaking change...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599081935:182,allocate,allocates,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599081935,1,['allocate'],['allocates']
Energy Efficiency,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:566,adapt,adapt,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,2,['adapt'],['adapt']
Energy Efficiency,"Another abstraction I think would be useful is a utility for building multiple outputs. Imagine this:. ```julia; indices = (xy=(:, :, k), xz=(:, 1, :), yz=(1, :, :)); sliced_outputs!(simulation, outputs, indices; schedule=TimeInterval(1), filename=""sliced""); ```. this would append `filename` with the keys of `indices`, eg we would get 3 outputs titled `""sliced_xy""`, `""sliced_xz""`, and `""sliced_yz""`. I personally find myself using `indices` the most for this kind of thing but others might have additional input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375774486:213,schedul,schedule,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375774486,1,['schedul'],['schedule']
Energy Efficiency,"Another design is to use something like . ```julia; set_Δt!(sim, new_Δt); ```. While overloading `setproperty` is nicer syntax, it is a little implicit to do an all reduce within setproperty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3336#issuecomment-1760201985:165,reduce,reduce,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3336#issuecomment-1760201985,1,['reduce'],['reduce']
Energy Efficiency,"Another idea after talking with @josuemtzmo: add another function called `checkpoint!(simulation, schedule)` that adds a checkpointer with an automatically generated name. (More to come on this idea)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2393923610:98,schedul,schedule,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2393923610,1,['schedul'],['schedule']
Energy Efficiency,"Another issue is that I believe one cannot embed `AveragedField`s into `AbstractOperations` on the GPU, despite that we have developed the abstraction and machinery so that everything does work as expected on the CPU. Embedding `AveragedField`s in `AbstractOperations` is needed to calculate things like turbulent kinetic energy and so is important for LES. Currently there's a custom field `TurbulentKineticEnergy` in the `LESbrary.jl` for this purpose:. https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/turbulent_kinetic_energy.jl. It might be good to come up with a list of `AbstractOperations` that we would like to work on the GPU eventually, and then write tests for them and add them in a PR. We can then `@test_skip` them until either we figure out how to solve the issue or, perhaps, the julia compiler changes in a way that makes the tests pass... :-D",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738298190:322,energy,energy,322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738298190,1,['energy'],['energy']
Energy Efficiency,Another option is to use a model proposed by [Pizzo et al. 2019](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2019_Pizzo_Melville_Deike-Journal_of_Physical_Oceanography_vol_49.pdf) and described in the appendix of [Lenain and Pizzo 2020](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2021/01/2020_Lenain_Pizzo-Journal_of_Physical_Oceanography_vol_50.pdf). This is conveniently expressed in terms of the friction velocity / momentum flux rather than wind speed at 10 meters.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055871038:487,meter,meters,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055871038,1,['meter'],['meters']
Energy Efficiency,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:62,schedul,schedulers,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516,7,['schedul'],"['schedule', 'schedulers']"
Energy Efficiency,"Another solution is to increase the amount of energy in the initial condition, which leads to strong numerical dissipation at the beginning and yields a smoother solution at later times...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442661794:46,energy,energy,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442661794,1,['energy'],['energy']
Energy Efficiency,"Another thought. I was reading how the MITgcm sets up the boundary conditions for the pressure solver [here](http://mitgcm.org/public/r2_manual/latest/online_documents/node20.html). The docs discuss how the boundary condition in terms of the nonhydrostatic pressure is an inhomogeneous Neumann (derivative) in the vertical at the surface, but can be rewritten as a homogeneous Neumann (derivative) condition using a source-charge, a la Williams 1969. . I looked at where the code solves the pressure problem [here](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/horizontally_periodic_pressure_solver.jl) and it seems to be solving a homogeneous Neumann (derivative) boundary condition for ressure. It's doing the same thing for GPU's as well as CPU's, so this doesn't explain any there is a difference, but can someone tell me if this source-charge method is used to make the boundary condition homogeneous?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735244136:423,charge,charge,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735244136,2,['charge'],['charge']
Energy Efficiency,"Another way to construct a reduced field could be. ```julia; u, v, w = model.velocities. U = mean(u, dims=(1,)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-652649598:27,reduce,reduced,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-652649598,1,['reduce'],['reduced']
Energy Efficiency,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:202,schedul,schedule,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904,7,['schedul'],['schedule']
Energy Efficiency,"Apart from `overwrite_existing` default, it seems like we have consensus that we should use `add_output_writer!` for this PR. I'll make that change and switch over the examples as well. I'll open an issue to discuss the `outputinfo` utility. I also think that an `output!` function would be useful, which simply writes the current state. Recently I have been found myself wanting only the final state of the simulation. It's a little convoluted to have to set up an output writer with a schedule for that task, it'd be easier to write. ```julia; run!(simulation); output!(""cool_stuff.jld2"", simulation); ```. in the above, the filename goes first because that's the thing being ""modified"" (similar to how `save` works)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433135341:487,schedul,schedule,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433135341,1,['schedul'],['schedule']
Energy Efficiency,"Apparently something breaks in this bugfix. Forgetting about the tilted buoyancy stuff for a while, even when the buoyancy isn't tilted this results in accumulating energy. In the simulation below I'm just using `buoyancy = BuoyancyTracer()` and aligning the stratification accordingly:. https://user-images.githubusercontent.com/13205162/233681167-b3d21670-ddd4-47fe-92e6-5227fb2cf344.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518031264:165,energy,energy,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518031264,1,['energy'],['energy']
Energy Efficiency,"As an optimistic aside: zeroing out halo regions to calculate horizontal averages is nice as the `sum!` function reduces along singleton dimensions so with essentially zero additional code we can have a fast diagnostic for zonal means, meridional means, vertical profiles, cross-stream profiles, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-525547052:113,reduce,reduces,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-525547052,1,['reduce'],['reduces']
Energy Efficiency,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] 2D QG turbulence: explore energy and enstrophy cascades; - [ ] lee wave generation and breaking (will require large-scale flow field and bathymetry),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/159:176,energy,energy,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/159,1,['energy'],['energy']
Energy Efficiency,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/442:207,reduce,reduce,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442,1,['reduce'],['reduce']
Energy Efficiency,"At the moment I'm playing with rectilinear and lon-lat grids, so those are the ones that I'm thinking about. However, I appreciate that we want these methods to work on all the grids that we support. . On these two grids, we could use the difference operators without any concern, for both the vertical component of vorticity and the horizontal component of divergence. No problem there. If you use Green's theorem to rewerite the integral of a vorticity as a circulation integral, then we should be able to rewrite the horizontal divergence using Gauss' divergence theorem as a line integral. Maybe that would generealize better to more exotic grids?. I will look at the paper you cited. Thanks for pointing this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956:399,Green,Green,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956,1,['Green'],['Green']
Energy Efficiency,"Attempt to close #3260. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```; ```Julia; JLD2OutputWriter scheduled on TimeInterval(3.333 minutes):; ├── filepath: ./surface.jld2; ├── 1 outputs: η; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB; ```. (with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3261:402,schedul,schedule,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3261,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,Available Potential Energy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297:20,Energy,Energy,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297,1,['Energy'],['Energy']
Energy Efficiency,"Averaging operations does not allocate any extra memory and is more performant than precalculating a field, storing the data, and then taking the average of that. In general, you only need 3D scratch space if you have 3D output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612:30,allocate,allocate,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612,1,['allocate'],['allocate']
Energy Efficiency,"Awesome! And to be more clear, I think the reason we want it to work is so that we can also reuse all the other schedules. Another reason to use it is because we may need to change `TimeInterval` in the future if we support different time types (for example `DateTime`, or other time types that solve the annoying problem of rounding error). So in all those cases it will be nice not to have to worry about different implementations of time interval schedules.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994:112,schedul,schedules,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994,2,['schedul'],['schedules']
Energy Efficiency,"Awesome! I'm happy to sit down and chat. I've had two meetings today with; MIT groups (ocean engineering and self-assembly lab), so maybe next week...; ;-). Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Fri, Oct 30, 2020 at 3:52 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Fun pair programming sesh with @ali-ramadhan; > <https://github.com/ali-ramadhan> @whitleyv <https://github.com/whitleyv>; > lead to this!; >; > [image: flow_around_cylinder]; > <https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif>; >; > Implementation is here:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl; >; > and the script that produced the above animation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl; >; > We just did something very simple as a starting point --- hopefully more; > to come.; >; > @weymouth <https://github.com/weymouth> thanks for your insights ---; > could make sense to schedule a meeting sometime soon to discuss next steps.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJYHOUF5GATVQ66VU7TSNLOMHANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719715164:1169,schedul,schedule,1169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719715164,1,['schedul'],['schedule']
Energy Efficiency,"Awesome! The two solvers do pretty different things at this point because; CuFFT doesn't do DCTs or r2r transforms but I've also baked in some; performance optimizations to reduce memory access and operation count. We; should be able to hide some of it away with dispatch but some of the; optimizations are baked into the time stepping so not completely... Might be easier to talk in person when we meet later today?. On Tue, Mar 5, 2019, 9:00 AM Gregory L. Wagner <notifications@github.com>; wrote:. > I'm going to work on this. I would also like to improve the solver; > implementation. Why are there different spectral solvers; > <https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/src/spectral_solvers.jl#L4>; > for different devices; > <https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/src/spectral_solvers.jl#L215>?; > Can we combine them into one type with the Device as a type parameter?; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/102#issuecomment-469689574>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ATKyBV5TY3u4FjjnraBoJT3fw5L4JqWNks5vTnhggaJpZM4bahv3>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469691219:173,reduce,reduce,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469691219,1,['reduce'],['reduce']
Energy Efficiency,"B1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `76.54% <0.00%> (-5.28%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.07% <0.00%> (-0.55%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `95.23% <0.00%> (-0.12%)` | :arrow_down: |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | ... and [44 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881?src=pr&el=footer). Last update [810a3a1...9128ab2](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-682318992:3185,Power,Powered,3185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-682318992,1,['Power'],['Powered']
Energy Efficiency,B; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Current Temp : 44 C; Memory Max Operating Temp : 85 C; Power Readings; Power Management : Supported; Power Draw : 44.85 W; Power Limit : 300.00 W; Default Power Limit : 300.00 W; Enforced Power Limit : 300.00 W; Min Power Limit : 150.00 W; Max Power Limit : 300.00 W; Clocks; Graphics : 135 MHz; SM : 135 MHz; Memory : 877 MHz; Video : 555 MHz; Applications Clocks; Graphics : 1290 MHz; Memory : 877 MHz; Default Applications Clocks; Graphics : 1290 MHz; Memory : 877 MHz; Deferred Clocks; Memory : N/A; Max Clocks; Graphics : 1530 MHz; SM : 1530 MHz; Memory : 877 MHz; Video : 1372 MHz; Max Customer Boost Clocks; Graphics : 1530 MHz; Clock Policy; Auto Boost : N/A; Auto Boost Default : N/A; Voltage; Graphics : N/A; Fabric; State : N/A; Status : N/A; Processes : None; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:22321,Power,Power,22321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,5,['Power'],['Power']
Energy Efficiency,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:287,adapt,adapt,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432,1,['adapt'],['adapt']
Energy Efficiency,"Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750:1176,schedul,schedule,1176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750,1,['schedul'],['schedule']
Energy Efficiency,"Based on the discussion with @iuryt on slack I realized that our ""Installation instructions"" session was a bit barebones. Here's attempt to re-write with a bit more explanation and ""hand-holding"", which I think will help users in general. Basically I think we need to touch on how to install Julia (both for personal computers and HPC systems), since that's often the hardest step, and also touch on running the simulations on HPC systems when you need GPUs (which basically means you have to deal with the job scheduler). This is only my first draft, but suggestions are welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312:511,schedul,scheduler,511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312,1,['schedul'],['scheduler']
Energy Efficiency,"Basically a ""callback"" is a way to run any function that takes a `Simulation` as an argument at a given schedule? Be it a function that prints things, updates model parameters (like `TimeStepWizard`) or whatever?. If so, I'm very much onboard with this feature :+1:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885815090:104,schedul,schedule,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885815090,1,['schedul'],['schedule']
Energy Efficiency,"Basically whenever I set a writer with `AveragedTimeInterval` where `interval` is the same as `window`, I get the following warnings:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ```. The call I'm using is something like that:. ```julia; simulation.output_writers[:averages] =; NetCDFOutputWriter(model, outputs,; filepath = @sprintf(""avg.%s.nc"", simname),; schedule = AveragedTimeInterval(2seconds; window=2seconds, stride=1),; ); ```. Note that if I change the schedule line to . ```julia; schedule = AveragedTimeInterval(2seconds; window=1.9seconds, stride=1),; ```. The warning gets suppressed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1274:723,schedul,schedule,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274,3,['schedul'],['schedule']
Energy Efficiency,"Because the string in constructed by iterating over. https://github.com/CliMA/Oceananigans.jl/blob/d7d146bc59f966d65eb66a875c16679bef365130/src/Utils/schedules.jl#L176. which includes the separators `"", ""`. So, we want to remove the separator from the very end of the string.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1622119946:150,schedul,schedules,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1622119946,1,['schedul'],['schedules']
Energy Efficiency,"Before proceeding further, I guess we should discuss a bit on whether we want a single parameter for gravitational acceleration (`effective_gravitational_acceleration`, which can encapsulate both gravitational acceleration `g` and reduced gravity `g'` terms) or two parameters (one for `g` and `g'` each), with Navid's code above an example of the latter. I am inclined towards the former as I feel it's cleaner (scientifically and for coding purposes), but happy to go either ways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471462772:231,reduce,reduced,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471462772,1,['reduce'],['reduced']
Energy Efficiency,"Below is a minimal working example of the problem:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(Float64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:614,schedul,schedule,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,2,['schedul'],['schedule']
Energy Efficiency,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209:142,adapt,adapted,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209,2,"['adapt', 'sustainab']","['adapted', 'sustainable']"
Energy Efficiency,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16164,schedul,schedule,16164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170,1,['schedul'],['schedule']
Energy Efficiency,Btw KernelAbstractions has a `ones`/`zeros`/`allocate` function.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936109289:45,allocate,allocate,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936109289,1,['allocate'],['allocate']
Energy Efficiency,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:991,Adapt,Adapt,991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Adapt'],['Adapt']
Energy Efficiency,"Building up OutputWriters can be a major source of boilerplate in ""production"" scripts that often involve multiple types of output (slices at different locations, different types of averages, etc). An example is:. https://github.com/glwagner/EadyTurbulence/blob/master/initial_value_problem/eady_initial_value_problem.jl. I think the point is more or less that output writers are often related to one another. For example, we typically want all our output in a single directory, and on the same schedule. I also pretty much always use `force=true` (I guess the equivalent for NetCDF is ""clobber"" mode). Is there a way to reduce this boilerplate or is it a fact of Oceananigans life? Can we specify some output parameters in `Simulation` rather than in each `OutputWriter` individually? Resolving #1163 might help but I'm not sure. It does seem to make sense to coordinate the output directory through the `Simulation` rather than each output writer individually. But this also contradicts some of what was discussed on #963, such as using the keyword `filepath` rather than `prefix` and `dir`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1171:495,schedul,schedule,495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1171,2,"['reduce', 'schedul']","['reduce', 'schedule']"
Energy Efficiency,But question: floats need adaptation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826:26,adapt,adaptation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826,1,['adapt'],['adaptation']
Energy Efficiency,But there's a big difference in the dynamics of course; with `buoyancy=nothing` then we just have 2D turbulence whereas with stratification (very strong here relative to the initial velocity perturbations) the energy does not dissipate as strongly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442579461:210,energy,energy,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442579461,1,['energy'],['energy']
Energy Efficiency,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:84,Adapt,Adapt,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372,2,['Adapt'],['Adapt']
Energy Efficiency,Calculation via $$\log_2(\vert \frac{progn}{tend} \vert)$$. with $progn$ being the prognostic variable (zonal velocity above) and $tend$ being the tendency taken as two consecutive time steps from the output. It's not exactly that obv because the AB2 time stepper works a bit differently but it's probably good enough! So this quantity is essentially the orders of magnitude (as power of 2) that the prognostic variables are larger than the tendencies. This is equivalent to the mantissa bits of precision lost in the addition of the two.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256:379,power,power,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256,1,['power'],['power']
Energy Efficiency,Calling `similar(f)` returns a field at the same location and with identical boundary conditions as `f` for `f::Field` and `f::ReducedField`. cc @christophernhill,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1539:127,Reduce,ReducedField,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1539,1,['Reduce'],['ReducedField']
Energy Efficiency,"Can we reduce the MWE even more? Why not `Nx, Ny, Nz = 4, 4, 4`? And `stop_time=30`?. Also, can you post the code to plot?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435830614:7,reduce,reduce,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435830614,1,['reduce'],['reduce']
Energy Efficiency,Can you explain? Why does a function like `read_output` depend on whether the time step is constant? Why does any part of the code need to assume a constant time-step?. I think adaptive time-stepping is useful in many scenarios and the time-step should not be assumed constant in general.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462546680:177,adapt,adaptive,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462546680,1,['adapt'],['adaptive']
Energy Efficiency,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:438,reduce,reduce,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,1,['reduce'],['reduce']
Energy Efficiency,Can't reduce `FieldTimeSeries` with non-default indices,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:6,reduce,reduce,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,1,['reduce'],['reduce']
Energy Efficiency,Can't reduce some `KernelFunctionOperation`s on the GPU with `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:6,reduce,reduce,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['reduce'],['reduce']
Energy Efficiency,Can't use kwarg `velocities` with `HydrostaticFreeSurfaceModel` for pre-allocated fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2341:72,allocate,allocated,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2341,1,['allocate'],['allocated']
Energy Efficiency,Cannot construct GPU models on PowerPC architectures: `ERROR: cfunction: closures are not supported on this platform`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:31,Power,PowerPC,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['Power'],['PowerPC']
Energy Efficiency,Changed the title slightly as it is being adapted: https://github.com/CliMA/Oceananigans.jl/blob/bf767af3c40c049ebc9499b7553065a9ef350178/src/ImmersedBoundaries/partial_cell_bottom.jl#L72-L84,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562:42,adapt,adapted,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562,1,['adapt'],['adapted']
Energy Efficiency,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866:538,schedul,schedule,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866,1,['schedul'],['schedule']
Energy Efficiency,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3795 by changing the default configuration of `NonhydrostaticModel` to `hydrostatic_pressure_anomaly = CenterField(grid)`. The spurious large-scale flow is developed due to numerical noise in the buoyancy field when the hydrostatic pressure anomaly is treated explicitly. When hydrostatic pressure anomaly is computed using the implicit integral of the buoyancy field, no spurious kinetic energy is introduced.; Here's the MWE as in https://github.com/CliMA/Oceananigans.jl/issues/3795:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3796:444,energy,energy,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796,1,['energy'],['energy']
Energy Efficiency,"Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=h1) Report; > Merging [#148](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/068da17959c1e125e4d1f9e62f0e287370f4de71?src=pr&el=desc) will **increase** coverage by `0.05%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #148 +/- ##; ==========================================; + Coverage 65.97% 66.03% +0.05% ; ==========================================; Files 19 19 ; Lines 629 630 +1 ; ==========================================; + Hits 415 416 +1 ; Misses 214 214; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80.76% <100%> (+0.76%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=footer). Last update [068da17...bcfacda](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/148#issuecomment-475479721:1705,Power,Powered,1705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/148#issuecomment-475479721,2,['Power'],['Powered']
Energy Efficiency,"Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=h1) Report; > Merging [#378](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/8c1c776b50df17ff10735e57488f22b20d455303?src=pr&el=desc) will **decrease** coverage by `0.05%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #378 +/- ##; ==========================================; - Coverage 78.37% 78.32% -0.06% ; ==========================================; Files 22 22 ; Lines 1244 1241 -3 ; ==========================================; - Hits 975 972 -3 ; Misses 269 269; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=footer). Last update [8c1c776...3e13ace](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/378#issuecomment-525945184:1705,Power,Powered,1705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/378#issuecomment-525945184,1,['Power'],['Powered']
Energy Efficiency,"CompatHelper: bump compat for ""Adapt"" to ""3.0""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287:31,Adapt,Adapt,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287,1,['Adapt'],['Adapt']
Energy Efficiency,"CompatHelper: bump compat for Adapt to 4, (keep existing compat)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3409:30,Adapt,Adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409,1,['Adapt'],['Adapt']
Energy Efficiency,Compute third stage time-step for RK3 in a way that reduces the accumulation of error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3617:52,reduce,reduces,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3617,1,['reduce'],['reduces']
Energy Efficiency,"Conditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:16051,schedul,schedule,16051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['schedul'],['schedule']
Energy Efficiency,Conservatively adapt ReducedField for GPUs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1354:15,adapt,adapt,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1354,2,"['Reduce', 'adapt']","['ReducedField', 'adapt']"
Energy Efficiency,"Consider:. * The Adams-Bashforth time stepper is not well-suited for adaptive time-stepping, because it requires a initialization step. Thus it behooves scientists to update their time-step only infrequently. * However, during model spinup / transition to turbulence, a sharp change in flow regime may occur. This sharp change necessitates updating the time-step frequently to avoid blow up (an alternative strategy is to take uniform small time-steps during this time, which is safer but will take longer). * In addition to the need to update a time-step frequently near transition to turbulence, it is *also* wise to take conservatively small time-steps . Because of these considerations I am not sure it makes sense to add `spinup_cfl`, which only addresses the last, minor point. The main feature that is needed is a change in the frequency at which the time-step is updated (we currently do this manually by writing two loops). However, a change in update frequency is only really needed because Adams-Bashforth is ill-suited for adaptive time stepping (otherwise it'd be fine to update frequently even in the main loop). So it's a hack-on-a-hack. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520824946:69,adapt,adaptive,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520824946,2,['adapt'],['adaptive']
Energy Efficiency,"Converted `benchmark_static_ocean.jl` to do a strong scaling test on a 256³ simulation when `Threads.nthreads() > 1`. Results are pretty sweet for multithreading that we basically got for free from KernelAbstractions.jl. Not sure what kind of speedups to expect for multithreading though. Maybe @leios, @christophernhill, or @vchuravy have a better idea. Some results on number of threads and wall clock time per time step:. # Tartarus. ```zsh; #!/bin/zsh; for threads in 1 4 8 16 24 32 40; ~/julia-1.5.0/bin/julia --project -t $threads benchmark_static_ocean.jl; ```. ```; Julia 1.5.0 + Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. 1 thread: 3.78 s; 4 threads: 1.35 s (2.8x); 8 threads: 839 ms (4.5x); 16 threads: 585 ms (6.5x); 24 threads: 551 ms (6.9x); 32 threads: 539 ms (7.0x); 40 threads: 483 ms (10.6x); 48 threads: 479 ms (10.7x); ```. # Satori. ```bash; #!/bin/bash; for threads in 1 4 8 16 32 64 128 160; do JULIA_NUM_THREADS=$threads julia --project benchmark_static_ocean.jl; done; ```. ```; Julia 1.4.1 + IBM Power System AC922 (8335-GTH). 1 thread: 5.13 s; 4 threads: 2.44 s (2.1x); 8 threads: 1.35 s (3.8x); 16 threads: 796 ms (6.4x); 32 threads: 637 ms (8.0x); 64 threads: 503 ms (10.2x); 128 threads: 501 ms (10.2x); 160 threads: 511 ms (10.0x); ```. A beautiful scene from Satori:. ![image](https://user-images.githubusercontent.com/20099589/91370150-96ad1100-e7db-11ea-9bf2-12e40de5ff93.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/869:1022,Power,Power,1022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/869,1,['Power'],['Power']
Energy Efficiency,"CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/averaged_field.jl:61; [16] top-level scope; @ REPL[55]:1; [17] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); ```. <details>; <summary>Manifest</summary>. ```; (Oceananigans) pkg> st -m; Project Oceananigans v0.58.1; Status `~/Oceananigans.jl/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.14; [ab4f0b2a] BFloat16s v0.1.0; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v3.2.1; [72cfdca4] CUDAKernels v0.2.1; [7057c7e9] Cassette v0.3.6; [d360d2e6] ChainRulesCore v0.9.44; [34da2185] Compat v3.30.0; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:12175,Adapt,Adapt,12175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Adapt'],['Adapt']
Energy Efficiency,"Copy pasting from @glwagner's fork. Adaptive time stepping with a `TimeStepWizard` that computes time steps for you. I just need to modify `time_step!` with a flag like `first_step_Euler=true` to take forward Euler steps at first iteration and when changing the time step, but with the ability to turn it off for tests where we actually don't want to do this. . I'll add some more docstrings and a couple of tests. cc @sandreza . Resolves #189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297:36,Adapt,Adaptive,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297,1,['Adapt'],['Adaptive']
Energy Efficiency,Could be a failure of `Adapt.jl`'s method for tuples and named tuples:. https://github.com/JuliaGPU/Adapt.jl/blob/a62a2568f1199d0e7b154eb6001afa629d31038e/src/base.jl#L3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-668065550:23,Adapt,Adapt,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-668065550,2,['Adapt'],['Adapt']
Energy Efficiency,"Couple thoughts from a discussion with @ali-ramadhan today:. To get `DiskTimeSeries` working with `JLD2OutputWriter`, we'll need to 1) serialize the grid (mostly for convenience...) and 2) serialize ""meta"" for fields by adding lines like. ```julia; file[""serialized/grid""] = model.grid. for (i, out) in enumerate(outputs); field_name = keys(outputs)[i]; out isa AbstractField && (file[""timeseries/$field_name/meta/location""] = location(out)); end; ```. to the `JLD2OutputWriter` constructor. We need a bit of extra work for `ReducedField`... though on second though it might be easier to build this logic into `DiskTimeSeries`. Some logic for serializing boundary conditions might be nice too (sometimes, but not always possible). This, plus changing the default `FieldSlicer` to `nothing`, are the primary changes that's needed for `JLD2OutputWriter`, I think. For `NetCDFOutputWriter`, the field location needs to be saved as a string in the field's attributes. I think we have what we need to reconstruct the grid otherwise. @ali-ramadhan can comment. I think we also want to make the default `field_slicer` to `nothing` so that the framework is friendly. The broadcasting infrastructure being developed on #1596 will make analysis with Oceananigans fields even nicer (since we can bypass `ComputedField` and launch kernels / make computations immediately via julia's broadcasting syntax).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204:525,Reduce,ReducedField,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204,1,['Reduce'],['ReducedField']
Energy Efficiency,"Coverage Diff @@; ## master #1083 +/- ##; ==========================================; + Coverage 56.76% 56.79% +0.03% ; ==========================================; Files 161 161 ; Lines 3793 3796 +3 ; ==========================================; + Hits 2153 2156 +3 ; Misses 1640 1640 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <ø> (ø)` | |; | [src/TimeSteppers/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy91cGRhdGVfc3RhdGUuamw=) | `87.50% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `87.93% <100.00%> (+0.21%)` | :arrow_up: |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `76.31% <100.00%> (+0.64%)` | :arrow_up: |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `79.16% <100.00%> (+0.29%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=footer). Last update [e2c1ee4...6dc402c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1083#issuecomment-713749219:2313,Power,Powered,2313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1083#issuecomment-713749219,1,['Power'],['Powered']
Energy Efficiency,"Current implementation of `dot(::Field, ::Field)` is slow and allocates a lot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2725:62,allocate,allocates,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725,1,['allocate'],['allocates']
Energy Efficiency,"Currently it takes 6-7 minutes to compile before the model will start running on the GPU. This is expected but is there a way to compile once and run multiple times, or even to reduce the compile time? Maybe this is the price we pay for zero-cost high-level abstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66:177,reduce,reduce,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66,1,['reduce'],['reduce']
Energy Efficiency,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:10,schedul,schedules,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,3,['schedul'],['schedules']
Energy Efficiency,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1140:235,reduce,reduce,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140,1,['reduce'],['reduce']
Energy Efficiency,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1182:816,allocate,allocate,816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182,1,['allocate'],['allocate']
Energy Efficiency,"Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an example, if `reduced_dim=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:1881,reduce,reduced,1881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['reduce'],['reduced']
Energy Efficiency,Derivatives of a reduced field over an Immersed boundary,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588:17,reduce,reduced,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588,1,['reduce'],['reduced']
Energy Efficiency,"Difference`. The ""biased"" operators would presumably only be used for interpolation, and by biased advection schemes. But we still want a unified implementation, since `Centered{N}` is used by both interpolation and differencing. The new syntax for operators would be. ```julia; δxᶠᵃᵃ(i, j, k, grid::AbstractGrid, order::AbstractOperatorOrder, c); ```. ### A global default stored in `grid` might make sense. We may want to add a type parameter to grid so we can write something like. ```julia; δxᶠᵃᵃ(i, j, k, grid::AbstractGrid, args...) = δxᶠᵃᵃ(i, j, k, grid, grid.order, args...); ```. We want to allow the operators to be controlled independent of the global `grid.order` for advection schemes and for differencing pressure. The above function, the default `grid.order == Centered{2}`, and specialization of the advection and pressure differencing operations will I think ensure that all existing code works as it did previously, I think. ### Boundary conditions need to know about `grid.order`. Our implementation of boundary conditions assumes second-order operators. We would need to dispatch on `grid.order` in `fill_halo_regions!` to support higher-order differentiation. This is eminently doable, just a fair amount of busy work / arithmetic. . A nice bonus is that we would be able to change how high-order advection schemes mutate close to the boundary. For example, if we are using both fourth-order advection and fourth-order diffusion, we don't need to limit to second-order advection at the boundary, since halos will be filled consistent with fourth-order operations. In the implementation I am outlining, this requires using `grid.order` in our ""topologically conditional interpolation"":. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Advection/topologically_conditional_interpolation.jl. For WENO5 with fourth-order diffusion, we just need to switch to fourth-order advection close the boundary. This is potentially a powerful increase in global accuracy of our methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744021493:2474,power,powerful,2474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744021493,1,['power'],['powerful']
Energy Efficiency,Do we want to be able to compute Available Potential Energy (APE) to get an idea as to the energtics of a flow?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297:53,Energy,Energy,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297,1,['Energy'],['Energy']
Energy Efficiency,"Do you mean saving outputs in Fourier space?. The objective of this PR is only to enable multi-GPU support for the nonhydrostatic model through MPI. ; Saving in Fourier space is independent of the single/multiple GPU framework and could be worked on as an independent PR.; I am not very sure you would want such a feature though, maybe a feature to automatically build power spectra and cospectra would be nice",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178894494:369,power,power,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178894494,1,['power'],['power']
Energy Efficiency,Does this reduce performance or is the effect negligible? (Just curious.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044:10,reduce,reduce,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044,1,['reduce'],['reduce']
Energy Efficiency,"EDIT: We can't set the locations of _all_ `Field` to `Nothing`. So I'm changing this issue topic to a discussion of whether we should support 1- and 2-argument functions for `set!` (when 2 or 1 directions are `Flat`), and also `dropdims` the `Flat` dimensions in `interior`. Previously:; This would allow us to use two- or one-argument function specification in `set!`, as well as two- and two-dimensional indexing. It might also make sense to `dropdims` `Nothing` locations when outputting raw field data... (it makes broadcasting with reduced fields, etc more difficult, but probably makes _most_ activities easier, like plotting)... ?. This would automagically solve @francispoulin's pain provided that `Flat` vertical topologies are enforced in the constructor for `ShallowWaterModel`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1655:537,reduce,reduced,537,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1655,1,['reduce'],['reduced']
Energy Efficiency,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509:0,Efficient,Efficiently,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509,1,['Efficient'],['Efficiently']
Energy Efficiency,Eliminate the previous rectilinear grids in favour of a general RectilinearGrid that is optionally stretched in any direction. Should be ready to merge.... Comments and to-do (in a future PR); - All grids except for `ConformalCubedSphereGrid` have an architecture field which means we should (a) include architecture in `ConformalCubedSphereGrid` and (b) remove architecture from all Models and Fields and let it be inferred by the grid (this might be a lot of work); - Nonhydrostatic Pressure solver is specified only for HRegRectilinearGrid (horizontally regular) and RegRectilinearGrid (fully regular). Specify pressure solver also for a non-regular grid? ; - Maybe: adapt the FFTTridiagonalSolver to grids with X and Z regular or Y and Z regular (might be useless because if a simulation requires a non-uniform direction that can just be set to be the z direction and would save us some coding),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050:670,adapt,adapt,670,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050,1,['adapt'],['adapt']
Energy Efficiency,Energy/enstrophy conserving schemes for Coriolis,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818:0,Energy,Energy,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818,1,['Energy'],['Energy']
Energy Efficiency,Error when writing `Field`s reduced over 3 dimensions to NetCDF,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:28,reduce,reduced,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['reduce'],['reduced']
Energy Efficiency,"Exactly! We have to allow for `h` getting close to zero, maybe even zero, but never anything negative. . Using this for the density seems like a good way to be efficient, but then we also have to make sure how it's used in the model Seems doable, one just has to be careful and worry about the details. I need to think more about `Δz`, but thanks for sharing your thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115546770:160,efficient,efficient,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115546770,1,['efficient'],['efficient']
Energy Efficiency,Feel free to press the green button @maeckha! (PR owners are given the responsibility to merge their PRs unless they state otherwise.) Thanks for your contribution!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872220747:23,green,green,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872220747,1,['green'],['green']
Energy Efficiency,"Finally all tests pass 🎉 Thanks @navidcy and @vchuravy for all your help!. @glwagner Let me know when it would be a good time to merge this PR and tag a new release. Ran the incompressible model benchmarks and in general it seems that with Julia 1.6 Oceananigans allocates more memory and is a bit slower on the CPU but a bit faster on the GPU. # Quick benchmark. ## Julia 1.6. ```; Oceananigans v0.57.2; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.996 ms │ 5.047 ms │ 5.113 ms │ 5.770 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 34.951 ms │ 35.967 ms │ 36.414 ms │ 41.417 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 301.074 ms │ 301.964 ms │ 302.498 ms │ 307.989 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 256 │ 2.894 s │ 2.895 s │ 2.895 s │ 2.896 s │ 1.77 MiB │ 2301 │ 2 │; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:263,allocate,allocates,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118,1,['allocate'],['allocates']
Energy Efficiency,"Firstly, thanks to both of you for pointing out the importance of the CFL in maintaining realistic simulation results. Switching to a lower time step/ lower CFL timestep-wizard fixed my problems in some other simulations I was trying to run, such as one of Couette flow and an Ekman spiral. Both of the simulations suffered from massive CFLs. Also, thanks @navidcy for mentioning a reduced grid size. It made the simulations run in a more reasonable amount of time. Here's a gif from the Couette flow that had a horrifying CFL, but now works.; ![Couette U-Velocity](https://user-images.githubusercontent.com/55706146/100040250-bee8e380-2dbb-11eb-867e-6b33d9a6c364.gif). Also, the in depth description of Rayleigh-Taylor instability from @glwagner was quite interesting, and thanks for taking the time to show me how to properly set up a simulation of highly nonlinear dynamics such as this. I didn't realize that numerical instability was such a problem beforehand. Lastly, thank you @glwagner for offering to help me set up a basic model, but for now I think all my issues have been fixed with other simulations I was trying thanks to the CFL advice, so those will suffice for now; still, thanks for the great help you've both already given. Thanks for all the work you put into Oceananigans too; it's quite fascinating and I can't wait to explore more.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-732663976:382,reduce,reduced,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-732663976,1,['reduce'],['reduced']
Energy Efficiency,Fix `_immered_cell` and adapt for `PartialCellBottom`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682:24,adapt,adapt,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682,1,['adapt'],['adapt']
Energy Efficiency,Fix `set!` for cubed sphere reduced fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1622:28,reduce,reduced,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1622,1,['reduce'],['reduced']
Energy Efficiency,Fix test for implicit free surface with `ImmersedBoundary` and indexed `ReducedField`s,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723:72,Reduce,ReducedField,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723,1,['Reduce'],['ReducedField']
Energy Efficiency,Fixes writing of 3d-reduced `Field`s to NetCDF,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865:20,reduce,reduced,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865,1,['reduce'],['reduced']
Energy Efficiency,Fixes writing of 3d-reduced `Field`s to NetCDF while pinning `GPUArrays`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2898:20,reduce,reduced,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2898,1,['reduce'],['reduced']
Energy Efficiency,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:293,energy,energy,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168,1,['energy'],['energy']
Energy Efficiency,"Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:88; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; ```. I'm not really sure how to fix this one...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:14596,schedul,schedule,14596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['schedul'],['schedule']
Energy Efficiency,"Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); @ GPUArrays /glade/work/tomasc/.julia/packages/GPUArrays/Zecv7/src/host/mapreduce.jl:10; [14] #maximum!#707; @ ./reducedim.jl:895 [inlined]; [15] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, No",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:21320,reduce,reducedim,21320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871,1,['reduce'],['reducedim']
Energy Efficiency,"Following up on @johncmarshall54 's comments, it would also be fun to do this with `ShallowWaterModel`. In that context, if we change gravity to be a reduced gravity, it should be very similar. That would require solving the model on a cubed sphere, which I hope to do sometime in the not so distant future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824307566:150,reduce,reduced,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824307566,1,['reduce'],['reduced']
Energy Efficiency,"For documentation purposes, I write here the three different unwinding treatment formulations:. #### `OnlySelfUpwinding`. - divergence flux: $u \left( \overline{[\delta_i U; D] + \delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u} +v\left( \overline{ \delta_i U + [\delta_j V; D] }^j \right)\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j \right)\frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `CrossAndSelfUpwinding`. - divergence flux: $u \overline{[D; D]}^i \frac{\boldsymbol{i}}{b_u}+ v \overline{ [D; D] }^j\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j\right) \frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `VelocityUpwinding`. - divergence flux: $u \left( \delta_i \overline{[U; U]}^i + \overline{\delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u}+ v\left( \overline{ \delta_i U} + \delta_j\overline{[V; V] }^j \right) \frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\delta_i \overline{[u^2; u^2]}^i + \delta_i \overline{v^2}^j\right)\frac{\boldsymbol{i}}{\Delta x_u}+ \left(\delta_j \overline{u^2}^i + \delta_j \overline{[v^2; v^2]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### For all three formulations; - vertical advection: $\delta_k \left(\overline{W}^i \overline{[u; u]}^k \right)\frac{\boldsymbol{i}}{b_u} + \delta_k \left( \overline{W}^j \overline{[v; v]}^k\right) \frac{\boldsymbol{j}}{b_v}$. where $D = \delta_i U + \delta_j V$, $U = Ax \cdot u$, $V = Ay \cdot v$, $W = Az \cdot w$ and $b = \Delta x \cdot \Delta y \cdot \Delta z$. $[u; v]$ refers to a WENO biased reconstruction of $u$ using $v$ as a smoothness measure. Upwinding is always performed with respect to the velocity corresponding to the reconstruction d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777:326,energy,energy,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777,2,['energy'],['energy']
Energy Efficiency,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:275,schedul,schedule,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,1,['schedul'],['schedule']
Energy Efficiency,For example:; https://buildkite.com/clima/oceananigans/builds/17468#0191fc2c-b421-4cf7-80b5-0429336b1d7f; https://buildkite.com/clima/oceananigans/builds/17473#0191fd88-d8b9-48d5-9c7f-18efc6747ea7; I believe this is because we are launching the docs from many different branches on a relatively small GPU. I think it would be best to move this test on the caltech cluster. Since the caltech cluster works with a slurm scheduler this error would never happen (I can open a PR to fix this),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779:418,schedul,scheduler,418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779,1,['schedul'],['scheduler']
Energy Efficiency,"For future reference, this is what the KE evolution looks like for the simulation with Δt=10 s:. ![Screenshot_20230223_144849](https://user-images.githubusercontent.com/13205162/221052306-22881de1-a2e1-4107-a3a4-749896e70cbd.png). And, for comparison, this is what is looks like for the same simulation but with `buoyancy=nothing`:. ![image](https://user-images.githubusercontent.com/13205162/221052579-168ce258-e5ec-471a-bdf3-015ce5a9913f.png). The latter figure looks way more reasonable to me (with only about 2.5% of energy lost due to numerics).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442558213:521,energy,energy,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442558213,1,['energy'],['energy']
Energy Efficiency,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677:798,reduce,reduce,798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677,2,['reduce'],['reduce']
Energy Efficiency,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747:907,reduce,reduce,907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747,1,['reduce'],['reduce']
Energy Efficiency,"For some cases, we _want_ these two parameters to be different (eg to ""slow down"" the free surface wave speed by using reduced gravity). But it might be friendly to some unsuspecting users to throw a warning in the constructor for `HydrostaticFreeSurfaceModel`, just in case this was not intended. cc @simonbyrne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2148:119,reduce,reduced,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2148,1,['reduce'],['reduced']
Energy Efficiency,For sure. The trick about the global environment is just Julia knowledge. But it is relevant to efficient workflows for testing so we can indeed put it there. Personally I don't test just one file unless I am debugging major refactors but perhaps others do it differently...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395:96,efficient,efficient,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395,1,['efficient'],['efficient']
Energy Efficiency,"For the ""model setup"" section of the documentation where we'll describe how to use the `TimeStepWizard` to choose adaptive time steps, I was thinking it would be good to recommend some CFL values. I think with 2nd-order Adams Bashforth we're limited to CFL < 0.5, so I'm thinking of recommending to start with CFL = 0.3 then decrease if issues are encountered. I usually run with 0.15 < CFL < 0.3. @glwagner What do you usually run with?. @jm-c @christophernhill Any wisdom from MITgcm?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/353:114,adapt,adaptive,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/353,1,['adapt'],['adaptive']
Energy Efficiency,"For; ```julia; schedule = AveragedTimeInterval(a, window=b); ```; It must be the case that a > b. If a = b or a < b the end result will produce NaNs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1288:15,schedul,schedule,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1288,1,['schedul'],['schedule']
Energy Efficiency,"From a MWE similar to the one in #3899 (adding some more reduced directions):; ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10)); bottom(x, y) = - rand() * 5 # Between -5 and 0; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). f1 = Field{Center, Center, Nothing}(grid); f2 = Field{Center, Nothing, Center}(grid); f3 = Field{Nothing, Center, Center}(grid); set!(f1, (x, y) -> rand()); set!(f2, (x, y) -> rand()); set!(f3, (x, y) -> rand()). fig = Figure(); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); ax3 = Axis(fig[1, 3]); heatmap!(ax1, f1); heatmap!(ax2, f2); heatmap!(ax3, f3); ```; <img width=""1174"" alt=""Screenshot 2024-11-05 at 12 26 38 PM"" src=""https://github.com/user-attachments/assets/fc22559f-2615-4e3e-b687-52f40ac5cd4e"">. Should we add some tests?. closes #3899",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3900:57,reduce,reduced,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3900,1,['reduce'],['reduced']
Energy Efficiency,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588:144,reduce,reduced,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588,3,"['Reduce', 'reduce']","['Reduced', 'reduced']"
Energy Efficiency,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:474,reduce,reduce,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,4,"['efficient', 'monitor', 'reduce']","['efficient', 'monitor', 'reduce']"
Energy Efficiency,Fun pair programming sesh with @ali-ramadhan @whitleyv lead to this!. ![flow_around_cylinder](https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif). Implementation is here:. https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl. and the script that produced the above animation:. https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl. We just did something very simple as a starting point --- hopefully more to come. @weymouth thanks for your insights --- could make sense to schedule a meeting sometime soon to discuss next steps.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414:625,schedul,schedule,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414,1,['schedul'],['schedule']
Energy Efficiency,"Future work:. 1) Make sure that the symmetric flux of buoyancy is very small, even on a stretched grid, etc; 2) Adapt the taper factor calculation to be boundary-friendly; 3) Also make sure the slope calculation is boundary-friendly. I don't really know how to do (3) so we need @jm-c help for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631:112,Adapt,Adapt,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631,1,['Adapt'],['Adapt']
Energy Efficiency,"GFyeUNvbmRpdGlvbnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0% <ø> (ø)` | :arrow_up: |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `93.75% <100%> (+0.89%)` | :arrow_up: |; | [src/Utils/with\_tracers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `73.68% <100%> (ø)` | :arrow_up: |; | [src/Models/model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `91.66% <100%> (ø)` | :arrow_up: |; | [...nditions/solution\_and\_model\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zb2x1dGlvbl9hbmRfbW9kZWxfYm91bmRhcnlfY29uZGl0aW9ucy5qbA==) | `94.59% <94.59%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601?src=pr&el=footer). Last update [ea74667...f1d341a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/601#issuecomment-579024761:2944,Power,Powered,2944,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/601#issuecomment-579024761,1,['Power'],['Powered']
Energy Efficiency,"Good one. On Sat, Aug 10, 2019, 6:34 PM Ali Ramadhan <notifications@github.com> wrote:. > This PR introduces reorganizes the diagnostics structs and introduces a; > new HorizontallyAveragedVerticalProfile diagnostic that can calculate; > vertical profiles efficiently on-the-fly on CPUs and GPUs. Other; > diagnostics like product and covariance profiles can be built on top of it.; >; > HorizontallyAveragedVerticalProfile is kind of a mouthful, suggestions; > welcome if anyone has a better name. I wanted to explicitly state; > ""horizontally averaged"" as vertical profiles are commonly used as well and; > imply no averaging.; >; > The profile can be passed to an output writer which can write it to disk.; >; > The horizontal averaging currently relies on a parallel reduction prefix; > sum algorithm that I hacked over a CUDAnative.jl example, although I do; > have a test for the diagnostic so it does work. The algorithm can be more; > efficient (see JuliaGPU/CuArrays.jl#68; > <https://github.com/JuliaGPU/CuArrays.jl/issues/68>).; >; > It allocates very minimal amounts of memory (less than mean) and; > benchmarks show that it is ~20x faster than what we were doing before; > (copying to CPU and calculating there) which is great but it's ~5x slower; > than optimal performance.; >; > As it does not allocate memory, we can now calculate vertical profiles; > even when running large models that fill up memory.; >; > Although I should mention that an intermediate array with a size of at; > least 1*Ny*Nz is required for the parallel reduction step (so I'm using; > poisson_solvers.storage because it's a vanilla CuArray that can be; > overwritten).; >; > N, H = 512, 1; > T = N + 2H; >; > a = rand(T, T, T) |> CuArray; > h = zeros(N) |> CuArray; >; > What we were doing before:; >; > @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]); >; > BenchmarkTools.Trial:; > memory estimate: 1.01 GiB; > allocs estimate: 250; > --------------; > minimum time: 684.013 m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010:256,efficient,efficiently,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010,2,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851:689,adapt,adapting,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851,1,['adapt'],['adapting']
Energy Efficiency,"Great stuff guys. Can we now put a ridge down our eddying channel? Is an; island possible? John. On Fri, Oct 30, 2020, 11:52 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Fun pair programming sesh with @ali-ramadhan; > <https://github.com/ali-ramadhan> @whitleyv <https://github.com/whitleyv>; > lead to this!; >; > [image: flow_around_cylinder]; > <https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif>; >; > Implementation is here:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl; >; > and the script that produced the above animation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl; >; > We just did something very simple as a starting point --- hopefully more; > to come.; >; > @weymouth <https://github.com/weymouth> thanks for your insights ---; > could make sense to schedule a meeting sometime soon to discuss next steps.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRK6RHZWBUDAPODUQLSNLOMHANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720000502:967,schedul,schedule,967,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720000502,1,['schedul'],['schedule']
Energy Efficiency,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:407,sustainab,sustainability,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,2,"['Green', 'sustainab']","['Green', 'sustainability']"
Energy Efficiency,"Greg, I have notes on a 'capacitance method' that we used in qg models in; complex geometries in the 1980s. That also would not require us to change; the solver. You carry out Green's function calculations in a rectangular; region where the delta-functions vorticities are placed at the positions of; the irregular boundary within the larger rectangular region. I will look; them out. John. On Sat, Mar 28, 2020 at 11:20 AM Gregory L. Wagner <notifications@github.com>; wrote:. > @johncmarshall54 <https://github.com/johncmarshall54> agreed, that's a; > challenge we have to confront.; >; > If we implement immersed boundaries using the ""continuous forcing; > technique"", then a boundary may be defined essentially by a masking; > function. In this case, we might be able to ""label"" each boundary / masking; > function with a name or number.; >; > The boundary condition objects we then give to fields would have to define; > a condition to be applied both at the boundaries of the numerical grid; > (which we currently support), as well as any immersed boundaries, where; > immersed boundaries are referenced by name or number.; >; > By the way, if we use a continuous forcing technique, we do not have to; > change the pressure solver. This is a major simplification. Recent work; > suggests there is no disadvantage in terms of accuracy in using the; > continuous forcing technique, either. I'm not sure if this is too good to; > believe or not --- we should discuss and take a deeper look at the; > literature.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605461456>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQHGXSSKOU7EIXSLBTRJYIVFANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623:176,Green,Green,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623,1,['Green'],['Green']
Energy Efficiency,"Grid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1228,schedul,schedule,1228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"Guys, is this a good idea? John. On Tue, Jun 25, 2019, 4:31 PM Ali Ramadhan <notifications@github.com> wrote:. > Copy pasting from @glwagner <https://github.com/glwagner>'s fork.; >; > Adaptive time stepping with a TimeStepWizard that computes time steps for; > you.; >; > I'll add some more docstrings and a couple of tests.; >; > cc @sandreza <https://github.com/sandreza>; >; > Resolves #189; > <https://github.com/climate-machine/Oceananigans.jl/issues/189>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/297; > Commit Summary; >; > - Utils for adaptive time stepping.; > - Some docstrings.; >; > File Changes; >; > - *A* src/time_step_utils.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/297/files#diff-0>; > (104); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/297.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/297.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQXE74LLYFD3QRG7BP3P4IT5HA5CNFSM4H3I7NT2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4G3SCVLA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQTKNBSXD3NJO6ROKDP4IT5HANCNFSM4H3I7NTQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505511666:185,Adapt,Adaptive,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505511666,2,"['Adapt', 'adapt']","['Adaptive', 'adaptive']"
Energy Efficiency,"Happy to open an issue (or post to #1634) when I have the time to work on CI. What should we do with this PR? I think it's a net positive change so I'm happy to approve as long as the images aren't in git history. If we decide to nuke this part of the docs then I suppose this PR is moot and should be closed. > _when_ / _if_ somebody can take responsibility for maintaining it. I think responsibility for maintaining the pipeline should fall on all maintainers/developers, otherwise it's not sustainable. Ideally if you open a PR that breaks a validation experiment you should fix it. If done concurrently it should only consist of small changes so it should only be a small burden (although burdens to add up). I guess we don't run the validation CI on every PR since it's too expensive so maintenance is tough right now. Maybe we can run validation CI before every tagged release or something? Better infrastructure is needed I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889:493,sustainab,sustainable,493,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889,1,['sustainab'],['sustainable']
Energy Efficiency,"Heh. I would never imply you can't take my code and adapt it to do nice things. You can of course do that. For example if you have `outputs` already assembled, you can do. ```julia; function create_subsampled_output(field); loc = location(field); subsampled_field = Field(loc, subsampled_grid); function output(model); interpolate!(subsampled_field, field); return subsampled_field; end; return output; end. subsampled_outputs = NamedTuple(name => create_subsampled_output(outputs[name]) for name in keys(outputs)); ```. And there's an infinity of other ways you can write your code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916:52,adapt,adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916,1,['adapt'],['adapt']
Energy Efficiency,"Hello everyone, I have tested ```VerticallyStretchedRectilinearGrid( )``` and found a hard time in setting up the time step for a stable solution. ; I will going to post the whole issue but before that I just want to know weather is there any adaptive time stepping method like we did have ```TimeStepWizard``` . I have searched and failed may be I might have missed it that's why I first ask this question.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741:243,adapt,adaptive,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741,1,['adapt'],['adaptive']
Energy Efficiency,"Hello, . I've worked implementing this automatic concatenation for the output, when a simulation is picked up from a checkpoint, with the flag splitting_files on. This feature addresses the fact that otherwise the simulation output filename needs to be changed manually each time the simulation is restarted. . In other words, if a simulation is run to output in a `file.nc` with the flag splitting_files, different files will be created such as `file_part1.nc`, `file_part2.nc`. If the overwrite_output is true, these files will be rewritten and the data will be deleted. If the overwrite_output is false, the simulation will crash since it will not find the original `file.nc`. The new code ensures that if overwrite_output is false, then the model will append the output to the last file. i.e. `file_part2.nc`. . Before working more on this (i.e. including joining output in jld2), I'm wondering if this will be useful to implement in the other schedulers and merge to master. What do you think @glwagner @tomchor @navidcy ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818:948,schedul,schedulers,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818,1,['schedul'],['schedulers']
Energy Efficiency,"Helpful error when using an invalid `schedule` in OutputWriters, Diagnostics, and Callbacks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:37,schedul,schedule,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,1,['schedul'],['schedule']
Energy Efficiency,"Here are some thoughts for the grid and fields tutorial:. # Grids tutorial. 1. Basic information: domains, resolution, architectures, number types; 2. First example: equally-spaced `RectilinearGrid`.; - meaning of the keyword arguments and different options; - emphasize explaining topology; - emphasize explaining architecture: CPU, GPU, distributed; 3. Second example: single column grid with vertical stretching via vector; 4. Third example: two-dimensional grid (short); 5. Fourth example: channel grid with function-specified y and z; - Explain how to use functions to build a grid; - Intro to some helper functions: `yspacing`, `ynodes`, etc.; 6. Fifth example: LatitudeLongitudeGrid with equal spacing; - Explain different keyword args; - Explain that only longitude can be periodic; 7. Sixth example: LatitudeLongitudeGrid with stretched latitude. Q: should we show tripolar grid / other examples with `OrthogonalSphericalShellGrid`? (At the very least we should reference this.). # Fields tutorial. 1. Explain the purpose of `Field`: data structure, plus infrastructure for building expression trees; 2. `Field` basics; - The staggered grid, `Field` locations; - Field size + data, staggered nodes, staggered spacings; 3. AbstractOperations and expression trees; - The concept of a lazy operator; - Arithmetic and derivatives; - Difference between a Field and Operation; - KernelFunctionOperation; - what else?; 4. Averaging, intergrals, and reduced fields. What else?. @navidcy @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3672#issuecomment-2263399540:1451,reduce,reduced,1451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672#issuecomment-2263399540,1,['reduce'],['reduced']
Energy Efficiency,"Here is the MWE related to this issue:; ```julia; # this is a MWE for reproducing AveragedTimeInterval errors; using Oceananigans; using Printf; using Plots. function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", pre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:670,schedul,schedule,670,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,3,['schedul'],['schedule']
Energy Efficiency,"Here's a clue: this fixes the issue. ```julia; Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). progress_cb = simulation.callbacks[:progress]; @show actuations = progress_cb.schedule.actuations. # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); progress_cb = simulation.callbacks[:progress]; progress_cb.schedule.actuations = actuations; run!(simulation, pickup=checkpoint); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650:382,schedul,schedule,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650,2,['schedul'],['schedule']
Energy Efficiency,"Here's a couple more thoughts:. * `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. * A very important usage of `Average`, however, is using it to reduce ""lazily evaluated data"". This is the case of taking an average of a ""`Computation`"". To take the average of a `Computation`, we have to trigger the generation of the data to be averaged. To support this functionality we have permitted `Average.field` to be defined as a `Computation`, and dispatched on this special case to ensure that the data is generated before the average is invoked. * One way to normalize these user-interfaces is to generalize the concept of an `AbstractField` to be ""lazy"" in general. There is one special case that does *not* require computation --- the ordinary case of a `Field`. But we can create an infrastructure where all `AbstractField`s are expected to have a function like `compute!` (or perhaps `evaluate!`). In that framework, we would always call `evaluate!` on `Average.field` before averaging it. Because `evaluate!(::Field) = nothing`, we preserve the basic functionality of `Average` when it acts on a basic `Field` and its data does not need to be generated. * Note that currently `Computation` data is stored in bare `Array`s. However, it should probably be stored as `Field`, and interacting with a `Computation` should feel the same as interacting with a field (with functions like `data`, `interior`, `getindex`, etc). We may also want to change the name of `Computation` to something that reflects its behavior a little more clearly. Perhaps `ComputedField`, or something. * `Average` itself should *also* subtype `AbstractField` within this framework. An `Average` is just a special type of computation that requires eva",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391:425,reduce,reduce,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391,1,['reduce'],['reduce']
Energy Efficiency,"Here's a few options for optimizing AbstractOperations with `^`:. 1. Auto-convert exponents to `Int32`. For this we'd define. ```julia; Base.^(L::Tuple, a::AbstractField, b::Int64) = ^(L::Tuple, a, Int32(b)); ```. Basically implementing the approach CUDA previously took. For us it's a ""less egregious"" hack since, unlike CUDA.jl, we can ""almost surely"" guarantee that users won't exponentiate with integers larger than `2^31-1 = 2147483647`. Probably the easiest thing to do in the near term. This is a specific extension of the abstract operation defined via `@binary ^` (such that `op = ^`):. https://github.com/CliMA/Oceananigans.jl/blob/1756bc9380999f160f3d2b96f64bf76771614c60/src/AbstractOperations/binary_operations.jl#L100-L108. 2. Convert small-power exponents to literal multiplications. Like `Base.literal_pow`:. ```julia; Base.^(L::Tuple, a::AbstractField, b::Integer) = our_literal_pow(L, a, Val(b)). our_literal_pow(L, a, Val{0}) = one(eltype(a)); our_literal_pow(L, a, Val{1}) = a; our_literal_pow(L, a, Val{2}) = *(L, a, a) # binary operation; our_literal_pow(L, a, Val{3}) = *(L, a, a, a) # multiary operation; our_literal_pow(L, a, Val(b)) where b = _binary_operation(location(a), ^, a, b, location(a), location(a), a.grid) ; ```. etc. I guess 2 would instead happen under the hood when abstract operations are compiled, hopefully, in the best of worlds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225:755,power,power,755,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225,1,['power'],['power']
Energy Efficiency,"Here's a script with a visualization. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. grid = RectilinearGrid(topology=(Periodic, Flat, Bounded), size=(64, 32), x=(0, 200), z=(0, 100)). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; buoyancy = BuoyancyTracer(),; tracers = :b). noise(x, y, z) = 1e-6 * (rand() - 1/2); constant_stratification(x, y, z) = 1e-5 * z; set!(model, u=noise, b=constant_stratification). simulation = Simulation(model, Δt=10.0, stop_iteration=1000); progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). u, v, w = model.velocities; e = (u^2 + w^2) / 2; E = Field(Integral(e, dims=:)); outputs = merge(model.velocities, model.tracers, (; e, E)). filename = ""test.jld2""; simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); et = FieldTimeSeries(filename, ""e""); bt = FieldTimeSeries(filename, ""b""); Et = FieldTimeSeries(filename, ""E""); times = wt.times; Nt = length(times). fig = Figure(resolution=(1800, 900)). axw = Axis(fig[2, 1], xlabel=""x (m)"", ylabel=""z (m)"", title=""Vertical velocity""); axe = Axis(fig[2, 2], xlabel=""x (m)"", ylabel=""z (m)"", title=""Kinetic energy""); axb = Axis(fig[2, 3], xlabel=""x (m)"", ylabel=""z (m)"", title=""Buoyancy""); axE = Axis(fig[3, 1:3], xlabel=""Time (s)"", ylabel=""Volume averaged kinetic energy""). slider = Slider(fig[1, 1:2], range=1:Nt, startvalue=1); n = slider.value. wn = @lift interior(wt[$n], :, 1, :); en = @lift interior(et[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). x, y, z = nodes(et). wlim = maximum(abs, wt); elim = maximum(abs, et). heatmap!(axw, x, z, wn, colorrange=(-wlim, wlim), colormap=:balance); heatmap!(axe, x, z, en, colorrange=(0, elim), colormap=:solar); heatmap!(axb, x, z, b",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442576976:963,schedul,schedule,963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442576976,1,['schedul'],['schedule']
Energy Efficiency,"Here's a starting list:. * `ViscousDissipation`, which @tomchor attempts to compute above, also being computed [here](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/viscous_dissipation.jl) (and note that there's [an open issue about the expression](https://github.com/CliMA/LESbrary.jl/issues/38)). * [`TurbulentKineticEnergy`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/turbulent_kinetic_energy.jl), which requires embedding `AveragedField`s in an operation. * [`ShearProduction`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/shear_production.jl), similar to above. @ali-ramadhan not sure if this is what you mean but when trying to adapt `Field` to the GPU we did encounter an error that was something like ""ptx arguments consume too much parameter space"". I believe this is an issue compiling very large objects (`Field` is large because it has boundary conditions). I don't think that this is the error we get for too-complex AbstractOperations though. I think for abstract operations its a type-inference issue. We should dump the whole error into this issue so that we know. I also think the error might change as the julia compiler evolves, or when we upgrade CUDA.jl.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738757085:721,adapt,adapt,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738757085,1,['adapt'],['adapt']
Energy Efficiency,"Here's a twin partial cell case (dx = 1 km as in the `GridFittedBottom` case above). The pattern in the differences is almost identical, although their magnitude is slightly smaller with partial cells:. ![numerical-EMVR08_pbc](https://github.com/user-attachments/assets/c99cdb8b-83bf-49b7-8946-b22d099edf0c). Resolution seems to have a negligible effect (dx = 200 m shown below, tried a few others):. ![hires_gfb](https://github.com/user-attachments/assets/bc29bbe3-5e8f-49d5-8f0b-8a2973df742d). The fact that partial cells actually reduce the magnitude of the difference seems encouraging, though. This could become a good validation case to illustrate the advantages of partial and cut cells for representing the BBL over a slope.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2272813809:533,reduce,reduce,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2272813809,1,['reduce'],['reduce']
Energy Efficiency,"Here's an example of how a user might generate unique ID's on their own without requiring our meddling:. ```julia; using Dates; id = string(""run_starting_at_"", now()) # eg ""run_starting_at_2024-04-06T14:16:16.083"". simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; schedule = TimeInterval(0.6), ; filename = ""pretty_cool_data.jld2"", ; dir = id); ```. This savvy user then never has to write `overwrite_existing=true` as long as they don't run two simulations within a millisecond of one another (I guess if that's possible, a bit more work is needed from the user to make a unique id).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041156925:286,schedul,schedule,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041156925,1,['schedul'],['schedule']
Energy Efficiency,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:442,schedul,schedule,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061,1,['schedul'],['schedule']
Energy Efficiency,"Here's some results for reference (flat bottom no slip), ""no slip"", ""free slip"", and ""bottom drag"" for fractional heights h=0.1 and h=0.2:. # h = 0.1; https://user-images.githubusercontent.com/15271942/164373427-e614311e-7ff0-492c-a0de-6156eadd24ae.mp4. # h = 0.2; https://user-images.githubusercontent.com/15271942/164373538-08dcc7ff-820c-4492-9a75-a4a406d2c416.mp4. Energy always decreases (rapidly). Momentum is more squirrely, but fortunately we do find that specifying drag / no-slip seems to extract more momentum than otherwise (eg than with free slip boundary conditions). The amount of momentum lost with a free-slip boundary condition and hills of size `h=0.2` is roughly equivalent to the flat bottom case with no-slip. There's also transient periods with `h=0.2` where the case with no-slip boundary conditions has more momentum than free-slip. I'm going to run a few more cases at higher resolution. We should also have a more quantitative validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550:368,Energy,Energy,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550,1,['Energy'],['Energy']
Energy Efficiency,"Here's some validation. The animation below is from a triply-periodic 3D simulation with an initial reasonably-resolved initial condition without any forcings. Note that the IC looks a bit weird right now (a couple of straight lines in strain) because I'm taking a shortcut in defining a well-resolved random IC, but I can easily change it later if necessary. Left panel shows the strain rate squared for the `SmagorinskyLilly` closure, while the one on the right shows results for the `ScaleInvarianteSmagorinsky` closure, implemented in this PR. The bottom panel shows the evolution of the dynamically-calculated Smagorinsky coefficient for the latter, in comparison with the constant value of 0.16 imposed on the former. Important here is that the value of 0.16 was analytically derived by Lilly by assuming an isotropic 3D turbulence, a Kolmogorovian energy cascade, and further assuming that the cut-off filter is in the inertial range. I think all these assumptions are valid in this simulation, so we expect the dynamically-calculated value of the Smagorinsky coefficient (the black line) to approach the value 0.16 as time goes on. https://github.com/CliMA/Oceananigans.jl/assets/13205162/4049e7cf-452e-4883-a709-a675cf12277c. Although the match is not exact (the value it approaches is ~0.17), I think this is close enough. That said, I'm planning on also implementing a boundary layer validation along similar lines, which we can use to validate the model in the same fashion as [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152). One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. ```julia; ┌ Info: Runnin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170:855,energy,energy,855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170,1,['energy'],['energy']
Energy Efficiency,"Here's the main differences:. 1. `FunctionOperation` is not backed by data; eg it doesn't allocate memory (its just a wrapper for a function); 2. `KernelComputedField` requires a `KernelAbstractions` `@kernel`. `FunctionOperation` requires a function of `i, j, k, grid, fields..., parameters)`. It's a subtle but real distinction. Sometimes defining `@kernel` may be more convenient / more readable.; 3. The `kernel` in `KernelComputedField` cannot be reduced on the fly (unless this is supported by `KernelAbstractions` someday, somehow, eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/234, but we don't know what this would look like yet). Taking the vertical vorticity for curvilinear / cubed sphere grids as an example, usage is. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᵃ # called with signature ζ₃ᶠᶠᵃ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = FunctionOperation(Face, Face, Center, ζ₃ᶠᶠᵃ, grid, computed_dependencies=(u, v)). ζ = ComputedField(ζ_op) # identical to `VerticalVorticityField`. barotropic_ζ = AveragedField(ζ_op, dims=3); ```. On the CubedSphere, `ζ₃ᶠᶠᵃ` cannot be expressed in terms of `AbstractOperations` due to the need to treat corners in a special manner.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910:90,allocate,allocate,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910,2,"['allocate', 'reduce']","['allocate', 'reduced']"
Energy Efficiency,"Here's the specific error we got when we tried to get `Field`, including all its glorious boundary conditions, to compile on the GPU:. ```; Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max); ```. dredged up from #746 . Some workarounds were suggested there, but I think our solution is actually better / simpler (adapt fields by unwrapping the underlying data and throwing away boundary conditions, rather than wrestling to get all the field info onto the poor GPU).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849:362,adapt,adapt,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849,1,['adapt'],['adapt']
Energy Efficiency,"Hey @navidcy topography hasn't been a priority for us as we're not looking at any problems where topographic effects are important (yet), although other people have asked about it (cc @hdrake) and we would like to include topography at some point. Some would argue that an ocean model without topography isn't an ocean model... From discussing this with @glwagner it seems like you could implement topography via an immersed boundary method that accounts for the topography via additional terms in the momentum equation, allowing us to keep using our efficient pressure solver which would be really cool. @glwagner posted this on Slack a few weeks ago:; > At some point, we should discuss how we plan to implement topography / complex boundaries. Immersed boundary methods (like that used in MITgcm) are probably the right approach. However, MITgcm uses a cut-cell technique that may require modifying the pressure solver. In contrast, a “continuous forcing method” that introduces forcing terms into the mometum / tracer equations to account for the solid boundary could potentially be easier to implement, since the pressure solver would not have to be modified. Here’s a paper that compares two implementations (though their “discrete forcing method” implementation uses ghost cells rather than cut cells as in MITgcm): https://www.sciencedirect.com/science/article/pii/S0009250918306250#b0120. There's also [Tseng & Ferziger (2003)](https://www.sciencedirect.com/science/article/pii/S0021999103004108) who implemented a ghost-cell immersed boundary method (different from the continuous forcing method) in MITgcm with good results compared to the shaved cell method.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553386363:551,efficient,efficient,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553386363,1,['efficient'],['efficient']
Energy Efficiency,"Hey all,. Awesome software, I am really enjoying using it. I was wondering if you have any recommendations for compatibility with [DrWatson.jl](https://github.com/JuliaDynamics/DrWatson.jl)? In particular, I am hoping to combine the [`tagsave`](https://juliadynamics.github.io/DrWatson.jl/dev/save/#DrWatson.tagsave) functionality (which stores meta information about a simulation, like git commit, filename, etc) with `JLD2OutputWriter` somehow. This is what I have tried so far. (I'll give the full script at the end). ```julia. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end. sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; # Save to `/data/simulations` based on parameters:; filename=datadir(""simulations"", savename(d, ""jld2"")),; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); ```. However, I get an error from `tag!`:; ```julia; ┌ Warning: Initialization of /Users/mcranmer/Documents/oceananigans_interpret/data/simulations/initial_condition=random_seed=0_stop_time=10.0_timestepper=RungeKutta3_Δt=0.2_Δx=0.00781.jld2 failed because MethodError: MethodError: no method matching tag!(::JLD2.JLDFile{JLD2.MmapIO}); │ Closest candidates are:; │ tag!(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2829:837,schedul,schedule,837,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829,1,['schedul'],['schedule']
Energy Efficiency,"Hey thanks for doing all this! Things look a lot neater. Just have a few comments/thoughts that I'll pepper throughout but should be good to merge!. > A `Model` constructor is now provided in which all important information can be input via keyword arguments. This is great for understanding what the model does, I agree. Would still be nice to keep the ""legacy constructor"" around for when you just want to create a simple `Model` for playing around with or for testing. And it makes for very nice and simple example code. > I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). I would argue against this. While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. Either way, we should always be testing a wide range of grid sizes (and weird grid sizes like `109x77x13`) because the code should work for all of them. If computational cost becomes an issue we should look into paying for extra CI resources rather than reduce testing. > A few more notes:. Might be good to create some new issues based on those just to keep track of what needs to be done. > The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain. This is something I'm actively working on in a different branch. I'll make sure they work with the changes in this pull request. > Lots of work to do!. For sure!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078:533,reduce,reduced,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078,7,"['power', 'reduce']","['powers', 'reduce', 'reduced']"
Energy Efficiency,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:906,adapt,adapt,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,1,['adapt'],['adapt']
Energy Efficiency,"Hi All - this should definitely be useful for the sort of ensemble of; LES parameter/background state; sweep runs that Greg mentions. On Tue, Jun 25, 2019 at 4:29 PM John Marshall <notifications@github.com> wrote:; >; > Ali and Greg, thanks for your comments. I found the exchange very; > enlightening. John; >; > On Tue, Jun 25, 2019, 7:49 PM Gregory L. Wagner <notifications@github.com>; > wrote:; >; > > Adaptive time-stepping is useful for a wide class of problems. The general; > > strategy is to use the CFL number to compute a stable time-step. This is; > > especially useful in problems with lots of time variability --- for; > > example, LES of a seasonal cycle. In addition, the CFL computation can be; > > used to stabilize the spin-up of a model, during which a transition to; > > turbulence occurs.; > >; > > Some complexity is introduced by the fact that we use Adams-Bashforth time; > > stepping (as opposed to a RK-method, which is more common and more stable),; > > since it means we need to re-initialize the ""previous source terms"" with a; > > forward Euler step when the time step is changed.; > >; > > I have been using adaptive time-stepping in my work, which along with a; > > strategy for handling model spinup / transition to turbulence, has proven; > > to be an important practical feature that makes running experimental; > > simulations under different conditions much easier, since all I need to do; > > is set my boundary conditions, and let the model run. I am then able to; > > start dozens of LES per day (if I want to) without having to choose my time; > > step size through a mistake-prone and time-consuming trial-and-error; > > process --- and I am guaranteed not to waste resources with a too-short; > > time-step.; > >; > > —; > > You are receiving this because you commented.; > > Reply to this email directly, view it on GitHub; > > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQVQYODJTMVZ46AOA3TP4JL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637:407,Adapt,Adaptive,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637,1,['Adapt'],['Adaptive']
Energy Efficiency,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:492,Adapt,Adapt,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['Adapt'],['Adapt']
Energy Efficiency,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:607,reduce,reduce,607,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,2,['reduce'],"['reduce', 'reduce-gpu-params']"
Energy Efficiency,"Hit a slight roadblock as the `Field` structs are not `isbitstype`:; ```julia; struct CellField{A<:AbstractArray,G<:Grid} <: Field; data::A; grid::G; end; ```; since `Array`s and `CuArray`s are not `isbits`. However, @vchuravy points out that a `CuArray` is not `isbits` only because it contains a `finalize` function (essentially a destructor) which makes it not `isbits` on the host. Apparently CUDAnative converts the `CuArray` to some sort of `CuDeviceArray` using [Adapt.jl](https://github.com/JuliaGPU/Adapt.jl) which is `isbits` and can be used as a device argument. So we'll have to figure out how to _adapt_ our `Field` structs to be `isbits` on the GPU device using Adapt.jl. It shouldn't be too hard as the struct is simple. I should also check out the `cudaconvert(args...)` function in CUDAnative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475660249:470,Adapt,Adapt,470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475660249,3,['Adapt'],['Adapt']
Energy Efficiency,"Hm... . ```Julia; julia> using Oceananigans, CairoMakie. julia> underlying_grid = RectilinearGrid(size = (250, 125),; x = (-1000e3, 1000e3),; z = (-2e3, 0),; halo = (4, 4),; topology = (Periodic, Flat, Bounded));. julia> bottom(x) = - underlying_grid.Lz + 500 * exp(-x^2 / (2*(20e3)^2));. julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom));. julia> c = Field{Center, Nothing, Nothing}(grid); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand()); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.952381, min=0.952381, mean=0.952381. julia> lines(c). julia> c; 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749:459,reduce,reduced,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749,1,['reduce'],['reduced']
Energy Efficiency,"Hmm I also want to point out that this pattern is inefficient with memory. If we are only interested in the values at `indices=(:, 1, :)`, then it is wasteful to allocate `Field(w*c)` etc. Instead we should compute `w*c` only at the indices required. The other ambiguous aspect of this setup is what we expect to happen when we ask for `Field(Average(field, dims=2), indices=(:, 1, :))`. The field is reduced in `y`, but we are asking for specific y-indices --- should this be allowed?. There's still a mystery here, even if the setup if a little confusing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437909887:162,allocate,allocate,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437909887,2,"['allocate', 'reduce']","['allocate', 'reduced']"
Energy Efficiency,"Hmm, I think then `cell_advection_timescale` and `cell_diffusion_timescale` need to be extended for `ShallowWaterModel`, after which the `TimeStepWizard` will probably work. Perhaps change the name of this issue to ""Adapt cell_advection_timescale for ShallowWaterModel""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599:216,Adapt,Adapt,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599,1,['Adapt'],['Adapt']
Energy Efficiency,"Hmm. I think it's still a type instability / compiler issue but that doesn't mean we don't have some work to do to solve this. (It's very unlikely that we allocate memory accidentally in Oceananigans; for example `Field` is immutable, so we cannot change the data that it points to...). Something interesting about this problem is that it _does_ compile when the problem size is reduced (for example to `(10, 10, 10)`.) So we are hitting some heuristic that is the combination of the problem size and the complexity of the object (which increases when we add `indices`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2168816882:155,allocate,allocate,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2168816882,2,"['allocate', 'reduce']","['allocate', 'reduced']"
Energy Efficiency,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097:207,reduce,reduced,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097,1,['reduce'],['reduced']
Energy Efficiency,"Hmmm, I don't know if many log levels will be that helpful. I guess for debug messages we'll want to have the file name and line number, but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. I think one place that logging can hugely improve user experience is in setting up large models, especially on the GPU, where you could be waiting for several minutes while all of Julia, CUDA, and Oceananigans compiles, model is being set up, memory is allocated, etc. We know it takes time but most users will think that something is wrong if Julia is silent for 5 minutes. In this context info messages can be useful and reassure the user that Oceananigans is working properly. It's well known that progress indicators improve user experience, e.g.: https://www.nngroup.com/articles/progress-indicators/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192:559,allocate,allocated,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192,1,['allocate'],['allocated']
Energy Efficiency,"Hmmm, I wonder if it might be easier to contribute a version of `mean` that works for us. @maleadt @vchuravy is it possible to efficiently calculate `mean(c)` where `c` is a non-contiguous view into a `CuArray`?. Nevermind, I think it's an open issue in CuArrays.jl: https://github.com/JuliaGPU/CuArrays.jl/issues/68",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519613398:127,efficient,efficiently,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519613398,1,['efficient'],['efficiently']
Energy Efficiency,"Hmmm, do we know why we can't adapt the full `Field` to work inside GPU kernels? I think you said you've tried it but ran into some issues a while back?. The definition is; ```julia; struct Field{X, Y, Z, A, G, B} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; boundary_conditions :: B; ```; where the `grid` has been adapted, `data` is usually an offset array which has also been adapted, and I thought individual boundary conditions have been adapted as well so feels like it should be easy to adapt the full `Field`. Note: `boundary_conditions` is a named tuple of `FieldBoundaryConditions` so maybe we just need to adapt `FieldBoundaryConditions`, `CoordinateBoundaryConditions`? Hmmm but they're really named tuples so maybe they're already adapted. If we can't adapt `Field` then yeah the adapt rules you've suggested sound pretty good and would simplify the time stepping a lot. The kernels already deal with data tuples so not much would even have to change I think. If we can adapt `Field` though, then we should get all the benefits of simpler time stepping code without the confusion of a non-vanilla adapt rule. X-Ref: https://github.com/climate-machine/Oceananigans.jl/issues/298",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535:30,adapt,adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535,11,['adapt'],"['adapt', 'adapted']"
Energy Efficiency,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:304,reduce,reduce,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367,2,"['Reduce', 'reduce']","['Reduce', 'reduce']"
Energy Efficiency,"Hmmm, using 2 threads seems to allocate the most memory by far. Seems pretty weird.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732516613:31,allocate,allocate,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732516613,1,['allocate'],['allocate']
Energy Efficiency,"Homogenize interface for initializing `Simulation`, schedules, etc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015:52,schedul,schedules,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015,1,['schedul'],['schedules']
Energy Efficiency,How could energy increase at all? This is stably stratified right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442561766:10,energy,energy,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442561766,1,['energy'],['energy']
Energy Efficiency,How does this PR change `adapt`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080:25,adapt,adapt,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080,1,['adapt'],['adapt']
Energy Efficiency,How to create efficient forcing functions?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365:14,efficient,efficient,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365,1,['efficient'],['efficient']
Energy Efficiency,How to reduce compile time for GPU code?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66:7,reduce,reduce,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66,1,['reduce'],['reduce']
Energy Efficiency,"However, I would also recommend using. ```julia; wc_average = Average(w*c, dims=1); ```. because this is more efficient (usually). One can in principle save some time by constructing a computational graph for the diagnostics, but I'm not sure it's worth it most of the time...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436097202:110,efficient,efficient,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436097202,1,['efficient'],['efficient']
Energy Efficiency,Huh. Is this a bug with `NCDatasets`? E.g. can you save a 0-dimensional array using `NCDatasets`? . I'm not sure what is desirable for NetCDF users. A field reduced in all dimensions is just a scalar. Right now we store this in a 0D array via. https://github.com/CliMA/Oceananigans.jl/blob/5d044fbda67bf8db13738cbaa5a703162cfcd94a/src/OutputWriters/netcdf_output_writer.jl#L489-L491. I don't know enough about NetCDF to say whether we should convert to a scalar in this case.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1349668016:157,reduce,reduced,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1349668016,1,['reduce'],['reduced']
Energy Efficiency,"Hyperviscosity _is_ an LES closure. It's not just a great one because it requires tuning (ie you have to select the hyperviscosity, and the hyperviscosity doesn't change). You can use a scaling argument to find the hyperviscosity:. $$ \nu_4 = \Delta^4 / \tau $$. where $\Delta$ is a length scale (typically the grid spacing) and $\tau$ is the time-scale over which you'd like to damp grid scale motions. The longer the better. Perhaps you can estimate a time-scale in terms of the buoyancy frequency (eg to damp grid scale buoyancy oscillations) --- like $\tau = C / N$ where $N$ is the buoyancy frequency and $C$ is a constant (perhaps not O(1)). $C = 10$ could be a good starting point. If you need more dissipation then decrease $C$, if you need less increase $C$. Its not ""less correct"" than an LES closure. (Both are closures, not exact.) As for all LES or macroscale computational science in general the goal is to find solutions with statistics of interest that are indepednent of resolution. Note that upwinding can be thought of as adding hyperdissipation which scales with the velocity (similar to traditional LES closures in fact). WENO is adaptive-order hyperdissipation, from biharmonic on up. Personally I suspect that WENO produces more physical solutions than ""traditional"" LES closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193:1151,adapt,adaptive-order,1151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193,1,['adapt'],['adaptive-order']
Energy Efficiency,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565:298,adapt,adapt,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565,1,['adapt'],['adapt']
Energy Efficiency,"I agree that most diagnostics like total tracer and total kinetic energy are pretty easy to compute and if it is a one liner, then we probably don't need to do anything special. . Computing the APE could be a oneliner as well, after we compute the reference depth and density. So maybe that's something we could add somewhere? . I have not done this before but I know it's pretty standard. I presume the MITgcm does and we could maybe borrow from their weather of knowledge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758716153:66,energy,energy,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758716153,1,['energy'],['energy']
Energy Efficiency,"I agree that your example does assign the first halo points correct. . We are using the main branch now and indeed we are trying to use higher order schemes near the boundary, a bad idea, and we will try and avoid that. . I looked over #2603 and can you point out where, say 3rd order upwinding switches to 1st order near the boundaries? That should help us to modify our forcing function appropriately. A more general piont is, if we never want to use the extra two halo points, why do we define them? Wouldn't it be more cost efficientive to only define them in the periodic case, and have smaller halos in the bounded case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240:528,efficient,efficientive,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240,1,['efficient'],['efficientive']
Energy Efficiency,"I agree the current state of affairs puts a lot of responsibility on the user to ensure they pass `Float32` to every constructor that requires it, which is not very _friendly_ especially to new users who aren't familiar with the code. I also agree that having a way to specify the default number type in Julia is better than using an environment variable. Besides the limitation of strings, I feel like it would stray from Oceananigans.jl's script-based interface. If you share a script with someone now, you also need to inform them to run with specific environment variables. With enough environment variables you'll want a `.env` file. Agree with @Yixiao-Zhang that with `Oceananigans.set_default_number_type(FT)` we can do some checks and throw appropriate warnings compared with `Oceananigans.settings[:default_number_type] = Float32` (assuming it's a vanilla dictionary). > Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817:1186,power,power,1186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817,1,['power'],['power']
Energy Efficiency,"I agree tutorials is the way to go.; Let's talk about how to get these done.; John. On Fri, May 24, 2019 at 8:01 AM Gregory L. Wagner <notifications@github.com>; wrote:. > I think we should have ""tutorials"" in addition to examples! Examples are; > for ""quickstarting"" -- download the code and run *something*. Tutorials; > are extended examples with documentation, plots, etc. What do you think; > about that?; >; > Ultimately when the code is more stable I could see the utility of having; > more than just 2-3 examples, though.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/221?email_source=notifications&email_token=AKXUEQRIXKFCEQMBMBP2IELPW7KJ5A5CNFSM4HM5OBLKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWFCXIA#issuecomment-495594400>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQV45XSBFQ4JHHFN2P3PW7KJ5ANCNFSM4HM5OBLA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-495691216:1089,Green,Green,1089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-495691216,1,['Green'],['Green']
Energy Efficiency,"I agree with you @jklymak , you can certainly compute APE in a rotating fluid, which will require a global sort. I wonder if the issue is how to pick the angle of the pycnoclines in the state of least potential energy? I am sure there are ways of doing these, and we can learn how when needed. It would be good to give the user an option as to whether they want to compute it and how often. Given what is set up in the time stepping wizard, I don't imagine this will be a concern, and would be nice to give the user the power to control this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449:211,energy,energy,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449,2,"['energy', 'power']","['energy', 'power']"
Energy Efficiency,"I agree with your four points and that a default of `with_halos = true` makes sense in anticipation of a more powerful fields abstraction. I'm happy to change the default (will commit once tests pass), I just wanted the option of including or excluding halos for different use cases. This also means that this PR does not introduce breaking changes anymore. I also revised the tests to actually reconstruct the `Average` as opposed to just setting `T̅.with_halos = true` which does not test the constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/859#issuecomment-674786222:110,power,powerful,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/859#issuecomment-674786222,1,['power'],['powerful']
Energy Efficiency,I agree. I would be more alarmed if an initial condition that includes small scales but resolved (that is with 5-6 grid points per shortest wavelength) eg cosm(mx)cos(nz) showed energy increase.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444487243:178,energy,energy,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444487243,1,['energy'],['energy']
Energy Efficiency,I agree; I also think this shows the need for a more structured definition of a `Nothing` location. We should split it into two in order to have two different `ReducedFields`:. - a _truly_ 2D field (for reductions); - a 2.5D field with an index associated with the reduced dimension (for free surface or similar fields),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224130725:160,Reduce,ReducedFields,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224130725,2,"['Reduce', 'reduce']","['ReducedFields', 'reduced']"
Energy Efficiency,"I am able to run the validatoin example. Unfortunately, it produces `NaNs` after just over an hour. Sigh. Even if I reduce the time step from 20 seconds to 1 second, it still goes unstable at about the same time. I need to look more closely as to why this might be happening. I would share an animation but one hour doesn't seem to be enough time for much to happen so I don't see any changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973396835:116,reduce,reduce,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973396835,1,['reduce'],['reduce']
Energy Efficiency,"I am having some issues i modifying the code to output the solution fields and the vorticity. I tried the following but it doesn't work. What is the right syntax for including both solution fields and `Fields`?; ```; u, v, h = model.solution. ζ = Field(∂x(v) - ∂y(u)); compute!(ζ); ; simulation.output_writers[:surface_fields] = JLD2OutputWriter(model, merge(u, v, h, (; ζ)),; schedule = TimeInterval(save_interval),; filename = output_prefix * ""_surface"",; overwrite_existing = true). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129053952:377,schedul,schedule,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129053952,1,['schedul'],['schedule']
Energy Efficiency,"I am not sure if this helps, but this might shed some light.; This is the same MWE with the progress function set as:; ```julia; function progress_message(sim) ; wta = sim.output_writers[:timeavg2].outputs[1]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); ; interval = wta.schedule.interval; pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "" , u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time: "", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", previous_interval_stop_time: "", pis, "", collecting: "", cll); end; ```. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds , u-avg: 0.0, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time: 0.0, fetch_operand: true, interval: 0.03, previous_interval_stop_time: 0.0, collecting: true; [ Info: ... simulation initialization complete (257.729 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.212 seconds).; [ Info: Iter: 1, time: 10 ms , u-avg: 0.0031413629825035438, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time: 0.01, fetch_operand: true, interval: 0.03, previous_interval_stop_time: 0.0, collecting: true; [ Info: Iter: 2, time: 20 ms , u-avg: 0.007851828677677537, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time: 0.02, fetch_operand: true, interval: 0.03, previous_interval_stop_time: 0.0, collecting: true; [ Info: Iter: 3, time: 30 ms , u-avg: 0.014652384734839867, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time: 0.03, fetch_operand: true, interval: 0.03, previous_interval_stop_time: 0.03, collecting: false; [ Info: Iter: 4, time: 40 ms , u-avg: 0.0, window_start_time: 0.04, window",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2264057759:370,schedul,schedule,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2264057759,3,['schedul'],['schedule']
Energy Efficiency,"I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686:136,efficient,efficient,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686,1,['efficient'],['efficient']
Energy Efficiency,"I am sharing the first set of results that look at the strong scaling of the distributed `ShallowWaterModel`. I should say that I'm doing this on my desktop while zoom is running, so it would certainly be redone elsewhere. But the results are copied below. ```; Shallow water model strong scaling benchmark; ┌──────────────┬───────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├──────────────┼───────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┤; │ (4096, 4096) │ 1 │ 8.738 s │ 8.738 s │ 8.738 s │ 8.738 s │ 392.52 KiB │ 2763 │; │ (4096, 4096) │ 2 │ 7.677 s │ 7.677 s │ 7.677 s │ 7.677 s │ 372.27 KiB │ 3195 │; │ (4096, 4096) │ 4 │ 5.063 s │ 5.063 s │ 5.063 s │ 5.063 s │ 372.41 KiB │ 3204 │; │ (4096, 4096) │ 8 │ 2.369 s │ 2.460 s │ 2.439 s │ 2.488 s │ 372.41 KiB │ 3204 │; │ (4096, 4096) │ 16 │ 1.356 s │ 1.381 s │ 1.389 s │ 1.438 s │ 371.72 KiB │ 3160 │; └──────────────┴───────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┘; [2021/03/12 17:32:56.309] INFO Writing Shallow_water_model_strong_scaling_benchmark.html...; Shallow water model strong scaling speedup; ┌──────────────┬───────┬─────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├──────────────┼───────┼─────────┼──────────┼─────────┤; │ (4096, 4096) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (4096, 4096) │ 2 │ 1.13814 │ 0.94841 │ 1.15635 │; │ (4096, 4096) │ 4 │ 1.72589 │ 0.948768 │ 1.15961 │; │ (4096, 4096) │ 8 │ 3.55262 │ 0.948768 │ 1.15961 │; │ (4096, 4096) │ 16 │ 6.32625 │ 0.947016 │ 1.14368 │; └──────────────┴───────┴─────────┴──────────┴─────────┘. ```. Using the means the efficients would be. ```; np effiiciency; == ========; 2 0.56; 4 0.43; 8 0.45; 16 0.39. ```. I suspect on a different day, or different computer, we will get better numbers. We will see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-797794664:1678,efficient,efficients,1678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-797794664,1,['efficient'],['efficients']
Energy Efficiency,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549:281,adapt,adapt,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549,3,"['adapt', 'power']","['adapt', 'adapted', 'powerful']"
Energy Efficiency,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:391,Adapt,Adapt,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008,3,"['Adapt', 'meter', 'schedul']","['Adapt', 'meters', 'schedule']"
Energy Efficiency,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472:185,adapt,adapted,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472,7,['adapt'],"['adapt', 'adapted']"
Energy Efficiency,I could keep cleaning things up but I think I've done enough to close #59 (and 6 other issues!). The only big feature missing is turning our `Field` struct into something we can adapt/convert to a CUDA device argument using `cudaconvert` or Adapt.jl. We can do more cleanup when we figure out how to do this. Note that tests will fail on dev/nightly builds (Julia 1.2) because something changed which broke Cassette (which GPUifyLoops depends on). Will release v0.5.0 once this is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479305069:178,adapt,adapt,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479305069,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Energy Efficiency,"I didn't have the same problem! I think that means the issue could arise from some downstream package in your Manifest.toml in your global 1.5 environment (which is not present in mine, for some reason). What is the output of. ```julia; julia> pkg""st --manifest""; ```. ?. Mine is. ```julia; julia> pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v2.4.0; [4fba245c] ArrayInterface v2.14.17; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e4b80f9] BenchmarkTools v0.7.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.3.0; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.4; [d360d2e6] ChainRulesCore v0.9.29; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.10.2; [3da002f7] ColorTypes v0.10.9; [5ae59095] Colors v0.12.6; [34da2185] Compat v3.25.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.3; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.2+1; [0c68f7d7] GPUArrays v6.2.0; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.53.0; [d2c73de3] GR_jll v0.53.0+0; [5c1252a2] GeometryBasics v0.3.9; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.8.19; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] Intel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:412,Adapt,Adapt,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,1,['Adapt'],['Adapt']
Energy Efficiency,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:62,reduce,reduce,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970,1,['reduce'],['reduce']
Energy Efficiency,"I don't know how the spherical hydrostatic model does this but I agree this would be nice to have for the rectilinear model as well. From what I recall from Sadourny (1975) you can have either energy or enstrophy conserving schemes, depending on how you do the averaging. When I played around with them I found that the enstrophy conserving scheme managed to prevent a numercial instability that can occur, but the energy conserving scheme did not. But getting either one (or both) working would be great!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735:193,energy,energy,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735,2,['energy'],['energy']
Energy Efficiency,"I don't mean to add to your alrady busy schedule but I do think that notebooks are pretty great and easy to use. I'm installing IJulia now, maybe something worth mentioning in the docs if you wanted to use jupyter, and am going to test it out myself. Also, I needed to add JLD2 to run the 1D diffusion problem. I might suggest saying explcitly you need to add this package?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724705606:40,schedul,schedule,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724705606,1,['schedul'],['schedule']
Energy Efficiency,"I don't mind if we call it ""Ri"" or not. The Richardson number has several interpretations and formulations; one interpretation is that it generally measures the ratio between potential energy and kinetic energy in the flow (this physical interpretation motivates its use in the ""stability correction"" proposed by Lilly 1962). The ""rate of strain definition"" limits to the ""typical"" oceanographic definition (also the quantity that arises in Kelvin-Helmholtz instability) for parallel laminar flow. Lilly 1962 used ""Richardson number"" and the symbol ""Ri"" to refer to this quantity:. ![image](https://user-images.githubusercontent.com/15271942/127530131-043ec421-8d7b-4420-9d75-5fd5aed36af3.png). For me, it's a natural generalization of the Richarsdon number that applies in unidirectional / laminar flow, so I feel it's nice notation. But not using it is ok too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889293513:185,energy,energy,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889293513,2,['energy'],['energy']
Energy Efficiency,"I don't think it's the tests that are slow. One of the tests involves time stepping a model for 10 time steps and it prints the wall clock time taken for each time step. It's only 2-3 ms so it's executing the tests at the expected speed. I've looked into the logs and it seems to be busy building packages. It's no different than what Travis and GitLab CI do, so maybe this just takes much longer on Windows CI? If we reduce the number of build dependencies that should help then. And if we can cache the builds then that would be excellent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-468291280:418,reduce,reduce,418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-468291280,1,['reduce'],['reduce']
Energy Efficiency,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1030,adapt,adapted,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,1,['adapt'],['adapted']
Energy Efficiency,"I don't think you can pass a field_dependency as symbols `(:v, :w)` because symbols cannot be passed into GPU kernels.; I'll check the proper syntax for `field_dependencies`. Correction: you should be able to because `field_dependencies` should not pass to the GPU when adapted, but now it is being passed internally somewhere...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748:270,adapt,adapted,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748,1,['adapt'],['adapted']
Energy Efficiency,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:644,reduce,reduce,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444,1,['reduce'],['reduce']
Energy Efficiency,"I finished the first draft (of the topics I know about at least). I haven't written the very last subsection though, which is about viewing/using arrays in GPU runs because honestly I don't know enough to write about it. I know there's a function called `view()` that helps with slicing, and you can also use `adapt` to view CUDA Arrays in REPL for investigating, but I feel like I don't know enough of this aspect of the code to write this. There are two options here:. - Someone helps me out and writes that last section; - Or I can merge the PR without it for now (there are many other important things there for the user) and we worry about that last part in a future PR. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032:310,adapt,adapt,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032,1,['adapt'],['adapt']
Energy Efficiency,"I found something. It's hard to provide code since I hacked apart the code base for this. I'll try to describe. I reduced `calculate_tendencies!` to just calculating the `u` tendency. I then wrote two methods:. ```julia; u_velocity_tendency(i, j, k, grid) = zero(grid); ```. and. ```julia; @inline function u_velocity_tendency(i, j, k, grid,; advection,; coriolis,; stokes_drift,; closure,; u_immersed_bc,; buoyancy,; background_fields,; velocities,; tracers,; auxiliary_fields,; diffusivities,; forcings,; hydrostatic_pressure,; clock). return zero(grid); end; ```. Even those these functions have identical output, applying `launch!` to the ""long argument list"" version is 300x slower. So the problem is in `launch!` somewhere?. Maybe splatting is the issue since we write. ```julia; """""" Calculate the right-hand-side of the u-velocity equation. """"""; @kernel function calculate_Gu!(Gu, args...); i, j, k = @index(Global, NTuple); @inbounds Gu[i, j, k] = u_velocity_tendency(i, j, k, args...); end; ```. ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481372033:114,reduce,reduced,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481372033,1,['reduce'],['reduced']
Energy Efficiency,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:846,reduce,reduce,846,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,2,['reduce'],['reduce']
Energy Efficiency,"I guess I agree that it'd be really nice to solve #1241... I've beat my head against the wall for quite a while on that problem. One solution is to invest more effort in trying to resolve it. Another possibility is to make the ""backup plan"" a bit easier (developing custom fields for complicated output). Since it's unlikely AbstractOperations will meet *all* of users diagnostics needs (considering the possibilty of weird / computationally intensive diagnostics...) I think this is a worthwhile investment anyways, even if we can make `AbstractOperations` more powerful. . @tomchor perhaps including some examples about how to develop custom diagnostics kernels in your own scripts will be useful, so that you don't feel like you are out of luck unless you have something like the LESbrary? What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738285838:563,power,powerful,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738285838,1,['power'],['powerful']
Energy Efficiency,I guess a way to do it might be by evaluating the kinetic energy budget (using a conservative method for advective fluxes),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404203605:58,energy,energy,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404203605,1,['energy'],['energy']
Energy Efficiency,I guess they are identical. Maybe we can change the `EnergyConserving` and `EnstrophyConserving` to `CenteredEnergyConserving` and `CenteredEnstrophyConserving`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2820#issuecomment-1312184365:53,Energy,EnergyConserving,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2820#issuecomment-1312184365,1,['Energy'],['EnergyConserving']
Energy Efficiency,"I guess this is not the issue (since `Qᵇ = 0`), but just be aware that this line:. https://github.com/BrodiePearson/Oceananigans.jl/blob/838cc38552ba8c4acff583aef840157cf7f145da/examples/nonlinear_EOS_crash.jl#L104. is not correct if `Qᵇ` is buoyancy flux (as the numbers of the commented out line suggest it is)--- it is only correct is `Qᵇ = 0` is *heat* flux. Which may be what you want anyways for this problem... Note also that TEOS10 requires a reference density. Thus this line:. https://github.com/BrodiePearson/Oceananigans.jl/blob/838cc38552ba8c4acff583aef840157cf7f145da/examples/nonlinear_EOS_crash.jl#L93. introduces a second reference density that isn't equivalent to the one used by TEOS10 (the [default for TEOS10 in `SeawaterPolynomials.jl` is 1020 kg / m^3](https://github.com/CliMA/SeawaterPolynomials.jl/blob/9e3342ec405bff01dee23e6309dd9de6fe342aa8/src/TEOS10.jl#L56)). The two can be synced by instantiating the TEOS10 equation of state object first:. ```julia; eos = TEOS10EquationOfState(FT); ```. and then using `eos.refererence_density`. You can also adjust the reference density for the equation of state by writing. ```julia; eos = TEOS10EquationOfState(FT, reference_density=1027); ```; As for negative salinity... the only thing I can think of is that its a numerical error due to a violation of a CFL condition (or something similar). Does reducing the CFL used in adaptive time stepping to 0.1 or 0.05 help? You might also reduce the initial time-step. With a strong momentum flux, you'll get strong surface velocities initially, and it may be best to start time-stepping with a very small time-step. Yo could try to replace this line: . https://github.com/BrodiePearson/Oceananigans.jl/blob/838cc38552ba8c4acff583aef840157cf7f145da/examples/nonlinear_EOS_crash.jl#L223. with. ```julia; wizard = TimeStepWizard(cfl=0.1, Δt=0.1, max_change=1.1, max_Δt=10.0); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659694281:1396,adapt,adaptive,1396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659694281,2,"['adapt', 'reduce']","['adaptive', 'reduce']"
Energy Efficiency,"I guess we talked on Slack but yeah the `depends_on` keyword argument idea does seem nicer and more general than just a `field_in_signature` or `field_dependent` kwarg. I guess to avoid interpolation issues we could just not interpolate for now which would still work for a large number of common boundary condition functions, e.g.; ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; τ₁₃_linear_drag(x, y, t, u, p) = p.μ * p.H * u; ```. Maybe interpolating these fields tangentially at the boundary would become easy once we have something like a lazy field or `ReducedField` implementation (#525)?. Are you thinking of resolving this issue as part of PR #894?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-685742271:570,Reduce,ReducedField,570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-685742271,1,['Reduce'],['ReducedField']
Energy Efficiency,"I guess when energy decreases to the point that advection is negligible compared to buoyancy/wave dynamics, the numerical diffusivity has no effect. At that point we just have wave dynamics acting on grid scale noise. I don't know what we expect. It is surprising that things blow up eventually. Adding `closure = ScalarDiffusivity(ν=1e-4, κ=1e-4)` causes energy to decrease monotonically.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442582678:13,energy,energy,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442582678,2,['energy'],['energy']
Energy Efficiency,I had missed that green line addition for the comment! Nice!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3678#issuecomment-2269974778:18,green,green,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3678#issuecomment-2269974778,1,['green'],['green']
Energy Efficiency,"I have a revision to my original post. Rather than add the size of the grid as types in the `RegularCartesianGrid` signature, we perhaps should come up with a `Topology` type indicator, eg:. ```julia; abstract type AbstractTopology end. struct Bounded <: AbstractTopology end; struct Flat <: AbstractTopology end; struct Periodic <: AbstractTopology end; ```. `AbstractGrid` then becomes. ```julia; abstract type AbstractGrid{FT, Tx, Ty, Tz} end; ```. where `(Tx, Ty, Tz)` denote the ""topology"" of the grid in their respect directions. For `Flat` grids, differentiation will return `0`, and interpolation will be reduced to an identity function. Distinguishing between `Periodic` and `Bounded` topologies will be useful for the implementation of higher-order operators that need to limit to a second-order derivative near non-periodic boundaries (this is important for avoiding the dreaded ""halo filling explosion""). I think this also corresponds more closely to the mathematical meaning of a ""Periodic"" and ""Flat"" dimension. Another thought is that we should make the constructor more verbose, eg. ```julia; RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz), topology=(Tx, Ty, Tz)).; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330#issuecomment-541196529:613,reduce,reduced,613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330#issuecomment-541196529,1,['reduce'],['reduced']
Energy Efficiency,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:519,schedul,schedule,519,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['schedul'],['schedule']
Energy Efficiency,"I have created a doc that goes with this example. This is my first attempt at this so feedback is greatly appreciated. Below are some questions that I have, 4 are mentioned explicitly in the docs and 1 I just thought of now. Of course these lines will be removed before merging. - <del>In the sidebar on the left I have that the title looks weird because of the underscores. How should I fix this?</del>; - <del>I should be able to reduce the number of lined with `using`. This may require modifying the model as well.</del>; - Should I change the parameters to be planetary or is this fine? ; - <del>The diagnostics that are produced are helped to compute the growth rates. Is there a cleaner way of doing this?</del>; - The final part should plot the figure and not save it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770:432,reduce,reduce,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770,1,['reduce'],['reduce']
Energy Efficiency,"I have noticed an issue with immersed boundaries in the latest version of [Oceananigans](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.91.4). At the immersed boundaries we expect the default tracer flux boundary conditions to be zero. While doing energy analysis, I noticed that something seemed off with my simulation. After increasing the colorrange in my animation, I noticed that near my immersed boundaries, the minimum buoyancy was drifting to values much less than the minimum value prescribed by the surface value boundary conditions, suggesting that the tracer flux at the immersed boundary is non-zero. For context, I'm running a 2D Horizontal Convection simulation, in which the buoyancy is initialized as zero everywhere to start. I apply a buoyancy gradient at the surface, cooling half of the surface and warming the other half. The boundaries are insulated and I have a pair of gaussian hills at the bottom defined using the immersed boundary function. Link to my [simulation setup](https://github.com/ikeshwani/HorizontalConvection/blob/main/src/simulation.jl). . Here is an animation of topographically-constrained horizontal convection where the nonhydrostatic pressure is not separated:. https://github.com/user-attachments/assets/9fd054c9-f1da-4b8d-9d04-b99479dbe348. Notice there seems to be a source of dense fluid in the basin between the hills. . To address this issue @hdrake and I separated the hydrostatic and nonhydrostatic pressure components in the `NonHydrostaticModel` by changing https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L70. To `hydrostatic_pressure_anomaly = CenterField(grid)`. Here is the animation of topographically-constrained horizontal convection when the pressure components are separated:. https://github.com/user-attachments/assets/249e9814-335f-49bb-999e-73a6f95fcf37",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677:258,energy,energy,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677,1,['energy'],['energy']
Energy Efficiency,"I have the following output writer set-up in my simulation:. ```julia; import Oceananigans.Fields: ComputedField; u, v, w = model.velocities.u, model.velocities.v, model.velocities.w; b, pHY′, pNHS = model.tracers.b, model.pressures.pHY′, model.pressures.pNHS; ν, νₑ = model.closure.ν, model.diffusivities.νₑ; #-----. #-----; import Oceananigans.AbstractOperations: ∂x, ∂y, ∂z. ddx = ∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2; ddy = ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2; ddz = ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2; #avg_ε = AveragedField(ComputedField(ddx + ddy + ddz), dims=(1,)); avg_ε = AveragedField(ν*(ddx + ddy + ddz), dims=(1,)). outputs = (ε = avg_ε,); simulation.output_writers[:avg_field_writer] =; NetCDFOutputWriter(model, outputs,; filepath = ""avg.jd15_3dbounded.nc"",; schedule = TimeInterval(2minutes),; mode = ""c""); ```. This works successfully on CPUs, but running on GPUs I get a huge amount of error lines with some . ```; [16] compute! at /glade/u/home/tomasc/.julia/packages/Oceananigans/6JcUu/src/Fields/averaged_field.jl:86 [inlined]; ```. Running the simulation without that output works for both GPUs and CPUs. Am I doing something wrong here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241:750,schedul,schedule,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241,1,['schedul'],['schedule']
Energy Efficiency,"I haven't had a chance to calculate this for GPUs yet, but I just wanted to open this for the time being. . Consider the following MWE that creates a given abstract operation (2D flow speed) and then calculates its x-average by using both a ` WindowedSpatialverage` and `AveragedField`:. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(64, 64), extent=(2π, 2π),; topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(architecture = CPU(),; grid = grid,; buoyancy = nothing,; tracers = nothing,; closure = nothing,; ). using Oceananigans.Diagnostics: WindowedSpatialAverage; u, v, w = model.velocities; s = sqrt(u^2 + v^2). s_wind = WindowedSpatialAverage(ComputedField(s), dims=(1,)); s_avgf = AveragedField(s, dims=(1,)). simulation = Simulation(model, Δt=0.2, stop_time=4). simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; s_wind, s_avgf),; schedule = TimeInterval(2),; filepath = ""2drot.nc"",; mode = ""c"",; verbose=true,; ); run!(simulation); ```. When I run this example I get:. ```; julia> include(""2drot.jl""); [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 283.373 μs.; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 1: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=1.592 seconds; [ Info: Computing s_avgf done: time=10.888 seconds; [ Info: Writing done: time=12.480 seconds, size=14.5 KiB, Δsize=0.0 B; [ Info: Executing first time step...; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 2: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=378.512 μs; [ Info: Computing s_avgf done: time=6.476 seconds; [ Info: Writing done: time=6.477 seconds, size=27.1 KiB, Δsize=0.0 B; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 3: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=322.307 μs; [ Info: Computing s_avgf done: time=6.301 seconds; [ Inf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024:890,schedul,schedule,890,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024,1,['schedul'],['schedule']
Energy Efficiency,"I haven't looked at APE because it's harder to compute. Although maybe with the area and distance operators it wouldn't be too hard to calculate it via integral (Winters et al., 1995):. ![image](https://user-images.githubusercontent.com/13205162/221880181-55c6efb5-bef5-43c7-b105-2be6056ffd85.png). where $z*$ is the sorted $z$. Note that initially the APE is zero since there are no fluctuations on top of the linear stable stratification. So the initial KE is indeed all the energy available to the system.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1448262472:477,energy,energy,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1448262472,1,['energy'],['energy']
Energy Efficiency,"I interpreted #1138 to be a broader issue about better simulation callbacks and stop criteria. So this PR only addresses a small part of #1138, item number 5 in particular. I don't think it's super different from what was suggested in #1138. The central function is. ```julia; Δt = align_time_step(simulation); ```. instead of. ```julia; # Might have to be align!(simulation, ...) as numbers are passed by value.; align!(simulation.Δt, writer.schedule, simulation.model); ```. and both seem compatible/orthogonal with the other changes proposed by #1138, but I can change this PR to implement an `align!` function instead if we think it's better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-734417124:443,schedul,schedule,443,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-734417124,1,['schedul'],['schedule']
Energy Efficiency,I just changed the Adapt.jl compat entry to make use of the new version with the `StepRangeLen` fix. The MWE from #3870 does not error with Adapt.jl v4.1.1 locally.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135:19,Adapt,Adapt,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135,2,['Adapt'],['Adapt']
Energy Efficiency,"I just created this quickly so that I could pull the created branch locally and start coding. I think the final approach will be very different. I now think the best way is to especially `min_Δx`, etc, and use that everywhere we can. After all, there;s also the diffusive time scale to worry about. Although, like you said, we should probably consider calculating the CFL as a reduced field in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799591051:377,reduce,reduced,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799591051,1,['reduce'],['reduced']
Energy Efficiency,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:187,Adapt,Adapt,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Energy Efficiency,"I made a PR that adds a warning and changes the default for immersed boundary grids: https://github.com/CliMA/Oceananigans.jl/pull/3692. I don't think this issue can really be closed. There will continue to be errors on immersed boundary grid for non-separated pressure. Perhaps, once we have a new solver that we are confident reduces the chance of egregious errors, we can convert this to a discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2275788394:328,reduce,reduces,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2275788394,1,['reduce'],['reduces']
Energy Efficiency,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:178,adapt,adapt,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461,1,['adapt'],['adapt']
Energy Efficiency,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/242:286,adapt,adapt,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242,1,['adapt'],['adapt']
Energy Efficiency,"I propose we change the API for vector invariant with WENO interpolation to read something like. ```julia; momentum_advection = VectorInvariant(WENO5(), VelocitySmoothness()); ```. or something like that. In other words I think the nesting should be reversed: the _first_ question is whether we are using the vector invariant or flux form formulation (flux form is default right now). The _second_ question is how we interpolate vorticity. The _third_ question is the field used in the smoothness metric. I also think we should disentangle the smoothness indicators (eg velocity and vorticity) from the WENO5 struct; we can express this concept simply by re-writing the functions to accept two fields: one for reconstruction, and one for smoothness. The default uses the reconstructed field for smoothness. `VectorInvariant` will handle passing vorticity or velocity into those kernels. We'll then need. ```julia; struct VectorInvariant; vorticity_stencil # energy or enstrophy conserving; vorticity_reconstruction # any advection scheme but we focus on `WENO5` and `CenteredSecondOrder()`; smoothness_indicator # `VelocitySmoothness()` or `VorticitySmoothness()`; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138:958,energy,energy,958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138,1,['energy'],['energy']
Energy Efficiency,"I ran. ```julia; using Oceananigans; using NCDatasets. Nx = Ny = Nz = 16; grid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 1, 1)). tracer_names = Tuple(Symbol(:τ, n) for n = 1:6); model = NonhydrostaticModel(; grid, tracers=tracer_names). uᵢ(x, y, z) = randn(); cᵢ(x, y, z) = sin(2π * z / grid.Lz); kw = NamedTuple(c => cᵢ for c in tracer_names); set!(model; u=uᵢ, v=uᵢ, w=uᵢ, kw...). simulation = Simulation(model, Δt=0.1/Nx, stop_iteration=100). u, v, w = model.velocities; fluxes = NamedTuple(Symbol(""wτ$n"") => Field(w*c) for (n, c) in enumerate(model.tracers)); averaged_fluxes = NamedTuple(Symbol(""avg_wτ$n"") => Average(flux, dims=2) for (n, flux) in enumerate(fluxes)). jld2_filename = ""test.jld2""; nc_filename = ""test.nc""; kwargs = (schedule = IterationInterval(1),; verbose = true,; indices = (:, 1, :),; overwrite_existing = true). simulation.output_writers[:jld2] = JLD2OutputWriter(model, merge(fluxes, averaged_fluxes);; filename = jld2_filename,; kwargs...). simulation.output_writers[:nc] = NetCDFOutputWriter(model, merge(fluxes, averaged_fluxes);; filename = nc_filename,; kwargs...). run!(simulation). ds = Dataset(nc_filename). Ntracers = length(tracer_names); flux_timeseries = Dict(""wτ$n"" => FieldTimeSeries(filename, ""wτ$n"") for n = 1:Ntracers); average_flux_timeseries = Dict(""wτ$n"" => FieldTimeSeries(filename, ""avg_wτ$n"") for n = 1:Ntracers). flux_1_nc = ds[""wτ1""]; avg_flux_1_nc = ds[""avg_wτ1""]; flux_1 = flux_timeseries[""wτ1""]; avg_flux_1 = average_flux_timeseries[""wτ1""]. for n = 2:Ntracers; flux_n = flux_timeseries[""wτ$n""]; avg_flux_n = average_flux_timeseries[""wτ$n""]. @show ""Fluxes for tracer $n:""; @show all(flux_1[:, 1, :, :] .≈ flux_n[:, 1, :, :]); @show all(avg_flux_1[:, 1, :, :] .≈ avg_flux_n[:, 1, :, :]); @show all(flux_1_nc .≈ ds[""wτ$n""]); @show all(avg_flux_1_nc .≈ ds[""avg_wτ$n""]); end. close(ds); ```. and all the fluxes and averaged fluxes are identical for both JLD2 and NetCDF output writers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436113039:744,schedul,schedule,744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436113039,1,['schedul'],['schedule']
Energy Efficiency,"I reducing the time step to `0.1`, and it still becomes unstable. . What's interesting is that `NaN`'s appear in the velocity field after about 100 iterations, regardless of whether the time step is 20 or 0.1 seconds. . When I reduced the amplitude of the topograpahy by a factor of 2, it was stable for a long time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129168647:227,reduce,reduced,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129168647,1,['reduce'],['reduced']
Energy Efficiency,I reminded myself that there is some motivation/explanation just before the beginning of the section **A Powerful algorithm**.; I added some more clarifications. @jklymak what do you think?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1298:105,Power,Powerful,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1298,1,['Power'],['Powerful']
Energy Efficiency,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:131,adapt,adapt,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['adapt'],['adapt']
Energy Efficiency,"I run this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size=(16, 16, 16), extent = (500, 500, 120)). n_tracers = 6; tracer_symbols = [ Symbol(:τ, i) for i in 1:n_tracers ]; model = NonhydrostaticModel(; grid, tracers = (tracer_symbols...,)); @info model. uᵢ(x, y, z) = 1e-2 * randn(); set!(model, w=uᵢ). tracer_IC_odd(x, y, z) = sin(2π * z / grid.Lz); for i in 1:n_tracers; @info ""Setting tracer $i""; expression = Meta.parse(""set!(model, τ$i=tracer_IC_odd)""); eval(expression); end. simulation = Simulation(model, Δt=30, stop_iteration=4). u, v, w = model.velocities. wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key, τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full)). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""test.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. and got; ```Julia; [ Info: Initializing simulation...; [ Info: Writing to NetCDF: ./test.nc...; [ Info: Computing NetCDF outputs for time index 1: [""wτ3"", ""wτ2_yavg"", ""wτ6_yavg"", ""wτ1"", ""wτ5_yavg"", ""wτ6"", ""wτ2"", ""wτ5"", ""wτ4"", ""wτ1_yavg"", ""wτ4_yavg"", ""wτ3_yavg""]...; [ Info: Computing wτ3 done: time=439.823 ms; [ Info: Computing wτ2_yavg done: time=3.404 seconds; [ Info: Computing wτ6_yavg done: time=3.018 seconds; [ Info: Computing wτ1 done: time=225.326 ms; [ Info: Computing wτ5_yavg done: time=2.950 seconds; [ Info: Computing wτ6 done: time=292.708 μs; [ Info: Computing wτ2 done: time=192.674 ms; [ Info: Computing wτ5 done: time=190.263 ms; [ Info: Computing wτ4 done: time=193.185 ms; [ Info: Computing wτ1_yavg done: time=1.210 seconds; [ Info: Computing wτ4_yavg done: time=2.954 seconds; [ Info: Computing wτ3_yavg done: time=2.953 seconds; [ Info: Writing done: time=17.732 s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387:973,schedul,schedule,973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387,1,['schedul'],['schedule']
Energy Efficiency,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330:1350,efficient,efficient,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330,1,['efficient'],['efficient']
Energy Efficiency,"I see it like this: Tartarus is a shared system with very small limitations so it is quite difficult to prevent people from running on GPU 0 (I do not think we have the ability to implement a scheduler), so there is more possibility to incur in downtime due to users running on GPU 0. The Caltech cluster might be slower but is much more reliable because it has a professionally maintained slurm scheduler that prevents these types of problems. I tend to prefer having reliability over a modest speedup for these cases, but I am ok with other solutions. One solution would be to routinely kill the jobs on tartarus running on GPU 0 without warning, that would be possible only for people with access on tartarus though. I am ok following that route (I just killed a couple of jobs now 😅). It would be nice to find a more permanent solution though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587:192,schedul,scheduler,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587,2,['schedul'],['scheduler']
Energy Efficiency,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:312,efficient,efficient,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659,1,['efficient'],['efficient']
Energy Efficiency,I still think it might be a good idea to implement `VectorInvariant` in `ShallowWaterModel` first because then (1) we have a (hopefully positive) addition to the code (2) we have an exact solution to quantitatively and efficiently test the scheme on,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062904021:219,efficient,efficiently,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062904021,1,['efficient'],['efficiently']
Energy Efficiency,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260:486,schedul,schedule,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260,1,['schedul'],['schedule']
Energy Efficiency,"I think I understand the issue now. Here's a summary of what we are trying to do. 1. Create a 3D computed field `wc = Field(w*c)`; 2. Create a reduced field that averages this field: `wc_avg = Average(wc, dims=2)`. Note that we usually recommend averaging an _operation_ rather than `Field` via `wc_avg = Average(w*c, dims=2)`, which is more efficient if we don't require the three-dimensional results in `wc`. If we do require the 3D `wc` as well, we could compute its average in post processing on the fly. But I guess there are use cases for precomputing the 3D field (convenience, or GPU compilation issues...). Next, we . 3. Slice into both the reduced field _and_ the 3D field in an output writer by passing the kwarg `indices = (:, 1, :)`. As discussed above, we aren't sure if this is good practice, since we're asking the output writers to ""reindex"" a reduced field in `y` along a specific y index, ie `(:, 1, :)`. Being a reduced field, the y-index is meaningless, so this kwarg is basically ignored for the reduced field. I think a better way to write this code is to build the `indices` for each output individually / manually rather than using the convenience kwarg. Nevertheless --- for this last step, the output writer creates a ""view field"" that slices into the original 3D field (ie it does not allocate any additional memory, but instead creates a new field whose `data` is a view into the parent 3D field):. https://github.com/CliMA/Oceananigans.jl/blob/e394bf7ef7e4341ffddd449f52f58cee84698813/src/OutputWriters/output_construction.jl#L46. this calls. https://github.com/CliMA/Oceananigans.jl/blob/e394bf7ef7e4341ffddd449f52f58cee84698813/src/Fields/field.jl#L180. which calls. https://github.com/CliMA/Oceananigans.jl/blob/e394bf7ef7e4341ffddd449f52f58cee84698813/src/Fields/field.jl#L298-L322. Note that `view(f, i, j, k)` passes `f.status` into the sliced field. This is the issue --- then when we call `compute!(sliced_f)`, the parent field `f` ""thinks"" it has been computed, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438491184:143,reduce,reduced,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438491184,6,"['efficient', 'reduce']","['efficient', 'reduced']"
Energy Efficiency,"I think I'd be on board with `XAverage`, `XYAverage`, etc. as Oceananigans.jl is not on the sphere so there's no notion of a zonal or meridional direction (unless maybe when implied by an `FPlane` or `BetaPlane`). I do prefer `HorizontalAverage` over `ZAverage` though, but would rather not have a lot of aliases floating around... > We need tests for both the zonal average and the volume average before this can be merged. Yeah for sure. @sandreza and I were gonna add those next time we pair program. Also reduce the amount of boilerplate as you suggested in your review of #783. > Does this PR replace #783?. Yes so I closed #783 and left an explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-658228502:509,reduce,reduce,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-658228502,1,['reduce'],['reduce']
Energy Efficiency,I think I've fixed this for lat/lon grids given the new `x/ynode` definitions for lat/lon grids without touching the lagrangian particles (and assuming they're still positioned in degrees not meters) (@tomchor). I'm not so keen on my function names:; https://github.com/CliMA/Oceananigans.jl/blob/92709dd96852af2806ec91148e6d463c67f25787/src/Fields/interpolate.jl#L61-L77; but can't think of better alternatives,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1550228541:192,meter,meters,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1550228541,1,['meter'],['meters']
Energy Efficiency,"I think [Coordinate system and notation](https://clima.github.io/OceananigansDocumentation/stable/physics/notation/) page in the docs needs to be updated. . First, we don't only use a Cartesian grid anymore (we don't even use the word Cartesian for the `RegularRectilinearGrid` anymore). I'm not sure how you guys wanna adapt this page and notation for the spherical coordinate grid though. Second, a part of the math isn't rendering and I'm not sure why.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1779:320,adapt,adapt,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1779,1,['adapt'],['adapt']
Energy Efficiency,"I think `reverse` allocates memory though, so I don't know if we want to use it...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035263877:18,allocate,allocates,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035263877,1,['allocate'],['allocates']
Energy Efficiency,"I think a new type would reduce confusion. Right now `ConstantIsotropicDiffusivity` is fine as it's both constant in time and space, but could be confusing if it's just constant in time. `SpatiallyVaryingIsotropicDiffusivity` is a bit of a mouthful, but being verbose is probably better than having the user guess or have them continuously checking the documentation. > Also, I am realizing that we want to do this with functions rather than arrays. Arrays can always be implemented via a function that accesses a `const` array anyways, but would be good to benchmark.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531226496:25,reduce,reduce,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531226496,1,['reduce'],['reduce']
Energy Efficiency,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470:800,efficient,efficient,800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470,1,['efficient'],['efficient']
Energy Efficiency,"I think for idealized stuff the hydrostatic model is fairly well tested, but if one wants to do complex domains, problems requiring mixing parameterizations, etc, then our capability is still a little green I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576:201,green,green,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576,1,['green'],['green']
Energy Efficiency,"I think functions that output something will likely only be called during the construction of types --- which occurs once in the model lifecycle, during initialization. After model initialization, almost no new memory can be allocated; therefore all functions mutate existing data structures. This concept manifests even at the user-level, where one scripting pattern might be. ```; model = Model(parameters...). set_ic!(model, ic). run!(model); ```. In this case, the user obtains an output (`model`) from the `Model` constructor at model initialization. Subsequently, all compute-intensive operations act to mutate 'model' in place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437380066:225,allocate,allocated,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437380066,1,['allocate'],['allocated']
Energy Efficiency,"I think it looks pretty good! Thanks @josuemtzmo for the work on `NetCDFOutputWriter`. In a future PR, we can add a test to ensure that `file_splitting = TimeInterval(T)` works. Also I'm trying to brainstorm a better word to use than ""actuated"" for talking about scheduling. But I think once the tests pass we should merge this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2016537205:263,schedul,scheduling,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2016537205,1,['schedul'],['scheduling']
Energy Efficiency,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:157,Adapt,Adapt,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881,1,['Adapt'],['Adapt']
Energy Efficiency,"I think it should be part of the `Fields` submodule. `Average` would be a wrapper around `ReducedField`. It would have similar behavior, but with the added complication that it requires evaluation to be correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-675819405:90,Reduce,ReducedField,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-675819405,1,['Reduce'],['ReducedField']
Energy Efficiency,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:533,reduce,reduce,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,1,['reduce'],['reduce']
Energy Efficiency,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:398,efficient,efficiently,398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328,1,['efficient'],['efficiently']
Energy Efficiency,"I think the problem is basically that the schedules are not saved to the checkpoint. Actually, the output themselves are also not saved to checkpoint which is also an issue for time averages. I believe this wasn't previously an issue but recent changes to `TimeInterval` in #3616 may have created the problem... Likely we can find some simple way to fix `TimeInterval` but let's keep in mind that there are some broader challenges to be solved for checkpointing that basically will require a feature that can save callback and output writer states.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467:42,schedul,schedules,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467,1,['schedul'],['schedules']
Energy Efficiency,"I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533:269,efficient,efficient,269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533,1,['efficient'],['efficient']
Energy Efficiency,"I think the setup looks great! Hopefully we can reduce the number of import statements (especially after #1132). The 2D turbulence example always looks great but it might be nice to do something different just to have more variety in the examples. Is there a neat example that requires a shallow water model?. Alternatively we could convert the 2D turbulence example to use `ShallowWaterModel` if the output still looks cool. This would increase variety among the existing examples. Having an example with `ShallowWaterModel` would suggest it's ready for use though, so it should then be exported.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780101036:48,reduce,reduce,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780101036,1,['reduce'],['reduce']
Energy Efficiency,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136:97,schedul,schedules,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136,1,['schedul'],['schedules']
Energy Efficiency,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977:111,adapt,adapted,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977,1,['adapt'],['adapted']
Energy Efficiency,"I think this PR is ready for another review @glwagner. Users can now specify their own particle types with custom properties, e.g. ```julia; struct Microbe{T, S, D}; x :: T; y :: T; z :: T; w :: T; T :: T; species :: S; dna :: D; end; ```. where `w` and `T` can store the w and T at the particle's location if `tracked_fields = (w=model.velocities.w, T=model.tracers.T)` is passed to `LagrangianParticles`. Tracked fields can include `ComputedField`s (see the tests). Custom properties, e.g. `species` and `dna`, can be modified via a callback. We might have to figure out callbacks for `LagrangianParticles`. I think ideally we'll want a schedule for the callback so might make sense to do this with/after #1138. Right now it's kind of a ""hidden feature"" as I modify custom particle properties as part of the simulation callback. I should run benchmarks for 0-10 tracked fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-738174154:639,schedul,schedule,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-738174154,1,['schedul'],['schedule']
Energy Efficiency,"I think this is a a big step forward and happy to share my two cents worth. I agree that we should keep `gravitational_acceleration` the same as before. We will need to have a bunch of `g'`. Since we have a free surface, we assume that we have air above, then `g'` of the top layer is really just `g`. That's why I would suggest having n reduced gravities for n layers. We will need n interfaces and we could also store the n heights. Sometimes it's convenient to have one or the other. For efficiency we only need one, but for convenience we might want to have both. What are people's preferences?. The more layers we have, the thinner each layer tends to be. This means that it's more likely that layer depths can vanish. If this ever happens, then a numerical instability can happen. I remember discussing with @simone-silvestri using the positive preserving property of WENO to deal with this but I also remember that a preliminary test showed that it wasn't actually ensure to be positive. Sadly, I didn't follow up. Any idea if that was fixed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717:338,reduce,reduced,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717,1,['reduce'],['reduced']
Energy Efficiency,"I think we should run it at a reasonably high resolution to produce eddies, and then checkpoint the run and upload it to `OceananigansArtifacts.jl`. Then we can download the checkpoint in the example, restart from there and run maybe 100 iterations to make a (short) animation?. It might make sense to revisit some of the more expensive examples and reduce their cost too (until we find a way to run examples on tartarus, or some other way to make them less expensive).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1025775907:350,reduce,reduce,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1025775907,1,['reduce'],['reduce']
Energy Efficiency,"I think we still need `Base.show` for `Reduction`. That would go here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/field_reductions.jl. The issue is that we only added `show` for `ReducedComputedField`, but not `Reduction` itself. https://github.com/CliMA/Oceananigans.jl/blob/2436895ee931c730c077031d955dd1780816b2ac/src/Fields/field_reductions.jl#L85. A pattern we use elsewhere is to start `show(io, obj)` by printing `summary(obj)`. This allows us to define new `summary` but keep the same `show` body. Like here:. https://github.com/CliMA/Oceananigans.jl/blob/2436895ee931c730c077031d955dd1780816b2ac/src/AbstractOperations/show_abstract_operations.jl#L24-L28",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073022456:199,Reduce,ReducedComputedField,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073022456,1,['Reduce'],['ReducedComputedField']
Energy Efficiency,"I think we want to consider calling `precomputations!(model)` (and perhaps changing its name) _after_ a time-step is complete, rather than before. The reason to do this is that it ensures _all_ fields are _entirely_ up-to-date and synchronized between time-steps. Currently, for example, field halo regions, hydrostatic pressure, and diffusivities are a ""step behind"" model.velocities and model.tracers. This is a problem for some diagnostics; for example, turbulent kinetic energy dissipation cannot be correctly calculated during output. Correct halo regions also cannot be saved. Having the entire model state synced at the end of a time-step is thus important for correct output. There's no extra computational cost to this procedure. However, we will have to execute one special call to `precomputations!(model)` inside `run!(simulation)` to initialize a time-stepping loop. I think this price is worth it. This change will mean that all aspects of the model state are ""untouchable"" between time-steps. In other words, one cannot change halos or the pressure fields at whim. I think this is ok, since this is already true for the majority of the model data (interior parts of the model velocities and tracer fields). This issue is entangled with #1063 since we cannot resolve this issue until we have standard output that does not change a field's halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1069:475,energy,energy,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069,1,['energy'],['energy']
Energy Efficiency,"I think we want to show both checkpointing and pickup/restoring from a checkpoint like a script that's meant to be resubmitted multiple times to a job scheduler like Slurm (and we can also include the accompanying Slurm file). Actual example itself may not be that important. If anything, checkpointing just involves adding a few lines so it could be a pretty small section.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1136#issuecomment-813452833:151,schedul,scheduler,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1136#issuecomment-813452833,1,['schedul'],['scheduler']
Energy Efficiency,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:577,reduce,reduce,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534,2,"['reduce', 'sustainab']","['reduce', 'sustainable']"
Energy Efficiency,"I think you're right that `view(::Field)` doesn't recover the same behavior as `view(::Array)`. This is because `Field` are fixed to three dimensions; we don't have a way to express the concept of a `Field` with one dimension. So for example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid);. julia> size(view(c, 1, :, 2)); (1, 3, 1). julia> size(view(parent(c), 1, :, 2)); (9,); ```. If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481:655,reduce,reduced-dimensionality,655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481,1,['reduce'],['reduced-dimensionality']
Energy Efficiency,"I think, for now, since all docs built in 1h then let's not bother. But if we want to reduce it we'd know we have to start from the SWE example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630300785:86,reduce,reduce,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630300785,1,['reduce'],['reduce']
Energy Efficiency,"I thought we had decided to leave oceananigans as an LES model. Rather than; develop it further as an all-purpose model. That is what CliMa-O is going; to be. On Wed, Nov 13, 2019, 12:38 PM Ali Ramadhan <notifications@github.com>; wrote:. > Hey @navidcy <https://github.com/navidcy> topography hasn't been a; > priority for us as we're not looking at any problems where topographic; > effects are important (yet), although other people have asked about it (cc; > @hdrake <https://github.com/hdrake>) and we would like to include; > topography at some point. Some would argue that an ocean model without; > topography isn't an ocean model...; >; > From discussing this with @glwagner <https://github.com/glwagner> it; > seems like you could implement topography via an immersed boundary method; > that accounts for the topography via additional terms in the momentum; > equation, allowing us to keep using our efficient pressure solver which; > would be really cool.; >; > @glwagner <https://github.com/glwagner> posted this on Slack a few weeks; > ago:; >; > At some point, we should discuss how we plan to implement topography /; > complex boundaries. Immersed boundary methods (like that used in MITgcm); > are probably the right approach. However, MITgcm uses a cut-cell technique; > that may require modifying the pressure solver. In contrast, a “continuous; > forcing method” that introduces forcing terms into the mometum / tracer; > equations to account for the solid boundary could potentially be easier to; > implement, since the pressure solver would not have to be modified. Here’s; > a paper that compares two implementations (though their “discrete forcing; > method” implementation uses ghost cells rather than cut cells as in; > MITgcm):; > https://www.sciencedirect.com/science/article/pii/S0009250918306250#b0120; >; > There's also Tseng & Ferziger (2003); > <https://www.sciencedirect.com/science/article/pii/S0021999103004108> who; > implemented a ghost-cell immersed boundary metho",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553389217:909,efficient,efficient,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553389217,1,['efficient'],['efficient']
Energy Efficiency,"I tried to compare computing Nu from saved χ and from saved b and I got some differences. Any ideas what's happening here?. So with only the `.jld2` output you get when you run the example, I did:. ```Julia; using JLD2, Plots; using Oceananigans; using Oceananigans.AbstractOperations: volume; using Oceananigans.Fields. saved_output_prefix = ""horizontal_convection""; saved_output_filename = saved_output_prefix * "".jld2"". file = jldopen(saved_output_filename); κ = file[""closure/κ/b""]. χ_timeseries = FieldTimeSeries(saved_output_filename, ""χ""). t = χ_timeseries.times; grid = χ_timeseries.grid. ∫ⱽ_χ = ReducedField(Nothing, Nothing, Nothing, CPU(), grid, dims=(1, 2, 3)); Nu_from_χ = zeros(length(t)). ## Can we broadcast over the time dimension?; for i = 1:length(t); χ = χ_timeseries[i]; sum!(∫ⱽ_χ, χ * volume); Nu_from_χ[i] = ∫ⱽ_χ[1, 1, 1]; end. plot(t, Nu_from_χ,; title = ""A measure for Nu(t)"",; xlabel = ""Time"",; ylabel = ""Nu(t)"",; linewidth = 3,; label = ""computed from saved χ""). b_timeseries = FieldTimeSeries(saved_output_filename, ""b""). t = b_timeseries.times; grid = b_timeseries.grid. ∫ⱽ_mod_∇b = ReducedField(Nothing, Nothing, Nothing, CPU(), grid, dims=(1, 2, 3)); Nu_from_b = zeros(length(t)). ## Can we broadcast over the time dimension?; for i = 1:length(t); b = b_timeseries[i]; sum!(∫ⱽ_mod_∇b, κ * (∂x(b)^2+∂z(b)^2) * volume); Nu_from_b[i] = ∫ⱽ_mod_∇b[1, 1, 1]; end. plot!(t, Nu_from_b,; linestyle = :dash,; linewidth = 3,; label = ""computed from saved b""). savefig(""two_Nu_computations.png""); ```. ![two_Nu_computations](https://user-images.githubusercontent.com/7112768/125404874-7d648180-e3fa-11eb-8f90-6171b0e40d1e.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878826622:604,Reduce,ReducedField,604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878826622,2,['Reduce'],['ReducedField']
Energy Efficiency,I tried two problems in horizontally-periodic domains: a problem with circular wind stress (Beaufort-like) and an idealized Eady problem. . These problems are also nominally hydrostatic and I'd also like to understand differences in numerical stability (if they exist) between non-hydrostatic and hydrostatic algorithms. This is also an easy modification to the code (though off topic for this issue). . Perhaps we can discuss more offline and outline an efficient but also forward-looking strategy to achieve fast time-to-solution for these problems?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546716771:455,efficient,efficient,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546716771,1,['efficient'],['efficient']
Energy Efficiency,"I tried. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; summed_c = Field(Reduction(sum!, c, dims=1)); @time compute!(summed_c); @time compute!(summed_c); ```. which produces. ```julia; julia> @time compute!(summed_c); 0.103867 seconds (153.65 k allocations: 10.584 MiB, 13.85% gc time, 99.78% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(summed_c); 0.000114 seconds (60 allocations: 3.000 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:452,reduce,reduced,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['reduce'],['reduced']
Energy Efficiency,"I updated the title to broaden the issue to include show for `Field`. @simone-silvestri suggests on #2121 that we also include some information about field _values_, like for example maximum and minimum, or mean (or even just print the whole array for small / reduced fields).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-1012213458:260,reduce,reduced,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-1012213458,1,['reduce'],['reduced']
Energy Efficiency,"I used `validation/mesoscale_turbulence/baroclinic_adjustment.jl` but I reduced the grid size. The big problem of main is the implicit solver, so if you don't use it you see only the difference given by the tracer tendencies, which is smaller. The results above, however, are obtained using exactly the same code you posted (on a mac M1 with one thread though, you use 6, so maybe that is the root cause of the difference)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486143133:72,reduce,reduced,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486143133,1,['reduce'],['reduced']
Energy Efficiency,"I vote we include it. Even if it's not the most efficient implementation, it's probably gonna be useful for some users. Also might prompt users to contribute if they see that the closure exists, but also see it has limitations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967752595:48,efficient,efficient,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967752595,1,['efficient'],['efficient']
Energy Efficiency,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:599,Green,Green,599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407,3,['Green'],['Green']
Energy Efficiency,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:524,green,green,524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583,3,"['energy', 'green']","['energy', 'green']"
Energy Efficiency,"I was envisioning option 2 (or both if we feel that `initialize!(callback)` is an important option). An important practical reason to have option 2 is that some callbacks will only be called very infrequently so it's better to quickly find out that there's a typo or mistake in your callbacks before the simulation runs for 1,000,000 iterations if the callback's schedule is `IterationInterval(1_000_000)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-739544658:363,schedul,schedule,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-739544658,1,['schedul'],['schedule']
Energy Efficiency,"I was trying use `NetCDFOutputWriter` to write some data using the syntax that is used in the example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/) and tried the following:. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filename = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. That did not work. The error was `keyword argument filepath not assigned`. . I checked `help` it said I should be using `filepath` instead of `'filename`. Hence I tried the following, which did work. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filepath = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. I am using juliav1.6 and `NCDatasets v0.12.4`, which seems to be the latest version. . Does anyone have any suggestions as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2541:355,schedul,schedule,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2541,2,['schedul'],['schedule']
Energy Efficiency,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226:590,schedul,schedule,590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226,1,['schedul'],['schedule']
Energy Efficiency,I will deal with it during morning coffee and merge. If in the mood will add the energy plot :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722347761:81,energy,energy,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722347761,1,['energy'],['energy']
Energy Efficiency,I will work on the time splitting schedule. Should we do it in this PR? or should I do another one once it is ready?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2002622733:34,schedul,schedule,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2002622733,1,['schedul'],['schedule']
Energy Efficiency,"I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. ; We have an implementation like that for `fill_halo_regions!` here; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78. What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields. On the other hand, if defining a new type is useful for OutputWriters I am ok with it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688:170,Reduce,Reduced,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688,1,['Reduce'],['Reduced']
Energy Efficiency,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990:444,efficient,efficient,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990,1,['efficient'],['efficient']
Energy Efficiency,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:281,Adapt,Adapt,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313,1,['Adapt'],['Adapt']
Energy Efficiency,"I'd be on board with assuming `AbstractField` elements must be lazily evaluated with `::Field` being a special no-op case. And with renaming `Computation` to `ComputedField`. > There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. Right I was referring to the `Average` methods defined in `AbstractOperations`. > For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. Yeah I considered this as it seems like the most sensible solution but then instead of a useful error, users could end up allocating huge 3D arrays and run out of GPU memory (at which point it might be hard for them to figure out what they did wrong). > `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. Hmmm, does it make sense to rename the `Average.field` property to `Average.kernel` in line with `WindowedTimeAverage` in PR #856?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622:615,allocate,allocated,615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"I'd like to also two 2D examples. 1. rising thermal bubble and; 2. lid-driven cavity. as super simple examples. Their set up shouldn't take more than 10 lines excluding comments. > Dramatically simplify internal wave example. +1! Always good to simplify scripts as much as possible. Would also be nice to include it in the example tests (PR #418) if it can use something like `makeplot = false`. > Free decay of two dimensional turbulence (use x,y plane). Only issue with 2D xy-plane simulations is I think things are weird with `Nz=1` so I had to use `Nz=2` (see Taylor-Green vortex test in `test_dynamics.jl`). 1D and 2D models haven't been a priority unfortunately so this sort of stuff has cropped up. I think 2D xz and yz simulations are fine with `Ny=1` and `Nx=1` respectively. > Stratified Couette flow example. I can simplify the simulation script from PR #381 down to a 2D example. This one would be good. > I think we should split deepening mixed layer into a few examples. Sound like a good idea!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084378:571,Green,Green,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084378,1,['Green'],['Green']
Energy Efficiency,"I'd like to resurrect this issue. We've implemented 5, but we don't have callbacks. I think we should just add a callback layer to `Simulation` to replace `simulation.progress` and address whether diagnostics should become callbacks later. The key change is that `iteration_interval` would no longer be an argument to `Simulation`. Instead we would refactor all the examples and validation tests to implement logging and adaptive time stepping via callbacks. Because of that this ends up being a big API change. A barebones callback feature might be. ```julia; struct Callback{F, S}; func :: F; schedule :: S; end; ```. Usage would be something like. ```julia; progress(sim) = println(""Iteration $(sim.model.clock.iteration)""); progress_printer = Callback(progress, schedule = IterationInterval(100)). wizard = TimeStepWizard(cfl=0.1, initial_dt = 2minutes, schedule = IterationInterval(10)). simulation = Simulation(model, stop_time=2hours, callbacks = [progress_printer, wizard]); ```. In other words, the `TimeStepWizard` becomes a callback with a schedule, and we can print progress and adapt the time step on different schedules. What do people think about this API?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-881904721:421,adapt,adaptive,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-881904721,7,"['adapt', 'schedul']","['adapt', 'adaptive', 'schedule', 'schedules']"
Energy Efficiency,"I'll try to parse this carefully, but I do have a comment on this part:. > Now, when I print out ∫ᶻQ.u I see that all its elements are supposedly 0:. ```; julia> ∫ᶻQ.u; 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 135×7×1 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, 1:1) with eltype Float64 with indices -2:132×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0; ```. > But this returns the right answer. ```; julia> maximum(∫ᶻQ.u.data); 8.0; ```. Crucially, `maximum(∫ᶻQ.u)` will ignore immersed cells and halo cells, but `maximum(∫ᶻQ.u.data)` does not. Does this explain what you're seeing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238527382:206,reduce,reduced,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238527382,1,['reduce'],['reduced']
Energy Efficiency,"I'm also doubtful small round off errors in the timestep would be related, unless there a place in the code where the scheduled times for outputting / checkpointing need to exactly match some value. In the MWE, the problematic values look like they're all zeros. In our more complicated example, where the averaging interval is a large (decimal) multiple of the timestep, it's not clear if the values are underestimated because the velocities are of both signs so a biased average could go either way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595:118,schedul,scheduled,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595,1,['schedul'],['scheduled']
Energy Efficiency,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:504,schedul,schedule,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,2,['schedul'],['schedule']
Energy Efficiency,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:611,schedul,schedule,611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['schedul'],['schedule']
Energy Efficiency,"I'm limited by my ignorance, but at least on the GPU it seems plausible that register allocation has to occur when the kernels are launched; ie, it cannot occur dynamically depending on runtime information. Thus branches that depend on runtime values (like what you've proposed) can't alleviate register pressure, since the compiler is forced to allocate registers for _both_ branches anyways at compile time... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-699521493:346,allocate,allocate,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-699521493,1,['allocate'],['allocate']
Energy Efficiency,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:527,Adapt,Adapt,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603,1,['Adapt'],['Adapt']
Energy Efficiency,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:640,reduce,reduced,640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520,1,['reduce'],['reduced']
Energy Efficiency,"I'm not sure this will run smoothly on Julia v1.6. E.g., on v1.6:. ```Julia; (Oceananigans) pkg> instantiate; ERROR: AssertionError: sourcepath !== nothing; Stacktrace:; [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1789; [2] #13; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131 [inlined]; [3] _all; @ ./reduce.jl:923 [inlined]; [4] #all#698; @ ./reducedim.jl:886 [inlined]; [5] all; @ ./reducedim.jl:886 [inlined]; [6] is_instantiated(ctx::Pkg.Types.Context); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131; [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1358; [8] instantiate; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1325 [inlined]; [9] #instantiate#252; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321 [inlined]; [10] instantiate(); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321; [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:405; [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386; [13] do_cmd; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]; [14] (::Pkg.REPLMode.var""#24#27""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550; [15] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [16] invokelatest; @ ./essentials.jl:706 [inlined]; [17] run_interf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840:428,reduce,reduce,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840,3,['reduce'],"['reduce', 'reducedim']"
Energy Efficiency,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:63,schedul,scheduled,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961,4,['schedul'],"['scheduled', 'schedules']"
Energy Efficiency,"I'm not sure. I'm not very familiar with the testing part of Oceananigans, so I'm not sure what would be a good test for this. Just testing that `min_Δz` works seems too specific, on the other hand, creating a whole simulation with a stretched grid and running it with an LES and adaptive time-stepping just to test that seems wasteful. I'm happy to just merge this for now and create a test for this in the future. Thoughts?. CC @glwagner @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165:280,adapt,adaptive,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165,1,['adapt'],['adaptive']
Energy Efficiency,"I'm only running the x64 builds so this should reduce Appveyor build times by a half to ~1 hour. Closing this issue as there's not much else we can do except remove dependencies or pay for better resources. Build cache could help but we'd have to manually update it each time package versions change, etc. and the extra maintenance isn't worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-500234619:47,reduce,reduce,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-500234619,1,['reduce'],['reduce']
Energy Efficiency,"I've already made sure the forcing function doesn't reference anything outside the function (reduces clarity unfortunately) and pasted the benchmarks using the script from PR #370 at the bottom. Did not try changing the function signature to `FT(grid, u, v, w, T, S, i, j, k)` as that would make implementing #25 more difficult. Also, I was kind of lazy. Adding `@inbounds` seems to help a lot. Went from being 2.1x slower to being 1.3x slower. Still a significant slowdown considering that these forcing functions aren't as computationally demanding as the rest of the right-hand-side calculation. But good enough for me right now. It can be a very powerful feature (essentially replacing the MITgcm RBCS package, for one example) so would be good to get maximum performance out of the forcing functions. But it will probably always depend on exactly how you write them. So might make sense to have guidelines on writing ""performant forcing functions"" in the documentation. ---; Attempt 1:; ```julia; @inline function Fu(grid, U, Φ, i, j, k); if k == 1; return -2*0.1/grid.Δz^2 * (U.u[i, j, 1] - 0); elseif k == grid.Nz; return -2*0.1/grid.Δz^2 * (U.u[i, j, grid.Nz] - 0); else; return 0; end; end. @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); ```; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Forcing function benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 59.9s / 0.41% 7.38GiB / 0.36% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 128×128×128 with forcing (GPU, Float64) 10 166ms 68.2% 16.6ms 13.8MiB 51.2% 1.38MiB; 128×128×128 no forcing (GPU, Float64) 10 77.4ms 31.8% 7.74ms 13.1MiB 48.8% 1.31MiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```; ---; Attempt 2:; ```julia. @inline function Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208:93,reduce,reduces,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208,2,"['power', 'reduce']","['powerful', 'reduces']"
Energy Efficiency,"I've been using `WindowedTimeAverage`s for my simulations (by setting `schedule = AveragedTimeInterval(...)` in a `NetCDFOutputWriter`). I noticed that whenever I run out of walltime and have to checkpoint my simulations, when I pick them up again I get the following warning for each of the time-averaged outputs:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters /glade/work/tomasc/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/windowed_time_average.jl:201; ```; (which comes from [this call](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/src/OutputWriters/windowed_time_average.jl#L196-L204).). Does this mean that the time averages aren't being correctly calculated after picking up? I tried following the trail to figure it out but couldn't determine the answer...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485:71,schedul,schedule,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485,1,['schedul'],['schedule']
Energy Efficiency,I've documented an attempt to adapt `Field` to the GPU at #746 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-652527928:30,adapt,adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-652527928,1,['adapt'],['adapt']
Energy Efficiency,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794:738,energy,energy,738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794,1,['energy'],['energy']
Energy Efficiency,"I've long been unsatisfied with how we build output. It requires a lot of typing --- that is, [_boilerplate_](https://en.wikipedia.org/wiki/Boilerplate_text). I often feel a sense of dread when I have to go beyond ""visualizing the final iteration"" of a prototype to defining an output writer. _So much typing_. This PR is an attempt to make output easier and more fun. I use JLD2 as an example but if there is some consensus then I think this PR should extend the same to NetCDF. The main thrust of this PR is a new function called `output!`. It works like this:. ```julia; output!(simulation, outputs; schedule=TimeInterval(1), filename=""low_hanging_fruit""); ```. The default is `JLD2Format()`. For `NetCDF` users would write. ```julia; output!(simulation, outputs, NetCDFFormat(); kw...); ```. The function adds an output writer to `simulation`, choosing a ""generic name"" for the `simulation.output_writers` dictionary. Does this enable one line output writing?. I'd love to hear feedback about this design. I implemented it in the `two_dimensional_turbulence.jl` example for illustration:. https://github.com/CliMA/Oceananigans.jl/blob/6a6853ddf53c53c321c16393682b786e82ef5a8f/examples/two_dimensional_turbulence.jl#L109. There are two more things. First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Simulations are cheap, but life is short!. PS I also want to change `add_callback!` to just `callback!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793:603,schedul,schedule,603,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793,1,['schedul'],['schedule']
Energy Efficiency,"I've now added some validation scripts that seem appropriate for realistic use cases. First, as a classic CFD example we have flow around a cylinder with prescribed flow on one side and no gradient in the wall-normal flow on the other, this works quite well:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/e3c13b81-b5d9-4fda-81b5-900013d566fa. Adding to this, as a case where we know what the flow is doing ""outside"" the domain, the flow now oscillates sinusoidally. We could do the same as above and prescribe this on both the boundaries:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/116344f5-699a-4af1-a47c-3d4fd9b65975. but when the flow is out of the domain this causes oscillations as interior perturbations hit the boundary. To reduce the oscillations we can instead say that there should be no wall-normal velocity gradient and relax to the prescribed flow (so the boundary point is some mix of information from the prescribed and interior flows):. https://github.com/CliMA/Oceananigans.jl/assets/26657828/09668bb2-adf5-4529-bad6-6c8c484ac3e9. For all the plots isolines of vorticity are shown in the whole domain. CC: @tomchor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2197735344:758,reduce,reduce,758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2197735344,1,['reduce'],['reduce']
Energy Efficiency,"I've run a simulation with a timestep of $\Delta t = 1.066666...$ and it looks as though there's some kind of rounding bug which is resulting in multiple saves occasionally. I choose 'schedule = TimeInterval(t_end/num_saves)' and expect to get 'num_saves' (or possibly 'num_saves+1') points in the saved 'time' variable. However, I end up with about 30 extra saves. Examining 'time' in more detail reveals that most of the points are separated by 't_end/num_saves' but a few (around 30) are separated by a much smaller interval. My guess is that this is a rounding bug with when the code saves the field. Alternatively I could have messed something up. Matt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614:184,schedul,schedule,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614,1,['schedul'],['schedule']
Energy Efficiency,"If @ali-ramadhan wants us to try this but I'm tempted to say we save this for another PR. If it is efficient to use GPUs then we probably want to change more than one, but I'm fine with anything really.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802273792:99,efficient,efficient,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802273792,1,['efficient'],['efficient']
Energy Efficiency,"If I understood correctly, I think that @glwagner just wanted to have the code directly pasted here. ```julia; using Oceananigans; using Oceananigans.Units; using Printf. Ns = 200 # number of time saves; T = 7200 # simulation stop time (s); Δt = 1 # timestep (s). grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)). model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3). simulation = Simulation(model; Δt, stop_time = T). progress_message(sim) = @printf(""Iteration: %03d, time: %s, Δt: %s, wall time: %s\n"",; 	iteration(sim), prettytime(sim), prettytime(sim.Δt), prettytime(sim.run_wall_time)). simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(T/Ns)). dir = ""output/test_MWE"". ## checkpoint ; simulation.output_writers[:checkpointer] = Checkpointer(; model,; schedule=TimeInterval(T),; dir=dir,; prefix=string(""checkpoint""),; cleanup=false); file = string(dir,""/checkpoint_iteration3600.jld2""); run!(simulation,pickup=file); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2245598464:802,schedul,schedule,802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2245598464,1,['schedul'],['schedule']
Energy Efficiency,If `times` is a `Vector` then it needs to be converted to `arch_array` _and_ adapted when passed to GPU. We're doing a big overhaul on #3450 and this is one of the thing we fixed:. https://github.com/CliMA/Oceananigans.jl/blob/13dcd4ff9767c5a1e030bf4ce5765cc661b1175b/src/OutputReaders/field_time_series.jl#L235-L243,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002:77,adapt,adapted,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002,1,['adapt'],['adapted']
Energy Efficiency,"If the docs actually recommend outputting fields themselves, we should obviously change that. We can perhaps add a note about why we cannot output fields (once we figure it out) --- or fix it so that we can output fields. I actually think it could be useful to output fields when we have a more powerful field abstraction system in the future, especially if it can do MPI operations, etc, which are useful in post processing. It'd be convenient to be able to load fields directly to memory rather than having to reconstruct them from their data and some grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-564382208:295,power,powerful,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-564382208,1,['power'],['powerful']
Energy Efficiency,"If we have a `Particle` design that looks something like. ```julia; struct Particle{P, T, R, E, D}; position :: P; properties :: T; restitution :: R; external_velocities :: E; diffusivity :: D; end; ```. With the following meaning:. * `position`: a 3-element object with the particle position (not sure what's best for GPU --- some kind of mutable struct or `Array` / `CuArray`)?; * `properties` (could use a better name): user-defined properties + model fields for simulating reactions and such. Probably need additional types / interface for these; * `restitution`: floating point number between 0 and 1 that determines particle behavior at solid walls; * `external_velocities`: a 3-tuple of settling/buoyant/other velocities to be applied to the particle in addition to the resolved + background velocity field. We can also design an abstraction / special type that computes the buoyancy of a particle with a certain temperature / salinity / buoyancy (for example); * `diffusivity` diffusion coefficient that is used to compute stochastic noise added to the particle position (requires some care to ensure the stochastic diff eq is integrated correctly. Would be nice to support both constants and functions of space-time, etc. We can start with just a few of these fields in our `Particle` type, and extend its power in future PRs if we need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713698417:1315,power,power,1315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713698417,1,['power'],['power']
Energy Efficiency,"If we want to allow for variable `nu`, which is a good idea, then the first two have the problem of not guaranteeing that viscosity reduces the kinetic energy,. The third form is the one to focus on, and is what would appear in the non-conservative of vector invariant forms. For the conservative form we need to mutliply the 3rd equation by `h`, and then `nu` has the correct dimensions: length^2/time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174:132,reduce,reduces,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174,2,"['energy', 'reduce']","['energy', 'reduces']"
Energy Efficiency,"If you are looking to pass structs with CuArray members into kernels, I think that you might be looking for something like https://github.com/sandreza/Learning/blob/master/nla/gmres.jl#L50; (thanks to @vchuravy for showing me how to use adapt!); It should work recursively so that composite structs will function as desired as long as each individual struct is adapted",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-621378116:237,adapt,adapt,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-621378116,2,['adapt'],"['adapt', 'adapted']"
Energy Efficiency,Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <ø> (ø)` | |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `34.21% <17.39%> (-2.16%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `52.94% <52.94%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `81.25% <66.66%> (+20.83%)` | :arrow_up: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `87.27% <70.00%> (-4.73%)` | :arrow_down: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `76.47% <76.47%> (ø)` | |; | [src/Fields/new\_data.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `76.92% <100.00%> (+10.25%)` | :arrow_up: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `85.71% <0.00%> (-3.18%)` | :arrow_down: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/920/di,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/920#issuecomment-689748446:1904,reduce,reduced,1904,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/920#issuecomment-689748446,1,['reduce'],['reduced']
Energy Efficiency,"Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `58.9% <100%> (+1.76%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.58% <100%> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `87.5% <100%> (+6.25%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `84.21% <82.35%> (+71.71%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `74.86% <0%> (-1.07%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=footer). Last update [35a6a05...5771f8d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223463:2641,Power,Powered,2641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223463,1,['Power'],['Powered']
Energy Efficiency,Implements `similar(f::Field)` and `similar(r::ReducedField)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1539:47,Reduce,ReducedField,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1539,1,['Reduce'],['ReducedField']
Energy Efficiency,Implements a `ConsecutiveIterations` schedule,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2100:37,schedul,schedule,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100,1,['schedul'],['schedule']
Energy Efficiency,Implements boundary_conditions for ReducedField,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1350:35,Reduce,ReducedField,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1350,1,['Reduce'],['ReducedField']
Energy Efficiency,"Implements callbacks between sub-steps as described in #2772 . I chose to add them to the model since that is the only part of the simulation they have access to when they run, and went with using the same `Callback` constructor so that parameters can still be passed to the functions despite the fact that whatever the specified schedule they have to run at every sub-step.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773:330,schedul,schedule,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773,1,['schedul'],['schedule']
Energy Efficiency,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/732:151,energy,energy,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732,1,['energy'],['energy']
Energy Efficiency,"In a supposedly quiescent flow with constant temperature and salinity, seeded with tiny random noise in `w`, a large-scale flow develops and is maintained. Thus the flow gains kinetic energy in an otherwise unforced configuration, creating a ""perpetual machine"". Here is a MWE:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; maximum(abs, sim.model.tracers.T),; maximum(abs, sim.model.tracers.S),; maximum(KE_total),; prettytime(sim.Δt)). wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3795:184,energy,energy,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795,1,['energy'],['energy']
Energy Efficiency,"In light of #2700, let's make sure we have a good reason / sustainable strategy for adding this potentially expensive feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1226016719:59,sustainab,sustainable,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1226016719,1,['sustainab'],['sustainable']
Energy Efficiency,"In my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), the preconditioner is also perturbed. The goal is to solve the following equation in an immersed boundary grid. $$\nabla^2 \phi + \delta N \bar \phi = R $$. The perturbed preconditioner solves this equation in a regular grid:. $$ \phi = L_\mathrm{FFT}R + \frac{1}{\delta N}\overline{R}$$. where $L_\mathrm{FFT}$ is the FFT-based Poisson solver. Due to the gauge condition of $L_\mathrm{FFT}$,. $$\nabla^2L_\mathrm{FFT}R = R - \overline{R}$$. $$\overline{L_\mathrm{FFT}R} = 0$$. for a random $R$ whose mean is not necessarily zero. The latter is simply the gauge condition; the former means that $L_\mathrm{FFT}$ ignores the mean component of $R$ \(which can be understood as $\frac{1}{N}ee^TR$\). It is easy to verify that the preconditioner gives the exact solution in a regular grid. Besides, in my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), I perturb the preconditioner directly by adding the mean of the input vector. However, a more efficient solution is to a new parameter to the FFT-based Poisson solver, so that it solves. $$\nabla^2 \phi + m \phi - \mu \overline{\phi} = r $$. where $\mu$ represents the role of $\delta$ or $c$ in previous comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417544874:1133,efficient,efficient,1133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417544874,1,['efficient'],['efficient']
Energy Efficiency,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:420,reduce,reduced,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159,1,['reduce'],['reduced']
Energy Efficiency,"In that example I'm using [`schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1)`](https://pastebin.com/F6ankx4L). So (unless I'm missing something), I expected the time-averaged results to be very close (if not identical) to the snapshot one, since it's only an average over `2Δt`. . From the plot it looks like the average instead is being performed over the interval `[0, t]`, for every `t`. (i.e., a cumulative average starting at the beginning of the simulation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872:28,schedul,schedule,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872,1,['schedul'],['schedule']
Energy Efficiency,In the end my ocd couldn't let me finish this without the energy time-series...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722659461:58,energy,energy,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722659461,1,['energy'],['energy']
Energy Efficiency,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:582,schedul,scheduling,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,7,['schedul'],"['schedule', 'scheduled', 'schedules', 'scheduling']"
Energy Efficiency,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3057:210,energy,energy,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057,1,['energy'],['energy']
Energy Efficiency,"Indeed:; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test3"", schedule = IterationInterval(1), with_halos = true); JLD2OutputWriter scheduled on IterationInterval(1):; ├── filepath: ./test3.jld2; ├── 1 outputs: c; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; ├── file_splitting: NoFileSplitting; └── file size: 20.3 KiB. julia> JLD2OutputWriter(model, (; c, d), filename = ""test4"", schedule = IterationInterval(1), with_halos = true); JLD2OutputWriter scheduled on IterationInterval(1):; ├── filepath: ./test4.jld2; ├── 2 outputs: (c, d); ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; ├── file_splitting: NoFileSplitting; └── file size: 25.9 KiB. ```; I ll take a look at the `restrict_to_interior` function",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835#issuecomment-2400220504:77,schedul,schedule,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835#issuecomment-2400220504,4,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2352:759,schedul,schedule,759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352,1,['schedul'],['schedule']
Energy Efficiency,Index for Reduced fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2177:10,Reduce,Reduced,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177,1,['Reduce'],['Reduced']
Energy Efficiency,Initialize schedules at iteration 0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2268:11,schedul,schedules,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268,1,['schedul'],['schedules']
Energy Efficiency,Inspired by @Lichriszz and their problem in [#1362](https://github.com/CliMA/Oceananigans.jl/discussions/1362#discussioncomment-374286) I started to make an example of two dimensional turbulence using the shallow water model. At the moment the results are not necessarily worth looking at but I wonder if people could look at the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/two-dimensional-turbulence-shallow-water-example/examples/two_dimensional_turbulence_shallow_water.jl) and say whether the set up is what we want?. A few issues that I have come cross are the following:. - [x] Use the time stepping wizard for numerical stability; - [x] Reduce the number of import statements; - [ ] Plot the vorticity and the divergence fields; - [x] Pick the parameters to get nice results. What is a good a reference for a planar geometry?; - [ ] Should test on GPU; - [ ] Should test with higher resolution. One possible paper is [Polvani et al (1994)](https://aip.scitation.org/doi/pdf/10.1063/1.166002),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365:662,Reduce,Reduce,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365,1,['Reduce'],['Reduce']
Energy Efficiency,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:16,adapt,adapt,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875,3,['adapt'],['adapt']
Energy Efficiency,"Interacting with modeling software via scripts is novel for some users. We (and many others) are accumulating knowledge in this area, including:. * Scripting philosophy and its advantages.; * Literate scripting style for ""paper-like"" code, tutorials and pedagogical applications.; * Best practices for parameter exploration (eg how to replicate the functionality of a parameter file or namelist in your script, and why divorcing parameter lists from model setup should be considered carefully).; * Best practices for reproducibility (naming conventions, using output directories, checkpointing, script reuse).; * The use of external packages to achieve these goals (like `ArgParse`, or perhaps `DrWatson`). Oceananigans tries to give users great power and flexibility for designing numerical experiments. However, with this power comes great responsibility for users to write and use their scripts for Good. We can possibly help by adding some documentation. I also think the writers of said documentation might benefit if said documentation stimulates community input / outside contributions to these best practices. cc @ali-ramadhan @navidcy @kpamnany @kburns",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1127:746,power,power,746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1127,2,['power'],['power']
Energy Efficiency,Interesting that the `h=0.2` case has kinetic energy increasing for the case of free-slip. I don't suspect that is physical but should go away with increased resolution. The movies are very fun to watch!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105588048:46,energy,energy,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105588048,1,['energy'],['energy']
Energy Efficiency,Interesting! But I guess that dissipation of energy still comes from a viscous term?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185581695:45,energy,energy,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185581695,1,['energy'],['energy']
Energy Efficiency,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:649,allocate,allocate,649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134,2,"['allocate', 'reduce']","['allocate', 'reduce']"
Energy Efficiency,Is energy increasing? If so that might be a time stepping error and you need to reduce your time step.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1439243627:3,energy,energy,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1439243627,2,"['energy', 'reduce']","['energy', 'reduce']"
Energy Efficiency,"It appears that we allocate memory for a few more 3D arrays than needed in order to calculate pressure in `NonhydrostaticModel`. We currently allocate 3 arrays: one for hydrostatic pressure, one for non-hydrostatic pressure, and a third array with `Complex{Float64}` elements that's used for in-place FFTs while solving the pressure Poisson equation. For our algorithm to be correct, however, we only need one array with `Complex{Float64}` elements. This array can than be used as scratch space when calculating the hydrostatic pressure and computing hydrostatic pressure gradients. It will then be overwritten when calculating the nonhydrostatic pressure component. The distinction between the solver field with `Complex{Float64}` elements and the nonhydrostatic pressure is just that the nonhydrostatic pressure is `real`, which we enforce when copying it over:. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/src/Solvers/fft_based_poisson_solver.jl#L102-L105. However, we could just as easily extract the real component when computing the pressure gradient:. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/src/Models/NonhydrostaticModels/pressure_correction.jl#L34-L40",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2126:19,allocate,allocate,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2126,2,['allocate'],['allocate']
Energy Efficiency,"It could be consistent with the indexing behavior of `Nothing` location --- ie if you ""slice"" a field along a reduced dimension, nothing happens. Yet still I feel that the `indices` kwarg isn't being used properly here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438426850:110,reduce,reduced,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438426850,1,['reduce'],['reduced']
Energy Efficiency,It could be fun to reproduce the results of this paper: https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/how-surface-roughness-reduces-heat-transport-for-small-roughness-heights-in-turbulent-rayleighbenard-convection/B7B4E4F392EDC249A3B5FD75790F88FC,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587520861:157,reduce,reduces-heat-transport-for-small-roughness-heights-in-turbulent-rayleighbenard-convection,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587520861,1,['reduce'],['reduces-heat-transport-for-small-roughness-heights-in-turbulent-rayleighbenard-convection']
Energy Efficiency,"It could be nice to have a type for managing time stepping --- eg, `Simulation` --- rather than requiring the writing of explicit loops as in . https://github.com/climate-machine/Oceananigans.jl/blob/4b7e5bced1019b1a6804d3797cfe0ed41fda4a51/examples/ocean_wind_mixing_and_convection.jl#L190. `Simulation` could look like. ```julia; struct Simulation; model; Δt; simulation_stop_time; wall_time_limit; simulation_stop_iteration; progress; end; ```. Or something along those lines. The field `progress` could either be a function or callable object, or tuple / list of functions or callable objects. The field `Δt` could either be a constant time-step or a `TimeStepWizard`. We might also need a new type called `ProgressMessage` for managing logging / emitting progress messages for simulations. Then we can give it a `frequency` (and `interval`) of emission and support some other nice behaviors like a default format and auto-emission of diagnostic / monitoring results. xref: #432 #431",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447:952,monitor,monitoring,952,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447,1,['monitor'],['monitoring']
Energy Efficiency,It currently leaves something to be desired:. ```julia; help?> SpecifiedTimes; search: SpecifiedTimes. struct SpecifiedTimes <: AbstractSchedule. Callable TimeInterval schedule for periodic output or diagnostic evaluation according to model.clock.time.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2608:168,schedul,schedule,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2608,1,['schedul'],['schedule']
Energy Efficiency,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:130,allocate,allocates,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903,1,['allocate'],['allocates']
Energy Efficiency,"It looks a lot better! Although, I still see near-grid-scale wave motions in the right movie (but they are reduced versus the left / original, right?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1528873049:107,reduce,reduced,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1528873049,1,['reduce'],['reduced']
Energy Efficiency,"It looks like #1138 proposes writing a function that aligns the time step according to the schedule, presumably using dispatch. This PR; proposes a different solution, doesn't it?. Just want to be careful about creating more debt/work to clean up when #1138 is resolved, but I think you're right this functionality can be implemented as a step towards #1138 if done carefully.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-734466215:91,schedul,schedule,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-734466215,1,['schedul'],['schedule']
Energy Efficiency,"It looks like `validate_advection` is also needed if we want to support a nice API for changing the floating point precision:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L139. Right now users have to specify `Float32` in both the `grid` and `WENO5` to get reduced-precision all around. If we `validate_advection` we can use the ""stub, regularization"" strategy where `FT` is set to `eltype(grid)` only if it's not specificed (to support existing behavior where `FT` can be set indepednently of `eltype(grid)`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047966020:334,reduce,reduced-precision,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047966020,1,['reduce'],['reduced-precision']
Energy Efficiency,"It looks like this PR fixes some issues with complex AbstractOperations, but it does not allow us to use AveragedField on the GPU. I think a possible avenue to explore could maybe be to Adapt an AveragedField by wrapping the underlying, `Adapt`ed data in `Base.Broadcast.Broadcasted`, rather than attempting to adapt `AveragedField` (with its custom `getindex`, which it the crucial part) directly for the GPU. We know that broadcasting with singleton dimensions already works on the GPU and its possible we might borrow some of that machinery. The key function we might want to get a hold of is `_broadcast_getindex`:. https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827:186,Adapt,Adapt,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827,3,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Energy Efficiency,"It really just comes down to these lines:. ```julia; @inbounds for IA in CartesianIndices(indsAt); IR = Broadcast.newindex(IA, keep, Idefault); @simd for i in axes(A, 1); R[i,IR] = op(R[i,IR], f(A[i,IA])); end; end; ```. https://github.com/JuliaLang/julia/blob/7c5c724ed93015d2e9c52c7fcd8f5c4ebbefff03/base/reducedim.jl#L284. The problem could in fact be here:. https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/field.jl#L404. which I think cannot be type-inferred by the compiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176710306:307,reduce,reducedim,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176710306,1,['reduce'],['reducedim']
Energy Efficiency,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:1362,green,green,1362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529,1,['green'],['green']
Energy Efficiency,It seems like the `Δt` that is calculated in `accumulate_result!` does not agree with the simulation `Δt` because of finite precision arithmetic. Wouldn't it be better to pass the simulation `Δt` to the schedule so everything becomes more consistent and we avoid discrepancies between schedule time and simulation time?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261675303:203,schedul,schedule,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261675303,2,['schedul'],['schedule']
Energy Efficiency,"It seems that with Julia 1.6 and recent versions of CUDA.jl, the output of averaged fields is wrong. By inspection it seems that the output is being written to disk prematurely somehow as some grid points contain the sum instead of the mean. @xkykai and I have tried to reproduce in CUDA.jl but with no luck so far. I've tried adding a `CUDA.@sync blocking=true` to https://github.com/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Fields/averaged_field.jl#L62 but that didn't help. Adding a `sleep(0.01)` afterwards helped a bit (reduced the number of occurences of this issue). It's not a useful hack but it may suggest that a race condition is involved?. X-Ref: This is a minimal reproduction of https://github.com/CliMA/LESbrary.jl/issues/118; X-Ref: https://github.com/JuliaGPU/CUDA.jl/issues/929 (Attempt at reproducing but turned out to be a REPL issue). # Minimal working example. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(256, 256, 128), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); simulation = Simulation(model, Δt=1, stop_time=100). set!(model, u=1, v=1, T=1). U = AveragedField(model.velocities.u, dims=(1, 2)); V = AveragedField(model.velocities.v, dims=(1, 2)); T = AveragedField(model.tracers.T, dims=(1, 2)). simulation.output_writers[:jld2] =; JLD2OutputWriter(model, (; U, V, T),; prefix = ""stats"",; schedule = TimeInterval(10),; force = true). simulation.output_writers[:nc] =; NetCDFOutputWriter(model, (; U, V, T),; filepath = ""stats.nc"",; schedule = TimeInterval(10),; mode = ""c""). run!(simulation); ```. ## Looking at the NetCDF output. ```julia; using NCDatasets; ds = NCDataset(""stats.nc""); ds[""T""][:]; ```. ```; 128×11 Matrix{Float32}: ; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767:556,reduce,reduced,556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767,1,['reduce'],['reduced']
Energy Efficiency,It should be pretty easy to adapt `correct_incompressible_immersed_tendencies.jl` to create `correct_shallow_water_immersed_tendencies.jl` to this features to `ShallowWaterModel`. It may also make it easier to test the immersed boundary method as there is no need for a pressure solve in simulating the equations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1458:28,adapt,adapt,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458,1,['adapt'],['adapt']
Energy Efficiency,"It would for sure introduce noise because of the jagged bottom, maybe try cranking up a bit the resolution to have less bathymetry imprinting. But, if the energy does not increase we found our culprit.; Anyways, I don't think it's an advection scheme problem. It might be something more fundamental about this setup or about tilted gravity per se.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517952596:155,energy,energy,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517952596,1,['energy'],['energy']
Energy Efficiency,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:43,reduce,reduced,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,1,['reduce'],['reduced']
Energy Efficiency,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:727,reduce,reduced,727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,1,['reduce'],['reduced']
Energy Efficiency,"It's confusing why this fails, but the offending line is here:. https://github.com/climate-machine/Oceananigans.jl/blob/cdf5091a9164c1ee6efd2f0b349e6170f2fab749/src/OutputWriters/jld2_output_writer.jl#L81. I don't understand why `convert` is called here. Do we need to `deepcopy` the field in order to output it?. The stack trace is obscure because, I think, the error appears inside the generator in the line I've posted, and also because the function that's being called is anonymous. I think. We could try rewriting the offending line to create an empty `Dict{Any, Symbol}` and then load the outputs into that. Not sure if that would prevent `convert` from being called --- it might. I guess at the time I believed using the generator could be more efficient in some cases. I don't know if it matters in practical scenarios though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-564381723:752,efficient,efficient,752,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-564381723,1,['efficient'],['efficient']
Energy Efficiency,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127:721,reduce,reduces,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127,1,['reduce'],['reduces']
Energy Efficiency,"It's not the geometry that allows a two-argument function, it's because the free surface in `HydrostaticFreeSurfaceModel` is a `ReducedField`. `set!` with a function now uses `FunctionField` and then broadcasting:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/set!.jl#L29-L33. and `FunctionField` at reduced locations are now called with reduced arguments:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L60-L62. where `call_func` is invoked in `getindex` for `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L64-L65. which in turn uses `node`. The length of the tuple return by `node` depends on how many locations are `Nothing`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Grids/grid_utils.jl#L158-L168. @francispoulin what is the vertical location of fields in `ShallowWaterModel`? I think if you use `Nothing` for vertical location, you'll obtain this behavior.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622:128,Reduce,ReducedField,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622,3,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,It's used in `summary`:. https://github.com/CliMA/Oceananigans.jl/blob/d7d146bc59f966d65eb66a875c16679bef365130/src/Utils/schedules.jl#L262. which in turn is used to display output writers info in `Simulation`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1624208860:122,schedul,schedules,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1624208860,1,['schedul'],['schedules']
Energy Efficiency,"It’s not strict because the problem is nonlinear!. On Sat, Oct 31, 2020 at 9:56 PM Navid C. Constantinou <; notifications@github.com> wrote:. > *@navidcy* commented on this pull request.; > ------------------------------; >; > In examples/kelvin_helmholtz_instability.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1125#discussion_r515563721>; > :; >; > > +; >; > +using Oceananigans.Advection; >; > +; >; > +model = IncompressibleModel(timestepper = :RungeKutta3,; >; > + advection = UpwindBiasedFifthOrder(),; >; > + grid = grid,; >; > + coriolis = nothing,; >; > + background_fields = (u=U, b=B),; >; > + closure = IsotropicDiffusivity(ν=5e-5, κ=5e-5),; >; > + buoyancy = BuoyancyTracer(),; >; > + tracers = :b); >; > +; >; > +# # A _Power_ful algorithm; >; > +#; >; > +# We will find the most unstable mode of the Kelvin-Helmholtz instability using the ""power method"".; >; > +# In brief, if a linear operator ``\mathcal{L}`` has eigenmodes ``u_j`` and corresponding; >; >; > I condemn you though for writing ≈ in your suggestion above.; > The equality is strict there!; > But I'll move Lφ to the right-hand-side... :); >; > —; > You are receiving this because you commented.; >; >; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1125#discussion_r515563721>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADUQQBUJRFGJLAUVLIIWXJLSNS54XANCNFSM4TFVUQKA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720014741:864,power,power,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720014741,1,['power'],['power']
Energy Efficiency,"I’m happy with output_writers.jl; I think all the code in that file is appropriately related. The checkpointer could provide its own constructor to avoid excess memory allocation. . For GPU problems I don’t think there is an issue: checkpointed arrays can b loaded into CPU memory rather than GPU memory, and then the data can be copied into the fields allocated by the model constructor. So at first glance the excess memory allocation does not seem like a major issue on modern CPUs. . I am particularly concerned about the maintainability of the checkpointer, since it will need to be updated every time a new feature is added. Let’s make sure the design is easy to maintain before merging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-517777579:353,allocate,allocated,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-517777579,1,['allocate'],['allocated']
Energy Efficiency,"JjL0ZpZWxkcy9iYWNrZ3JvdW5kX2ZpZWxkcy5qbA==) | `92.85% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `79.09% <0.00%> (+0.96%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `96.87% <0.00%> (+1.63%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `85.71% <0.00%> (+2.38%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `96.15% <0.00%> (+2.40%)` | :arrow_up: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `42.85% <0.00%> (+2.85%)` | :arrow_up: |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `82.35% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039?src=pr&el=footer). Last update [d274364...1675e40](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1039#issuecomment-707647298:3483,Power,Powered,3483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1039#issuecomment-707647298,1,['Power'],['Powered']
Energy Efficiency,"JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <ø> (+22.85%)` | :arrow_up: |; | [src/LagrangianParticleTracking.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL0xhZ3JhbmdpYW5QYXJ0aWNsZVRyYWNraW5nLmps) | `83.33% <83.33%> (ø)` | |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `76.92% <100.00%> (+0.60%)` | :arrow_up: |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/store\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9zdG9yZV90ZW5kZW5jaWVzLmps) | `72.72% <0.00%> (ø)` | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | | |; | [...Models/IncompressibleModels/pressure\_correction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | | |; | ... and [29 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091?src=pr&el=footer). Last update [7d30dba...03d1209](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713522601:3226,Power,Powered,3226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713522601,1,['Power'],['Powered']
Energy Efficiency,"JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32% <0%> (-2.1%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [41 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656?src=pr&el=footer). Last update [0676c76...645a483](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/656#issuecomment-592649433:3720,Power,Powered,3720,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/656#issuecomment-592649433,1,['Power'],['Powered']
Energy Efficiency,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:92,reduce,reduce,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,1,['reduce'],['reduce']
Energy Efficiency,"Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`. `VectorInvariant`. https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4. `WENOVectorInvariant`. https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4. `WENOVectorInvariantZVEL`. https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4. `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; - Noise is reduced significantly despite dissipation not being too high; - Agreement between different resolutions is much higher",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116:880,reduce,reduced,880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116,1,['reduce'],['reduced']
Energy Efficiency,"Just adding to @glwagner's comment, @whitleyv and I have discussed adding:. - Boundary interpolation, so the topography does not have to match the grid.; - Neumann boundary conditions. ; - A simple log-layer wall-model. I think we have a good sense of how to approach the above. I'm also interested in discussing pressure solver modifications with @weymouth, we will talk on our end and then be in touch to schedule a time to chat. ; Thanks!; Jacob",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720088717:407,schedul,schedule,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720088717,1,['schedul'],['schedule']
Energy Efficiency,"Just an update: @ChrisRackauckas and I chatted some months ago on Slack about this issue and tried to figure out how Oceananigans.jl could use DifferentialEquations.jl for time-stepping. I think we stumbled upon papers like https://onlinelibrary.wiley.com/doi/abs/10.1002/fld.4083 that use the method of lines. > The discretized Navier–Stokes equations form an index 2 system of differential algebraic equations, which are afterwards reduced to a system of ordinary differential equations (ODEs), using the discretized form of the continuity equation. The pressure field is computed solving a discrete pressure Poisson equation. Finally, the resulting ODEs are solved using the backward differentiation formulas. which is a pretty different method from what Oceananigans currently uses. Solving index-2 DAEs seemed quite niche (and maybe tricky) so probably not something to pursue for 3D simulations on GPUs especially when we already have a fast solver. ---. I'm going to close this issue since Oceananigans doesn't really have problems with time-stepping and I don't think higher-order time-steppers would help Oceananigans a huge amount. If anyone thinks that it would be interesting to try time-stepping Oceananigans as a `SplitODEProblem` with the `FFTBasedPoissonSolver` as a non-linear solver following https://diffeq.sciml.ai/latest/features/linear_nonlinear/#linear_nonlinear then please feel free to reopen!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-800745408:434,reduce,reduced,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-800745408,1,['reduce'],['reduced']
Energy Efficiency,"Just for reference, I created the MWE example below of a column model with a sheared `u` that evolves in time, where I write both the full `u` and an interpolated `u` to half the original resolution. What I'm doing here is creating a coarse grid, coarse model, and coarse field that takes the interpolated `u`. I use a `Callback` to keep interpolating `u` into `coarse_u` and then it's only a matter of setting up a coarse `NetCDFWriter` with `coarse_model`. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_model = NonhydrostaticModel(; grid=coarse_grid, closure = ScalarDiffusivity(ν=1e-2)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(coarse_model, (; coarse_u,),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. This seems to be working. In the figure below the lines and triangles come from the full res output, while the cirlces come from the coarse (interpolated) output:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/1a72237a-67ac-4804-9230-9d766e71b353). You can definitely take nicer/fancier a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777:928,schedul,schedule,928,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777,1,['schedul'],['schedule']
Energy Efficiency,"Just like to discuss this a little more. I think it'd be nice to have some awareness of units in the code. Some places we assume units, like `prettytime`. Other places we don't mention units, like `@show grid`. The two important cases are SI units and ""no units"". Maybe we can just have `grid.units = u""m""` by default, where. ```; julia> using Unitful. julia> typeof(u""m""); Unitful.FreeUnits{(m,), 𝐋, nothing; ```. is the `Unitful.jl` way of saying ""meters"". We could also choose `grid.units = nothing` by default. From the length of grid, we can infer the units for every other quantity. I think we should start unambitious and just have `grid.units` and `clock.units`; if `grid.units === u""m""` then we'll set `clock.units = u""s""`. If `isnothing(grid.units)` then every unit `isnothing`. We'll then use these units in things like `prettytime` and `@show grid`. In principle, we also need `field.units`; field quantities have units that cannot be derived from `grid`. But for Oceananigans, units are really just sugar for showing and displaying things. So it may not make sense to add units to `field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1462#issuecomment-1031692310:450,meter,meters,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1462#issuecomment-1031692310,1,['meter'],['meters']
Energy Efficiency,Just pasting this definition (approximation?) of APE from Vallis' textbook (2nd edition):. ![image](https://user-images.githubusercontent.com/20099589/104056542-aa6f7780-51be-11eb-8924-22de37acfdbd.png). Should be possible to compute/diagnose with a `KernelComputedField` (#1293). Also found this paper on oceanic convective available potential energy (CAPE) but it looks pretty complicated and not sure if it's immediately useful: https://doi.org/10.1175/JPO-D-14-0155.1. cc @sandreza since APE might be a useful diagnostic for your mesoscale simulations?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938:345,energy,energy,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938,1,['energy'],['energy']
Energy Efficiency,"Just thinking about this PR a bit more and building off of @tomchor's summaries:. Am I correct in thinking that we want `xspacing`, `yspacing`, `zspacing`, etc. (+ λ, φ, ξ, η, r) to all be functions of `(i, j, k, lx, ly, lz, grid)` and return a number? This might already be true, although some may be missing. Then we want `xspacings`, `yspacings`, `zspacings`, etc. to return an array of spacings (perhaps with a `with_halos` flag)? Should it be an array or a `Field`?. Should the returned array/field be reduced when possible? So calling `zspacings` on an immersed partial-cell grid returns a 3D array/field, calling `xspacings` on a lat-lon grid returns a 2D array/field, and calling `xspacings` on a regular rectilinear grid returns a 1D array/field?. If so, then we can have a generic `KernelFunctionOperation` that returns a 3D array of spacings, and specialize via dispatch wherever possible to return 2D and 1D arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2449864662:507,reduce,reduced,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2449864662,1,['reduce'],['reduced']
Energy Efficiency,"Just throwing these in here to document what we've discussed. 1. Rayleigh–Bénard convection (DNS, LES?). @glwagner ; 2. Stratified Couette flow (DNS + LES). @ali-ramadhan ; 3. Homogenous cooling in a stratified flow. @glwagner ; 4. Idealized deep convection (compare with MITgcm). @ali-ramadhan and @jm-c ; 5. Taylor-Green vortex. @sandreza and @ali-ramadhan (Done in PR #336). ![unnamed](https://user-images.githubusercontent.com/20099589/62747395-3c9bab00-ba22-11e9-9f08-95a0f91dbc6c.jpg). Photo credit: @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/346:317,Green,Green,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/346,1,['Green'],['Green']
Energy Efficiency,"Just to note; since we can now reduce abstract operations, it'd be appropriate (and efficient) to compute the correct CFL for all grids using `GridMetricOperation` and a reduction. For example:. ```julia; using Oceananigans.AbstractOperations: Δx. u, v, w = model.velocities; u_Δx = u / Δx; max_u_Δx = ReducedField(Nothing, Nothing, Nothing, arch, grid, dims=(1, 2, 3)); maximum!(max_u_Δx, u / Δx); max_u_Δx[1]; ```. I guess we would still need to ignore `Flat` dimensions with this pattern. But at least we can have one efficient, non-approximate method valid for all grids, and we can also get rid of ""accurate_cell_advection_timescale"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1750#issuecomment-866251064:31,reduce,reduce,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1750#issuecomment-866251064,4,"['Reduce', 'efficient', 'reduce']","['ReducedField', 'efficient', 'reduce']"
Energy Efficiency,"JzLmps) | `46.97% <96.15%> (-17.77%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <0%> (-56.97%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `16.21% <0%> (-40.93%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `51.42% <0%> (-37.15%)` | :arrow_down: |; | [src/turbulence\_closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY2xvc3VyZV9vcGVyYXRvcnMuamw=) | `42.62% <0%> (-22.55%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `42% <0%> (-20.03%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.15% <0%> (-10.85%)` | :arrow_down: |; | ... and [8 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=footer). Last update [66670ad...40fd4b0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974976:3098,Power,Powered,3098,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974976,1,['Power'],['Powered']
Energy Efficiency,"L2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | `0.00% <ø> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `100.00% <ø> (ø)` | |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `81.81% <50.00%> (-8.19%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `89.36% <54.54%> (-10.64%)` | :arrow_down: |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <85.71%> (ø)` | |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `93.42% <87.50%> (-2.95%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=footer). Last update [40e7caf...2a19ef9](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956:3238,Power,Powered,3238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956,1,['Power'],['Powered']
Energy Efficiency,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:1123,reduce,reduces,1123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612,1,['reduce'],['reduces']
Energy Efficiency,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:141,allocate,allocate,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field. I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example). But I'll try it out and post the results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974306630:408,efficient,efficient,408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974306630,1,['efficient'],['efficient']
Energy Efficiency,"LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1368,reduce,reduce,1368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"Looking at this PR, I think we should make a few structural changes:; * Move `AbstractSchedule` to `Simulations`. This is where it belongs? (not `Utils`); * Make schedules a function of `Simulation`, not `model`. I don't think users really care --- it's just more logical I think this way. It's about homogenizing the Simulation/AbstractModel interface I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799:162,schedul,schedules,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799,1,['schedul'],['schedules']
Energy Efficiency,"Looks like KernelAbstractions.jl depends on StaticArrays.jl so it was a free dependency I suppose but good to clean up the Project.toml a bit. @navidcy Ah yeah maybe I'm a little too attached to that `weno_nth_order.jl` implementation haha. Been hoping to make it efficient so we can get fast and automatically generated WENO(n) schemes for n = 3, 5, 7, 9, ... (but it can always be fished out of git history of course).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735482050:264,efficient,efficient,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735482050,1,['efficient'],['efficient']
Energy Efficiency,Looks like deploying docs to https://github.com/CliMA/OceananigansDocumentation is successful now! There was a commit on the `OceananigansDocumentation#gh-pages` branch but nothing on `Oceananigans#gh-pages`. We can probably nuke the `Oceananigans#gh-pages` branch now and massively reduce the repo size.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661253502:283,reduce,reduce,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661253502,1,['reduce'],['reduce']
Energy Efficiency,"Looks like it does:. ```julia; julia> using Oceananigans. julia> using Oceananigans.Fields: interpolate!. julia> source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> source_field = Field{Center, Center, Nothing}(source_grid);. julia> set!(source_field, (x, y) -> x + y); 2×2×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 2×2×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 8×8×1 OffsetArray(::Array{Float64, 3}, -2:5, -2:5, 1:1) with eltype Float64 with indices -2:5×-2:5×1:1; └── max=1.5, min=0.5, mean=1.0. julia> to_grid = RectilinearGrid(size=(4, 4), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> to_field = Field{Center, Center, Nothing}(to_grid); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=0.0, min=0.0, mean=0.0. julia> interpolate!(to_field, source_field). julia> to_field; 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512:364,reduce,reduced,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512,1,['reduce'],['reduced']
Energy Efficiency,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:32,Adapt,Adapt,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548,2,['Adapt'],['Adapt']
Energy Efficiency,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835:249,schedul,schedule,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835,2,['schedul'],['schedule']
Energy Efficiency,"MWE:; ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10)); bottom(x, y) = - rand() * 5 # Between -5 and 0; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). f1 = Field{Center, Center, Nothing}(grid); f2 = Field{Center, Center, Nothing}(grid); set!(f1, (x, y) -> rand()); set!(f2, (x, y) -> rand()). fig = Figure(); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); heatmap!(ax1, f1); heatmap!(ax2, interior(f2, :, :, 1)); ```; Produces:. <img width=""1045"" alt=""Screenshot 2024-11-05 at 12 21 29 PM"" src=""https://github.com/user-attachments/assets/2840dd1b-edd2-4e74-a5f7-d0c378396e84"">. It seems the field has been masked by checking the immersed condition at `k = 1`, which is not true for `Reduced` fields that need to check the whole direction to see if they are immersed. To mask the field to `NaN,` we should check that all the `k` indices at `i, j` are immersed. . This is not a bug in the visualization but in the masking procedure that should do something different if a direction is nothing. I can create a PR for this; some computational efficiency considerations might be needed if this `mask_immersed_field!` is included in time-stepping loops.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3899:759,Reduce,Reduced,759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3899,1,['Reduce'],['Reduced']
Energy Efficiency,Make checkpointer more memory efficient,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/416:30,efficient,efficient,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/416,1,['efficient'],['efficient']
Energy Efficiency,"Many models of size (16, 16, 16) are reduced to size (1, 1, 1). Oftentimes the test just executes a time-step to ensure there's no error. For this, a size (1, 1, 1) is sufficient.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937:37,reduce,reduced,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937,1,['reduce'],['reduced']
Energy Efficiency,Mask `ReducedFields` accounting the immersed column,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3900:6,Reduce,ReducedFields,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3900,1,['Reduce'],['ReducedFields']
Energy Efficiency,"Might be a pretty good idea, other models do it too. I can think of three so far: @sandreza's KPP paper, @glwagner's momentum + energy transfer paper, and [Bhamidipati et al. (2020)](https://doi.org/10.1016/j.ocemod.2020.101615).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/973:128,energy,energy,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/973,1,['energy'],['energy']
Energy Efficiency,"Might be good to clarify some of this discussion: a ""sponge layer"" refers to any region in a simulation domain that dissipates energy. A wide variety of forcing functions are ""valid"" sponge layers, including the example in the documentation. The Gaussian mask appears to be behaving correctly, and as one expects given the documentation, source code, and known/measurable/plottable properties of Gaussians. Using a Gaussian to define the masked region is valid strategy used successfully in research. Of course, this does not mean that other masking functions may be more appropriate, or that a ""smooth step"" function might be more useful to users, since the width of the sponge, and width of the sponge layer *transition* region may be modulated independently. This is not the case for the Gaussian, which has only one width parameter. A sharp heaviside is not a good choice for a sponge layer when the sponge is intended to absorb radiating internal waves. The reason is that waves can reflect off a sponge layer if the transition between undamped and damping regions is too abrupt (as pointed out by @navidcy). was under the impression this might even be an issue for problems without waves... ?. The requirement that sponge layers involve smooth transitions does mean that sponge layers can take up a substantial portion of the computational domain. This is often cited as a downside of sponge layers (eg Klemp and Durran 1993).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734408323:127,energy,energy,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734408323,1,['energy'],['energy']
Energy Efficiency,"Might be interesting to give adaptive time-stepping a try. @christophernhill says it didn't work super well last time they tried it in the MITgcm but that might have been a long time ago. I suspect for most MITgcm runs, which act on large horizontal domains, the time step is severely limited by vertical motions which may not be true for all Oceananigans simulations. Not sure if this changes anything. I suspect you just calculate the time step using; ```julia; C = 1 # Maximum Courant number. Probably 1 for our explicit AB2 time-stepping scheme. Δt_x = C*Δx / maximum(abs.(u)); Δt_y = C*Δy / maximum(abs.(v)); Δt_z = C*Δz / maximum(abs.(w)). Δt = min(Δt_x, Δt_y, Δt_z); ```. Even if we don't use adaptive time-stepping, it might be a useful `CFLChecker` diagnostic that prints warnings when CFL is being violated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/189:29,adapt,adaptive,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189,2,['adapt'],['adaptive']
Energy Efficiency,"Minor update:. I have a reduced case that is `4x4` that I'm playing with to try and determine why the results from CPUs differ from GPUs. After one time step, using `QuasiAdamsBashforth2`, I get that the two sets of values in the first column are identical. ; ```; CPU; 10-element OffsetArray(::Array{Float64,1}, -2:7) with eltype Float64 with indices -2:7:; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905. GPU; 10-element OffsetArray(::CuArray{Float64,1}, -2:7) with eltype Float64 with indices -2:7:; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; ```. However, when I use `RungeKutta3` I get that the results are different.; ```; CPU; 10-element OffsetArray(::Array{Float64,1}, -2:7) with eltype Float64 with indices -2:7:; 0.00676299502124483; 0.00676299502124483; 1.696248222222971e-8; 1.696248222222971e-8; 0.00676299502124483; 0.00676299502124483; 1.6962482222229713e-8; 1.6962482222229713e-8; 0.00676299502124483; 0.00676299502124483. GPU; 10-element OffsetArray(::CuArray{Float64,1}, -2:7) with eltype Float64 with indices -2:7:; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; ```; I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. I observed that QAB2 then starts to differ at the next time step. I suppose the differences in the `RK3` method appear sooner because it is a multistep method, so three steps in one?. I know that the pressure solve is what differs significantly between the `CPU` an",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815174351:24,reduce,reduced,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815174351,1,['reduce'],['reduced']
Energy Efficiency,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:152,sustainab,sustainable,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722,1,['sustainab'],['sustainable']
Energy Efficiency,More powerful and elegant benchmarking framework,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1088:5,power,powerful,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088,1,['power'],['powerful']
Energy Efficiency,More support for broadcasting to reduced fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2157:33,reduce,reduced,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2157,1,['reduce'],['reduced']
Energy Efficiency,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1420:373,reduce,reduce,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420,1,['reduce'],['reduce']
Energy Efficiency,"Mostly I am worried about scalability and sustainability in this design, or future designs. . Currently our models are fairly simple, but its challenging to place bounds on potential future complexity. For example, models in the future may require additional fields associated with closures or parameterizations, such as boundary layer depth fields, in-plume tracer concentrations and vertical momentum, precomputed mixing length fields, and perhaps other auxiliary fields associated with various prognostic / diagnostic LES models. We probably can't plan to support setting boundary conditions on every possible field via the model constructor. With our current design we have essentially special-cased turbulent diffusivities because our focus is LES, turbulent diffusivities are relatively common, and it convenient for us. However doing this incurs some maintenance burden --- which will increase if we plan to hard-code validation and error checking. Food for thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798:42,sustainab,sustainability,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798,1,['sustainab'],['sustainability']
Energy Efficiency,Moved it out of examples since I agree it might not be good to just fill it up with convection examples. It's in the sandbox now as a script for generating movie data. Not necessarily a good example in its current form. > Why don’t we use a function instead since that is cleaner and more Julian. In this case `Q` is constant in time so it's more efficient to generate it once and apply it as an `AbstractArray` boundary condition rather than a function with if statements that gets called at Nx*Ny times every time step.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/334#issuecomment-518900928:347,efficient,efficient,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/334#issuecomment-518900928,1,['efficient'],['efficient']
Energy Efficiency,"Movies are looking very good @glwagner ! . Great to see that the kinetic energy is only decreasing. . The momentum oscillating seems very reasonable to me. The topography does act like a force can change the momentum, but I don't have a reference to site.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105200836:73,energy,energy,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105200836,1,['energy'],['energy']
Energy Efficiency,"My suggestion of opening a separate issue comes from the fact that I don't have much time to work on this PR (as you guys could probably see by the month-delay in answering the last comments). And in the meantime there's a bug in the code that could be fixed rn with one extra commit. But fair enough. Let's solve this here. > I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough... If I understand what you're proposing, the way forward would be to implement something that always returns the 3D field/array, since that's the only way that works for all grids no matter what. Correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596:596,efficient,efficient,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596,1,['efficient'],['efficient']
Energy Efficiency,"N0X3NvbHZlcnMuamw=) | | |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [test/test\_grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2dyaWRzLmps) | | |; | [...ergence\_tests/ConvergenceTests/ConvergenceTests.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvQ29udmVyZ2VuY2VUZXN0cy5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | | |; | [...ence\_tests/ConvergenceTests/OneDimensionalUtils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxVdGlscy5qbA==) | | |; | [...erification/lid\_driven\_cavity/lid\_driven\_cavity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2xpZF9kcml2ZW5fY2F2aXR5L2xpZF9kcml2ZW5fY2F2aXR5Lmps) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=footer). Last update [d80be8c...a0ca748](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/979#issuecomment-699227574:3389,Power,Powered,3389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/979#issuecomment-699227574,1,['Power'],['Powered']
Energy Efficiency,"Navid here is the output-; ```; julia> using Pkg. julia> Pkg.activate("".""); Activating environment at `~/new_directory/Project.toml`. julia> print(read(""Manifest.toml"", String)); # This file is machine-generated - editing it directly is not advised. [[AbstractFFTs]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""485ee0867925449198280d4af84bdb46a2a404d0""; uuid = ""621f4979-c628-5d54-868e-fcf4e3e8185c""; version = ""1.0.1"". [[Adapt]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""f1b523983a58802c4695851926203b36e28f09db""; uuid = ""79e6a3ab-5dfb-504d-930d-738a2a938a0e""; version = ""3.3.0"". [[ArrayInterface]]; deps = [""IfElse"", ""LinearAlgebra"", ""Requires"", ""SparseArrays"", ""Static""]; git-tree-sha1 = ""2fbfa5f372352f92191b63976d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d250",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:422,Adapt,Adapt,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,Nice adaptations. I agree with modifying the NaNchecker as a stop criteria (which outputs also the NaN location). No need to have simulations timestepping with NaNs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615:5,adapt,adaptations,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615,1,['adapt'],['adaptations']
Energy Efficiency,"Nice job, I am curious to see if the Cholesky preconditioner is efficient on GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374611261:64,efficient,efficient,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374611261,1,['efficient'],['efficient']
Energy Efficiency,"Nice work! I'm curious about the criteria. Should it be something like . ```julia; dt = 10 * eps(dt) * sim.dt; ```. ? Or does it have to be larger than that (hence the factor 1e10). It'd be nice not to have to define `next_actuation_time` for every schedule... it doesn't really make sense for `WallTimeInterval` either. Plus, we want users to be able to provide custom schedules (since they only need to be a function of `model` that returns true/false) so that people can trigger output / action using interesting custom criteria...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2130395065:249,schedul,schedule,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2130395065,2,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"Nice! We probably want to replace docstrings judiciously, since there are some we may want to reduce (for the purpose of readability / understability) relative to the automatically generated versions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2879#issuecomment-1404148796:94,reduce,reduce,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2879#issuecomment-1404148796,1,['reduce'],['reduce']
Energy Efficiency,"Nice!. I was actually going to advocate for adding such a utility because I've found myself running a few tests where the time steps are likely to be diffusion limited:; 1. possibly stratified Couette flow sometimes,; 2. the Pearson vortex test from PR #336,; 3. more recently the [forced flow test](https://github.com/climate-machine/Oceananigans.jl/blob/5355044deae3120134b55cc20f6e38f637eea6a5/test/verification/forced_flow.jl) from (Brown, Cortez, & Minion, 2000) that I'm using to test whether our operator-splitting method is second-order accurate in both velocity and pressure. For geophysical flows, the time step will almost always be limited by advection, but there seem to be many other flows where the time step will be limited by diffusion. So if we want a package that is usable for not just geophysical flows, it would be nice to have adaptive time stepping that works with both advective and diffusive CFL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951:850,adapt,adaptive,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951,1,['adapt'],['adaptive']
Energy Efficiency,"Nice, thank you! I don't think it's necessary to use an output writer because schedules work the same for output and callbacks. Here's another possible MWE:. ```julia; using Oceananigans. Ns = 200 # number of time saves; T = 8e5*π/7 # simulation stop time (s); Δt = 16/15 # timestep (s). grid = RectilinearGrid(size = (), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time=T). captured_times = []; capture_time(sim) = push!(captured_times, time(sim)); add_callback!(simulation, capture_time, TimeInterval(T/Ns)). run!(simulation). @show captured_times; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3056#issuecomment-2152068920:78,schedul,schedules,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3056#issuecomment-2152068920,1,['schedul'],['schedules']
Energy Efficiency,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:703,schedul,schedule,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154,2,['schedul'],['schedule']
Energy Efficiency,"Normally Julia will cache compilation, to reduce compilation costs. Sadly for the GPU we currently have to turn off all the caches and each GPU function basically compiles the entire world.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466255161:42,reduce,reduce,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466255161,1,['reduce'],['reduce']
Energy Efficiency,"Not really, it will call the fallback. But it's no cost to just have an adapt there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246:72,adapt,adapt,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246,1,['adapt'],['adapt']
Energy Efficiency,"Not supposed to be concrete but just to lay out some goals for big new features and prioritize them based on our needs. Also in case I forgot about them. Most of these can be done independently so the version ordering is mostly for priority. * v0.6: Arbitrary LES closures (Smagorinsky and AMD implemented); * v0.7: Halo regions (PR #167); * v0.8: Reduce memory usage by storing fewer fields.; * v0.9: Machine precision mass conservation; * v0.10: channel and boxed/cubed models, i.e. multiple wall-bounded dimensions (PR #180); * v0.11: True finite volume operators; * v0.12: Variable Δz grid; * v0.13: Higher-order advection schemes (4th order, 3rd order DST, WENO?, Prather??); * v0.14: GPU performance optimization (GPU hackathon); * v0.15: Multi-GPU (and multi-CPU?) distributed parallelism (GPU hackathon); * v0.16: Fuller high-level and API documentation; * v0.17: Fast on-the-fly diagnostics framework (CPU and GPU friendly); * v1.0: Awesome LES model!; * v1.1: Hydrostatic mode; * v1.2: Spherical grid (pole problem)?; * v1.3: Cubed sphere grid?; * ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/207:348,Reduce,Reduce,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207,1,['Reduce'],['Reduce']
Energy Efficiency,"Not sure if this means we cannot use PowerPC/Satori for now?. ```julia; julia> using Oceananigans. julia> IncompressibleModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1))); ```. ```julia; ERROR: cfunction: closures are not supported on this platform; Stacktrace:; [1] compile_method_instance(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/jlgen.jl:325; [2] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneT",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:37,Power,PowerPC,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['Power'],['PowerPC']
Energy Efficiency,"Note that `.=` between different arrays is `copyto!` and `convert(CuArray, A)` tends to be better written as `adapt(CuArray, A)`. The former will lose structure if you have `A==Transpose{CuArray}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-482187814:110,adapt,adapt,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-482187814,1,['adapt'],['adapt']
Energy Efficiency,Note that functionality for reduced fields also would need to be generalized from `UnitRange` to `AbstractRange`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L54,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810574949:28,reduce,reduced,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810574949,1,['reduce'],['reduced']
Energy Efficiency,Note: It seems that it didn't really reduce the docs built overall time. I guess we've reached to the point where examples aren't the bottleneck anymore but rather doctests and compilation times are. :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344:37,reduce,reduce,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344,1,['reduce'],['reduce']
Energy Efficiency,"Now also with resting potential energy RPE and available potential energy APE. ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/616360e4-b61b-48c2-80ca-684311f73802). Float32 is more jaggedy, I reckon it's gravity waves that affect buoyancy? But note that there's no obvious bias otherwise. Which may explain why APE decreases less fast as with Float32 too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417:32,energy,energy,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417,2,['energy'],['energy']
Energy Efficiency,"Now that `ShallowWaterModel` is established I think it's important to make it more efficient. At the moment when we use `WENO5`, as I've been doing, we define 3 halo points in each direction. That means that our 1-layer model is really a 7-layer model, which is much more storage than we need. I very much want to remove this so that we can be much more efficient and have the code run faster. I know that #1024 tried to establish a flat dimension for `IncompressibleModel`. This is before my time and I heard multiple people tried doing this and it was a challenge. . I would like to do something independent of #1024, and force that any grid for `ShallowWaterModel` not define halo regions in the vertical and then not fill in those halo regions as it evolves. Below are a list of different things that I think should be done but am very curious to know what people suggest. I haven't tried this so I'm sure there are some details that I have not thought of and hoping to learn from others. - [ ] Maybe define the boundary conditions to be `flat` in the vertical and then try and get flat to work for this model?; - [ ] Maybe in `field_boundary_conditions.jl`, define `uhFluxBoundaryCondtions`, `vhFluxBoundaryCondtions`, `hBoundaryCondtions` that do not do anything to `top` and `bottom`?; - [ ] If we set the number of halos in the vertical to be 0, then we should still be able to use `new_data.jl` without having to modify it?; - [ ] Tell `fill_halo_regions.jl` to not do anything for `bottom` and `top`.; - [ ] If we remove the halos then I don't think we have to modify the tendencies at all so that might be fine.; - [ ] Other things that I've not considered?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499:83,efficient,efficient,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499,2,['efficient'],['efficient']
Energy Efficiency,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:187,Adapt,Adapt,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,2,"['Adapt', 'Allocate']","['Adapt', 'Allocate']"
Energy Efficiency,"Now that we have an interface for fast on-the-fly reductions, it might make sense to implement a `KernelFunctionOperation` feature that accepts custom `kernel_function(i, j, k, grid, fields...)` so these can be reduced. (And in fact, this might also provide a replacement for `KernelComputedField`). Something like. ```julia; struct KernelFunctionOperation{LX, LY, LZ, P, A, G, T, K, D} <: AbstractOperation{LX, LY, LZ, A, G, T}; op :: K; grid :: G; architecture :: A; computed_dependencies :: D; parameters :: P; end. @inline Base.getindex(κ::KernelFunctionOperation, i, j, k) = κ.op(i, j, k, grid, κ.computed_dependencies..., κ.parameters}; @inline Base.getindex(κ::KernelFunctionOperation{LX, LY, LZ, <:Nothing}, i, j, k) where {LX, LY, LZ} = κ.op(i, j, k, grid, κ.computed_dependencies...}; ```. With an appropriate `compute!` (or `compute_at!`) method for ensuring that `computed_dependencies` get computed, this might be a better / leaner interface than the one provided by `KernelComputedField`, with the added, extremely useful benefit that it can be reduced on the fly just like other `AbstractOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623:211,reduce,reduced,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623,2,['reduce'],['reduced']
Energy Efficiency,"Numerical dissipation by `UpwindBiasedFifthOrder()` should dissipate energy, similarly as in the two dimensional turbulence example. I would also expect to see a lot of small scale waves because this is stably stratified. I guess those would also dissipate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442569111:69,energy,energy,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442569111,1,['energy'],['energy']
Energy Efficiency,"OK, if docs build and look fine I'll merge and leave the energy plot for some other time :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722630125:57,energy,energy,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722630125,1,['energy'],['energy']
Energy Efficiency,"OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. Usually systems with imposed mean flow _do not_ have an energy integral. This is a side-effect of the system not being energetically closed since something is continuously putting energy in to keep that mean flow fixed. E.g., Phillips 2-layer baroclinic instability where an imposed mean flow is kept fixed then kinetic energy grows... I'm not sure if this imposed mean buoyancy does this in this example, but here's an example in which the imposed mean flow does not guarantee that kinetic energy will decay:. Take periodic boundary conditions in x and y and 2D flow $\boldsymbol{u}(\boldsymbol{x}, t) = (u(x, y, t), v(x, y, t))$. Then,. $$; \begin{gather}; \partial_t u + u\partial_x u + v\partial_y u = ν \nabla^2 u \\; \partial_t v + u\partial_x v + v\partial_y v = ν \nabla^2 v\\; \partial_x u + \partial_y v = 0; \end{gather}; $$. implies that . $$; \begin{align}; \frac{\mathrm{d}}{\mathrm{d}t} \int \frac1{2} (u^2+v^2) \mathrm{d}^2\boldsymbol{x} &= \int (u \partial_t u + v \partial_t v) \mathrm{d}^2\boldsymbol{x} \\; &= - \int (u^2 \partial_x u + u v \partial_y u + u v \partial_x v + v^2 \partial_y v) \mathrm{d}^2\boldsymbol{x} + ν \int (u \nabla^2 u + v \nabla^2 v) \mathrm{d}^2\boldsymbol{x} \\; &= - \int [u \partial_x ( u^2+v^2)/2 + v \partial_y ( u^2+v^2)/2 ] \mathrm{d}^2\boldsymbol{x} + ν \int (u \nabla^2 u + v \nabla^2 v) \mathrm{d}^2\boldsymbol{x} \\; &= - \underbrace{\int \boldsymbol{\nabla \cdot} \left[ \boldsymbol{u} \ \frac1{2}( u^2+v^2) \right] \mathrm{d}^2\boldsymbol{x}}_{=0 \text{ from boundary conditions}} - ν \int | \boldsymbol{\nabla} \boldsymbol{u}|^2 \\; &= - ν \int | \boldsymbol{\nabla} \boldsymbol{u}|^2 \mathrm{d}^2\b",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1487989708:150,energy,energy,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1487989708,5,['energy'],['energy']
Energy Efficiency,"OK. All these is great!. So all this info you just shared is it anywhere else written? E.g. ""StretchedSmoothness is much less efficient... another reason to avoid it"". Btw, what exactly is ""StretchedSmoothness""?. We should have a docs section on advection schemes (#1318) and perhaps this PR is not the right place to deal with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531:126,efficient,efficient,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531,1,['efficient'],['efficient']
Energy Efficiency,"OK. But as a point of reference, this PR only reduced docs built from 3h to 2h30 --> https://buildkite.com/clima/oceananigans/builds/11644#018897e6-4547-44d2-9644-d8eeed5d1957",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583214793:46,reduce,reduced,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583214793,1,['reduce'],['reduced']
Energy Efficiency,"Oceananigans already supports `advection = nothing`, `buoyancy = nothing` and `coriolis = nothing`. So if support for `pressure = nothing` (or `pressure_solver = nothing`) is added, would `BackgroundField` effectively work as a prescribed unchanging velocity?. I guess Oceananigans would reduce to solving the advection-diffusion equation. So it would have to be `advection = nothing` for momentum only (keeping tracer advection).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768489317:288,reduce,reduce,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768489317,1,['reduce'],['reduce']
Energy Efficiency,"Oceananigans.jl/pull/336?src=pr&el=h1) Report; > Merging [#336](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/a26da9c932f562241fd96d97bfcc16f3c033e72a?src=pr&el=desc) will **increase** coverage by `0.51%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #336 +/- ##; ==========================================; + Coverage 61.06% 61.57% +0.51% ; ==========================================; Files 22 22 ; Lines 1243 1231 -12 ; ==========================================; - Hits 759 758 -1 ; + Misses 484 473 -11; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `9.67% <0%> (-3.23%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.41% <0%> (+4.42%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=footer). Last update [a26da9c...a2cabed](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518876039:1752,Power,Powered,1752,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518876039,1,['Power'],['Powered']
Energy Efficiency,"Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <0%> (-57.62%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `39.34% <0%> (-19.56%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `46.83% <0%> (-15.19%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.19% <0%> (-1.94%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `62.5% <0%> (-1.79%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `76.06% <0%> (-0.54%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86% <0%> (-0.28%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388?src=pr&el=footer). Last update [af5d513...e113346](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/388#issuecomment-526922577:3011,Power,Powered,3011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388#issuecomment-526922577,1,['Power'],['Powered']
Energy Efficiency,"Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.80% <100.00%> (+2.91%)` | :arrow_up: |; | [src/TurbulenceClosures/diffusion\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9kaWZmdXNpb25fb3BlcmF0b3JzLmps) | `100.00% <100.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `75.00% <100.00%> (ø)` | |; | [...urbulenceClosures/viscous\_dissipation\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92aXNjb3VzX2Rpc3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `100.00% <100.00%> (ø)` | |; | ... and [39 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999?src=pr&el=footer). Last update [e808a82...b56c813](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-700403403:3601,Power,Powered,3601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-700403403,1,['Power'],['Powered']
Energy Efficiency,"Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); bᵢ(x, y, z) = B(x, y, z) + 0e-6*rand(). b_bc = FieldBoundaryConditions(top = GradientBoundaryCondition(N²), bottom = GradientBoundaryCondition(N²)). model = NonhydrostaticModel(; grid,; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν),; boundary_conditions = (b = b_bc, ); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=1hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:5109,schedul,schedule,5109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,2,['schedul'],['schedule']
Energy Efficiency,"Oh yeah right... Well, I don't know any ""good reference"". I've seen some people use an ad-hoc ""boundary layer depth"" of few tenth's of meters. In isopycnal coordinates (e.g. mom6) one uses the depth of the bottom layer, or an average of the fluid layers within e.g. 10 meters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445:135,meter,meters,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445,2,['meter'],['meters']
Energy Efficiency,"Oh, if GLMakie works with the ""correct"" GPU then stick to that. Because it produces output. CairoMakie doesn't produce a figure but only can save, e.g., to a png file. We use CairoMakie in the docs because they are build on remote computers without monitors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1128314831:249,monitor,monitors,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1128314831,1,['monitor'],['monitors']
Energy Efficiency,"Ok I am convinced, I will close the PR and maybe we can monitor more closely GPU 0 for the moment until we find a stable solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2358274080:56,monitor,monitor,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2358274080,1,['monitor'],['monitor']
Energy Efficiency,"Ok here's an idea: replace `Scan` with `Accumulation`. I think a sum can be thought of as ""accumulating"" without any leaps. We then would have _reducing_ accumulations (intermediate accumulations are not stored), and _cumulative_ accumulations (where the result is not reduced). We then have the mapping:. * `Scan` to `Accumulation`; * `Accumulation` to `Cumulation` (but we only really need the cumulative sum / integral anyways probably, so this need not be user facing anyways); * `Accumulating` to `Cumulating`. Honestly discussing this, the phrase ""cumulative sum"" is not the most clear, either. But, history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104552538:269,reduce,reduced,269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104552538,1,['reduce'],['reduced']
Energy Efficiency,"Ok, I agree with your comments.; This said then, it is better to close this PR and start from a clean slate.; I'll close this PR and open a new one which will focus on the following changes:. - Free surface will be: `Field((Center, Center, Face), grid, indices = (:, :, grid.Nz+1))`; - Changes to inner workings of PCG and MG solver to accommodate this change; - Immersed reductions for _sliced_ and _windowed_ fields (and in general conditional reductions); - Try windowed-sliced BC? (We need this for `η`). - Reductions on `ReducedFields`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248423509:526,Reduce,ReducedFields,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248423509,1,['Reduce'],['ReducedFields']
Energy Efficiency,"Ok, here's a multi-pronged strategy to address this:. 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?; 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103328247:120,schedul,schedules,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103328247,2,"['reduce', 'schedul']","['reduce', 'schedules']"
Energy Efficiency,"Ok, now I realize that we actually can't do this because it will probably prevent GPU compilation. `ReducedField` keep their location on the GPU, but we can't keep the locations of all fields on the GPU. I'll change this issue to a discussion of behavior changes for `set!` and `interior` with `Flat` directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1655#issuecomment-1047955114:100,Reduce,ReducedField,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1655#issuecomment-1047955114,1,['Reduce'],['ReducedField']
Energy Efficiency,"Ok, this change doesn't work because we actually pass the `closure` and `buoyancy` to `apply_flux_bcs!`, right now:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl#L42-L43. This is for models like CATKE that have boundary conditions which depend on the closure... which extend `getbc`... https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_top_boundary_condition.jl#L19-L20. So I think to make this change we also need to generalize the implementation of `DiscreteBoundaryFunction`. We would need to have a type that indicates whether or not we should somehow truncate the `args` that are passed to `fill_halo_regions!` (in that generalization, the pattern on `main` would be the special case that all the args after the first 2 are discarded). ## Nota bene. A different solution one might invent would _copy_ `model.closure` and `model.buoyancy` into CATKE's `TKETopBoundaryConditionParameters`. The reason this doesn't work is that we support _changing_ the parameters of `model.closure` after creating the model. (This is a nifty feature that makes calibration a lot more efficient.) This means that we always need to get the closure parameters from `model.closure` to be consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780:1329,efficient,efficient,1329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780,1,['efficient'],['efficient']
Energy Efficiency,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310:616,schedul,schedule,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310,1,['schedul'],['schedule']
Energy Efficiency,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553:802,Efficient,Efficient,802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553,1,['Efficient'],['Efficient']
Energy Efficiency,"Okay, then let's start with a one-layer, reduced-gravity SW model with a free-surface. Afterwards, we can get fancy and do a rigid lid version if we like and then talk about other interesting problems. I would be happy to do it in both but let's focus on Oceananigans as that allows a greater versatility in terms of the boundary conditions. I am also interested in solving eigenvalue problems to compute stability characteristics in Julia and have done a bit of this already. 1D problems are of course easy to solve but 2D ones are much trickier. It would be great to talk to a Julia expert about what best practices they might suggest. I am happy to setup a zoom conversation sometime. I don't know what time-zone everyone is in but if there is a typical time that might meet please suggest it and I will see if I can make that time. I'm also happy to close this issue whenever you like as an idea as come up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724314613:41,reduce,reduced-gravity,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724314613,1,['reduce'],['reduced-gravity']
Energy Efficiency,"On #3624 . ```julia; using Oceananigans; grid = RectilinearGrid(size=(1000, 64, 100), extent=(1, 1, 1), topology=(Periodic, Periodic, Bounded));; c = CenterField(grid; indices=(1:grid.Nx, 1:grid.Ny, 1:grid.Nz));; averaged_c = Field(Average(c, dims=2)); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); ```. Makes. ```julia; julia> @time compute!(averaged_c); 1.576736 seconds (1.81 M allocations: 123.040 MiB, 99.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.450573 seconds (150.91 k allocations: 10.220 MiB, 7.82% gc time, 99.15% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.403323 seconds (150.90 k allocations: 10.217 MiB, 98.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:597,reduce,reduced,597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,"On a c-grid computing the Coriolis term could lead to energy/enstrophy loss. Schemes by Sadourny (1975) help alleviate this. These schemes are implemented on the sphere, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Coriolis/hydrostatic_spherical_coriolis.jl. However, they are not implemented for `RegularRectilinearGrid`. cc: @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818:54,energy,energy,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818,1,['energy'],['energy']
Energy Efficiency,"On the CPU it seems like things are failing with `FATAL ERROR: Symbol ""__nv_llabs""not found`. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). GPU tests don't want to run (CUDA driver might be too old on Sverdrup?) but GPU regression tests passed on Tartarus so things might be fine there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508:114,reduce,reduce,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508,1,['reduce'],['reduce']
Energy Efficiency,"On the skip condition `hasnan`: we currently have. https://github.com/CliMA/Oceananigans.jl/blob/be424494c720e2f5152c485178a963c96b110a0f/src/Simulations/nan_checker.jl#L14. but for the above pattern we'd need something like. ```julia; hasnan(model::AbstractModel) = hasnan(first(fields(model))); ```. With generic ""skip conditions"" users can also write things like. ```julia; schedule = Skip(model -> hasnan(model.pressures.pNHS), TimeInterval(100)); ```. (or something)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982873709:377,schedul,schedule,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982873709,1,['schedul'],['schedule']
Energy Efficiency,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:860,allocate,allocate,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,1,['allocate'],['allocate']
Energy Efficiency,"One problem is that `∫ᶻQ.u` is a reduced field so `maximum(∫ᶻQ.u)` excludes points at `i, j` corresponding to immersed cells at `i, j, k = 1`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238531744:33,reduce,reduced,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238531744,1,['reduce'],['reduced']
Energy Efficiency,"One simple solution would be to host the GitHub action on the `OceananigansDocumentation` and have it so that it runs on a schedule (e.g., weekly).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308611712:123,schedul,schedule,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308611712,1,['schedul'],['schedule']
Energy Efficiency,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722:84,Adapt,Adapt,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722,2,['Adapt'],['Adapt']
Energy Efficiency,"Oof, ok I understand. I thought the filtering would allow us to remove the warnings from the docstring. But it doesn't. Instead we have to include the warning in the docstring (including a random path to someone's Oceananigans version, eg `Research/OC11.jl`:. ```; help?> MultiRegionGrid; search: MultiRegionGrid multi_region_grid MultiRegionField MultiRegionObject. MultiRegionGrid(global_grid; partition = XPartition(2),; devices = nothing,; validate = true). Split a global_grid into different regions handled by devices. Positional Arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • global_grid: the grid to be divided into regions. Keyword Arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • partition: the partitioning required. The implemented partitioning are XPartition (division along the x direction) and; YPartition (division along the y direction). • devices: the devices to allocate memory on. If nothing is provided (default) then memorey is allocated on the the CPU.; For GPU computation it is possible to specify the total number of GPUs or the specific GPUs to allocate memory on. The; number of devices does not need to match the number of regions. • validate :: Boolean: Whether to validate devices; defautl: true. Example; ≡≡≡≡≡≡≡. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(12, 12), extent=(1, 1), topology=(Bounded, Bounded, Flat)); 12×12×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on CPU with 3×3×0 halo; ├── Bounded x ∈ [0.0, 1.0] regularly spaced with Δx=0.0833333; ├── Bounded y ∈ [0.0, 1.0] regularly spaced with Δy=0.0833333; └── Flat z. julia> multi_region_grid = MultiRegionGrid(grid, partition = XPartition(4)); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion ~/Research/OC11.jl/src/MultiRegion/multi_region_grid.jl:108; MultiRegionGrid{Float64, Bounded, Bounded, Flat} partitioned on CPU():; ├── grids: 3×12×1 RectilinearGrid{Float64, RightConnected, Bounded, Flat} on ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287773336:852,allocate,allocate,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287773336,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,Or maybe to adapt the default based on the incoming grid?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164,1,['adapt'],['adapt']
Energy Efficiency,"Originally added in PR #592 but removed in #1221, this PR reintroduces the `weno_nth_order.jl` implementation. We should look into making it as fast and efficient as the `weno_fifth_order.jl` before merging. Also this PR adds the cursed SymPy dependency which has caused problems for users in the past (see #990) so would be nice to get rid of it somehow. X-Ref: #995",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1238:153,efficient,efficient,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1238,1,['efficient'],['efficient']
Energy Efficiency,"Other names:. * `bc.get`; * `bc.specification`; * ... ?. > Agree that CoordinateBoundaryConditions might be a weird name but yeah, maximum flexibility would be very powerful. Maybe the common use case isn't to impose each of the 30 boundary conditions one-by-one but we can just have nice helper functions/abstractions. precisely, and I like the syntax you propose. We can do lots of stuff here to make our user's lives easy. There are two issues: the backend, and the user interface. Maybe the title of this PR is confusing, because I think it's primarily about the backend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472249269:165,power,powerful,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472249269,1,['power'],['powerful']
Energy Efficiency,"Ouch! Maybe we should fix the seed. And reduce the time step to 0.1 or something so it doens't fall exactly on the bleeding edge of possibility, depending on the whims of `rand`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846:40,reduce,reduce,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846,1,['reduce'],['reduce']
Energy Efficiency,"Output of the `benchmark_advection_schemes.jl` script ran on Tartarus with the following specs:; ```julia; Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, cascadelake); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); Environment:; JULIA_CUDA_MEMORY_POOL = none; LD_LIBRARY_PATH = /storage4/simone/lib:; GPU: NVIDIA TITAN V; ```; Note that ; - the `Centered` scheme is unaffected by this PR ; - `UpwindBiased` should have a similar execution time between this branch and main given that the operations are the same but they just happen at different levels; - `WENO(; order = 1)` defaults to `UpwindBiased(; order = 1)`. # On Main; <img width=""1160"" alt=""Screenshot 2024-07-24 at 11 37 44 AM"" src=""https://github.com/user-attachments/assets/1530b2b6-7c79-4d77-b379-854c65bfa940"">. # On this PR; <img width=""1192"" alt=""Screenshot 2024-07-24 at 11 02 35 AM"" src=""https://github.com/user-attachments/assets/d776af2b-3c6a-4997-a7ae-2763ed49bc6c"">. There are a couple of things to note here when it comes to the WENO scheme:; - on CPU we gain roughly a factor of 1.8 given that computations have been reduced by 2X; - on the GPU the gain is less, because, in this case, the uncoalesced memory access (which has to happen for both the branches) costs much more than on the CPU; - (I suspect that) if using WENO only for horizontal reconstructions (like in the global ocean shown above) the penalty of uncoalesced memory access is reduced significantly and the kernel speeds up by a factor of 2 also on the GPU by virtue of the lower (2X) arithmetic intensity of the kernel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2248327750:1344,reduce,reduced,1344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2248327750,2,['reduce'],['reduced']
Energy Efficiency,Output writer schedules should be checkpointed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280:14,schedul,schedules,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280,1,['schedul'],['schedules']
Energy Efficiency,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1137:925,schedul,scheduled,925,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137,2,['schedul'],['scheduled']
Energy Efficiency,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851,18,"['Adapt', 'adapt']","['Adapt', 'adapt', 'adaptions', 'adaptor', 'adapts']"
Energy Efficiency,Passing `compression` to `NetCDFOutputWriter` does not reduce output file sizes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3152:55,reduce,reduce,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3152,1,['reduce'],['reduce']
Energy Efficiency,"Perhaps a more concise and extendable implementation would be. ```julia; compute!(collection::Union{Tuple, NamedTuple}) = map(compute!, collection); ```. inspired by [Adapt](https://github.com/JuliaGPU/Adapt.jl/blob/ff4419424b6b48b4440c5235f5a4070880fcdf79/src/base.jl#L3)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483:167,Adapt,Adapt,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483,2,['Adapt'],['Adapt']
Energy Efficiency,"Personally, I think things are working well as they are now. We're assuming time is in seconds, but also that positions are in meters and so on. We could create a flat in `NetCDFWriter` that switches from metric no nondimensional, but unless other users seem bothered by this, I say we just close the issue for now. Ideally we'd solve this issue for Oceananigans as a whole by using `Unitful` and such, but that's probably a very big effort...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-1479872542:127,meter,meters,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-1479872542,1,['meter'],['meters']
Energy Efficiency,"Picking up some of the discussion in #858 , we may want to adopt a more hierarchical approach to `ReducedField`s than suggested by the above comments. A more bare-bones implementation of a `ReducedField` would be. ```julia; struct ReducedField{X, Y, Z, A, G, N} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; dims :: NTuple{N, Int}; end. @propagate_inbounds getindex(r::ReducedField{Nothing, Y, Z}, i, j, k) where {Y, Z} = r.data[j, k]; @propagate_inbounds getindex(r::ReducedField{X, Nothing, Z}, i, j, k) where {X, Z} = r.data[i, k]; @propagate_inbounds getindex(r::ReducedField{X, Y, Nothing}, i, j, k) where {X, Y} = r.data[i, j]. @propagate_inbounds getindex(r::ReducedField{X, Nothing, Nothing}, i, j, k) where X = r.data[i]; @propagate_inbounds getindex(r::ReducedField{Nothing, Y, Nothing}, i, j, k) where Y = r.data[j]; @propagate_inbounds getindex(r::ReducedField{Nothing, Nothing, Z}, i, j, k) where Z = r.data[k]; ```. We can then provide further wrappers around `ReducedField` that specify the computation that generates `ReducedField.data`. We only support one of these right now (an average), so we'd only need something like `AveragedField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674392343:98,Reduce,ReducedField,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674392343,11,['Reduce'],['ReducedField']
Energy Efficiency,"Playing around with an internal wave test case I think we actually need todo something more like the adaptive boundary described in section 4.1 of this paper https://doi.org/10.1016/S1463-5003(00)00013-5 as I have come across two problems: when the flow is directed out of the domain on a prescribed interface (e.g. u = cos(pi/h(z+h)) then information can't get out, and on the ""Orlanski"" side where information is travelling into the domain I am getting instability as it is just keeping the boundary value constant which by default is zero. This might present some more user interface issues as it is going to require us to set a ""known"" value on every open boundary unless we're confident that the flow will only be leaving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155:101,adapt,adaptive,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155,1,['adapt'],['adaptive']
Energy Efficiency,Plotting a reduced field on an `ImmersedBoundaryGrid` fills in NaNs incorrectly,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3899:11,reduce,reduced,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3899,1,['reduce'],['reduced']
Energy Efficiency,Preserve locations when adapting Field to GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1906:24,adapt,adapting,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906,1,['adapt'],['adapting']
Energy Efficiency,Pretty sure what I wrote will work. May need `adapt` as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146:46,adapt,adapt,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146,1,['adapt'],['adapt']
Energy Efficiency,"Previous behavior was that time steps could overshoot output writing times and simulation stop times, which caused output to not be exactly aligned with the specified schedules. This PR fixes this long-complained-about fact.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1213:167,schedul,schedules,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1213,1,['schedul'],['schedules']
Energy Efficiency,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1649:352,adapt,adapting,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649,3,"['Reduce', 'adapt', 'reduce']","['ReducedField', 'adapting', 'reduced']"
Energy Efficiency,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:450,power,power,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965,1,['power'],['power']
Energy Efficiency,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:767,power,power,767,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['power'],['power']
Energy Efficiency,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:767,power,power,767,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['power'],['power']
Energy Efficiency,Probably something to implement when we have a time stepper that’s more appropriate for adaptive time stepping like RK3?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/431#issuecomment-535903452:88,adapt,adaptive,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/431#issuecomment-535903452,1,['adapt'],['adaptive']
Energy Efficiency,Proposal for sustainable `validation` scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:13,sustainab,sustainable,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,1,['sustainab'],['sustainable']
Energy Efficiency,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294:100,power,powerful,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294,1,['power'],['powerful']
Energy Efficiency,"Quite concerning that some of the convergence tests do not pass on the GPU... This is probably due to #1170 since the simpler convergence tests that do not rely on a pressure solver seem to pass (also the fact that it passes forced flow free slip with doubly periodic (x, z) but not with a wall-bounded dimension (x, y)). Hmmm, but the Taylor-Green one is doubly periodic... ![image](https://user-images.githubusercontent.com/20099589/100450333-76634b80-3083-11eb-92ea-0d645f564aab.png). ![image](https://user-images.githubusercontent.com/20099589/100450382-8c710c00-3083-11eb-801e-1ed16e5b22a9.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-734821927:343,Green,Green,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-734821927,1,['Green'],['Green']
Energy Efficiency,"Ran the baroclinical adjustement example:; ```; using Oceananigans; using Oceananigans.Units. Lx = 1000kilometers # east-west extent [m]; Ly = 1000kilometers # north-south extent [m]; Lz = 1kilometers # depth [m]. grid = RectilinearGrid(Oceananigans.Architectures.MetalBackend(), Float32;; size = (48, 48, 8),; x = (0, Lx),; y = (-Ly/2, Ly/2),; z = (-Lz, 0),; topology = (Periodic, Bounded, Bounded)). advection = UpwindBiased(Float32); free_surface = ExplicitFreeSurface(); coriolis = BetaPlane(Float32, latitude = -45). model = HydrostaticFreeSurfaceModel(; grid,; coriolis,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = advection,; tracer_advection = advection,; free_surface); ```. This runs with none of the callbacks in about 4 seconds. This output writer works (but `TimeInterval` won't work):; ```; b = model.tracers.b; simulation.output_writers[:fields] = JLD2OutputWriter(model, (; b);; filename = filename * ""_slice"",; schedule = IterationInterval(10),; overwrite_existing = true); ```. And the timestep wizard also won't work because reductions cause a metal compiler error. https://github.com/CliMA/Oceananigans.jl/assets/26657828/c75b33ba-5b06-454b-a883-93eb659d06d6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731743139:951,schedul,schedule,951,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731743139,1,['schedul'],['schedule']
Energy Efficiency,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:825,adapt,adapt,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,1,['adapt'],['adapt']
Energy Efficiency,"Recently, many of my simulations that run on clusters have crashed due to out-of-memory errors. I find that `NetCDFOutputWriter` seems to cause memory leak, which can by reproduced by the code below:. ```Julia; using Printf; using Oceananigans; using Oceananigans.OutputWriters: write_output!. const arch = CPU(). const Nx = 50; const Ny = 50; const Nz = 50. grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (0., 1.),; y = (0., 1.),; z = (0., 1.),; topology = (Bounded, Bounded, Bounded),; ). # Model; model = NonhydrostaticModel(;; grid = grid,; ). output_writer = NetCDFOutputWriter(; model,; model.velocities,; filename = ""output.nc"",; schedule = TimeInterval(1.0),; ). for i in 1:1000; write_output!(output_writer, model); # GC.gc(); @info i; @info Printf.@sprintf ""Max. RSS: %9.3f MiB\n"" Sys.maxrss()/2^20; end; ```. The total memory usage reported by `Sys.maxrss` keeps increasing over time, the rate which is roughly the output data size. Forcing `Gc.gc()` slows down the trend but cannot stop the increase. I believe it is a bug in `NCDatasets`. See Alexander-Barth/NCDatasets.jl#266. The version of `NCDatasets` is 0.14.5 in my case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777:648,schedul,schedule,648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777,1,['schedul'],['schedule']
Energy Efficiency,Reduce ContinuousBoundaryFunction location + features for auxiliary fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1859:0,Reduce,Reduce,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859,1,['Reduce'],['Reduce']
Energy Efficiency,Reduce memory fetch for ContinuousBoundaryFunction BCs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3077:0,Reduce,Reduce,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3077,1,['Reduce'],['Reduce']
Energy Efficiency,Reduce memory usage for source term storage by a factor of 2.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/121:0,Reduce,Reduce,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/121,1,['Reduce'],['Reduce']
Energy Efficiency,Reduce the size of the eady_turbulence.jl script test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1058:0,Reduce,Reduce,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1058,1,['Reduce'],['Reduce']
Energy Efficiency,Reduce velocity divergence during time-stepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228:0,Reduce,Reduce,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228,1,['Reduce'],['Reduce']
Energy Efficiency,ReducedField,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/920:0,Reduce,ReducedField,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/920,1,['Reduce'],['ReducedField']
Energy Efficiency,ReducedField surface displacement,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1540:0,Reduce,ReducedField,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1540,1,['Reduce'],['ReducedField']
Energy Efficiency,Reduces allocations for Multigrid solver on CPU: Multilevel structure only created when required,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2736:0,Reduce,Reduces,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2736,1,['Reduce'],['Reduces']
Energy Efficiency,"Reductions over all dimensions (eg that reduce to a scalar, like `maximum(u)`) on `Field`s that are distributed across many ranks should trigger a global reduction across all workers. A second question is, when this feature is implemented, how will we support ""only local"" reductions? (One may still want to know what `maximum(u)` is on a given worker. For that, we may need things like `local_maximum`, etc.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3337:40,reduce,reduce,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3337,1,['reduce'],['reduce']
Energy Efficiency,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:1395,schedul,schedule,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370,1,['schedul'],['schedule']
Energy Efficiency,Remove Immersed map from `Adapt`ing the `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3690:26,Adapt,Adapt,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690,1,['Adapt'],['Adapt']
Energy Efficiency,Rename Pearson vortex test to Taylor-Green vortex,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/468:37,Green,Green,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/468,1,['Green'],['Green']
Energy Efficiency,"Replacing; ```julia; @apply_regionally begin; launch!(grid.architecture, grid, kernel_parameters,; _fill_cubed_sphere_center_center_field_east_west_halo_regions!, field, multiregion_field, region,; grid.connectivity.connections, Nc, Hc); end; ```; by; ```julia; for region in number_of_regions(grid); launch!(grid.architecture, grid[region], kernel_parameters,; _fill_cubed_sphere_center_center_field_east_west_halo_regions!, field[region], field.data.regional_objects, region,; grid.connectivity.connections[region], Nc, Hc); end ; ```; in `src/MultiRegion/cubed_sphere_boundary_conditions.jl` reduces the wall time of filling only the east-west halos of a `CenterField` on a `ConformalCubedSphereGrid` with one region of `128x128` cells per panel from; ```julia; julia> @btime fill_halo_regions!(c); 711.639 μs (714 allocations: 950.66 KiB); ```; to; ```julia; julia> @btime fill_halo_regions!(c); 13.371 μs (61 allocations: 14.83 KiB); ```; Upcoming commits will incorporate modifications of this type.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2099801416:595,reduce,reduces,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2099801416,1,['reduce'],['reduces']
Energy Efficiency,"Reply:. > 1. No, non-hydrostatic is good... it's just to double check... ; >; > 2. Yes... either varied grid or topography is fine as long as it works. I guess I should try to test it to see which is the easy way... ; >; > 3. That is ok. Not in an urgent manner. It's perfectly fine to test the non-parameterised eddy resolving case at relative high resolution, since efficiency is the claimed strength of Julia and I want to check how efficient it is as well.; > ; > 4. Naively thought it will just be coating 1-3 nonslip layers by enforcing 0 velocities around the topographic feature, well, if the topographic feature is set correctly.. is it more complicated?; > ; > _Originally posted over email_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640693102:436,efficient,efficient,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640693102,1,['efficient'],['efficient']
Energy Efficiency,Return `field` from `compute!(field::ReducedComputedField)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2380:37,Reduce,ReducedComputedField,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2380,1,['Reduce'],['ReducedComputedField']
Energy Efficiency,"RfdXRpbHMuamw=) | `82.50% <30.00%> (-4.78%)` | :arrow_down: |; | [src/BoundaryConditions/zero\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy96ZXJvX2hhbG9fcmVnaW9ucy5qbA==) | `73.68% <81.25%> (-2.79%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (ø)` | |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `96.42% <100.00%> (ø)` | |; | [src/Diagnostics/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL3dpbmRvd2VkX3RpbWVfYXZlcmFnZS5qbA==) | `52.94% <0.00%> (-31.44%)` | :arrow_down: |; | [src/OutputWriters/fetch\_output.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmV0Y2hfb3V0cHV0Lmps) | `60.00% <0.00%> (ø)` | |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `92.30% <0.00%> (+0.78%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929?src=pr&el=footer). Last update [0f33c1d...ed03e78](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/929#issuecomment-690596871:3207,Power,Powered,3207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/929#issuecomment-690596871,1,['Power'],['Powered']
Energy Efficiency,"Right --- the core functions cannot allocate memory. Even `@views` may not be best for the final code because it allocates some memory. I would have written the `xderiv` functions, but I wasn't exactly sure how to deal with the staggered grid --- does the differentiation formula depend on whether the variable is stored at cell centers or cell faces?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437202068:36,allocate,allocate,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437202068,2,['allocate'],"['allocate', 'allocates']"
Energy Efficiency,"Right now JLD2 files always include the full grid (with halos) in `file[""grid""]` which can make it hard to make plots of the data, especially if it was sliced (requiring users to know how to cut out the halos). Not sure if this is a bug as `file[""grid""]` might be referring to the grid the simulation was run on in which case it makes sense to include all the coordinates including halos, but this might still surprise users wishing to make plots. Thanks to @vchuravy for helping uncover this issue!. ```julia; using Oceananigans, Oceananigans.OutputWriters, JLD2; grid = RegularCartesianGrid(size=(8, 8, 8), extent=(1, 2, 3)); model = IncompressibleModel(grid=grid); simulation = Simulation(model, Δt=1, stop_iteration=1); simulation.output_writers[:test] = JLD2OutputWriter(model, merge(model.velocities, model.tracers), schedule=IterationInterval(1), prefix=""test"", field_slicer=FieldSlicer(k=grid.Nz, with_halos=false)); run!(simulation); f = jldopen(""test.jld2""); ```. so. ```julia; julia> size(f[""timeseries/u/1""]); (8, 8, 1); ```. but. ```julia; julia> f[""grid/zC""]; 10-element Array{Float64,1}:; -3.1875; -2.8125; -2.4375; -2.0625; -1.6875; -1.3125; -0.9375; -0.5625; -0.1875; 0.1875; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1194:823,schedul,schedule,823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194,1,['schedul'],['schedule']
Energy Efficiency,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:522,Reduce,ReducedField,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,2,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719:1478,schedul,schedules,1478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719,1,['schedul'],['schedules']
Energy Efficiency,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3748:422,schedul,schedule,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748,2,['schedul'],['schedule']
Energy Efficiency,"Right now reductions only exclude _immersed_ peripheral nodes:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/ImmersedBoundaries/immersed_reductions.jl#L27. It recently caused me a lot of pain and confusion and time that ""ordinary"" peripheral nodes are included in the reduction, but immersed peripheral nodes are not. What is the logic for treating immersed boundaries differently from ordinary boundaries? I think we should either exclude only inactive nodes or peripheral nodes, but this behavior should be consistent between immersed and not immersed grids. This change would mean we don't need special reductions (at least for fields that are not reduced) on immersed vs not-immersed grids. @simone-silvestri may have the answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3064:697,reduce,reduced,697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3064,1,['reduce'],['reduced']
Energy Efficiency,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:652,reduce,reduce,652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['reduce'],['reduce']
Energy Efficiency,"Right now the `NetCDFOutputWriter` saves some useful metadata (date, Julia version, Oceananigans version, schedule metadata) but this could be extended to saving model and simulation parameters (advection scheme, coriolis parameters, boundary condition parameters when possible, equation of state parameters, etc.). This would be generally useful and reduce the burden to do this in other packages, e.g. LESbrary.jl. This saving of metadata can easily be extended to work with `JLD2OutputWriter` as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1313:106,schedul,schedule,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313,2,"['reduce', 'schedul']","['reduce', 'schedule']"
Energy Efficiency,"Right now the element-wise operators are all written for the constant _Δx_, _Δy_, _Δz_ case. As we transition to supporting variable grid spacings, the operators should be written as finite volume operators that take into account the variable areas and volumes. We should be able to figure out a way to write the operators such that they work efficiently for all Cartesian grids. Would be good to do this before #47 is implemented. This may require #59 to be resolved first.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115:343,efficient,efficiently,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115,1,['efficient'],['efficiently']
Energy Efficiency,Right now we are wasting memory and time computing free surface tendencies when `free_surface isa ImplicitFreeSurface` with `HydrostaticFreeSurfaceModel`. A minor optimization would neither allocate memory for the free surface tendencies or calculate them in this case.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1941:190,allocate,allocate,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1941,1,['allocate'],['allocate']
Energy Efficiency,"Right, I think we should selectively and conservatively add features to docs to save users the pain of banging their heads against the wall with experimental stuff. It also helps us work more efficiently since if we decide to do things like change a filename associated with a feature, we don't have extra work to keep the docs up to date.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1943#issuecomment-902000322:192,efficient,efficiently,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1943#issuecomment-902000322,1,['efficient'],['efficiently']
Energy Efficiency,Running Oceananigans with 2 threads allocates the most memory,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1218:36,allocate,allocates,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1218,1,['allocate'],['allocates']
Energy Efficiency,Running with 2 threads is the worst memory-wise. See benchmarks from https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732516353 and similar results were reported by @francispoulin on a different machine from https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734500922. Not sure if this is because of Oceananigans.jl or because of KernelAbstractions.jl. Multithreaded seems to allocate a ton of memory in general though.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1218:405,allocate,allocate,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1218,1,['allocate'],['allocate']
Energy Efficiency,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3401:98,adapt,adapt,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401,1,['adapt'],['adapt']
Energy Efficiency,"Seems like a good idea but let me make sure I understand it. If I take your example and modify it slightly, change 10 to 1, should it give output everytime step?. ```; progress_callback = Callback(print_progress, schedule=IterationInterval(10)); run!(simulation, callbacks=[progress_callback]); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885836832:213,schedul,schedule,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885836832,1,['schedul'],['schedule']
Energy Efficiency,"Shall we extend the `ShallowWaterModel` type to incorporate single- and multi-layer configs? What other properties does a multilayer shallow water type need? The reduced gravities that correspond to each interface is an obvious one... any other?. The number of layers could be a parameter of the type so we can dispatch on it in various methods. E.g.,. ```julia; mutable struct ShallowWaterModel{N, G, A<:AbstractArchitecture, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} <: AbstractModel{TS}; number_of_layers :: Int # Number of fluid layers; grid :: G # Grid of physical points on which `Model` is solved; architecture :: A # Computer `Architecture` on which `Model` is run; clock :: Clock{T} # Tracks iteration number and simulation time of `Model`; gravitational_acceleration :: GR # Gravitational acceleration; reduced_gravitational_acceleration :: RG # Reduced gravitational acceleration between for fluid interfaces; advection :: V # Advection scheme for velocities, mass and tracers; velocities :: U # Velocities in the shallow water model; coriolis :: R # Set of parameters for the background rotation rate of `Model`; forcing :: F # Container for forcing functions defined by the user; closure :: E # Diffusive 'turbulence closure' for all model fields; bathymetry :: B # Bathymetry/Topography for the model; solution :: Q # Container for transports `uh`, `vh`, and height `h`; tracers :: C # Container for tracer fields; diffusivity_fields :: K # Container for turbulent diffusivities; timestepper :: TS # Object containing timestepper fields and parameters; formulation :: FR # Either conservative or vector-invariant. function ShallowWaterModel(number_of_layers, grid, all_other_things...); arch = architecture(grid); return new{number_of_layers, typeof(G), typeof(arch), the_rest_of_parameters...}(number_of_layers, grid, arch, all_other_things...); end; end. const SingleLayerShallowWaterModel{N, G, A, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} = ShallowWaterModel{1, G, A, T, GR, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910:162,reduce,reduced,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910,2,"['Reduce', 'reduce']","['Reduced', 'reduced']"
Energy Efficiency,"ShallowWater example fails in docs. . ```julia; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; ω, ω′),; filepath = joinpath(@__DIR__, ""shallow_water_Bickley_jet_fields.nc""),; schedule = TimeInterval(1),; mode = ""c""); ERROR: type StepRangeLen has no field parent; Stacktrace:; [1] getproperty(x::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, f::Symbol); @ Base ./Base.jl:33; [2] default_dimensions(output::Dict{String, ComputedField{Face, Face, Center, Oceananigans.Fields.FieldStatus{Float64}, O, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}} where O}, grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, field_slicer::FieldSlicer{Colon, Colon, Colon}); @ Oceananigans.OutputWriters ~/Research/OC2/src/OutputWriters/netcdf_output_writer.jl:39; [3] NetCDFOutputWriter(model::ShallowWaterModel{RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920:201,schedul,schedule,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920,1,['schedul'],['schedule']
Energy Efficiency,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:32,energy,energy,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089,2,['energy'],['energy']
Energy Efficiency,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:134,adapt,adapting,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087,1,['adapt'],['adapting']
Energy Efficiency,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1604:353,allocate,allocates,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604,1,['allocate'],['allocates']
Energy Efficiency,Should we plot the time-series of total kinetic and potential energy in the final simulation together with `exp(2 * estimated_growth * time)`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722200853:62,energy,energy,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722200853,1,['energy'],['energy']
Energy Efficiency,"Side note: hopefully we will have RK3 time stepping at some point, and then we will be able to dramatically improve our adaptive time-stepping as there will be no penalty in updating the step size every time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659699785:120,adapt,adaptive,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659699785,1,['adapt'],['adaptive']
Energy Efficiency,Simulation that produces the video below; https://user-images.githubusercontent.com/33547697/156404654-e5b37a58-d6d8-4ecb-b1df-a69eef4589ee.mp4. (actually this simulation uses monthly average climatology from 1993-2003 while this PR uses only the year 1992 to reduce the memory footprint on OceananigansArtifacts.jl). Future improvements:; - second order equation of state; - improve vertical mixing (CATKE); - switch to hybrid fluxes and relaxation for scalars; - possibly quadratic bottom drag?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2298:260,reduce,reduce,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2298,1,['reduce'],['reduce']
Energy Efficiency,Simulation with tilted gravity and background buoyancy increases in total energy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036:74,energy,energy,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036,1,['energy'],['energy']
Energy Efficiency,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775:548,schedul,schedule,548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775,1,['schedul'],['schedule']
Energy Efficiency,So I am a bit confused on which term the diffusion (or energy dissipation) comes from (as what Francis said above). Is it advective redistribution through the shock?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185593464:55,energy,energy,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185593464,1,['energy'],['energy']
Energy Efficiency,"So I did a bench. I run this:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid). Δt=20minutes; simulation = Simulation(model, Δt=20minutes, stop_time=4Δt). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)). @time run!(simulation); ```. on my laptop on an evnironment with _only_ Oceananigans. Just for the record, my general env contains:. ```Julia; (@v1.9) pkg> st; Status `~/.julia/environments/v1.9/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [13f3f980] CairoMakie v0.10.12; [e9467ef8] GLMakie v0.8.12; [db073c08] GeoMakie v0.5.1; [7073ff75] IJulia v1.24.2; [12c4ca38] Imaginocean v0.1.0 `https://github.com/navidcy/Imaginocean.jl#main`; [85f8d34a] NCDatasets v0.13.1; [5fb14364] OhMyREPL v0.5.23; [c3e4b0f8] Pluto v0.19.32; [295af30f] Revise v3.5.7; ```. Now on an environment with **Oceananigans v0.89.3** I get:. ```Julia; julia> @time run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (18.715 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (7.933 seconds).; [ Info: Simulation is stopping after running for 18.861 minutes.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 1134.663423 seconds (2.18 G allocations: 1.143 TiB, 10.69% gc time, 100.03% compilation time); ```. while with **Oceananigans v0.90.1** I get:. ```Julia; julia> @time run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (13.845 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.351 seconds).; [ I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804711654:525,schedul,schedule,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804711654,1,['schedul'],['schedule']
Energy Efficiency,"So I reduced my code to be just; ```; using Oceananigans; ```; and the code gave the following error; ```; [20610] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg/platform_augmentation.jl:283; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; ERROR: LoadError: Failed to precompile CUDA_Runtime_jll [76a88914-d11a-5bdc-97e0-2f5a05c973a2] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA_Runtime_jll/jl_FIXMhf"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6 ; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] inv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5,reduce,reduced,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['reduce'],['reduced']
Energy Efficiency,So I removed `~/.julia` and ran the instantiate before and I got the following output; ```; [45606] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Installing known registries into `~/.julia`; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.2). Unexpected behavior may occur.; └ @ /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml:0; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed Adapt ─────────────────────── v4.0.4; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed SentinelArrays ────────────── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaT,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:642,Adapt,Adapt,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Adapt'],['Adapt']
Energy Efficiency,"So I'm not sure but something might be going wrong with this line:. https://github.com/JuliaGPU/CUDA.jl/blob/92f1001861641cb173af49454b05c91728cbfc3d/src/mapreduce.jl#L218. which I'm copying here:. ```julia; partial = similar(R, (size(R)..., reduce_blocks)); ```. ~~if you can figure out what `reduce_blocks` is we can figure out what `similar(r::ReducedField, args...)` gives here. Maybe it's non-sensical.~~. Nevermind, this might be a legit bug because we ""unwrap"" `R` which means that `R::SubArray`:. ```; mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, A::Field{Face, Center, Center, GPU, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/mapreduce.jl:228; ```. notice that the type of `R` is `R::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845599439:347,Reduce,ReducedField,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845599439,1,['Reduce'],['ReducedField']
Energy Efficiency,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:91,adapt,adaptive,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['adapt'],['adaptive']
Energy Efficiency,"So this PR is to merge something on an Oceananigans.jl branch, `amdgpu`. It modifies **482** files?!. The `amdgpu` branch is waaay outdated so as a first step perhaps we need to bring that branch up to date? I'm wondering if the seemingly proposed changes to 482 files would be much reduced if we bring `amdgpu` up to date with `main`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448146037:283,reduce,reduced,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448146037,1,['reduce'],['reduced']
Energy Efficiency,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:903,Adapt,Adapt,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['Adapt'],['Adapt']
Energy Efficiency,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:73,energy,energy,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912,1,['energy'],['energy']
Energy Efficiency,"Some highlights/conclusions:; 1. (Periodic, Bounded, Bounded) channels used to take ~37 ms/time step on GPUs but are now takes ~18 ms/time step so it's ~2x as fast :tada:; 2. Our favorite (Periodic, Periodic, Bounded) topology slowed down a bit: from ~11 ms to ~13 ms/time step. Might be due to extra kernel launches in the discrete transforms (index permutations are now done in the discrete transforms).; 3. The `FFTBasedPoissonSolver` allocates quite a bit of memory when DCTs are involved. Should probably see if there are any obvious sources of memory allocations that can be improved but probably not absolutely required.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773410660:438,allocate,allocates,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773410660,1,['allocate'],['allocates']
Energy Efficiency,"Some nice surface gravity waves without rotation!. https://user-images.githubusercontent.com/20099589/114105606-0cfa1180-989b-11eb-8650-695d056f7140.mp4. With Coriolis the corner looks like it's complaining (I tried both energy and enstrophy conserving Coriolis)... https://user-images.githubusercontent.com/20099589/114106008-e4bee280-989b-11eb-9a12-7846c21500f4.mp4. @christophernhill had some suggestions for things to double check:. > In the ""flux form"" then it would be good to double check if averaging is barj(bari(u)) and bari(barj(v)) - those are well defined.; > These; > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-cdscheme-gu; > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-gu-fv; > show the two forms....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816284063:221,energy,energy,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816284063,1,['energy'],['energy']
Energy Efficiency,"Some notes while trying to sort out the output writer logic flow. The key function is `schedule(model)`, which is called every `timestep!`. When `schedule(model) == true`, the `write_output!(writer, sim.model)` function gets triggered:. https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/Simulations/run.jl#L146-L148. The trick for `AveragedTimeInterval` is that, for every timestep in an averaging window, we increment the `WindowedTimeAverage.result`:. https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L220. The difficult part is handling the logic of when to stop collecting increments for a given window:. https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L270-L280. and to reset the `WindowedTimeAverage.result` back to zero to begin accumulating over the next window:. https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L255-L268",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2294972510:87,schedul,schedule,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2294972510,2,['schedul'],['schedule']
Energy Efficiency,"Some results from the ""closure comparison"" validation test (rotating wind-driven mixing in a stratified fluid):. # dz = 1 meter, dx = dy = 2 meter. ![smag_comparison_10](https://github.com/user-attachments/assets/5c6a3bf2-42c8-46ad-968d-91210cc37fb5); ![closure_comparison_10](https://github.com/user-attachments/assets/71de45d3-c3aa-476d-8e31-bbba4bf70546). # dz = 2 meter, dx = dy = 4 meter. ![smag_comparison_20](https://github.com/user-attachments/assets/a223e274-1efa-400f-8a71-1c82e0e98bde); ![closure_comparison_20](https://github.com/user-attachments/assets/74d44106-3ebb-489c-b93a-b5329b8d62a5). Seems like dynamic smag is doing what it should which is great. I'm surprised to see that the Lilly coefficient doesn't do much at coarse resolution at least. On cost: it is a bit interesting. I think as kernel saturate, WENO(order=9) will start to win. For small kernels however, AMD seems ideal. We'll have to do a proper benchmark. This PR also contains an experimental implementation of Lagrangian-averaged (scale-invariant) dynamic Smagorinsky.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2443333362:122,meter,meter,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2443333362,4,['meter'],['meter']
Energy Efficiency,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:97,adapt,adapt,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514,3,['adapt'],"['adapt', 'adaptation']"
Energy Efficiency,"Some time ago I told @simone-silvestri I wanted to show a ""simple 2D example"" in a tutorial, to which he responded. > It's actually harder to construct a 2D grid than a 3D grid. @simone-silvestri's point, I think, is that to reduce the dimension of a grid we have to pass `topology` with `Flat` elements. It's easier to construct a grid with the default topology `(Periodic, Periodic, Bounded)`. This has been haunting me ever since. I think one way we can solve this issue is to introduce convenience constructors like. ```julia; grid = ZRectilinearGrid(size=16, z=(0, 1), topology=Bounded); grid = XYRectilinearGrid(size=(64, 64), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic)); ```. These are relatively simple to implement since they're one-liners:. ```julia; XYRectilinearGrid(args...; topology=(Periodic, Periodic), kw...) = XYRectilinearGrid(args...; kw..., topology=tuple(topology[1:2]..., Flat)); ```. et cetera. We can also define the appropriate type aliases:. ```julia; const XYRectilinearGrid{FT, TX, TY} = RectilinearGrid{FT, TX, TY, Flat} where {FT, TX, TY}; ```. and change `show` (if we desire). Is this friendly / a good idea?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2292:225,reduce,reduce,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292,1,['reduce'],['reduce']
Energy Efficiency,"Something I don't quite understand: say that I want to output horizontal averages, and I pre-allocate memory to store the result of these computations on the GPU. How would I then write a function to use with `JLD2OutputWriter`?. I don't understand the implementation and the use of shared memory for this task. Isn't it enough to write a simple kernel that computes something like. ```julia; average[k] += field[i, j, k] / (grid.Nx * grid.Ny); ```. at every horizontal location `i, j`?. Edit: actually, I think it'd be better to write a function that computes an integral, eg. ```julia; integral[k] += field[i, j, k] * A_cell[i, j]; ```. We can then transfer `integral` to the CPU and compute the average there by dividing by the total area of the domain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520506054:93,allocate,allocate,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520506054,1,['allocate'],['allocate']
Energy Efficiency,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620:163,adapt,adapt,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620,2,['adapt'],['adapt']
Energy Efficiency,"Something else I tried was deleting the `Project.toml` and `Manifest.toml` file as well as `~/.julia`, and after running the following:; ```; using Pkg; Pkg.activate("".""); Pkg.add(""CUDA""); Pkg.instantiate(); using CUDA; ```; I got:; ```; [57577] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg/platform_augmentation.jl:210; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Activating new project at `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer`; Installing known registries into `~/.julia`; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Adapt ─────────────────────── v4.0.4; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed SentinelArrays ────────────── v1.4.5; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed FixedPointNumbers ─────────── v0.8.5; Installed Tables ────────────────────── v1.12.0; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed GPUCompiler ───────────────── v0.26.7; Installed StaticArraysCore ──────────── v1.4.3; Installed TimerOutputs ──────────────── v0.5.24; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed AbstractFFTs ──────────────── v1.5.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArrays ──────────────── v1.9.7; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed LLVMExtra_jll ───────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:868,Adapt,Adapt,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Adapt'],['Adapt']
Energy Efficiency,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:128,Adapt,Adapt,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Energy Efficiency,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:917,Adapt,Adapt,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,1,['Adapt'],['Adapt']
Energy Efficiency,"Sounds like it would be more productive if we discussed this PR (and what we want ""diagnostics"" to look like) in person. Diagnostics may not be the best name. I'm not advocating for diagnostics for all use cases, but we should provide at least a few common ones (e.g. horizontal averages which we already use a lot) and users can build their own using the provided diagnostics as examples. Users shouldn't have to worry about pre-allocating arrays for their horizontal averages. Something as basic as a horizontal average should be fast and allocate zero memory out of the box.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520514848:541,allocate,allocate,541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520514848,1,['allocate'],['allocate']
Energy Efficiency,Stop adapting `OffsetArray` in Oceananigans,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1141:5,adapt,adapting,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141,1,['adapt'],['adapting']
Energy Efficiency,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11614,adapt,adapt,11614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['adapt'],['adapt']
Energy Efficiency,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2072,adapt,adapt,2072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Energy Efficiency,Sure! only the first halo node is required since we have 2nd order viscous terms and advection reduces to second order near the boundary,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2369#issuecomment-1074294876:95,reduce,reduces,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2369#issuecomment-1074294876,1,['reduce'],['reduces']
Energy Efficiency,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:154,Adapt,Adapt,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Adapt'],['Adapt']
Energy Efficiency,"Sure, the PR resolves the rounding issue caused by `previous_interval_stop_time` through the use of actuations (as inspired by its application [here](https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63)).; Here is the part of the code showing these [changes](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877#diff-532eb4a17264dc44a7cae7601aca768c39bfb08f0493561c333f24a3261d6a46R123-R130). Another important change is that ; ```julia. # Save averaging start time and the initial data collection time; wta.window_start_time = model.clock.time; wta.window_start_iteration = model.clock.iteration; wta.previous_collection_time = model.clock.time. wta.schedule.collecting = false; wta.schedule.actuations += 1; ```. occurs only when the window ends, i.e., when `end_of_window(wta.schedule, model.clock) == true`. In contrast, the [previous version](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877#diff-532eb4a17264dc44a7cae7601aca768c39bfb08f0493561c333f24a3261d6a46L265-L268) triggered this only when the model wasn't collecting. > I'm wondering if it makes sense that this is hard or if we should actually consider a more fundamental redesign to make it more robust... I agree that a more fundamental redesign could improve robustness in the long term. That said, the current adjustments seem to resolve the issue for now (I'll look into why certain cases aren't passing the test). We can continue to monitor its performance and consider a redesign if further issues arise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379285570:247,schedul,schedules,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379285570,5,"['monitor', 'schedul']","['monitor', 'schedule', 'schedules']"
Energy Efficiency,"Sure, these are the results for WENO order 3rd up to 11th. Since it is a linear problem (I am just advecting with a constant velocity), the order is retained also with a dimension by dimension reconstruction (we reduce to second order only on non-linear problems).; ![weno2](https://user-images.githubusercontent.com/33547697/176909442-95600577-37e4-432f-a862-ac0436f5a10a.png); ![weno3](https://user-images.githubusercontent.com/33547697/176909448-1fcad0e9-6cbd-46e0-9791-5a8f8adb8a8f.png); ![weno4](https://user-images.githubusercontent.com/33547697/176909451-3d81adee-6a70-46bc-b11f-678a7287b905.png); ![weno5](https://user-images.githubusercontent.com/33547697/176909452-314da3b7-f869-4cd9-9222-4d4f9f115feb.png); ![weno6](https://user-images.githubusercontent.com/33547697/176909455-c96c1650-b234-4d9b-83d5-85741158c4a9.png); ; for `WENON` the order is `2N-1`) In the legend `(x)` stands for advection in x and y, `(y)` is advection in y and z and `(z)` is advection in x and z, I forgot to change the legend from the one dimensional case",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172381519:212,reduce,reduce,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172381519,1,['reduce'],['reduce']
Energy Efficiency,"SurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1666,adapt,adapt,1666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapt']
Energy Efficiency,Taylor-Green vortex verification experiment and convergence test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/611:7,Green,Green,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611,1,['Green'],['Green']
Energy Efficiency,Test needed for `ConsecutiveIterations` schedule,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2154:40,schedul,schedule,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2154,1,['schedul'],['schedule']
Energy Efficiency,"Tests fail on v0.76.5 on GPU... weird... ```Julia; nc3020@gadi-gpu-v100-0100:/g/data/v45/nc3020/OC.jl$ julia-1.6 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| |; |__/ |. (Oceananigans) pkg> test; Testing Oceananigans; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Project.toml`; [79e6a3ab] Adapt v3.3.3; [6e4b80f9] BenchmarkTools v1.3.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [124859b0] DataDeps v0.7.10; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:477,Adapt,Adapt,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Energy Efficiency,Thank you @simonbyrne!. @glwagner I tried to fix `all_*_nodes` so that we can `set!` reduced fields (which `model.free_surface` now is) but not sure if `[]` is the best solution. If tests pass we should merge and tag v0.54.1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1573#issuecomment-819020035:85,reduce,reduced,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1573#issuecomment-819020035,1,['reduce'],['reduced']
Energy Efficiency,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297:825,adapt,adaptive,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297,1,['adapt'],['adaptive']
Energy Efficiency,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:797,efficient,efficient,797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,2,"['adapt', 'efficient']","['adapt', 'efficient']"
Energy Efficiency,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:345,Green,Green-Naghdi,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,1,['Green'],['Green-Naghdi']
Energy Efficiency,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:60,adapt,adapt,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,1,['adapt'],['adapt']
Energy Efficiency,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133:973,charge,charge,973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133,1,['charge'],['charge']
Energy Efficiency,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:774,green,green,774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011,1,['green'],['green']
Energy Efficiency,"Thanks @simone-silvestri . I agree. I changed my list to a checked boxes, to help with monitoring the progress. I can also change the main script to go back to volumes, if we decide this is what we perfer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1166146068:87,monitor,monitoring,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1166146068,1,['monitor'],['monitoring']
Energy Efficiency,Thanks @simone-silvestri for adding a GPU test for `FieldTimeSeries`! I've adapted it correctly now and tests pass locally so I think this PR is ready for review. Actually I should add a test that uses the new kwargs. Would do a test where multiple threads open the same `FieldTimeSeries` but don't think we have multi-threaded tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158:75,adapt,adapted,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158,1,['adapt'],['adapted']
Energy Efficiency,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:512,adapt,adapt,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['adapt'],['adapt']
Energy Efficiency,"Thanks for linking to the papers, we consulted them a while back but forgot to reference them in the documentation. Another needed change is that I incorrectly use the term geopotential. . We can definitely put them in a separate package, I'm sure someone else might find it useful. We might still need to have a separate version for ourselves that integrates with `CellField`s, pre-allocated wavenumbers, and integrates the DCT with the time stepping on the GPU. So might be better if we just spawn off a package as the core functionality of solving the poisson equation can be done in a small amount of code and doesn't need frequent updates.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469315731:383,allocate,allocated,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469315731,1,['allocate'],['allocated']
Energy Efficiency,"Thanks for the link!. Hmmm, maybe the better approach without be to try using the `@stencil` abstraction on a smaller problem like a Laplacian kernel and once that works efficiently, try the Oceananigans kernels again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/442#issuecomment-538481053:170,efficient,efficiently,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442#issuecomment-538481053,1,['efficient'],['efficiently']
Energy Efficiency,Thanks for the useful link. That makes sense that it's all about efficient memory arrangement. Since it's a micro-optimization I'll mark it as wontfix and revisit when we have a model that runs on GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462555060:65,efficient,efficient,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462555060,1,['efficient'],['efficient']
Energy Efficiency,"Thanks to @hennyg888 , we now have scalings results for the distributed shallow water and nonhydrostatic models for both weak and strong scaling going up to 128 cores. . https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md. The good news is that the `ShallowWaterModel`, in both weak and strong scaling, reaches efficienties of around 80% on 128 cores. This is something we can probably make better but not the first concern. The not so good news is that the `NonhydrostaticModel`, the efficiency goes down close to 10%. I don't know why but wanted to mention it as it's something that we should be able to do much better with. Thoughts? @christophernhill @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1948:344,efficient,efficienties,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948,1,['efficient'],['efficienties']
Energy Efficiency,"Thanks to @vchuravy's work, a two-year old PR was finally merged! https://github.com/JuliaArrays/OffsetArrays.jl/pull/57. So OffsetArrays v1.4.0 now adapts OffsetArrays. This means we can should rid of this file: https://github.com/CliMA/Oceananigans.jl/blob/a48f284ca7341193254ddb3fc44daa9f5e9f318d/src/Utils/adapt_structure.jl. because right now we get a method redefinition warning:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition adapt_structure(Any, OffsetArrays.OffsetArray{T, N, AA} where AA<:AbstractArray{T, N} where N where T) in module OffsetArrays at /home/alir/.julia/packages/OffsetArrays/ExQCD/src/OffsetArrays.jl:486 overwritten in module Utils at /home/alir/Oceananigans.jl/src/Utils/adapt_structure.jl:5.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1141:149,adapt,adapts,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141,1,['adapt'],['adapts']
Energy Efficiency,"Thanks, @hdrake, for bringing up this important point. I guess we should also remember that the sorting procedure is only an approximation to the actual calculation of background potential energy. It's super useful and easy in most cases, so most people jump straight to that, but the more ""proper"" calculation of BPE involves calculating the quantity `z_*`:. ![Screenshot from 2021-05-11 18-44-11](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png). from [Winters et alia, (1995).](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/available-potential-energy-and-mixing-in-densitystratified-fluids/A45F1A40521FF0A0DC82BC705AD398DA). I think calculating BPE this way still has some complications, but at least I believe the calculation is unique. It might be the preferred for cases with topography, stretched grids, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174:189,energy,energy,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174,2,['energy'],"['energy', 'energy-and-mixing-in-densitystratified-fluids']"
Energy Efficiency,"Thanks, @tomchor ! ; Is that a reason why you define the closure for the coarse_model?. Until now, what I was doing was something like this. ```julia; for i = 1:10:model.Nz; key = Symbol(""xy"", i) # Create the dictionary key dynamically; fname = ""vxy_z$(@sprintf(""%05d"", i)).nc""; simulation.output_writers[key] = NetCDFOutputWriter(model, output_fields,; schedule = TimeInterval(output_interval),; filename = fname,; indices = (:,:,i),; with_halos = false,; overwrite_existing = overwrite_existing,; array_type = Array{Float32}); end; ```; Which creates a file for each subset level. While I think that @tomchor solution is the best because it is more general and can be for any arbitrary new grid, I still think we should also be able to simply pass the indices to `NetCDFOutputWriter`. For example, this should work. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; indices = (:,:,1:10:model.Nz),; overwrite_existing=true,). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470:354,schedul,schedule,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470,3,['schedul'],['schedule']
Energy Efficiency,That code allows two things that would not be possible with `maximum(parent(f.data))`. - it returns a `ReducedField` instead of an Array if `dims != :`; - it is possible to perform a conditional reduction which means that we can remove immersed cells from the reduction. It can be done in another way though if it errors... when do you find the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870:103,Reduce,ReducedField,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870,1,['Reduce'],['ReducedField']
Energy Efficiency,"That error is a weird way to say that the file was not found. I moved around a few things and maybe some of those didn't stick. I'll get it working. Yes, I think we should merge this before arbitrary tracers. I think you're right that we should reduce `test_step!`. I'll request another review when I make the changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542412461:245,reduce,reduce,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542412461,1,['reduce'],['reduce']
Energy Efficiency,"That solution looks pretty good!. As far as I can tell I think it makes sense for the ""full"" pressure field to continue smoothly into the IB, since the pressure field is somehow a solution to Poisson's equation --- even if the RHS of the Poisson equation varies rapidly close to the IB (?). Does the magnitude of the velocity error scale with the time-step, or resolution? Perhaps plotting the dependence of the error on some of those parameters can give us confidence that the method is working as expected. Should we try iterating the IB correction + pressure solve to see if it reduces the velocity error, as we hypothesized it might?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609:581,reduce,reduces,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609,1,['reduce'],['reduces']
Energy Efficiency,"That was for sure a problem, we want both bathymetry and `h` to be positive (I changed it in the later commit) It still NaNs very quickly though. . It is for sure vanishing `h`... if I displace the bathymetry by 400 meters, it's stable",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129196732:216,meter,meters,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129196732,1,['meter'],['meters']
Energy Efficiency,That was just an example. There's a lot of erroneous usage. This might help:. ```; (base) gregorywagner:src/ (glw/fix-adapt) $ grep -r unroll ./* [11:11:55]; ./Advection/Advection.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./BoundaryConditions/fill_halo_regions_open.jl:# and need to unroll a loop over the boundary normal direction.; ./BoundaryConditions/fill_halo_regions.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_flux.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl: @inbounds @unroll for k = 1:target_grid.Nz; ./Fields/regridding_fields.jl: @unroll for k_src = k₋_src:k₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for j = 1:target_grid.Ny; ./Fields/regridding_fields.jl: @unroll for j_src = j₋_src:j₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for i = 1:target_grid.Nx; ./Fields/regridding_fields.jl: @unroll for i_src = i₋_src:i₊_src-1; ./Fields/field_boundary_buffers.jl:using KernelAbstractions.Extras.Lo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155,1,['adapt'],['adapt']
Energy Efficiency,That's a good point. Upon further inspection I can see that indeed the time step wizard increases Δt past that 100 s at some point. I ran the same set-up for a fixed `Δt=10` (also for 10 days) and the energy increased by a factor of 5. Definitely better! But it still seems too large of an increase for a quasi-quiescent run for such a short period of time for me. I'd expect something in the single-digit percentages...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442553443:201,energy,energy,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442553443,1,['energy'],['energy']
Energy Efficiency,"That's great news @ali-ramadhan . I guess by looking at your code I can learn how to adapt it to `ShallowWaterModel`. Maybe I will start by doing some tests for the two-dimensional turbulence example, or has someone done that already? By that I mean checking scalabiilty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921:85,adapt,adapt,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921,1,['adapt'],['adapt']
Energy Efficiency,That's great. So the differences between this and `KernelComputedField` are the here we can reduce on the fly and we don't need to define a `getindex` method?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827802530:92,reduce,reduce,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827802530,1,['reduce'],['reduce']
Energy Efficiency,"That's very nice @apaloczy, thank you! I have to think about it more but I think the hypothesis is rational: there is an unavoidable error associated with step topography, but the error can be reduced by using partial cells vs full cells. If that holds this would be an excellent case to use to motivate/develop cut cells. Note there are a few articles that suggest the same:. - [How slippery are piecewise-constant coastlines in numerical ocean models?](https://www.tandfonline.com/doi/abs/10.3402/tellusa.v50i1.14514); - [Sliding or Stumbling on the Staircase: Numerics of Ocean Circulation Along Piecewise-Constant Coastlines](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2022MS003594). This could be a good bona fide example I think. We only have an internal tide example now, right? But definitely a validation test otherwise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2273594015:193,reduce,reduced,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2273594015,1,['reduce'],['reduced']
Energy Efficiency,"The ""long line"" issue is not just a problem for diff's by the way. I use a text editor (and many others do too) in which navigation is performed by the keyboard. Navigating to the middle of an extremely long line is annoying and time consuming (I could possible build in shortcuts that jump many words at at time for that... but I haven't). Code navigation is more efficient (for me) when the lines are short and I can navigate through the text by jumping lines.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470523539:365,efficient,efficient,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470523539,1,['efficient'],['efficient']
Energy Efficiency,"The Adams-Bashforth time stepper relies on an approximate time-integral to calculate the tendencies. ; This time integral, when using a constant time step, is simply approximated as; ```math; G^{n+1} = \left(\frac{3}{2} + \chi \right) G^n - \left( \frac{1}{2} +\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have adde",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:365,reduce,reduce,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['reduce'],['reduce']
Energy Efficiency,"The `@hascuda` macro used to be necessary but with the addition of `CUDA.has_cuda()` I don't think it is anymore. So this PR finally gets rid of the `@hascuda` macro. It's been a source of errors for users, especially when using Oceananigans on clusters where some nodes have GPUs and others do not. So hopefully this PR will help reduce errors for users on clusters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1589:331,reduce,reduce,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1589,1,['reduce'],['reduce']
Energy Efficiency,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:272,energy,energy,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272,1,['energy'],['energy']
Energy Efficiency,"The basic munerics of oceananigans is the same as MITgcm: we use a scheme; which conserves tracer variance: e.g. D/Dt (T**2) = exactly 0 in the; absence of sources and sinks. This is ensured by just taking the average of; the T between adjacent boxes when one is computing the flux of T across the; cell face. This is true even in the vertical when del_z is not constant.; John. On Tue, Oct 22, 2019 at 1:41 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Is the idea that there is some kind of compromise with putting the u-points; > at the ""center"" of the u control volumes, versus putting the tracer; > points at the center of the tracer control volumes? I see that it is; > impossible to achieve both.; >; > In other words, certain assumptions about ""interpolation"" are baked into; > the interpolation operators (we do not do a true interpolation between the; > different grids for u, v, w, etc).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/491?email_source=notifications&email_token=AKXUEQRCTHJHAZRI5GKCT6TQP43NXA5CNFSM4JDC6IX2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEB6S3NQ#issuecomment-545074614>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSMDJBGJELHENZ6XVLQP43NXANCNFSM4JDC6IXQ>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-545300631:1472,Green,Green,1472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-545300631,1,['Green'],['Green']
Energy Efficiency,"The boundary condition functions should have the arguments `x, y, t, p` (no `z`!) so. ```julia; Qᵘ(x, y, t, p) = radius(x, y) < p.L ? imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; Qᵛ(x, y, t, p) = radius(x, y) < p.L ? - real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; ```. You may also want to tag functions with `@inline` and use `ifelse` rather than the shortcircuiting ternary `? :` for performance:. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline U(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = ifelse(d(x, y) < p.L, +imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = ifelse(d(x, y) < p.L, -real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; ```. Is `U` air speed? We sometimes recommend using the momentum flux itself as an input, rather than introducing a bulk formula (like a drag law) because this reduces the number of parameters in the problem (making it easier to understand and reproduce) --- but that's up to you. Here you could write. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline s(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, +imag(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, -real(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; ```. or something like that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300:983,reduce,reduces,983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300,1,['reduce'],['reduces']
Energy Efficiency,"The calls to `convert` here:. https://github.com/climate-machine/Oceananigans.jl/blob/40dbd96fd45a30867063c476b3eecbe13db1fb5c/src/grids.jl#L98. are unnecessary, because `convert` is called anyways due to the fact that the `eltype` of `RegularCartesianGrid` is specified a few lines below. We can reduce code noise by getting rid of them.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/285:297,reduce,reduce,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/285,1,['reduce'],['reduce']
Energy Efficiency,"The change is great!. Before merging, the code needs to be proofread to remove formatting inconsistencies. I may not have caught all of them, so I think it'd be good to look over every file individually. It may be more efficient in the future to issue search and replace in individual files, so the change sites can be inspected at that time (except in lucky cases where the replaced pattern has the same number of characters as the original one, like incompressible -> nonhydrostatic).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884797579:219,efficient,efficient,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884797579,1,['efficient'],['efficient']
Energy Efficiency,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:44,allocate,allocates,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803,3,"['allocate', 'reduce']","['allocate', 'allocates', 'reduce']"
Energy Efficiency,The default now it `Implicit` right? I think `SplitExplicit` will be more efficient. `Implicit` is done on only one GPU while split explicit takes advantage of all the workers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1998700298:74,efficient,efficient,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1998700298,1,['efficient'],['efficient']
Energy Efficiency,"The discussion about molecular viscosity being resolved/modeled physics is a deep one. Probably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:959,energy,energy,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802,1,['energy'],['energy']
Energy Efficiency,"The docs include a ""Model setup"" section which includes references and info about `Simulation`. I think we should have a separate section on `Simulation`, which includes an explanation of diagnostics, output writers, adaptive timestepping, and `run!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/946:217,adapt,adaptive,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/946,1,['adapt'],['adaptive']
Energy Efficiency,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:664,adapt,adaptive,664,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['adapt'],['adaptive']
Energy Efficiency,"The issue of calculating a thermally-wind-balanced background has popped up a couple times before (more recently [here](https://github.com/CliMA/Oceananigans.jl/issues/1826)) and I think it would be nice to have an example where `b` is computed from `u` for a general function. I myself don't know how to do that properly and efficiently (I think), so it would definitely be helpful for a larger audience I believe. @glwagner @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846:326,efficient,efficiently,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846,1,['efficient'],['efficiently']
Energy Efficiency,"The issue with the power method is that its convergence depends on the _difference_ between the two largest eigenvalues, and this can be really slow. Arnoldi iteration does a lot better, and gives you multiple eigenmodes. I think it should also be easy to add since most implementations (including ArnoldiMethod.jl, it looks like) are matrix-free. Directly calculating the full spectrum might be harder -- Dedalus can do this because it forms sparse matrices for the global linear operator, but I don't think oceananigans does this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731279135:19,power,power,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731279135,1,['power'],['power']
Energy Efficiency,"The issues with the `HydrostaticFreeSurfaceModel` are the tendency kernels. The difference with the non-hydrostatic model is that we do not know a priori which RHS function to call (for example CATKE has an `:e` tracer that requires a different RHS function and the same goes with a 1 equation parameterization of mesoscales that evolves an additional tracer equation for the mesoscale energy `:K`). Our solution now is to infer the RHS function and pass it as an argument to the kernel. Apparently, this prevents compilation. I ll come up with a solution today",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926:386,energy,energy,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926,1,['energy'],['energy']
Energy Efficiency,"The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Getting some of these values but I don't know what that would look like. Also, if you are not computing this field at every time step, the cost of computing it sepratelyl might not be that high, but that of course depends on the particular problem you are dealing with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025:135,efficient,efficient,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025,1,['efficient'],['efficient']
Energy Efficiency,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97:111,reduce,reduce,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97,4,"['power', 'reduce']","['powers', 'reduce', 'reduced']"
Energy Efficiency,The memory savings is a major advantage of this closure over `AnisotropicMinimumDissipation` for problems with very large numbers of tracers (eg biogeochemistry problems with 10+ tracers). Note also that there is overhead to launching a kernel which cannot be ignored --- we can't estimate computational cost just by adding the number of operations. Typically (though not always) our goal is to reduce the number of kernel launches as much as possible.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419789153:395,reduce,reduce,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419789153,1,['reduce'],['reduce']
Energy Efficiency,"The metrics across panels don't seem to be continuous for a `ConformalCubedSphereGrid`. They seem a bit iffy between non-trivial panel connections (e.g. East->North, etc). See, e.g., below. Panel 1 East -> Panel 2 West seems OK; Panel 2 West -> Panel 4 South the metrics don't seem to coincide. ```Julia; using Oceananigans; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 5, 5; H = 3. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, 1), z = (0, 1), horizontal_direction_halo = H). j_index = 2; i_index = Nx+1 - j_index. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(getregion(grid, 1).Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""panel 1""); lines!(ax, range_with_offset(Nx, H, 1), parent(getregion(grid, 2).Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""panel 2""); lines!(ax, range_with_offset(Ny, H, 2), parent(getregion(grid, 4).Δyᶜᶜᵃ)[i_index+H, :], linewidth=4, color = (:blue, 0.5), label=""panel 4""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); fig; save(""metrictest.png"", fig); ```. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9ed5be14-05b9-4f83-81f5-2d92def37ff5). (thanks to @simone-silvestri)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3254:809,green,green,809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3254,1,['green'],['green']
Energy Efficiency,"The notes look great! . One question though. In your definition for the reduced gravity, why not divide by $\rho_j$ instead of $\rho_{j+1}$, since that's what naturally apprears in the pressure graident term? I know that because the densities are almsot the same, it won't matter much, but it is not clear why you make this approximation when you don't need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348:72,reduce,reduced,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348,1,['reduce'],['reduced']
Energy Efficiency,"The only parts of the solver algorithm that require communication between nodes are `norm` and `dot`, right?. The ""matrix product"" --- a Poisson operator for us --- has unavoidable communication as well. But, we should be able to keep this limited in scope and we only need 1 halo. The trickier part where I think there is room for significant optimization is in the development of an effective multi-GPU preconditioner that is also efficient in parallel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386795222:433,efficient,efficient,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386795222,1,['efficient'],['efficient']
Energy Efficiency,"The problem is in the calculation of the linear operator. ```; @inline ∫ᶻ_Ax_∂x_ηᶠᶜᶜ(i, j, k, grid, ∫ᶻ_Axᶠᶜᶜ, η) = @inbounds ∫ᶻ_Axᶠᶜᶜ[i, j, k] * ∂xᶠᶜᶜ(i, j, k, grid, η); @inline ∫ᶻ_Ay_∂y_ηᶜᶠᶜ(i, j, k, grid, ∫ᶻ_Ayᶜᶠᶜ, η) = @inbounds ∫ᶻ_Ayᶜᶠᶜ[i, j, k] * ∂yᶜᶠᶜ(i, j, k, grid, η); ```. These functions are evaluated at `k = 1` because they are reduced fields, but in the example script at `k=1` there is an immersed boundary. Hence the conditional derivatives get triggered returning a 0 where there shouldn't be any. We need to have reduced fields with the correct location (in this case for the free surface the field is located at `grid.Nz`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899:340,reduce,reduced,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899,2,['reduce'],['reduced']
Energy Efficiency,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:58,reduce,reduced,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937,4,['reduce'],['reduced']
Energy Efficiency,"The problem is not with the reduction but with derivatives that act on reduced fields.; The reductions are not an issue, because by performing a reduction we know what operation leads us to a reduced field, so we can perform the reduction accordingly (for example we exclude immersed cells from reductions). . When performing a derivative we use all three indices regardless of the field being reduced or not. ; In this case we get a funky result where we are trying to evaluate a derivative at `k == 1` for a reduced field that does not necessarily live at `k == 1`. In other words, the assumption that the field lives at `k == 1` is wrong for a reduced field; the right solution, on the other hand, is not so clear cut:. If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708:71,reduce,reduced,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708,9,['reduce'],['reduced']
Energy Efficiency,"The problem is this iteration:. ```julia; [ Info: Iter: 32, time: 300 ms , u-avg: 2.5442761423093008, window_start_time: 0.28, window_start_iteration: 30, previous_collection_time: 0.3, fetch_operand: true, interval: 0.03, previous_interval_stop_time: 0.27, collecting: true; ```. We should have `collecting: false`. That means `end_of_window`. https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/OutputWriters/windowed_time_average.jl#L270. spuriously returns `false`. https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/OutputWriters/windowed_time_average.jl#L93. So we want to look at `model.clock.time` and `sch.previous_interval_stop_time + sch.interval`. It does seem probable the issue is roundoff error. Probably `AveragedTimeInterval` needs to be updated to align more with the (new) criteria currently being used for `TimeInterval` eg we need a similar criteria as used for `next_actuation_time`:. https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/Utils/schedules.jl#L56-L61. Would be helpful to have a test too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2264548157:1083,schedul,schedules,1083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2264548157,1,['schedul'],['schedules']
Energy Efficiency,There is no adapt method for the model. I don't know how it would play to send the whole model to the GPU. We might have some parameter space issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517,1,['adapt'],['adapt']
Energy Efficiency,"There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. The problem can be fixed by dispatching the main constructor for `Average` on `Union{Field, Computation}`. I am ok with this restriction of `Average`. However, it's worth noting that it's changes its capability. Previously, `Average` would work with anything that defines `parent` and `architecture`, including arbitrary user-defined types (this is why it works with `Computation`s, for example). With this change, it will only work with types that are specifically allowed by the constructor. Partly I think the underlying motivation for this PR could suggest we need to put a bit more effort into streamlining the user interface to `AbstractOperations` and `Computation`s. For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. We may also need to spend some more time refining the `Field` abstraction, and formalizing the connection between `Field`s and other similar objects like `Computation`s and `Average`s. In that case, we could define `Computation` as a subtype of `AbstractField`, and dispatch on `AbstractField` in the constructor for `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389:1031,allocate,allocated,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,There was some power interruption at MIT. Now it's fixed but probably someone has to go turn on Sverdrup (where the GPU tests run on).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364:15,power,power,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364,1,['power'],['power']
Energy Efficiency,"There's some info in CUDA docs but it doesn't explicitly answer my question:. > For small integer powers (e.g., x2 or x3), explicit multiplication is almost certainly faster than the use of general exponentiation routines such as pow(). While compiler optimization improvements continually seek to narrow this gap, explicit multiplication (or the use of an equivalent purpose-built inline function or macro) can have a significant advantage. This advantage is increased when several powers of the same base are needed (e.g., where both x2 and x5 are calculated in close proximity), as this aids the compiler in its common sub-expression elimination (CSE) optimization. So maybe we shouldn't square at all here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593:98,power,powers,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593,2,['power'],['powers']
Energy Efficiency,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:137,reduce,reduced,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['reduce'],['reduced']
Energy Efficiency,"These are exported types that got renamed: `EnergyConservingScheme` -> `EnergyConserving`, `EnstrophyConservingScheme` -> `EnstrophyConserving`,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367:44,Energy,EnergyConservingScheme,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367,2,['Energy'],"['EnergyConserving', 'EnergyConservingScheme']"
Energy Efficiency,"These are good points. I'll close the issue. I hope you don't mind if I use your comments in the documentation under the adaptive time-stepping section. I ended up finding other ways to transition to turbulence in a stable manner using `TimeStepWizard` as is, e.g. either increasing the CFL with time; ```julia; cfl(t) = min(0.005*t, 0.1); wizard.cfl = cfl(model.clock.time); ```; or changing the number of time steps between adaptive time steps with time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520902324:121,adapt,adaptive,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520902324,2,['adapt'],['adaptive']
Energy Efficiency,"These lines do not work for `ImmersedBoundaryGrid`. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/OutputWriters/netcdf_output_writer.jl#L391-L395. Changing the first line to; ```Julia; if model.grid isa AbstractRectilinearGrid || model.grid isa ImmersedBoundaryGrid{<:Any,<:Any,<:Any,<:Any,<:AbstractRectilinearGrid}; ```; temporarily fixed my problem. Here is the script that I use for testing this issue:; ```Julia; using Oceananigans. underlying_grid = RectilinearGrid(; size=(32, 32, 16),; x=(-3.0, 3.0), y=(-3.0, 3.0), z=(0.0, 1.0),; topology=(Periodic, Periodic, Bounded),; halo=(4, 4, 4),; ). hill(x::Real, y::Real) = 0.1 + 0.1 * exp(-x^2 - y^2). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill)). model = NonhydrostaticModel(;; grid,; advection = WENO(),; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_time = 100.0). fields = model.velocities. simulation.output_writers[:fields] = NetCDFOutputWriter(; model,; fields,; filename = ""output.nc"",; schedule = Oceananigans.TimeInterval(10.0),; ). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3069:1032,schedul,schedule,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3069,1,['schedul'],['schedule']
Energy Efficiency,"Thinking about this a bit more --- do we need to use `mapreduce` at all? Supposedly `mean` will take an iterator as an argument:. ```julia; help?> mean; search: mean mean! median median! SegmentationFault macroexpand @macroexpand @macroexpand1 Meta numerator enumerate timedwait promote_shape MethodSummary. mean(itr). Compute the mean of all elements in a collection.; ```. Does this mean we can use `AbstractOperations` directly in `mean` (if they iterate correctly?) . This may also provide a way to compute correct averages on-the-fly on stretched grids, combined with #1452 (which we haven't discussed yet). I might be missing something about specifically how we would use `mapreduce`. As a side note, if we do need to use `mapreduce`, we may want to use `Base.mapreducedim!` (which stores results in a previously allocated array, as I think we want).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1422#issuecomment-811595869:819,allocate,allocated,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422#issuecomment-811595869,1,['allocate'],['allocated']
Energy Efficiency,"Thinking about this a bit more, I think we can actually just define `IsotropicDiffusivity` and `AnisotropicDiffusivity`, and use dispatch to produce the appropriate behavior when the specific diffusivity is either a constant or a function. In other words, the user can write. ```julia; closure = IsotropicDiffusivity(κ = 1.0); ```. or. ```julia; closure = IsotropicDiffusivity(κ = (x, y, z, t) -> 1.0 * exp(z / 10)); ```. and correct behavior will result. Perhaps we should just assume the diffusivity is also a function of time for maximum generality. While we are mutilating the API, does it make sense to use a more verbose terminology than ""`κ`"" and ""`ν`""? We might instead use. ```julia; closure = IsotropicDiffusivity(tracers = 1.0, velocities = 2.0); ```. or something like that. This might not be a good idea, since it could actually reduce readability. Not sure. This is a major change to the API. However, we can ease the transition by providing the aliases `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` that reproduce previous behavior, if we want. @ali-ramadhan curious what you think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/781#issuecomment-652495375:842,reduce,reduce,842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/781#issuecomment-652495375,1,['reduce'],['reduce']
Energy Efficiency,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:345,adapt,adaptive,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,2,"['adapt', 'allocate']","['adaptive', 'allocated']"
Energy Efficiency,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/238:10,adapt,adapts,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238,1,['adapt'],['adapts']
Energy Efficiency,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:649,reduce,reduced,649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['reduce'],['reduced']
Energy Efficiency,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:710,Adapt,Adapt,710,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,1,['Adapt'],['Adapt']
Energy Efficiency,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704:8,adapt,adapts,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704,1,['adapt'],['adapts']
Energy Efficiency,This PR adapts the hydrostatic regression tests to be run in distributed mode. an important step in this direction is to allow array partitioning under the hood in `set!` if the array size coincides with the global size of the field (implemented here). a more important step is to remove the topology from the `Distributed` architecture (it should not know anything about topology which is a grid property),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328:8,adapt,adapts,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328,1,['adapt'],['adapts']
Energy Efficiency,"This PR addresses issue https://github.com/CliMA/Oceananigans.jl/issues/3670, focusing on a problem likely caused by floating-point errors; https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L91; Similar to https://github.com/CliMA/Oceananigans.jl/blob/a18b81d4c8776987d3cf619521941ba85000a1cb/src/Utils/schedules.jl#L58-L63; Implementing actuation time helps prevent floating-point errors, ensuring the correct execution of statements in; `advance_time_average!` https://github.com/CliMA/Oceananigans.jl/blob/56dbae31bb54c1293e12b6ccc88f77976cc1103f/src/OutputWriters/windowed_time_average.jl#L271-L335. There is still an issue for post-checkpoint when checkpoint interval is _not_ an integer multiple of the `AveragedTimeInterval`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717:383,schedul,schedules,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717,1,['schedul'],['schedules']
Energy Efficiency,"This PR adds `OneField` and `ConstantField` and generalizes `ZeroField` to be capable of producing zeros of any type. In particular it may be useful to use a `ZeroField(Bool)` since `false` is a ""strong"" zero. @simone-silvestri you may find `OneField` useful for estimating lengths efficiently, along with `ConditionalOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2171:282,efficient,efficiently,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2171,1,['efficient'],['efficiently']
Energy Efficiency,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:743,energy,energy,743,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['energy'],['energy']
Energy Efficiency,"This PR adds a new Coriolis implementation, a non-traditional β plane that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. This implementation is based off of section 5 of Dellar (2011). It conserves energy, angular momentum, and potential vorticity. Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional beta-plane equations from Hamilton's principle on a sphere. Journal of Fluid Mechanics, 674, 174-195. doi:[10.1017/S0022112010006464](https://doi.org/10.1017/S0022112010006464)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/899:282,energy,energy,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/899,1,['energy'],['energy']
Energy Efficiency,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:117,reduce,reduced,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,4,"['adapt', 'reduce']","['adaptive', 'reduced']"
Energy Efficiency,"This PR adds a new property `indices` to `Field`. By default `indices = (:, :, :)`. Using `UnitRange` for a dimension's indices will ""window"" a field in that direction. This permits diagnostics to be ""windowed"" for selected indices; for example a surface field might be computed with `indices = (:, :, grid.Nz:grid.Nz)`. Another important feature is the extension of `FieldTimeSeries` to ""sliced"" fields. This means we can save just the surface velocity fields (rather than the 3D velocity fields), and in post-processing compute the surface vorticity. This PR is still very much WIP, but hopefully will be fully featured by the time it's merged, and we'll convert free surface displacements from reduced fields to windowed fields. Closes #2177; Closes #1080; Closes #1647",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2246:697,reduce,reduced,697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2246,1,['reduce'],['reduced']
Energy Efficiency,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:19,schedul,schedule,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,5,['schedul'],"['schedule', 'schedules', 'scheduling']"
Energy Efficiency,"This PR adds a new turbulence closure called `HorizontalCurvilinearDiffusivity`, following section 2.15.7 in the MITgcm documentation:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. There it is stated that this closure. > conserves potential vorticity (thickness weighted relative vorticity) and divergence and dissipates energy, enstrophy and divergence squared. The same details are not given for tracer diffusion, so I left the tracer diffusivity at zero for now. @christophernhill please advise. I also needed to add a few operators. I'm not sure where to put them since we have both ""closure_operators.jl"" and ""viscous_dissipation_operators.jl"". It might make sense to clean this up a bit in this PR --- @ali-ramadhan let me know what you think. To do:. - [x] Tracer diffusion valid on curvilinear grids; - [x] Some clean up of `TurbulenceClosures` module; - [x] Unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1375:365,energy,energy,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1375,1,['energy'],['energy']
Energy Efficiency,"This PR adds an `AbstractReducedField` that subtypes `AbstractField`, as well as a concrete `ReducedField` that is the analogue of `Field`. Reduced dimensions are tagged as having `Nothing` locations, and three-dimensional indexing into reduced fields is managed. This PR also reorganizes the `Fields` submodule in light of the generalization of the concept of an `AbstractField`. Resolves #525",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/920:93,Reduce,ReducedField,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/920,3,"['Reduce', 'reduce']","['Reduced', 'ReducedField', 'reduced']"
Energy Efficiency,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1998:1112,reduce,reduce,1112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998,1,['reduce'],['reduce']
Energy Efficiency,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602:1224,energy,energy,1224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602,1,['energy'],['energy']
Energy Efficiency,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1371:644,adapt,adapt,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371,1,['adapt'],['adapt']
Energy Efficiency,"This PR adds docstrings for all exported functions (i.e. functions that will be part of the public API) so users can actually look up what functions do. In the next PR I will make sure all the necessary docstrings get compiled to documentation. I followed the guidelines on https://docs.julialang.org/en/v1.0.2/manual/documentation/ and limited docstrings to 92 character lines. I ended up documenting abstract types because although they aren't exported, they show up in the docstrings of many functions, so it's reasonable to expect that users may want to look them up. One thing I noticed is how often we use this pattern where we define extra constructors like; ```julia; thing(T=Float64; kwargs) = thing{T}(kwargs); ```; when it seems like we should just be using `thing{T}(kwargs)` which will help declutter the public user API a bit. I also noticed that using the prefix `Abstract` for all abstract types may reduce code readability (and isn't followed in Julia Base: see the abstract types `AbstractFloat`, `Number`, `Real`). So we might have to judge a little bit: `AbstractGrid` is probably a good idea but `AbstractBoundaryConditionType` is going a little far and `AbstractTensorDiffusivity` seems a little verbose. Not sure of the best guideline to stick to. Some things that still need to be done:; 1. Not sure of the proper citation(s) to use for `DeardorffSmagorinsky`. @glwagner; 2. Will wait for PR #409 before I write docstrings for `fields.jl`.; 3. While not part of the public user API, I'll write docstrings for the time stepping kernels as I think they'll prove to be valuable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/410:916,reduce,reduce,916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410,1,['reduce'],['reduce']
Energy Efficiency,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1611:516,allocate,allocate,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611,3,"['allocate', 'efficient', 'reduce']","['allocate', 'efficient', 'reduced']"
Energy Efficiency,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767:1210,Green,Green,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767,1,['Green'],['Green']
Energy Efficiency,"This PR associates the GPU architecture with a specific device. This helps make the device that a model / grid is located on more explicit, so we don't have to ""infer"" the device based on where a particular piece of memory is allocated. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2629:226,allocate,allocated,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2629,1,['allocate'],['allocated']
Energy Efficiency,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2538:824,efficient,efficient,824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538,3,"['efficient', 'reduce']","['efficient', 'reduces']"
Energy Efficiency,This PR changes the surface displacement in `HydrostaticFreeSurfaceModel` to a `ReducedField` rather than full `Field`. cc @christophernhill,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1540:80,Reduce,ReducedField,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1540,1,['Reduce'],['ReducedField']
Energy Efficiency,This PR contains some improvements that allow better scaling on multiple devices. . In particular:; - Splitting the interior active cell map into `west` `east` `north` `south` and `interior` to allow for overlapping communication and computations with _active_ cells.; - Advancements for the `SplitExplicitFreeSurface` to reduce kernel launch latency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3404:322,reduce,reduce,322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3404,1,['reduce'],['reduce']
Energy Efficiency,"This PR contributes a barotropic instability example co-authored with @navidcy . The main contribution of this example is to illustrate how to use Oceananigans to calculate instability growth rates using the ""power"" method. The example illustrates some of the strengths of Oceananigans' flexibility (and also some weaknesses that we might improve on). Ways to make the example more interesting are definitely welcome too! It's also a bit expensive right now, so we'll probably want to find ways to reduce its computational cost.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1122:209,power,power,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1122,4,"['power', 'reduce']","['power', 'reduce']"
Energy Efficiency,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048:342,energy,energy,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048,3,['energy'],['energy']
Energy Efficiency,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1807:16,schedul,schedule,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807,5,['schedul'],['schedule']
Energy Efficiency,"This PR does some minor refactoring to reduce code length. It also introduces an `AdamsBashforthTimestepper` type which will be useful in the future if new timesteppers are implemented. @ali-ramadhan, can you check to see that GPU tests pass? I had some trouble on my local machine.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325:39,reduce,reduce,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325,1,['reduce'],['reduce']
Energy Efficiency,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:384,reduce,reduce,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,1,['reduce'],['reduce']
Energy Efficiency,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:375,schedul,scheduled,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['schedul'],['scheduled']
Energy Efficiency,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628:174,allocate,allocates,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628,1,['allocate'],['allocates']
Energy Efficiency,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413:187,adapt,adapt,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413,1,['adapt'],['adapt']
Energy Efficiency,"This PR generalizes file splitting for `JLD2OutputWriter`, replacing `max_filesize` with a `file_splitting` keyword argument. To implement a maximum filesize we use. ```julia; JLD2OutputWriter(model, outputs; file_splitting=FileSizeLimit(max_filesize), ...); ```. This feature should also be extended to `NetCDFOutputWriter` in this PR -- hopefully @josuemtzmo can help!. This PR will enable `TimeInterval` (or any other schedule --- `IterationInterval`, `WallTimeInterval`) to be used for splitting output files. Closes #2967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515:421,schedul,schedule,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515,1,['schedul'],['schedule']
Energy Efficiency,"This PR generalizes the broadcasting implementation to work with fields reduced in any direction. The changes mean that, for example, if broadcasting to a field that's reduced in _two_ directions (eg a 1D field on a 3D grid), the kernel that's launched to do the computation will be 1D and therefore will not ""waste"" computation. It also turns out that the ""generalization"" requires less code than the original implementation (doh). This PR also adds more tests for broadcasting to reduced fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2157:72,reduce,reduced,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2157,3,['reduce'],['reduced']
Energy Efficiency,"This PR homogenizes the interface for initializing things: models, simulations, callbacks, schedules. It also makes it so `SpecifiedTimes` schedules do not actuate at iteration 0 unless time=0 is contained in the schedule. Closes #2719",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015:91,schedul,schedules,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015,3,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"This PR implements `Callback`, designed to be used with `Simulation`. Illustration:. ```julia; using Oceananigans. model = NonhydrostaticModel(grid = RegularRectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)),; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; buoyancy = nothing,; tracers = nothing). set!(model, u = (x, y, z) -> randn(), v = (x, y, z) -> randn()). simulation = Simulation(model, Δt=0.01, stop_iteration=100). print_progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(sim.model.clock.time)""; simulation.callbacks[:progress] = Callback(print_progress, schedule=IterationInterval(10)). run!(simulation); ```. we get. ```julia; julia> run!(simulation); [ Info: Iteration: 0, time: 0.0; [ Info: Iteration: 10, time: 0.09999999999999999; [ Info: Iteration: 20, time: 0.19999999999999984; [ Info: Iteration: 30, time: 0.30000000000000004; [ Info: Iteration: 40, time: 0.4000000000000007; [ Info: Iteration: 50, time: 0.5000000000000013; [ Info: Iteration: 60, time: 0.6000000000000003; [ Info: Iteration: 70, time: 0.6999999999999993; [ Info: Iteration: 80, time: 0.7999999999999983; [ Info: Iteration: 90, time: 0.8999999999999972; [ Info: Iteration: 100, time: 0.9999999999999962; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; ```. We also support passing an iterable of callbacks to `run!`:. ```julia; progress_callback = Callback(print_progress, schedule=IterationInterval(10)); run!(simulation, callbacks=[progress_callback]); ```. just in case someone wants to do that... I think we could also redesign `TimeStepWizard` to be a special kind of `Callback`, and nuke the `progress` property. What do others think? Are they ok with this big change to the API?. cc @navidcy @ali-ramadhan @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894:642,schedul,schedule,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894,2,['schedul'],['schedule']
Energy Efficiency,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2100:25,schedul,schedule,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100,8,['schedul'],['schedule']
Energy Efficiency,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945:435,reduce,reduces,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945,2,['reduce'],"['reduce', 'reduces']"
Energy Efficiency,"This PR implements a two-equation turbulent closure, which evolve turbulent kinetic energy and an additional ""scale variable"". Here we choose the scale variable dissipation; another name for this two-equation model is ""k-epsilon"". In Oceananigans it will be called the `TKEDissipationVerticalDiffusivity`. This PR is a WIP; we still have to implement the stability functions and, perhaps more importantly, figure out how to make time-stepping stable. . Closes #2278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3509:84,energy,energy,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3509,1,['energy'],['energy']
Energy Efficiency,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:777,energy,energy,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['energy'],['energy']
Energy Efficiency,"This PR implements two advancements for CATKE. First is a reformulation of the shear production term. Previously this was computed using the velocity field at time-step `n` in the TKE tendency, like all other terms in the velocity and tracer explicit tendencies. However, [Burchard (2002)](https://www.sciencedirect.com/science/article/pii/S1463500302000094?casa_token=3cKiqlICvN8AAAAA:Hg3iGP-1q_UYh2We7maQRb9z9F5blbp8lHiH61T_Gep7y0DG8VYVRWwGvzvCDlbD2iANNHbLp4g) argue that the shear production term should be formulated to _exactly_ conserve total kinetic energy, which means that it's form actually depends on the time-stepping scheme being used. In our case, temporally-discrete shear production requires using the velocity field at time step `n` and `n+1`. To implement this scheme we have to add some features to the time stepping routine. In particular we have to allow closures to tell `HydrostaticFreeSurfaceModel` not to step forward certain tracers. Next, we step forward the TKE within `compute_diffusivities!`. Second, this PR also implements split-explicit substepping for CATKE's TKE. It seems that this is required because even though the new shear production discretization dramatically stabilizes CATKE (allowing long time-steps stably), it does not render CATKE's solutions completely insensitive to the time-step. So, for _accuracy_ (and performance) purposes, we are motivated to also add the capability to advance the TKE on a short time-step while the velocities and tracers advance on a slower time-step. This only matters for high vertical resolutions and very strong forcing. But when you do global simulations, there is strong forcing somewhere on the Earth, and we probably want to represented it accurately... More documentation to come.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3585:557,energy,energy,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3585,1,['energy'],['energy']
Energy Efficiency,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910:435,reduce,reduce,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910,1,['reduce'],['reduce']
Energy Efficiency,"This PR introduces a new ""Matrix based"" implicit solver `Oceananigans/Solvers/matrix_iterative_solver` that uses the package IterativeSolvers.jl to solve a linear system of equation based on a sparse matrix formulation. This has a couple of advantages in terms of performance; - there is no need to `fill_halo_regions!` on the residuals while iterating; - it is possible to implement efficient preconditioning techniques. the `MatrixIterativeSolver` accepts a tuple of coefficients `Ax, Ay, Az, C, D` as inputs and creates the associated matrix to solve the following ; <img src=""https://render.githubusercontent.com/render/math?math=Ax_{i%2B 1jk} \eta_{i%2B 1jk} %2B Ax_{ijk} \eta_{i-1jk} %2B Ay_{ij%2B 1k} \eta_{ij%2B 1k} %2B Ay_{ijk} \eta_{ij-1k} %2B Az_{ijk%2B 1} \eta_{ijk%2B 1} %2B Az_{ijk} \eta_{ijk-1} - 2 (Ax_{i%2B 1jk} %2B Ax_{ijk} %2B Ay_{ij%2B 1k} %2B Ay_{ijk} %2B Az_{ijk%2B 1} %2B Az_{ijk} ) \eta_{ijk} %2B ( C_{ijk} %2B D_{ijk} /\Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an exa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:384,efficient,efficient,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['efficient'],['efficient']
Energy Efficiency,"This PR introduces an `AveragedField` type. The intent is that this field will eventually replace `Average`. Before that occurs, we need to overhaul both output writers, but especially the NetCDFOutputWriter, so that they can properly slice all types of fields. An `AveragedField` is constructed with the syntax (for example). ```julia; avg = AveragedField(operand; dims=(1, 2)); ```. where `operand` is the object being averaged (which should also be a field), and `dims` are the dimensions over which the field is reduced. There is an optional argument `data` which would be an `OffsetArray` of the correct size which avoids extra memory allocation. We also overload `Statistics.mean`, so that the above code can be written. ```julia; avg = mean(operand; dims=(1, 2)); ```. When we have `ComputedField`s, `operand` can involve `AbstractOperations`. This will come in a future PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/930:516,reduce,reduced,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930,1,['reduce'],['reduced']
Energy Efficiency,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727:391,reduce,reduced,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727,1,['reduce'],['reduced']
Energy Efficiency,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214:769,reduce,reduced,769,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214,1,['reduce'],['reduced']
Energy Efficiency,"This PR makes `node` and `nodes` return the native coordinates of the grid. It changes the behavior of `x/ynode(s)`. Now `x/ynode(s)` _always_ returns `x/y` distances. The PR also introduces `λ/φnode(s)` for curvilinear grids. This way, now `node(s)` behaviour didn't change. But now they return:. - `(xnode(s), ynode(s), znode(s))` for RectilinearGrid; - `(λnode(s), φnode(s), znode(s))` for CurvilinearGrids. Note that still there are `x/y/znode(s)` methods _for all grids_ and those methods actually return distances (in meters). Before this PR when `ynode` called on, e.g., a LatitudeLongitude grid would return latitude in degrees and this was tad confusing. Closes #2978",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2979:524,meter,meters,524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2979,1,['meter'],['meters']
Energy Efficiency,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [ ] Tests that allocating reductions of abstract operations work (`maximum(a * b)`, etc); - [ ] Test that allocating reductions are correct (eg they only reduce over the interior of an array); - [ ] Benchmark?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2039:353,reduce,reduce,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2039,1,['reduce'],['reduce']
Energy Efficiency,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2040:639,reduce,reduce,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040,1,['reduce'],['reduce']
Energy Efficiency,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1859:549,reduce,reduces,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859,3,"['Reduce', 'reduce']","['ReducedField', 'reduces']"
Energy Efficiency,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2597:1387,reduce,reduces,1387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597,3,['reduce'],['reduces']
Energy Efficiency,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:844,efficient,efficiently,844,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,1,['efficient'],['efficiently']
Energy Efficiency,"This PR modifies `TimeInterval` so that, rather than keeping track of the `previous_actuation_time`, it keeps track of the `first_actuation_time` plus the number of `actuations` (including the initial actuation). The next actuation time is then computed by . ```julia; function next_actuation_time(schedule::TimeInterval); t₀ = schedule.first_actuation_time; N = schedule.actuations; T = schedule.interval; return = t₀ + N * T; end; ```. Note we use `N` instead of `N+1` because the first actuation occurs at `t₀`. So for example, after this first actuation the next actuation time is `t₀ + T`. This may address #3056.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3616:298,schedul,schedule,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616,4,['schedul'],['schedule']
Energy Efficiency,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:751,Adapt,Adaptive,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,3,"['Adapt', 'adapt', 'schedul']","['Adaptive', 'adaptive', 'schedule']"
Energy Efficiency,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:60,schedul,scheduling,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,4,['schedul'],"['schedule', 'scheduled', 'scheduling']"
Energy Efficiency,"This PR removes argument splatting in intermediate functions that are called to compute the hydrostatic free surface tendencies. Argument splatting was removed in a prior PR (that'd be great if someone can remember), but was reinstated in #3360. This PR re-removes splatting. It yields a 2x performance gain for a column model:. # `main`. ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.398369 seconds (727.30 k allocations: 706.103 MiB, 30.55% gc time); ```. # This PR; ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.214935 seconds (258.50 k allocations: 195.374 MiB, 10.57% gc time); ```. It also reduces memory allocation. . Note that the nonhydrostatic model was not changed (it does not splat).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477:1538,reduce,reduces,1538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477,1,['reduce'],['reduces']
Energy Efficiency,"This PR removes the adapting of the immersed map from the immersed boundary grid by shuffling some definitions around and making sure that the active cells map is always passed as an argument instead of being embedded in the grid. This can possibly help with parameter space issues in complex kernels (see [ClimaOcean, Issue#116](https://github.com/CliMA/ClimaOcean.jl/issues/116#issuecomment-2273878888)). . This PR is still a draft because I would like to take the opportunity to add some docstring for the immersed map",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3690:20,adapt,adapting,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690,1,['adapt'],['adapting']
Energy Efficiency,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:661,Adapt,Adapt,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Adapt'],['Adapt']
Energy Efficiency,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:131,efficient,efficiently,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,3,"['allocate', 'efficient']","['allocates', 'efficient', 'efficiently']"
Energy Efficiency,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2121:96,Reduce,ReducedField,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121,4,"['Reduce', 'reduce']","['ReducedField', 'reduce', 'reduced']"
Energy Efficiency,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3596:600,efficient,efficient,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596,1,['efficient'],['efficient']
Energy Efficiency,"This PR tweaks `initialize_simulation!` so that the schedules get called when `iteration == 0` --- in addition to running diagnostics, executing callbacks, and writing output. This is a tiny step in the direction of having a robust initialization procedure. I think we still need to work on the abstractions a bit though, since it'd be nice to initialize schedules / callbacks more explicitly rather than implicitly relying on `iteration == 0`. This change will affect `SpecifiedTimes` and `WallTimeInterval` the most, I think. TODO:. - [ ] Test for initialization of `SpecifiedTimes`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2268:52,schedul,schedules,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268,2,['schedul'],['schedules']
Energy Efficiency,"This PR tweaks the initialization procedure for `run!` so that schedules are initialized separately from the execution of callbacks and output writers at `iteration == 0`. This allows simulations that start from iterations other than `0` to execute correctly. It also re-defines the meaning of ""actuations"" for `TimeInterval` to be more sensible. Previously the actual number of actuations was `actuations - 1` which is confusing. There are still some issues with initialization. However I think this PR helps to clarify the distinction between ""initialization"", which occurs whenever we call `run!`, vs the thing we do at ""iteration 0"", like writing output. Resolves #3657",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3660:63,schedul,schedules,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3660,1,['schedul'],['schedules']
Energy Efficiency,"This PR updates the Langmuir turbulence example to have an initial mixed layer 33 meters deep. This initial mixed layer was prescribed by [McWilliams et al. (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38), which escaped me when I first read that paper. Thanks to @qingli411 for alerting me to this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1129:82,meter,meters,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1129,1,['meter'],['meters']
Energy Efficiency,"This PR was created yesterday to start a discussion about how we might want to change the input arguments for `VerticallyStetchedRectilinearGrid`. After some disucssion there is no concensus that a chance should be made so I'm going to close this PR. . I think it's better that users get to play with stretched grids in any or all dimensions sooner rather than later. Hence, I'm going to return to #1532 and change the arguments to be inline with what `VerticallyStretchedRectilinearGrid`. . One change that I would like to make is instead of having `zF` as input, I would prefer to have `zFs` or even `zFaces`, to emphasize that all the faces are specified. Usually, when I see `zF` I think of a face, and that's not the case here. @tomchor , what do you think about this?. When users have played with grid stretching we will be better able to asses from experience what is good for the user, and we will be able to adapt to that in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518:917,adapt,adapt,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518,1,['adapt'],['adapt']
Energy Efficiency,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:20,Adapt,Adapt,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,3,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Energy Efficiency,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664:216,energy,energy,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664,2,['energy'],['energy']
Energy Efficiency,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242:436,reduce,reduce,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242,1,['reduce'],['reduce']
Energy Efficiency,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:972,schedul,schedule,972,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['schedul'],['schedule']
Energy Efficiency,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865:59,reduce,reduced,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865,1,['reduce'],['reduced']
Energy Efficiency,"This fleshes out the `ReducedField` implementation a bit more by adding `boundary_conditions`. The `DefaultBoundaryCondition` for a reduced dimension is `nothing`. . This PR also generalizes our `launch!` utility so that kernel layouts can be ""flattened"" along reduced dimensions. It feels like there's a lot of boilerplate in our halo-filling functionality, but I'm not 100% sure how to mitigate (except with some hacky code generation which, we already have some of, and doesn't seem like the right solution). I also took the liberty to generalize halo filling for `Value` and `Gradient` halos while I was in the files (slight scope creep) so that simple `Value`/`Gradient` boundary conditions can be implemented that don't require the `clock, model_fields` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1350:22,Reduce,ReducedField,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1350,3,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,"This happens after a number of time steps; ```julia; CUFFTError(code 2, cuFFT failed to allocate GPU or CPU memory). Stacktrace:; [1] macro expansion at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/error.jl:59 [inlined]; [2] _mkplan(::UInt8, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/wrappers.jl:27; [3] plan_fft! at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/highlevel.jl:10 [inlined]; [4] fft! at /home/gridsan/aramadhan/.julia/packages/AbstractFFTs/7WCaR/src/definitions.jl:51 [inlined]; [5] solve_poisson_3d_ppn_gpu!(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32}, ::CellField{CuArray{Complex{Float64},3}}, ::CellField{CuArray{Complex{Float64},3}}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Complex{Float64},3}, ::CuArray{Complex{Float64},3}) at /home/gridsan/aramadhan/Oceananigans.jl/src/spectral_solvers.jl:426; [6] time_step_kernel!(::Model, ::Int64, ::Int64) at /home/gridsan/aramadhan/Oceananigans.jl/src/time_steppers.jl:375; [7] deep_convection_3d_gpu() at /home/gridsan/aramadhan/Oceananigans.jl/examples/deep_convection_3d_gpu.jl:17; [8] top-level scope at In[5]:1; ```. Or if you just save output to disk every ~10 time steps, the garbage collector has a chance to catch up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/68:88,allocate,allocate,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/68,1,['allocate'],['allocate']
Energy Efficiency,"This illustrates the bug (slightly overpowered, because I was trying to figure out what's going wrong):. ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size=3, halo=3, z=(0, 1), topology=(Flat, Flat, Bounded)). c_bottom_bc = ValueBoundaryCondition(1); c_bcs = FieldBoundaryConditions(bottom=c_bottom_bc); closure = ScalarDiffusivity(κ=1). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = :c,; buoyancy = nothing,; boundary_conditions=(; c=c_bcs)). simulation = Simulation(model, Δt=1e-2, stop_iteration=100). filename = ""simple_tracer_output_test.jld2""; simulation.output_writers[:c] = JLD2OutputWriter(model, model.tracers; filename,; schedule = IterationInterval(1),; overwrite_existing = true,; with_halos = true). # Evaluate c on boundary; using Oceananigans.Operators: ℑzᵃᵃᶠ. function show_boundary_c(sim); c = sim.model.tracers.c; cb = ℑzᵃᵃᶠ(1, 1, 1, grid, c); @info string(""Iter: "", iteration(sim), "", c(z=0): "", cb); return nothing; end. simulation.callbacks[:show] = Callback(show_boundary_c). run!(simulation). ct = FieldTimeSeries(filename, ""c""). t = ct.times; grid = ct.grid; Nt = length(t); cb = zeros(Nt); for n = 1:Nt; cn = ct[n]; cb[n] = ℑzᵃᵃᶠ(1, 1, 1, grid, cn); end. fig = Figure(); ax = Axis(fig[1, 1], xlabel=""Iteration"", ylabel=""c""); lines!(ax, ct[1, 1, 0, :], label=""c[0]""); lines!(ax, cb, label=""c(z=0)""); lines!(ax, ct[1, 1, 1, :], label=""c[1]""); axislegend(ax); display(fig); ```. giving. <img width=""396"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/f9d97246-0cc1-4185-a346-590a0f7357f1"">. yellow is `c` interpolated to the boundary --- which should be 1 always (as the `show_boundary_c` illustrates is true online). the blue is the halo value, which should not be 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689894462:672,schedul,schedule,672,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689894462,1,['schedul'],['schedule']
Energy Efficiency,This is a lot more sustainable than adding new properties to every output writer every time we want to support splitting a file by a different criterion. It's a decent change to the user interface. I can help if you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454:19,sustainab,sustainable,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454,1,['sustainab'],['sustainable']
Energy Efficiency,"This is a small nicety for friendliness^TM. For safety^TM we throw a warning if we reshaped. Just in case it wasn't intended. This allows things like. ```julia; julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1)); 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> c = Field{Nothing, Nothing, Center}(grid); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand(4)); ┌ Warning: Reshaped 4-element Vector{Float64} to set! its data to; │ 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:86; 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.172696, min=0.00231136, mean=0.0906944; ```. which is nice when working with 1D data.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3535:589,reduce,reduced,589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3535,3,['reduce'],['reduced']
Energy Efficiency,"This is a temporary fix for #1280 (time stepping a model with `pickup=true` -> it blows up) until schedules can be probably checkpointed. While this is a temporary fix, it has affected a number of people already (@qwert2266, @suyashbire1, @sandreza, and now @sam12396 in #1300) so would be good to merge this and tag a new release.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1303:98,schedul,schedules,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303,1,['schedul'],['schedules']
Energy Efficiency,"This is about more than just defining inuitive behavior, though. Executing a callback at iteration 0 might be considered a feature. However, I think that sometimes it's not desired. In reality, what we are missing is the concept of callback ""initialization"" (we are also missing the concept of callback ""finalization""). Right now, we use the hack that ""calling at iteration 0"" is tantamount to initialization. I think we should discuss how to generalize our design to something more sustainable...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233490967:483,sustainab,sustainable,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233490967,1,['sustainab'],['sustainable']
Energy Efficiency,"This is an API change but it won't reduce source code. For `(1, 2)` (eg `HorizonalDirections()`) we use [a scheme from MITgcm](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation) with special conservation properties (eg conserves potential vorticity), whereas for `(1, 2, 3)` we use the standard 3D isotropic formulation in terms of the strain tensor. Each case `1`, `2`, `3` has to be written out because our code isn't written to be ""n-dimensional""; instead we write out `x, y, z` explicitly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2265#issuecomment-1047303258:35,reduce,reduce,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2265#issuecomment-1047303258,1,['reduce'],['reduce']
Energy Efficiency,"This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this:; lambda=1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0)));; end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016:488,meter,meters,488,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016,1,['meter'],['meters']
Energy Efficiency,"This is interesting. I like the concept of reusing the `scheme` kwarg. But I think this isn't sustainable given the future planned changes to the advection scheme API, right? Ie an ""advection scheme"" is going to be more comprehensive. Also, it doesn't make sense unless we are using vector invariant. Another possibility is to add another kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1240862371:94,sustainab,sustainable,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1240862371,1,['sustainab'],['sustainable']
Energy Efficiency,"This is probably fine as I don't think the MITgcm uses adaptive time stepping and for what we do I doubt we'll be changing Δt halfway through a simulation, but as it stands if Δt changes it will break some code, `read_output(...)` methods in particular.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37:55,adapt,adaptive,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37,1,['adapt'],['adaptive']
Energy Efficiency,This is the latest attempt to preserve locations when adapting `Field` to the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1906:54,adapt,adapting,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906,1,['adapt'],['adapting']
Energy Efficiency,"This issue appears to have magically disappeared on 0.71.6 and with Julia 1.6.5:. ```julia; gregorywagner:examples/ (glw/indices✗) $ julia --project [7:02:02]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(64, 64), extent=(1, 1), topology=(Periodic, Periodic, Flat));. julia> c = CenterField(grid); averaged_c = Field(Average(c, dims=1)); 1×64×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 64, 1); ├── grid: 64×64×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 1×1×0 halo; ├── operand: mean! over dims (1,) of 64×64×1 Field{Center, Center, Center} on RectilinearGrid on CPU; └── status: time=0.0. julia> @time compute!(c); 0.000297 seconds (1.08 k allocations: 103.719 KiB, 78.90% compilation time). julia> @time compute!(c); 0.000005 seconds; ```. I'm also not sure why the timings previously were so slow. It's more appropriate now:. ```julia; julia> using Statistics. julia> a = rand(64, 64);. julia> @time mean(a, dims=1); 0.297254 seconds (781.27 k allocations: 44.972 MiB, 5.28% gc time, 99.97% compilation time); 1×64 Matrix{Float64}:; 0.516131 0.572081 0.497259 0.422505 0.505043 0.453625 … 0.511134 0.52023 0.443803 0.503798 0.497578 0.501285. julia> @time mean(a, dims=1); 0.000014 seconds (7 allocations: 1.203 KiB); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534:711,reduce,reduced,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534,1,['reduce'],['reduced']
Energy Efficiency,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:110,reduce,reduce,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107,1,['reduce'],['reduce']
Energy Efficiency,"This issue is cropping up now that we regularly timeout on Travis (max runtime is 50 minutes) and we almost always time out on GitLab GPU CI (max runtime is 60 minutes, @maleadt might be able to increase that but it's a shared resource and we probably shouldn't be hogging it up). Surprisingly Appveyor is always fast now. I think free CI servers are just generally underpowered. We definitely want to keep our tests and make them even more comprehensive so here are some ideas we can discuss (probably in January):; 1. See if we can move Travis CI pipelines onto Azure DevOps. They seem to give out more runtime (up to 360 minutes I think) although they might always reduce that in the future if they get more users. CliMA and @simonbyrne seem to be having a good experience with Azure.; 2. Split tests into a fast smaller test set (regression only?) and the full comprehensive test set. But we still need a place to run the comprehensive test set (maybe Azure runs the comprehensive tests?). We'll probably have to do this at some point.; 3. Split up the tests into jobs that run in <50 minutes each. You can have unlimited jobs on Travis. But this feels like a lot of work to set up and the tests would still take long as you can't have that many parallel builds. We'll have to test Oceananigans + MPI pretty soon but we can worry about that later. Slurm CI or setting something up with our 4xTitan V server might be a good option here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566810671:668,reduce,reduce,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566810671,1,['reduce'],['reduce']
Energy Efficiency,This kind of error arises when using the environment on the branch `integrate-turbulence-closures`:. ```juliarepl; (Oceananigans) pkg> st; Project Oceananigans v0.5.4; Status `/archive1/glwagner/Projects/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v0.4.2; [c5f51814] CUDAdrv v3.0.1; [be33ccc6] CUDAnative v2.1.1; [3a865a2d] CuArrays v1.0.2; [7a1cc6ca] FFTW v0.2.4; [ba82f77b] GPUifyLoops v0.2.3; [4138dd39] JLD v0.9.1; [30363a11] NetCDF v0.7.3; [90137ffa] StaticArrays v0.10.3; [a759f4b9] TimerOutputs v0.5.0; [8ba89e20] Distributed ; [37e2e46d] LinearAlgebra ; [de0858da] Printf ; [9a3f8284] Random ; [10745b16] Statistics ; [8dfed614] Test ; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250:246,Adapt,Adapt,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250,1,['Adapt'],['Adapt']
Energy Efficiency,"This looks like a symptom of a larger problem and, indeed, does not seem to be tested. ; I think to solve it we should fix the time-indexing of reduced FTS. We seem to be missing the 4D indexing of reduced FTS:; ```julia; @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, j, 1, memory_index(f, n)); @propagate_inbounds getindex(f::XZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, 1, k, memory_index(f, n)); @propagate_inbounds getindex(f::YZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, 1, j, k, memory_index(f, n)); ```; to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L108). and the 2D-Time indexing of reduced FTS; ```julia ; @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, time_index::Time) = getindex(f, i, j, 1, time_index); @propagate_inbounds getindex(f::XZFTS, i::Int, k::Int, time_index::Time) = getindex(f, i, 1, k, time_index); @propagate_inbounds getindex(f::YZFTS, j::Int, k::Int, time_index::Time) = getindex(f, 1, j, k, time_index); ```; maybe to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L116). and all the respective methods for 1D and 0D FTS.; In theory, the boundary conditions should work as intended. Indeed, we should add a test for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251176411:144,reduce,reduced,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251176411,3,['reduce'],['reduced']
Energy Efficiency,"This may be a caveat about attempting to solve fluids problems with single precision. For example [these authors](https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.036315) report issues running two-dimensional turbulence simulations at single precision. You may ameliorate issues with round-off error and finite precision by perhaps using a different (non-)dimensionalization of the equations of motion, parameters, and initial conditions. I'm not sure that avenue is worth investigating, however --- it's up to the user. I think you can be reasonably sure that if a calculation is correct in double precision, then the algorithm is correct at single precision as well. Round-off errors will become a problem *at some point* as you reduce the precision of your calculation, no matter what.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/55#issuecomment-465308737:740,reduce,reduce,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/55#issuecomment-465308737,1,['reduce'],['reduce']
Energy Efficiency,This may help https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178:42,Adapt,Adapt,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178,1,['Adapt'],['Adapt']
Energy Efficiency,"This now spits out; ```julia; julia> grid = RectilinearGrid(size = (16, 2, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×2×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.5; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid, advection = WENO());; [ Info: User-defined advection scheme WENO reconstruction order 5 reduced to WENO reconstruction order 3 in the y-direction to comply with grid-size limitations.; ┌ Warning: Inflating model grid halo size to (3, 2, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/development/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:250. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid, advection = WENO());; [ Info: User-defined advection scheme WENO reconstruction order 5 reduced to Nothing in the y-direction to comply with grid-size limitations.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310743910:578,reduce,reduced,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310743910,2,['reduce'],['reduced']
Energy Efficiency,"This paper describes a ""cell merging"" technique that can help reduce problems with very small cells: https://journals.ametsoc.org/view/journals/mwre/138/10/2010mwr3252.1.xml?tab_body=abstract-display. There are also some citations in there about an alternative method that they call the ""thin wall"" method.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1595648745:62,reduce,reduce,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1595648745,1,['reduce'],['reduce']
Energy Efficiency,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3409:52,Adapt,Adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409,1,['Adapt'],['Adapt']
Energy Efficiency,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287:52,Adapt,Adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287,1,['Adapt'],['Adapt']
Energy Efficiency,This script:. https://github.com/glwagner/ColumnModelOptimizationProject/blob/master/les/simple_flux.jl. shows how to use the JLD2OutputWriter to calculate horizontal averages efficiently on the GPU. edit: I missed your point about not including the halos.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519589331:176,efficient,efficiently,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519589331,1,['efficient'],['efficiently']
Energy Efficiency,This should help us figure out how to write efficient forcing functions. Important as they're used by the Europa and seasonal cycle simulations to implement relaxation terms at the boundaries. X-ref: #365,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/370:44,efficient,efficient,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/370,1,['efficient'],['efficient']
Energy Efficiency,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1076:19,reduce,reduced,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733:874,efficient,efficiently,874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733,1,['efficient'],['efficiently']
Energy Efficiency,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:331,allocate,allocate,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860,1,['allocate'],['allocate']
Energy Efficiency,"This will allow us to support 4 dimensional fields. PS: do we actually need `AbstractReducedField` and `ReducedField`? We can infer the `dims` property (dimensions over which a field is reduced) from the locations, and don't need to store it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1640:104,Reduce,ReducedField,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1640,2,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,This will be needed to make `HydrostaticFreeSurfaceModel.free_surface.η` a `ReducedField`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1354:76,Reduce,ReducedField,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1354,1,['Reduce'],['ReducedField']
Energy Efficiency,"This would actually be good to work on since a `minimum`, `mean`, etc. that works seamlessly for CPU and GPU would reduce a lot of headaches and accidental CUDA scalar operations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1117#issuecomment-779523805:115,reduce,reduce,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1117#issuecomment-779523805,1,['reduce'],['reduce']
Energy Efficiency,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073:201,Reduce,Reduced,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073,1,['Reduce'],['Reduced']
Energy Efficiency,"Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2453,Adapt,Adapt,2453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Energy Efficiency,"To address the first issue, here's the definition of `time_average_outputs`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L11-L16. The arguments are the specified `schedule` (which is an `AveragedTimeInterval` per the API we have designed), the `outputs` (here a `Dict`), `model`, and `field_slicer` (because we support averaging slices of fields). The first line:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L12-L13. converts the `outputs` `Dict` into a `Dict` of `WindowedTimeAverages` by wrapping each member of output in `WindowedTimeAverage`. The second part is to return the `TimeInterval` that corresponds to `AveragedTimeInterval`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L15. It'd be great to improve this functionality if we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599:249,schedul,schedule,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599,1,['schedul'],['schedule']
Energy Efficiency,To avoid `Manifest.toml` merge conflicts should we update NCDatasets.jl (#1217) and StaticArrays.jl (#1222) in this PR as well?. I actually don't think we use StaticArrays.jl...? I used it for the `WENO{N}` implementation but it's currently commented out until it can be made efficient (also users did not like the sympy dependency).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432:276,efficient,efficient,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432,1,['efficient'],['efficient']
Energy Efficiency,"To include an updatable friction velocity in the model constant calculation, we'd do something like. ```julia; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall, noting that `δ⁺₀` and `δ⁺₁` are `Ref`; d⁺₀ = (z - z₀) / p.δ⁺₀[]; d⁺₁ = (z₁ - z) / p.δ⁺₁[]; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end; # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). δ⁺₀ = Ref(0.0) # allocate an updatable reference to `δ⁺` (for the top and bottom separately), which we will compute within a Callback; δ⁺₁ = Ref(0.0) # Reference to the bottom `δ⁺`. parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom; Δz₁ = Δz₁, # vertical grid spacing at the top; δ⁺₀ = δ⁺₀,; δ⁺₁ = δ⁺₁) # function of molecular_diffusivity.ν. van_driest_damping = FunctionField{Center, Center, Center}(van_driest_damping_function, grid; parameters). # later... function compute_wall_length_scales!(sim); δ⁺₀[] = # computed as function of sim.model.velocities; return nothing; end. simulaton.callbacks[:length_scale_computation] = Callback(compute_wall_length_scales!); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1789395517:671,allocate,allocate,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1789395517,1,['allocate'],['allocate']
Energy Efficiency,"To me this looks like implementing arbitrary functions to replace a specific term in the momentum equations, which is kind of similar to #73 #85. . > I propose that we view a ""closure"" as the addition of a viscosity/diffusivity, even a constant isotropic 'molecular' diffusivity. Is a closure always meant to replace the viscous dissipation (𝜈∇²u) operators? Will Smag/AMD replace the Laplacian diffusion operators (e.g. κ∇²T) as well?. > In addition, we may need to implement special time-stepping methods that apply both to LES closures and diffusivities. Does this apply to constant/dynamic Smagorinsky or AMD?. > We may also want/need to implement LES closures that add additional 'tracers' (like subgrid scale turbulent kinetic energy) that have their own evolution equations. We'll do the easy 'eddy diffusivity' closures first, but we must keep in mind that including optional evolution equations for closure-specific tracers requires an implementation of an abstraction for equations (as discussed in #110). Out of curiousity, can these closures be framed as `ODEProblem`s using DifferentialEquations.jl?. > does that make sense?. Makes sense to me! If it's an arbitrary function then we should be able to implement any closure (or no closure which should produce inviscid flow?). > In order to calculate the stress divergence for eddy viscosities, therefore, we need the eddy viscosity at (Center, Center, Center) . With finite volume the interpolation operators (`avgx!`, `avgy!`, `avgz!`), applied correctly, should allow us to calculate the eddy viscosity at any location. Sounds like #115 (and https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471136259) should be resolved before this closure abstraction is merged in?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472004913:733,energy,energy,733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472004913,1,['energy'],['energy']
Energy Efficiency,"To my mind there are three main ways to approach this:. 1. design simulations such that the output can be directly compared with analytical solutions;; 2. design simulations such that the statistics of the output can be compared with theory; or; 3. design simulations to mimic published results. Option 1 restricts us to systems with tractable analytical solutions, but still contains a wealth of feasible problems, such as:; 1. Munk gyre; 2. Spin down of a flow-field under the influence of friction; 3. Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; 4. Rayleigh–Bénard convection (as mentioned previously); 5. Onset of baroclinic instability: compare growth rates with analytical predictions. Option 2 lets us explore dynamics in the presence of turbulence. Potential test cases here include:; 1. 2D QG turbulence: explore energy and enstrophy cascades; 2. lee wave generation and breaking (will require large-scale flow field and bathymetry). Option 3 lets you do whatever you want - you just need to find a published result and try to reproduce it. It's unlikely that you'll get the exact same answer, so this option is more difficult to implement in a testing framework that doesn't require eyeballs to validate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237:888,energy,energy,888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237,1,['energy'],['energy']
Energy Efficiency,"To reduce the number of operations, the number of memory allocations, and register pressure in GPU kernels, we might want to try refactoring upwind schemes to convert this pattern. ```julia; @inline upwind_biased_product(ũ, ψᴸ, ψᴿ) = ((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2. @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v). ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); uᴸ = _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); uᴿ = _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u). return Ayᵃᵃᶠ(i, j, k, grid) * upwind_biased_product(ṽ, uᴸ, uᴿ); end; ```. to something like. ```julia; @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v); ; ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); u = ṽ > 0 ? _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u) :; _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); ; return Ayᵃᵃᶠ(i, j, k, grid) * ṽ * u; end; ```. Could save a lot of operations and register pressure for higher-order schemes. I actually don't see why `((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2` is used instead of if-statements. Maybe @christophernhill or @jm-c know?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987:3,reduce,reduce,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987,1,['reduce'],['reduce']
Energy Efficiency,"To reproduce this bug:; ```Julia; using Oceananigans. grid = RectilinearGrid(; CPU(),; size=(128, 128, 128),; x=(0.0, 1.0), y=(0.0, 1.0), z=(0.0, 1.0),; topology=(Bounded, Bounded, Bounded),; ). model = NonhydrostaticModel(;; grid,; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_iteration = 8). fields = model.velocities. simulation.output_writers[:compression_0] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_0.nc"",; compression = 0,; schedule = IterationInterval(1),; overwrite_existing = true,; ). simulation.output_writers[:compression_4] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_4.nc"",; compression = 4,; schedule = IterationInterval(1),; overwrite_existing = true,; ). run!(simulation). @info filesize(""compression_0.nc""); @info filesize(""compression_4.nc""); ```. Output:; ```; Info: Initializing simulation...; Info: ... simulation initialization complete (915.221 ms); Info: Executing initial time step...; Info: ... initial time step complete (5.500 seconds).; Info: Simulation is stopping after running for 8.465 seconds.; Info: Model iteration 8 equals or exceeds stop iteration 8.; Info: 460126123; Info: 460126123; ```. Expected behavior: the size of `compression_4.nc` should be much smaller than that of `compression_0.nc`, since the data are all zeros. Test enviroment:; - Julia: 1.9.1; - Oceananigans: v0.83.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3152:470,schedul,schedule,470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3152,2,['schedul'],['schedule']
Energy Efficiency,"Top: biharmonic diffusion. Bottom: WENO vector invariant with ""divergence damping"" with nu = 100 m^2 / s. Kinetic energy. ![image](https://user-images.githubusercontent.com/33547697/165781484-adc3d55d-bf58-4366-8cda-9565eb3ab5c1.png). Vorticity. ![image](https://user-images.githubusercontent.com/33547697/165783429-b40b86e4-4998-4140-855b-0fea58fe2a67.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112309201:114,energy,energy,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112309201,1,['energy'],['energy']
Energy Efficiency,Tried increasing the problem size by a factor of 8 to 512³. Scaling seems a bit better on Satori and a bit worse on Tartarus (some cores could have been in use by others). Maybe there's something fundamental limiting us to a ~10x speedup?. ```; Tartarus: Julia 1.5.0 + Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; 1 thread: 34.60 s; 4 threads: 12.00 s (2.88x); 8 threads: 7.00 s (4.94x); 16 threads: 4.93 s (7.02x); 24 threads: 4.59 s (7.54x); 32 threads: 4.25 s (8.14x); 40 threads: 4.06 s (8.52x); 48 threads: 4.19 s (8.26x) [some of the 48 cores were in use]. Satori: Julia 1.4.1 + IBM Power System AC922 (8335-GTH); 1 thread: 47.20 s; 4 threads: 21.70 s (2.18x); 8 threads: 11.30 s (4.18x); 16 threads: 7.16 s (6.59x); 32 threads: 5.40 s (8.74x); 64 threads: 4.29 s (11.0x); 128 threads: 4.14 s (11.4x); 160 threads: 4.02 s (11.7x); ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/869#issuecomment-682190586:588,Power,Power,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/869#issuecomment-682190586,1,['Power'],['Power']
Energy Efficiency,"Try. ```julia; rescale_factor = CUDA.@allowscalar √(target_kinetic_energy / energy[1, 1, 1]) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2021702345:76,energy,energy,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2021702345,1,['energy'],['energy']
Energy Efficiency,"Tuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothing},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}})(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{ty",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:1604,reduce,reduce,1604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,1,['reduce'],['reduce']
Energy Efficiency,Two questions:. > Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Is this one node or multiple nodes? . Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585:277,allocate,allocated,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585,1,['allocate'],['allocated']
Energy Efficiency,"Ultimately I think it’d be nice to build adaptive time stepping into the time step function itself, once we have time stepping methods that are well suited for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520912411:41,adapt,adaptive,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520912411,1,['adapt'],['adaptive']
Energy Efficiency,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:759,schedul,schedule,759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['schedul'],['schedule']
Energy Efficiency,"Unfortunately I don't have an example of this on hand (and our tests don't catch it), but I've noticed occasional irregularities in output writing that are presumably due to rounding artifacts when aligning a time-step for `TimeInterval`. One common case is that I run a parameter sweep and one of the files is one iteration shorter than another. This is often at the end of a long run. I think the culprit might be round-off error when computing `align_time_step` or `schedule_aligned_Δt`. Maybe using `Base.TwicePrecision` for some of the calculations would solve the problem?. Here's some of the code involved:. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Simulations/run.jl#L43-L58. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L51. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L152",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321:831,schedul,schedules,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321,2,['schedul'],['schedules']
Energy Efficiency,"Unfortunately this example. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:497,schedul,schedule,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['schedul'],['schedule']
Energy Efficiency,Update packages and one less adapt,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1142:29,adapt,adapt,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1142,1,['adapt'],['adapt']
Energy Efficiency,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372:28,reduce,reduce,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372,1,['reduce'],['reduce']
Energy Efficiency,"Update: we think this error arises because `CUDAnative` is not a dependency of `Oceananigans`. As a result, a `launch` function is not compiled by `GPUifyLoops`. In principle, this problem *could* be solved by adding `CUDAnative` to `Oceananigans`. However, this is not possible because `CUDAnative` and `CUDA` (which `Oceananigans` currently uses for CUDA functions / abstractions) cannot be used in the same environment due to conflicting requirements for `Adapt`. cc @sandreza @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565:459,Adapt,Adapt,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565,1,['Adapt'],['Adapt']
Energy Efficiency,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296:168,Adapt,Adapt,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296,1,['Adapt'],['Adapt']
Energy Efficiency,Use `-O1` or even `-O0` to reduce compile time for faster testing?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1076:27,reduce,reduce,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076,1,['reduce'],['reduce']
Energy Efficiency,Use adaptive timestep in two-dimensional turbulence example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3540:4,adapt,adaptive,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3540,1,['adapt'],['adaptive']
Energy Efficiency,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1088:104,power,powerful,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088,1,['power'],['powerful']
Energy Efficiency,Using `Flat` should be more efficient in terms of memory.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1659:28,efficient,efficient,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1659,1,['efficient'],['efficient']
Energy Efficiency,Using short-circuiting logic inside GPU kernels would reduce performance rather than improve it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-1056924530:54,reduce,reduce,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-1056924530,1,['reduce'],['reduce']
Energy Efficiency,"Victoria, is the velocity normal to the cylinder zero? and perhaps the; tangential component too, if you are using no-slip boundary conditions. I; have a nice application of all this if you are going in 3-d. John. On Thu, Dec 3, 2020 at 2:54 PM Gregory L. Wagner <notifications@github.com>; wrote:. > That solution looks pretty good!; >; > As far as I can tell I think it makes sense for the ""full"" pressure field; > to continue smoothly into the IB, since the pressure field is somehow a; > solution to Poisson's equation --- even if the RHS of the Poisson equation; > varies rapidly close to the IB (?); >; > Does the magnitude of the velocity error scale with the time-step, or; > resolution? Perhaps plotting the dependence of the error on some of those; > parameters can give us confidence that the method is working as expected.; >; > Should we try iterating the IB correction + pressure solve to see if it; > reduces the velocity error, as we hypothesized it might?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRQB7MCPDWK3EEILQDSS7UJBANCNFSM4SNJ4CSA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738278829:916,reduce,reduces,916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738278829,1,['reduce'],['reduces']
Energy Efficiency,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:101,adapt,adapt,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483,1,['adapt'],['adapt']
Energy Efficiency,"We also need to figure out how to adapt instruction 2:. <img width=""851"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/129913721-0a12190d-af28-43c6-9070-92eb9e8f5a25.png"">. to buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073:34,adapt,adapt,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073,1,['adapt'],['adapt']
Energy Efficiency,We are well above the recommended CFL number for |u| > 0.2 which will most likely happen with a random velocity field. ; (for |u| > 0.45 the CFL > 1.88); I think the correct thing to do is to; (1) set a random seed (should be always done for reproducibility regardless); (2) reduce the time step to satisfy CFL < 0.7; (3) Explicitly write in the example how to calculate the time step and the recommendation for time stepping (setting a time step size is not super trivial and many users could benefit from an explanation in the examples),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3540#issuecomment-2039744835:275,reduce,reduce,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3540#issuecomment-2039744835,1,['reduce'],['reduce']
Energy Efficiency,We can reduce memory usage in the Poisson solver by a factor of 2.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/122:7,reduce,reduce,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/122,1,['reduce'],['reduce']
Energy Efficiency,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:143,schedul,schedule,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949,4,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,We don't know of a way to know at compile time. This might be a question for GPUCompiler.jl or CUDA.jl. I have also found that it's rather limited what can be reduced on-the-fly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1582850631:159,reduce,reduced,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1582850631,1,['reduce'],['reduced']
Energy Efficiency,We don’t need reverse for Fields. We need to go away from reverse since it allocates,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035358102:75,allocate,allocates,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035358102,1,['allocate'],['allocates']
Energy Efficiency,"We have always launched a kernel for flux bcs! Our method is 1) fill halos to nullify diffusive fluxes across boundaries; 2) add the specified fluxes directly to boundary cells. Step 1 requires filling halos, which we have always done for flux bcs. Previously, we used broadcasting for flux bcs, similar to what we do for periodic bcs. When the halo size was greater than 1, the intent of the broadcast operation was violated, however, because zero diffusive flux was not guaranteed for biharmonic diffusivity. This PR corrects that, allowing biharmonic diffusivities to be used in bounded domains. Some informal benchmarks suggest that a KernelAbstractions kernel can be more efficient than using GPUArrays broadcasting. KernelAbstractions kernels are also multithreaded, unlike broadcast operations. Thus I would expect speed up from this change, rather than slowdown (but likely negligible speed up). But of course benchmarking is a good idea, and if there is a problem we should open an issue. Another advantage is that we can utilize KernelAbstractions dependency feature more fully if we get to the point where we do not use broadcasting for anything. We haven't optimized our dependency structure, however. Also, there are a few puzzles to be worked out regarding periodic boundary conditions before we can convert the periodic halo filling to kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686430220:677,efficient,efficient,677,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686430220,1,['efficient'],['efficient']
Energy Efficiency,"We have two functions called `arch_array` and `on_architecture` that pretty much do the same thing: moving a variable between GPU and CPU. However, neither of them covers all the types in Oceananigans, like `Fields` or `Models`. So, this PR tidies things up a bit. It removes `arch_array` in favor of `on_architecture`. In addition, it extends `on_architecture` to all the types with memory-allocated variables.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3490:391,allocate,allocated,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490,1,['allocate'],['allocated']
Energy Efficiency,"We may want vertical profiles of many variables, e.g. u, v, w, T. Would be nice to have a diagnostic that does this efficiently, especially if we have very frequent diagnostics. If it's literally every iteration then a CUDA kernel might be the way to go. But if it's like every 20-100+ iterations then it might be faster to copy stuff to the CPU and do a lot of extended on-the-fly analysis there (similar to what we do with asynchronous NetCDF output). Not sure if the same diagnostic can handle products of fields, e.g. _w'T'_. That could be another diagnostic?. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186:116,efficient,efficiently,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186,1,['efficient'],['efficiently']
Energy Efficiency,We maybe need to adapt the constructor of the `KrylovSolvers` (workspaces) for your specific type.; Example: https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/src/krylov_solvers.jl#L162. It works fine for CPU / GPU arrays as well as various partitioned arrays but `Field` seems quite different.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678,1,['adapt'],['adapt']
Energy Efficiency,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525:300,Reduce,ReducedField,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525,3,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,We need to add a test for `ConsecutiveIterations` schedule that was introduced by #2100,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2154:50,schedul,schedule,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2154,1,['schedul'],['schedule']
Energy Efficiency,"We reduced the number of time steps and the size of the time step, effectively decreasing the simulation time. The leading theory is that non-linearities in the simulation were preventing bitwise reproducibility, so reducing the extent of the simulation did the job",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3028#issuecomment-1485138938:3,reduce,reduced,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3028#issuecomment-1485138938,1,['reduce'],['reduced']
Energy Efficiency,"We should document the following constant definitions in `utils.jl`, which I think are useful and make scripts more readable, but would be quite confusing if you didn't know that they are just `Float64` constants. ```julia; const second = 1.0; const minute = 60.0; const hour = 60minute; const day = 24hour. KiB, MiB, GiB, TiB = 1024.0 .^ (1:4); ```. I'd also like to add constants for `meter`, `centimeter` (`cm`?), and `kilometer` (`km`?).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/545:387,meter,meter,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/545,1,['meter'],['meter']
Energy Efficiency,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:189,energy,energy,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['energy'],['energy']
Energy Efficiency,"We should look into using `mapreduce` as a way of computing reduced grid metrics and statistics using abstract operations. This could speed up `AveragedField` (and upcoming `SummedField`, `IntegratedField`, etc.) and make them lighter by not having to store a scratch space. There are two methods for `mapreduce`:. ```julia; mapreduce(f, op, itrs...; [init]); mapreduce(f, op, A::AbstractArray...; dims=:, [init]); ```. The first one might be useful for abstract operations (as long as `getindex` is defined?). Might be useful to do a bit of benchmarking to see if we can use them (and potentially get rid of some existing code). The second function I guess would only be useful if we already have a `ComputedField` with an array. We already use `mapreduce` a bit (the second method) but crucially we needed to pass in a view into a `CuArray` (and not a view into an `OffsetArray{CuArray}`): https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L57-L58",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1422:60,reduce,reduced,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422,1,['reduce'],['reduced']
Energy Efficiency,"We should probably improve our suite of examples. Some ideas:. * I think the thermal bubble might be a decent one to re-instate, since it's extremely simple.; * We may want to simply / reduce the length of the internal wave example. It could also be simplified if waves were excited by forcing rather than initial condition... ?; * I think reducing ""deepening mixed layer"" to free convection would be a good idea; * Some simplified version of stratified Couette flow might be nice to show the use of no-slip boundary conditions; * Driven cavity? What else? More ocean-y examples?. We haven't discussed tutorials; perhaps this is out the window.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531048061:185,reduce,reduce,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531048061,1,['reduce'],['reduce']
Energy Efficiency,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:341,Adapt,Adapting,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632,1,['Adapt'],['Adapting']
Energy Efficiency,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:9,reduce,reduce,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293,1,['reduce'],['reduce']
Energy Efficiency,"We would like a parallel hydrostatic model eventually, you're right. We need to parallelize the preconditioned conjugate gradient solver and ensure that reduced fields parallelize for that. I'm not sure this 2D internal tide problem is large enough to benefit from GPU parallelization --- have you tested GPU parallelization of such small problems?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867978094:153,reduce,reduced,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867978094,1,['reduce'],['reduced']
Energy Efficiency,"Well, `VectorInvariant` is for any vector-invariant-type advection scheme, whereas `WENOVectorInvariant` is specifically for vector invariant scheme with WENO interpolation (ie what Simone is developing in his paper). So `WENOVectorInvariant` is just a convenience function that hopefully reduces boiler plate a bit for hopefully what will become the most-used version of `VectorInvariant`. There are a few other differences, like `vertical_order` instead of `vertical_scheme`. We should get rid of `WENOVectorInvariant` though if it doesn't help much...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3449#issuecomment-1915260615:289,reduce,reduces,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3449#issuecomment-1915260615,1,['reduce'],['reduces']
Energy Efficiency,"Well, might be that the reconstruction is incorrect because it adds spurious kinetic energy. (It does not consider the spherical geometry). If you look at the kinetic energy of the above simulation that is exactly what happens; (sorry now the two cases are inverted). https://user-images.githubusercontent.com/33547697/235359276-11713879-4470-4267-a459-eae5db49e033.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529041690:85,energy,energy,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529041690,2,['energy'],['energy']
Energy Efficiency,"Well, that explains some of my flailing!. Ok, I agree with what you're saying. . Should we anticipate that functions should mutate some output array, so function signatures will generally be something like `operation!(out, in, otherargs...)`?. Anticipating the basic code pattern will reduce work later, and it'll still be possible to write `operation!` quick and dirty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437370488:285,reduce,reduce,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437370488,1,['reduce'],['reduce']
Energy Efficiency,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:242,reduce,reduce,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,2,"['power', 'reduce']","['power', 'reduce']"
Energy Efficiency,"Welp, it's a minor difference at 8m resolution here:. https://user-images.githubusercontent.com/15271942/164351531-dae7cec6-de9a-43a7-a60f-29f6bbeeb060.mp4. ""new"" is this PR. The results are expected though I think: when we put the diffusivity at cell interfaces (holding everything else the same / all parameters constant), the mixing rate is slightly reduced. @navidcy @simone-silvestri @adelinehillier shall we merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829:353,reduce,reduced,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829,1,['reduce'],['reduced']
Energy Efficiency,What are you trying to simulate?. It looks like you're trying to simulate a Gaussian surface cooling in a tiny 4 x 4 x 0.1 m box with a Coriolis parameter of f = 0.5 and beta = 3.75e-3?. Not sure if it makes sense to use a beta plane approximation on a domain that's only 4 meters long...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755309800:274,meter,meters,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755309800,1,['meter'],['meters']
Energy Efficiency,"What if we add this feature to `Callback`? I.e. ```julia; struct Callback{P, F, S, I}; func :: F; schedule :: S; parameters :: P; initialize :: I; end; ```. Then by default we set. ```julia; Callback(; ..., initialize=call_at_iteration_0); ```. where. ```julia; call_at_iteration_0(callback, simulation) = iteration(simulation) == 0 && callback(simulation); ```. so the default ""initialization"" is simply to ""call"" the callback at iteration 0 (as we currently do). Users can cancel this by setting `initialize=nothing` or providing some alternative function. Finally, rather than calling all the callbacks at iteration 0, we instead call `Callback.initialize!` for every callback inside `initalize_simulation!`:. https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Simulations/run.jl#L166. For ""finalization"" we need a bit more work, since I think we want to add the concept of finalizing a simulation as well, so we might need `Simulation.finalized`. That's probably a nice idea too though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501:98,schedul,schedule,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501,1,['schedul'],['schedule']
Energy Efficiency,What is the source of energy? (Of course it's unexpected for a simulation to blow up --- unless you like simulating NaNs??),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442101185:22,energy,energy,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442101185,1,['energy'],['energy']
Energy Efficiency,"What's needed is something like. ```julia; struct ContinuousDiffusionFunction{F, P}; func :: F; parameters :: P; end. @inline (K::ContinuousDiffusionFunction)(x, y, z, t) = K.func(x, y, z, t, K.parameters). @inline function convert_diffusivity(FT, κ; discrete_form=false, loc=(nothing, nothing, nothing), parameters=nothing) ; if discrete_form; return DiscreteDiffusionFunction(κ; loc, parameters); elseif isnothing(parameters); return ContinuousDiffusionFunction(κ, parameters); else; return κ ; end ; end ; ```. I think anyways. reduced dimensionality grids may be different",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401073362:531,reduce,reduced,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401073362,1,['reduce'],['reduced']
Energy Efficiency,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:37,reduce,reduced,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,2,"['reduce', 'schedul']","['reduced', 'schedule']"
Energy Efficiency,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:307,power,powerful,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729,1,['power'],['powerful']
Energy Efficiency,"When `StepRangeLen` is adapted to GPU it goes through this `adapt_structure`:. https://github.com/JuliaGPU/Adapt.jl/blob/5ef7c5329609df7ffb5b19942d6747b3dcc162c2/src/base.jl#L79-L80. This is invalid though, because it does not preserve the type of the range. It calls this constructor in Julia's base:. https://github.com/JuliaLang/julia/blob/9850a3881221a57a382e98c9b9ae2bf97ac3966d/base/range.jl#L524-L525. specifically we get a range of type `typeof(ref+zero(step))`, which is `Float64` if `step isa Float64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630:23,adapt,adapted,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630,2,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Energy Efficiency,"When a shock occurs, the function becomes multivalued and the equation is no longer valid. That's why discussing energy conservation after the shock is a bit weird. People usually have to add in other physics. This is an extreme case and I wonder if a smooth solution would be easier to understand?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185604762:113,energy,energy,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185604762,1,['energy'],['energy']
Energy Efficiency,"When creating a background field, I can add it to its respective perturbations to create a total field. However, this fails when writing to file. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: compute!; using Oceananigans.Utils; using Oceananigans.OutputWriters. grid = RegularCartesianGrid(size=(16, 1, 16), extent=(1, 1, 1)). U(x, y, z, t) = 0.2 * z. model = IncompressibleModel(grid = grid, background_fields = (u=U,)). U_tot = model.background_fields.velocities.u + model.velocities.u. simulation = Simulation(model, Δt=2,; iteration_interval=5,; stop_iteration=5,). outputs = (u = model.velocities.u, U_tot = U_tot,); simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, outputs,; filepath = ""mwe.nc"",; schedule = TimeInterval(20minutes),; mode = ""c""); run!(simulation); ```. This fails in the last line with. > ERROR: LoadError: type BinaryOperation has no field data. Is this expected behavior? It would be very nice to be able to do this!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308:762,schedul,schedule,762,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308,1,['schedul'],['schedule']
Energy Efficiency,When you reduce the averaging window do differences diminish? What if your averaging window is a dt?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809484323:9,reduce,reduce,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809484323,1,['reduce'],['reduce']
Energy Efficiency,"When you turn off closure you reduce the order of the differential equations and therefore no longer have the freedom to impose anything else but no-normal flow. It is due entirely to the order of the differential equations and not do to whether the boundary conditiosn are flux, gradient or value. Does that make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831593723:30,reduce,reduce,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831593723,1,['reduce'],['reduce']
Energy Efficiency,Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007:229,adapt,adapted,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007,1,['adapt'],['adapted']
Energy Efficiency,"Where is a reduced field located in the `Nothing` direction?. It is natural to locate the free surface at the surface, (`k = grid.Nz`), but for other fields which are Averages or sums the choice is not that natural. This is important in the context of Immersed boundaries to check if a Reduced Field is immersed or not (and eventally mask it). For the free surface it is enough to check `solid_interface(i, j, grid.Nz, grid)`, for averaged fields it might be necessary to check the whole column `all(solid_interface(i, j, 1:grid.Nz, grid))`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2177:11,reduce,reduced,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177,2,"['Reduce', 'reduce']","['Reduced', 'reduced']"
Energy Efficiency,Where to export schedules and output writers from?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:16,schedul,schedules,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,1,['schedul'],['schedules']
Energy Efficiency,"Which document are you referring to @Yixiao-Zhang ? . I think its important to enable Float32 for science applications. It's important enough that I think this could be the subject of a paper, especially since it does not seem trivially achievable. Multi-GPU is the safe solution right now. Single precision may also accelerate multi-GPU simulations though, because it reduces the amount of information that has to be communicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160:369,reduce,reduces,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160,1,['reduce'],['reduces']
Energy Efficiency,"Why do model tests have to be long runs? Surely a few timesteps is enough; to see if anything is broken. On Tue, Dec 17, 2019, 7:26 PM Ali Ramadhan <notifications@github.com> wrote:. > This issue is cropping up now that we regularly timeout on Travis (max; > runtime is 50 minutes) and we almost always time out on GitLab GPU CI (max; > runtime is 60 minutes, @maleadt <https://github.com/maleadt> might be; > able to increase that but it's a shared resource and we probably shouldn't; > be hogging it up). Surprisingly Appveyor is always fast now. I think free; > CI servers are just generally underpowered.; >; > Unfortunately it seems like paying for CI will never happen but we; > definitely want to keep our tests and make them even more comprehensive so; > here are some ideas we can discuss (probably in January):; >; > 1. See if we can move Travis CI pipelines onto Azure DevOps. They seem; > to give out more runtime (up to 360 minutes I think) although they might; > always reduce that in the future if they get more users. CliMA and; > @simonbyrne <https://github.com/simonbyrne> seem to be having a good; > experience with Azure.; > 2. Split tests into a fast smaller test set (regression only?) and the; > full comprehensive test set. But we still need a place to run the; > comprehensive test set (maybe Azure runs the comprehensive tests?). We'll; > probably have to do this at some point.; > 3. Split up the tests into jobs that run in <50 minutes each. You can; > have unlimited jobs on Travis. But this feels like a lot of work to set up; > and the tests would still take long as you can't have that many parallel; > builds.; >; > We'll have to test Oceananigans + MPI pretty soon but we can worry about; > that later. Slurm CI or setting something up with our 4xTitan V server; > might be a good option here.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceana",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566848638:984,reduce,reduce,984,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566848638,1,['reduce'],['reduce']
Energy Efficiency,Why does the test allocate so much memory? Is it possible to design an inexpensive test? It's important that CI is absolutely as cheap as possible.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748:18,allocate,allocate,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748,1,['allocate'],['allocate']
Energy Efficiency,Why here we drop the last two elements?. https://github.com/CliMA/Oceananigans.jl/blob/d7d146bc59f966d65eb66a875c16679bef365130/src/Utils/schedules.jl#L177,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3163:138,schedul,schedules,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3163,1,['schedul'],['schedules']
Energy Efficiency,Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Current Temp : 44 C; Memory Max Operating Temp : 85 C; Power Readings; Power Management : Supported; Power Draw : 44.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:22253,Power,Power,22253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,3,['Power'],['Power']
Energy Efficiency,"With no background diffusivity I also find the energy increases slowly. This is with WENO advection scheme. https://user-images.githubusercontent.com/15271942/221060649-86deb92a-45c3-401d-96ac-3dceabacc686.mp4. Perhaps one could compute the discrete conservation laws for the linear wave equations here given our staggered discretization of buoyancy / hydrostatic pressure + nonhydrostatic pressure... I'm not sure what we would find. It's not that simple, because nonhydrostatic pressure is treated implicitly / with a fractional step. Our hydrostatic pressure scheme is not the only possible scheme one might use. Perhaps other schemes have different numerical properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489:47,energy,energy,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489,1,['energy'],['energy']
Energy Efficiency,"With part 2 (#628) merged I merged master into this branch to resolve conflicts which also reduced the number of changes but it's still a pretty big and complicated PR. @glwagner We should probably make sure that the changes and design choices in this PR make sense. Once this PR is merged, I think we should release v0.23.0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589078151:91,reduce,reduced,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589078151,1,['reduce'],['reduced']
Energy Efficiency,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381:682,schedul,schedule,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381,1,['schedul'],['schedule']
Energy Efficiency,"Would `ReducedField` be part of the `AbstractOperations` module?. I think the bare-bones implementation makes a lot of sense for reduced averaged fields needed for computations like ; ```julia; TKE = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```; which can then be built up as we encounter new things we want to compute (or reduce?). I'm guessing you're suggesting the bare-bones implementation for something like `ReducedField(::Average, ...)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674790297:7,Reduce,ReducedField,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674790297,4,"['Reduce', 'reduce']","['ReducedField', 'reduce', 'reduced']"
Energy Efficiency,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/163:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163,3,['adapt'],['adapt']
Energy Efficiency,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1031,energy,energy,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['energy'],['energy']
Energy Efficiency,"WxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `19.23% <0%> (-4.58%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `48.38% <0%> (-1.62%)` | :arrow_down: |; | [...lence\_closure\_implementations/smagorinsky\_lilly.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3NtYWdvcmluc2t5X2xpbGx5Lmps) | `92.85% <100%> (-0.76%)` | :arrow_down: |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `80% <100%> (+10%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `66.66% <100%> (ø)` | :arrow_up: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `81.81% <88.23%> (+1.17%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=footer). Last update [6f40796...c53227c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548763706:3963,Power,Powered,3963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548763706,1,['Power'],['Powered']
Energy Efficiency,"XJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100.00% <ø> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `76.19% <ø> (+4.76%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <ø> (-32.36%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `100.00% <ø> (+25.00%)` | :arrow_up: |; | ... and [95 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=footer). Last update [3f491e7...c789ec6](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/765#issuecomment-637790496:3262,Power,Powered,3262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/765#issuecomment-637790496,1,['Power'],['Powered']
Energy Efficiency,"Y29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `100% <100%> (+40.54%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.97% <100%> (-0.61%)` | :arrow_down: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <23.95%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `53.33% <53.33%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <67.79%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <69.72%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=footer). Last update [5a12ab6...7e7449e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135941:3808,Power,Powered,3808,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135941,1,['Power'],['Powered']
Energy Efficiency,"Y29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `100% <100%> (+40.54%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.97% <100%> (-0.61%)` | :arrow_down: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <23.95%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `53.33% <53.33%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <67.79%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <69.72%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=footer). Last update [5a12ab6...be136c3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135943:3804,Power,Powered,3804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135943,1,['Power'],['Powered']
Energy Efficiency,"Y2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `35.84% <0%> (-2.45%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | [src/Solvers/triply\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvdHJpcGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | ... and [41 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=footer). Last update [4ed3660...2610b13](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940:3746,Power,Powered,3746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940,1,['Power'],['Powered']
Energy Efficiency,"Y3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `50.00% <ø> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <ø> (ø)` | |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <ø> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <ø> (ø)` | |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <ø> (ø)` | |; | ... and [41 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=footer). Last update [417e890...73a6798](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002:3509,Power,Powered,3509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002,1,['Power'],['Powered']
Energy Efficiency,Yeah I saw that comment. My understanding is that `-O1` is a good compromise between performance and latency but in our case we just want to reduce latency as performance during testing doesn't matter. But I guess `-O0` didn't really do much. Perhaps the optimizations (might only be in Julia 1.6+) mostly affect compilation when loading/importing packages. Should we still consider merging this? Once tests run I can do a comparison to see how many minutes (or seconds?) `-O0` saves us?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712840423:141,reduce,reduce,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712840423,1,['reduce'],['reduce']
Energy Efficiency,"Yeah I think the current time stepping algorithm (essentially what the MITgcm does) is pretty custom so it's probably not shared by other equations/methods, but the pressure correction step is pretty common to finite volume Navier-Stokes solvers and it should be possible to generalize it. I'm thinking it might be good to tackle ""generic time stepping"" in two steps. 1. Getting the current version of the time stepping algorithm running efficiently on GPUs for milestone v0.4 and then 2. we can redesign for v0.5 and include more generic time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463036545:438,efficient,efficiently,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463036545,1,['efficient'],['efficiently']
Energy Efficiency,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:8,Adapt,Adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971,1,['Adapt'],['Adapt']
Energy Efficiency,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:55,Reduce,ReducedField,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736,6,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,"Yeah that would be cool. Might also not be a bad idea to just use coolFFT.jl as it's <40 lines and seems to work (if we restrict ourselves to powers of 2 for `Nx`, `Ny`, `Nz`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562177414:142,power,powers,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562177414,1,['power'],['powers']
Energy Efficiency,"Yeah that would work but might be worth spending the extra work to support checkpointing and pickup for schedules (and time averages). I guess we will have to pass the `simulation` when constructing a `Checkpointer` but then we're stuck with the `write_output!(output_writer, model)` function signature. We could just fully switch to passing the simulation to output writers and diagnostics?. I think we also need to nuke `restore_from_checkpoint`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498:104,schedul,schedules,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498,1,['schedul'],['schedules']
Energy Efficiency,"Yeah, but the `ILU` preconditioner doesn't seem to be tested, which I remember was quite good to reduce the number of iterations. So in case of a large time step that would be quite efficient even if we have to solver two triangular linear systems each iteration. but anyways, maybe it's not faster, it was just I was wondering how it would compare",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064:97,reduce,reduce,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064,2,"['efficient', 'reduce']","['efficient', 'reduce']"
Energy Efficiency,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:38,adapt,adaptive,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450,2,['adapt'],"['adapt', 'adaptive']"
Energy Efficiency,"Yeah.. I am not yet sure how this would work embedded. By now, what I have is just some functions that the user has to add as callbacks.; e.g.; https://github.com/iuryt/Bioceananigans.jl/blob/ab35a7235fea532fe7ed283ce6e06ac12f378dae/test/NNP.jl#L109-L117; btw.. this test script is not yet fully developed 😄. Thinking more, it would be so the function automatically adds the callbacks to the simulation?. ```julia; const Δb=(g/ρₒ) * 0.03; h = Field{Center, Center, Nothing}(grid) ; MixedLayerDepth(simulation, h, Δb). # constants for the NP model; const μ₀ = 1/day # surface growth rate; const m = 0.015/day # mortality rate due to virus and zooplankton grazing; const Kw = 0.059 # meter^-1; const kn = 0.75; const kr = 0.5. # https://doi.org/10.1029/2017GB005850; const chl2c = 0.06 # average value for winter in North Atlantic. const α = 0.0538/day. const average = :growth; const shading = true. light_growth = Field{Center, Center, Center}(grid). # time evolution of shortwave radiation (North Atlantic); @inline Lₒ(t) = 116.5 * sin( 2π * ( t / days + 50 ) / 375.7 + 1.3 ) + 132.3; # evolution of the available light at the surface; @inline light_function(t, z) = 0.43 * Lₒ(t) * exp( z * Kw ); # light profile; @inline light_growth_function(light) = μ₀ * ( light * α ) / sqrt( μ₀^2 + ( light * α )^2 ). phytoplankton = (""P"",) # list of phytoplankton tracers ; LightGrowth(light_growth, h, simulation, phytoplankton, light_function, light_growth_function, time(simulation), average, shading, chl2c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657:682,meter,meter,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657,1,['meter'],['meter']
Energy Efficiency,"Yes - that makes sense. On Mon, Apr 29, 2019 at 9:45 AM Ali Ramadhan <notifications@github.com>; wrote:. > @christophernhill <https://github.com/christophernhill> Was wondering if; > your stretched vertical grid spacing 3D elliptic solver would be efficient; > enough to use for the case where *Δz* is constant.; >; > If it is, then we can make do with a single solver. And if there are no; > DCTs, then we can merge the CPU and GPU Poisson solvers!; >; > Just had this thought so leaving the issue open to discuss in the future.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/211>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AA27DYAHOUZSRNBFW5VFYADPS33WPANCNFSM4HJDOFMQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/211#issuecomment-487585763:248,efficient,efficient,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/211#issuecomment-487585763,1,['efficient'],['efficient']
Energy Efficiency,"Yes! Make sure to work from `main` because remember we changed how `TimeInterval` works recently. `TimeInterval` actuates on this criteria:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L65-L79. when `t` exceeds or is equal to `next_actuation_time`:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63. The first actuation time and number of actuations have to be initialized:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L50-L56. I think `WindowedTimeAverage` works differently and looks at `previous_stop_time`, plus the `interval` of the time-averaging. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/OutputWriters/windowed_time_average.jl#L90. and `previous_stop_time` is recorded here:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/OutputWriters/windowed_time_average.jl#L91. which in turn is called here:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/OutputWriters/windowed_time_average.jl#L280. So there's something about using the previous stop time, rather than the _number_ of actuations, which incurs a floating point error issue. I think `AveragedTimeInterval` should somehow use a _number_ of actuations as a criteria. Not sure actually how that would work, need to study the flow of information in detail. It will probably help to sketch out a diagram / make a cartoon on a piece of paper so that you understand precisely the flow of information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2285111141:238,schedul,schedules,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2285111141,3,['schedul'],['schedules']
Energy Efficiency,"Yes! The `HydrostaticFreeSurfaceModel` constructor permits the kwarg `velocities = PrescribedVelocities()`. This can be used to prescribe velocity fields rather than solving for them directly. when `velocities isa PrescribedVelocities`, then neither prognostic fields nor tendencies are allocated the velocity fields or free surface. With the addition kwarg `tracer_advection=nothing`, then advection can be omitted, permitting the solution of a diffusion equation. This feature is not documented; it can only be found in a few `validation` cases such as. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/curvilinear_diffusion/spot_tracer_diffusion.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924:287,allocate,allocated,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924,1,['allocate'],['allocated']
Energy Efficiency,"Yes, I’m happy to include general comments. We shouldn’t write too much on the topic. I think our advice will change when we have time stepping methods that are more appropriate for adaptive time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520910773:182,adapt,adaptive,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520910773,1,['adapt'],['adaptive']
Energy Efficiency,"Yes, except that we don't allocate memory for vorticity at all; we compute it on the fly. The prognostic fields are velocity components and tracers. For hydrostatic, w is diagnostic and free surface is prognostic. For nonhydrostatic, w is prognostic. The diagnostic fields include pressure, w if hydrostatic, and any diagnostics fields associated with the closure. We will also have a user interface for closure prognoetic fields at some point too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502:26,allocate,allocate,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502,1,['allocate'],['allocate']
Energy Efficiency,"Yes, if we are dealing with the conservative form, `1.` is the one that I am suggesting, and iut does ensure that kinetic energy is disispated by viscosity. I don't believe that `2.` and `3.` have that property.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090218750:122,energy,energy,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090218750,1,['energy'],['energy']
Energy Efficiency,"Yes, it seems there is some bad interaction between KernelAbstractions and the debugger. It seems likely that fixing it will requiring some development of the debugger (but possibly also KernelAbstractions). Once that's resolved, I think it's likely the debugger will work with Oceananigans. Hopefully you can still have a productive development workflow in the meantime! Let us know if there is any way we can help. I think the bright side of this situation is that Julia has a lot of powerful built-in features for code introspection and interactive usage, a lot of which overlap with the features provided by a traditional debugger (as I understand it). Are you planning to contribute to Oceananigans development or just to interact with Oceananigans as a user?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624350568:486,power,powerful,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624350568,1,['power'],['powerful']
Energy Efficiency,"Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394. And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395:26,adapt,adapted,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395,3,['adapt'],"['adapt', 'adapted']"
Energy Efficiency,"Yes, that is pretty much what I had in mind but for a different physical problem. . There are a variety of ways one can do this. Below are a few that come to mind. 1. Power method: worked well for Kelvin-Helmholtz instability and should work well for other problems. Two nice features are that it's pretty simple, and it's already coded up for one example so should be easy to adapt. One not so nice feature is that it only tells us the most unstable mode (spatial structure, growth rates and phase speed) but it doesn't tell us about any other unstable modes. 2. Arnoldi Method: A quick google search came across this [library](https://haampie.github.io/ArnoldiMethod.jl/stable/). I have not tried it but could try adapting it to the above mentioned KH problem. . 3. Standard eigenvals: If we assume periodicity in two directions it boils down to a 1D eigenvalue problem that should be easy to solve using eigenvals. There should be a direct solver that forms a full matrix and gives you all the eigenfunctions but the indirect uses Arnoldi and gives you some. . As for where they appera I don't kown but at some point, after I get a ShallowWaterModel off the ground, I will play around with different solvers and see what looks promising. This won't happen this week I'm pretty sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044:167,Power,Power,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044,3,"['Power', 'adapt']","['Power', 'adapt', 'adapting']"
Energy Efficiency,"Yes, that will be great. I will dive in into the schedule over the next few days!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000038293:49,schedul,schedule,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000038293,1,['schedul'],['schedule']
Energy Efficiency,"Yes, this is interesting!. To clarify: we identify a field as ""reduced"" if one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:63,reduce,reduced,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044,4,['reduce'],['reduced']
Energy Efficiency,"Yes, xc is a PencilArray object. Right now it looks like each process calculates the eigenvalues on the global grid and then the code on line 42 attempts to reduce the size to the local grid. One approach would be to calculate the eigenvalues on the local grid. I think that this would be more generalizable to other distributed domain decompositions (right now line 42 assumes that the domain is decomposed in one direction) but this approach would require a re-write of poisson_eigenvalues.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067792174:157,reduce,reduce,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067792174,1,['reduce'],['reduce']
Energy Efficiency,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:679,reduce,reduced,679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675,2,"['adapt', 'reduce']","['adapt', 'reduced']"
Energy Efficiency,"Yesterday we discussed solving the SW model in conservative form, which is a perfectly good approach. However, I remembered that there another formulation in terms of the velocity where we use the vorticity and the Bernouli function. This is also very nice and this approach shows there are the different finite difference formulations that ensure either energy or enstrophy conservation. I don't know how Finite Volume would compare, but I'm tempted to start with this for simplicity. http://www.aos.wisc.edu/~aos718/sadourny.pdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726852193:355,energy,energy,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726852193,1,['energy'],['energy']
Energy Efficiency,"You are correct @navidcy , this is to reduce the number of halo points from 3 to 0, which reduces the storage by a factor of 6.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1659#issuecomment-842497759:38,reduce,reduce,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1659#issuecomment-842497759,2,['reduce'],"['reduce', 'reduces']"
Energy Efficiency,You can probably also omit the `shape` component. That just reduces the noise to zero at the top and the bottom.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268575815:60,reduce,reduces,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268575815,1,['reduce'],['reduces']
Energy Efficiency,"You can start by allowing the coefficient to be an array as in AMD:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L143. Then with a callback you can implement any model, including dynamic Smagorinsky. So this provides unlimited flexibility in developing a new closure. I think its possible you will find that its more efficient to precompute (eg in a callback) the coefficient rather than compute it on the fly with a function, especially because the computation of the different filters is a bit non-local, eg you have to average over a few grid points, which could involve relatively expensive memory fetches. A function-based interface could be nice too, but note that they are relatively complicated. Do we expect a lot of users to experiment with custom coefficient functions? @tomchor if this feature is just for you to experiment with dynamic Smagorinsky implementations then I think experimenting in the source code is an even quicker and easier option than designing a function-based interface... @simone-silvestri and @xkykai have talked about dynamic Smagorinsky too but I think their main conclusion is that it is not a gimme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674:453,efficient,efficient,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674,1,['efficient'],['efficient']
Energy Efficiency,"You changed the initial condition for h. Can you try using the old one? The SWM is quite sensitive to `h` ; this is because `h` is the depth minus the bathymetry, or better `H = h + hB` where `H` is the total height. ; So you have to initialize with `maximum(bathymetry) .- bathymetry)` (where we assume that `H = maximum(bathymetry)`).; To this specific example I have added 10 just to make sure that `h>0` everywhere (maybe a smaller value is also ok). Edit: what you see in the video above is the _total_ height `H = h + hB`, about 10km everywhere with a `ΔH` of roughly 40 meters, quite large for the ocean, but still this is all barotropic so we cannot expect realistic values",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1476028985:577,meter,meters,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1476028985,1,['meter'],['meters']
Energy Efficiency,"You could maybe form a conservative estimate using. ```; uhmax = maximum(abs, uh); vhmax = maximum(abs, vh); hmax = maximum(abs, h). umax = max(uhmax / hmax, vhmax / hmax); ```. but this would be overly conservative for very nonlinear problems, I suppose. One issue is that writing `uh ./ h` will allocate memory. Note that you need `./` (with the `.`), not just `/`. You'll also need to dispatch on `model::ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762898249:297,allocate,allocate,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762898249,1,['allocate'],['allocate']
Energy Efficiency,"You had me at ""powerful and elegant""... As for automation, do we still need a webhook?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1088#issuecomment-713732023:15,power,powerful,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088#issuecomment-713732023,1,['power'],['powerful']
Energy Efficiency,"You have to define `A` as a `SparseMatrix` before iterating, otherwise the memory gets allocated anyways. The same goes for the vectors `e`, Try this. ```; using OffsetArrays; using SparseArrays. Lx = 2; Ly = 3; Nx = 12; Ny = 18; H = 1; δx = Lx/Nx; δy = Ly/Ny. poisson(f::OffsetMatrix, i, j) = (f[i+1, j] - 2*f[i, j] + f[i-1, j])/δx^2 + (f[i, j+1] - 2*f[i, j] + f[i, j-1])/δy^2. interior(f::OffsetMatrix) = f[1:Nx, 1:Ny]. function fill_halos!(f::OffsetMatrix); f[0, :] = f[Nx, :]; f[Nx+1, :] = f[1, :]. f[:, 0] = f[:, Ny]; f[:, Ny+1] = f[:, 1]. return nothing; end. A = spzeros(Float64, Nx*Ny, Nx*Ny). make_column(f::OffsetMatrix) = reshape(interior(f), (Nx*Ny, 1)). for j in 1:Ny, i in 1:Nx; eᵢⱼ = OffsetArray(spzeros((Nx+2H), (Ny+2H)), -H, -H); eᵢⱼ[i, j] = 1; fill_halos!(eᵢⱼ); ∇²eᵢⱼ = 0 * eᵢⱼ. for j in 1:Ny, i in 1:Nx; ∇²eᵢⱼ[i, j] = poisson(eᵢⱼ, i, j); end. A[:, Nx*(j-1)+i] = make_column(∇²eᵢⱼ); end; ```. then I suggest you to extract the constructors and just deal with those from here on out:; ```; using Oceananigans.Solvers: constructors, arch_sparse_matrix. matrix_constructors = constructors(arch, A); ```; whenever you want to write the matrix explicitly. ```; A = arch_sparse_matrix(arch, matrix_constructors); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1110447124:87,allocate,allocated,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1110447124,1,['allocate'],['allocated']
Energy Efficiency,"You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews?; That's great! That would work amazingly. Do you know how to do this weekly schedule?; (Then we can also do it for ClimaOcean Docs repo, etc!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418:173,schedul,schedule,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418,1,['schedul'],['schedule']
Energy Efficiency,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:84,power,powerful,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432,1,['power'],['powerful']
Energy Efficiency,"You start with a very unstable stratification so you set up Rayleigh-Taylor instability. The reason you get inf temp is because simulation blows up. If I reduce the time-step I can integrate up to the final time of `t=80sec` that you chose, but if you need to integrate further probably you need to reduce the time-step further or add a time-step wizard... I enhanced your script a bit with a log message to keep track of the CFL... I also added RK3 time-step. I also reduced the resolution to 128^3 so I can experiment as my laptop cannot casually run 256^3 simulations :) . ```Julia; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(128, 128, 128), y=(-500, 500), x=(-500, 500), z=(-500, 0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3), timestepper = :RungeKutta3,; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(Float64); set!(model1, u=-0.05, v=0, T=thermoc, S=sal). using Oceananigans.Diagnostics: AdvectiveCFL. CFL = AdvectiveCFL(wizard). start_time = time_ns(). progress(sim) = @printf(""i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - start_time)),; prettytime(sim.Δt),; CFL(sim.model)). simulation = Simulation(model1, Δt=2., stop_time=80second, iteration_interval=4, progress=progress). function init_save_some_metadata!(file, model); file[""author""] = ""oofs""; return nothing; end. simulation.output_writers[:tracers] = JLD2OutputWriter(model1, model1.tracers,; prefix = ""Temp Data"",; schedule = TimeInterv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277:154,reduce,reduce,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277,3,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"You're correct about the CPU method. We also opened an earlier issue to discuss this: #102 . Regarding what the GPU does differently: as cuFFT does not have a DCT function, we have to compute the type-II DCT using the FFT (and the type-III DCT using the IFFT). The relevant reference for how to do this efficiently (i.e. no padding or extra memory usage required) is:. Makhoul, [_A fast cosine transform in one and two dimensions_](https://ieeexplore.ieee.org/document/1163351?arnumber=1163351&tag=1), IEEE Transactions on Acoustics, Speech, and Signal Processing 28(1) (1980). but this DSP StackExchange post is probably more useful: https://dsp.stackexchange.com/questions/2807/fast-cosine-transform-via-fft",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496223540:303,efficient,efficiently,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496223540,1,['efficient'],['efficiently']
Energy Efficiency,"Yup it should be flexible enough to adapt it for ocean modeling. Might be worth thinking whether we need any additional abstractions. One important point is that the numerical method used does not time step pressure, it is instead diagnosed from potential temperature or entropy. May require some thought if we want to modify the speed of sound.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579990039:36,adapt,adapt,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579990039,1,['adapt'],['adapt']
Energy Efficiency,"ZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0%> (-6.67%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32% <0%> (-2.1%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [37 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=footer). Last update [2019cb7...c627f48](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313:3762,Power,Powered,3762,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313,1,['Power'],['Powered']
Energy Efficiency,[WIP] Adapt Field to run on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746:6,Adapt,Adapt,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746,1,['Adapt'],['Adapt']
Energy Efficiency,"[WIP] Implement ""MEKE"" parameterization with prognostic mesoscale eddy kinetic energy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:79,energy,energy,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['energy'],['energy']
Energy Efficiency,[da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2; [ab4f0b2a] BFloat16s v0.2.0; [6e4b80f9] BenchmarkTools v1.3.2; [d1d4a3ce] BitFlags v0.1.7; [fa961155] CEnum v0.4.2; [179af706] CFTime v0.1.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [49dc2e85] Calculus v0.5.1; [7057c7e9] Cassette v0.3.10; [d360d2e6] ChainRulesCore v1.15.0; [9e997f8a] ChangesOfVariables v0.1.3; [944b1d66] CodecZlib v0.7.1; [35d6a980] ColorSchemes v3.20.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.9.10; [5ae59095] Colors v0.12.10; [34da2185] Compat v3.43.0; [a216cea6] CompoundPeriods v0.5.1; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [9a962f9c] DataAPI v1.10.0; [124859b0] DataDeps v0.7.10; [864edb3b] DataStructures v0.18.12; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.11.0; [ffbed154] DocStringExtensions v0.8.6; [fa6b7ba4] DualNu,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:1917,Adapt,Adapt,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Energy Efficiency,"](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/c1f4c3363201d16a872617cca6dc0f180b9ef82e?src=pr&el=desc) will **increase** coverage by `0.41%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #264 +/- ##; ==========================================; + Coverage 70.73% 71.14% +0.41% ; ==========================================; Files 23 23 ; Lines 868 870 +2 ; ==========================================; + Hits 614 619 +5 ; + Misses 254 251 -3; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `71.42% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.47% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `78.78% <0%> (+11.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=footer). Last update [c1f4c33...32fc894](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487184:1907,Power,Powered,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487184,1,['Power'],['Powered']
Energy Efficiency,"]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1510,reduce,reduce,1510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft; >; >; >; > plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf); >; >; >; > Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; >; > represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly.; >; >; >; > To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; >; > the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; >; > array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; >; > \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â).; >; >; >; > The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; >; > different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; >; > the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation.; >; >; >; > plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; >; > but produce plans that perform the equivalent of the inverse transforms ifft and so on.; >; >; >; > help?> plan_fft!;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341:1445,allocate,allocated,1445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341,1,['allocate'],['allocated']
Energy Efficiency,"_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `59.45% <100%> (ø)` | |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `83.33% <100%> (ø)` | |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <100%> (-58.53%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `85.71% <100%> (-3.58%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `52.77% <27.27%> (ø)` | |; | [src/turbulence\_closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY2xvc3VyZV9vcGVyYXRvcnMuamw=) | `42.62% <42.85%> (ø)` | |; | ... and [12 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=footer). Last update [c961d39...a40de27](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-510662216:3584,Power,Powered,3584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-510662216,1,['Power'],['Powered']
Energy Efficiency,"_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <ø> (-57.62%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `30% <0%> (-29.71%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `68.33% <100%> (-1.67%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.68% <100%> (-1.9%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `37.5% <19.44%> (-6.41%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `46.83% <50%> (-15.19%)` | :arrow_down: |; | ... and [6 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=footer). Last update [848edd9...25cf2da](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164877:3136,Power,Powered,3136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164877,1,['Power'],['Powered']
Energy Efficiency,"_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:1903,reduce,reduces,1903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['reduce'],['reduces']
Energy Efficiency,"`91.42% <ø> (-0.24%)` | :arrow_down: |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `94.35% <ø> (+0.75%)` | :arrow_up: |; | [test/runtests\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0c191dGlscy5qbA==) | `67.56% <73.33%> (+42.56%)` | :arrow_up: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `100.00% <100.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <100.00%> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <100.00%> (ø)` | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `76.66% <100.00%> (-9.34%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=footer). Last update [8198ca7...871b448](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397:3202,Power,Powered,3202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397,1,['Power'],['Powered']
Energy Efficiency,`Adapt`ing all fields of the `OrthogonalSphericalShellGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619:1,Adapt,Adapt,1,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619,1,['Adapt'],['Adapt']
Energy Efficiency,`FieldTimeSeries` does not adapt correctly on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472,1,['adapt'],['adapt']
Energy Efficiency,`MultiRegion` adaptation of the `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795:14,adapt,adaptation,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795,1,['adapt'],['adaptation']
Energy Efficiency,"`NaNChecker` will also have to be moved from `diagnostics` to `callbacks`, see discussion on #1198. We also may want to make the list of `callbacks` an `OrderedDict`, so that we can write something like. ```julia; simulation.callbacks[:NaNChecker].schedule = IterationInterval(1); ```. If can overload `getproperty` for these custom OrderedDict we can also support the syntax. ```julia; simulation.callbacks.NaNChecker.schedule = IterationInterval(1); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-738797584:248,schedul,schedule,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-738797584,2,['schedul'],['schedule']
Energy Efficiency,"`NetCDFOutputWriter` and `JLD2OutputWriter` currently have different options. ```; NetCDFOutputWriter(model, outputs; filepath, schedule; array_type = Array{Float32},; field_slicer = FieldSlicer(),; global_attributes = Dict(),; output_attributes = Dict(),; dimensions = Dict(),; mode = nothing,; compression = 0,; verbose = false); ```. ```; JLD2OutputWriter(model, outputs; prefix, schedule,; dir = ""."",; field_slicer = FieldSlicer(),; array_type = Array{Float32},; max_filesize = Inf,; force = false,; init = noinit,; including = [:grid, :coriolis, :buoyancy, :closure],; verbose = false,; part = 1,; jld2_kw = Dict{Symbol, Any}()); ```. Some arguments are unique to each writer, but I think it would make things easier and more usable if we unified some of the arguments that really do the same thing. Specifically `filepath` could replace `dir` and `prefix`, and `mode` could replace`force`. I understand that the NetCDF and JLD2 libraries work differently when writing to disk (probably that's where the difference come from) but maybe we can do some translation behind the scenes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2217:128,schedul,schedule,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2217,2,['schedul'],['schedule']
Energy Efficiency,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138:264,adapt,adapt,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138,1,['adapt'],['adapt']
Energy Efficiency,`PartialCellBottom` needs to be adapted correctly for the GPU when using a `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:32,adapt,adapted,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapted']
Energy Efficiency,"`Periodic` boundary conditions should fill the whole halos, while flux, value and gradient BC should fill only the first because advection schemes have reduced order approaching boundaries. Did you notice this in a bounded direction or a periodic direction? In the latter case it is definitely a bug",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1181990838:152,reduce,reduced,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1181990838,1,['reduce'],['reduced']
Energy Efficiency,`ReducedField` type,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525:1,Reduce,ReducedField,1,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525,1,['Reduce'],['ReducedField']
Energy Efficiency,"```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Bas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:1042,reduce,reduce,1042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,1,['reduce'],['reduce']
Energy Efficiency,"```Julia; using Oceananigans; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 5, 5; H = 3. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, 1), z = (0, 1), horizontal_direction_halo = H). j_index = 2; i_index = Nx+1 - j_index. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(getregion(grid, 1).Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""panel 1""); lines!(ax, range_with_offset(Nx, H, 1), parent(getregion(grid, 2).Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""panel 2""); lines!(ax, range_with_offset(Ny, H, 2), parent(getregion(grid, 4).Δyᶜᶜᵃ)[i_index+H, :], linewidth=4, color = (:blue, 0.5), label=""panel 4""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); fig; save(""metrictest.png"", fig); ```. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/c9e2f210-a407-4e06-b3c4-0996b5ea8759). while **BEFORE THIS PR**:. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9ed5be14-05b9-4f83-81f5-2d92def37ff5)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1711700565:514,green,green,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1711700565,1,['green'],['green']
Energy Efficiency,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:21,Adapt,Adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Energy Efficiency,"```julia; mutable struct Clock{T}; time :: T; iteration :: Int; end; ```; Ah right so mutable structs are not `isbits` and so they cannot be passed into GPU kernels... We might have to roll back to using `time, iteration` in kernel and forcing/boundary function signatures instead of `clock`. But maybe it's simple enough that it could be adapted to the GPU...?. @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071:339,adapt,adapted,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071,3,"['Adapt', 'adapt']","['Adapt', 'adapt', 'adapted']"
Energy Efficiency,"```julia; using Random, Printf; using Oceananigans, Oceananigans.Utils. Nx = 25 # Number of grid points in x and y; Nz = 50 # Number of grid points in z; Δz = 4.0 # Grid spacing in x, y, z (meters); Qᵀ = 1e-5 # Temperature flux at surface; ∂T∂z = 0.005 # Initial vertical temperature gradient; f = 1e-4 # Coriolis parameter; α = 2e-4 # Thermal expansion coefficient; β = 8e-4 # Haline contraction coefficient. grid = RegularCartesianGrid(size=(Nx, Nx, Nz), extent=(Δz*Nx, Δz*Nx, Δz*Nz)); T_bcs = TracerBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵀ), bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. ## Temperature initial condition: a stable density tradient with random noise superposed.; T₀(x, y, z) = 20 + ∂T∂z * z + ∂T∂z * model.grid.Lz * 1e-6 * Ξ(z). set!(model, T=T₀); ```; That's the setup I'm using now. Should we start from this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629369389:190,meter,meters,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629369389,1,['meter'],['meters']
Energy Efficiency,"```julia> using Pkg; pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.7; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.4.3; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.5; [d360d2e6] ChainRulesCore v0.9.38; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.12.0; [3da002f7] ColorTypes v0.10.12; [5ae59095] Colors v0.12.7; [34da2185] Compat v3.27.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.3+0; [0c68f7d7] GPUArrays v6.2.2; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.57.4; [d2c73de3] GR_jll v0.57.2+0; [5c1252a2] GeometryBasics v0.3.12; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.9.5; [615f187c] IfElse v0.1.0; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [c8e1da08] IterTools v1.3.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.3; [692b3bcd] JLLWrappers v1.3.0; [682c06a0] JSON v0.21.1; [0f8b85d8] JSON3 v1.8.0; [aacddb02] JpegTurbo_jll v2.0.1+3; [63c18a36] KernelAbstractions v0.5.5; [c1c5ebd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115:135,Adapt,Adapt,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115,1,['Adapt'],['Adapt']
Energy Efficiency,`time_step!` function for adaptive time stepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/431:26,adapt,adaptive,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/431,1,['adapt'],['adaptive']
Energy Efficiency,"`time_step_precomputations!` is. ```julia; function time_step_precomputations!(diffusivities, pressures, velocities, tracers, model). fill_halo_regions!(merge(velocities, tracers), model.boundary_conditions.solution, model.architecture,; model.grid, boundary_condition_function_arguments(model)...). calculate_diffusivities!(diffusivities, model.architecture, model.grid, model.closure, model.buoyancy,; velocities, tracers). fill_halo_regions!(diffusivities, model.boundary_conditions.diffusivities, model.architecture, model.grid). @launch(device(model.architecture), config=launch_config(model.grid, :xy),; update_hydrostatic_pressure!(pressures.pHY′, model.grid, model.buoyancy, tracers)). fill_halo_regions!(pressures.pHY′, model.boundary_conditions.pressure, model.architecture, model.grid). return nothing; end; ```. To implement the optimizations discussed in this issue, we need to also consider the calculation of hydrostatic pressure and nonlinear diffusivities to intertwine communication with interior tendency computation. Can this be done abstractly perhaps via some combination of launch configurations and macro specifications to `@loop_xyz`? This would allow us to exert control over the ""region"" of interior source term computation from the ""outside"", while keeping our kernels intact. Notice that the ""pre-computation"" of nonlinear diffusivities and the isolation of the hydrostatic pressure both add communication steps. We should monitor whether these become significantly suboptimal algorithms in the presence of expensive communication. We can easily combine hydrostatic pressure with nonhydrostatic pressure with no loss of performance (probably a small performance increase, in fact). We can also in principle calculate nonlinear diffusivities ""in-line"", though when we tried this previously we were unable to achieve good performance. Also, ""in-line"" calculation of diffusivities makes the application of diffusivity boundary conditions much more difficult (or impossible).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290:2932,monitor,monitor,2932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290,1,['monitor'],['monitor']
Energy Efficiency,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:758,energy,energy,758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618,3,['energy'],['energy']
Energy Efficiency,"aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | ... and [60 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=footer). Last update [0fe0d15...c70ed0e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822:3141,Power,Powered,3141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822,1,['Power'],['Powered']
Energy Efficiency,"a_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:3039,reduce,reducedim,3039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reducedim']
Energy Efficiency,"ably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's mo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:1063,energy,energy,1063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802,2,['energy'],['energy']
Energy Efficiency,"acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: BetaPlane{Float64}. julia> simulation; Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 20 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: 30 days; ├── Stop iteration : Inf; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 6 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ ├── nan_checker => typename(Callback); │ ├── wizard => typename(Callback); │ └── print_progress => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── fields => typename(JLD2OutputWriter); └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.output_writers[:fields]; JLD2OutputWriter scheduled on TimeInterval(1 hour):; ├── filepath: ./baroclinic_adjustment.jld2; ├── 3 outputs: (:ζ, :b, :c); ├── field slicer: FieldSlicer(:, :, 16, with_halos=false); ├── array type: Array{Float32}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB. julia> horizontal_closure; ScalarBiharmonicDiffusivity: (ν=8.623357172365541e10, κ=8.623357172365541e10), isotropy: Horizontal. julia> diffusive_closure; ScalarDiffusivity:; ν=0.01, κ=0.01; time discretization: VerticallyImplicit(); isotropy: Vertical; ```. # This PR. ```julia; julia> model; HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (b, c); ├── closure: Tuple with 2 closures:; │ ├── ScalarBiharmonicDiffusivity{Horizontal}(ν=8.62336e10, κ=(b=8.62336e10, c=8.62336e10)); │ └── ScalarDiffusivity{VerticallyImplicit, Ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529:1598,schedul,scheduled,1598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529,1,['schedul'],['scheduled']
Energy Efficiency,"ace_model_state.jl:59; │ [22] update_state!; │ @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:34 [inlined]; │ [23] update_state!; │ @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:31 [inlined]; │ [24] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, clock::Clock{Float32, Float32}, momentum_advection::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, tracer_advection::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, buoyancy::BuoyancyTracer, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{Nothing, Nothing, Nothing, Float64, Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, tracers::Tuple{Symbol, Symbol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:153842,Energy,EnergyConserving,153842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,3,['Energy'],['EnergyConserving']
Energy Efficiency,"acian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only works for systems sizes that are powers of 2. As we need to solve a system of `Nz+1` equations, this means models with `2^m - 1` vertical levels will be the most efficient. If we can use it here, then we might need a non-cyclic reduction solver for models without `2^m - 1` vertical levels.; * Probably not within this scope of this PR, but this solver should work on CPUs and GPUs and will eliminate the need for two different solvers, so we can probably unify solvers. We may still want to use cyclic reduction wherever we can. We should be able to use it for uniform vertical spacing and `Nz = 2^m - 1`. @maleadt's implementation was ~3x faster than the cuSPARSE implementation and ~22x faster than the serial implementation, so it would be a huge speedup. cc @sandreza as I might ask you questions about this. This work is based off:; https://gist.github.com/christophernhill/8952075d6e95df28adf36f5dff64115a; https://gist.github.com/christophernhill/a43317694c6d65ecd27758c1bdcdf3f1; https://gist.github.com/maleadt/1ec91b3b12ede9898958c95596cabe8b. Resolves #46; Helps with #47; Helps with #211",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306:2511,efficient,efficient,2511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306,1,['efficient'],['efficient']
Energy Efficiency,"ackages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ .\subarray.jl:290 [inlined]; [10] macro expansion; @ .\multidimensional.jl:917 [inlined]; [11] macro expansion; @ .\cartesian.jl:64 [inlined]; [12] macro expansion; @ .\multidimensional.jl:912 [inlined]; [13] _unsafe_getindex!; @ .\multidimensional.jl:925 [inlined]; [14] _unsafe_getindex(::IndexCartesian, ::SubArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Base.Slice{Base.OneTo{Int64}}, ::Int64, ::Base.Slice{Base.OneTo{Int64}}); @ Base .\multidimensional.jl:903; [15] _getindex; @ .\multidimensional.jl:889 [inlined]; [16] getindex(::SubArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Function, ::Int64, ::Function); @ Base .\abstractarray.jl:1291; [17] estimate_growth_rate(simulation::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, @NamedTuple{u::Field{Face, Center, Center, Nothing....; ```. To solve this error, I tried to add the same comment ```CUDA.@allowscalar``` to the last line of the code below. Now, the code is running without any errors. ```; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); #CUDA.allowscalar(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = CUDA.@allowscalar estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. Thank you. I genuinely appreciate your support. Please let me know about your suggestion about the added comment line (whether it is correct or not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164:3500,Power,Power,3500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164,1,['Power'],['Power']
Energy Efficiency,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11570,Adapt,Adapt,11570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['Adapt'],['Adapt']
Energy Efficiency,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2028,Adapt,Adapt,2028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Energy Efficiency,"advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1287,reduce,reduce,1287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"age 78.23% 78.28% +0.05% ; ==========================================; Files 118 118 ; Lines 2375 2390 +15 ; ==========================================; + Hits 1858 1871 +13 ; - Misses 517 519 +2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <0%> (-1.93%)` | :arrow_down: |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.44% <0%> (-0.44%)` | :arrow_down: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=footer). Last update [e90c52a...d614833](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665#issuecomment-594938926:2437,Power,Powered,2437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665#issuecomment-594938926,1,['Power'],['Powered']
Energy Efficiency,"age Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | |; | [src/Models/show\_models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9zaG93X21vZGVscy5qbA==) | `0% <ø> (ø)` | |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `100% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0% <0%> (ø)` | |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.75% <100%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.78% <88.88%> (ø)` | |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `84.21% <90.9%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=footer). Last update [c417701...9187570](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059:2659,Power,Powered,2659,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059,1,['Power'],['Powered']
Energy Efficiency,"aged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); ```. Makes. ```julia; julia> @time compute!(averaged_c); 1.576736 seconds (1.81 M allocations: 123.040 MiB, 99.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.450573 seconds (150.91 k allocations: 10.220 MiB, 7.82% gc time, 99.15% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.403323 seconds (150.90 k allocations: 10.217 MiB, 98.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearG",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:1295,reduce,reduced,1295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,"agree with Greg. I would prefer we get w by stepping forward for w because; then there are no concerns about rigid lids etc. We ended up using; continuity because the elliptic inversion was missing a div.v/delt source; term. When that problem got fixed I believe integrating forward for w works; just fine. Ali, can you confirm?. On Wed, Aug 7, 2019 at 8:16 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We originally did the recompilation of w from continuity partly because we; > thought this may prevent an accumulation of error that could otherwise; > occur, and partly because @sandreza <https://github.com/sandreza>; > convinced us this was more correct. But I would argue that because we; > haven't done model verification we aren't sure whether this is correct or; > not.; >; > Another issue, or annoyance, with recomputing w from continuity is that it; > is only valid in the case of rigid lids on top and bottom.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/336?email_source=notifications&email_token=AKXUEQUD4TCBCCFDIMAPNC3QDK4KXA5CNFSM4IJ2G5UKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD3YGJQY#issuecomment-519070915>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQPFPDDHQ2JSNTPR3TQDK4KXANCNFSM4IJ2G5UA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519073694:1498,Green,Green,1498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519073694,1,['Green'],['Green']
Energy Efficiency,"al reflection; zₚ = reshape(repeat(z₀, 5), size(xₚ)) # Vertical direction isn't periodic, so we just need to repeat and reshape things . resolved_noise(x, y, z) = sum(@. 1e-6 * exp(-(x-xₚ)^2/σx^2 -(z-zₚ)^2/σz^2)). constant_stratification(x, y, z) = 1e-5 * z; set!(model, u=resolved_noise, b=constant_stratification). u, v, w = model.velocities. simulation = Simulation(model, Δt=20.0, stop_iteration=1e4); progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)). e = (u^2 + w^2) / 2; E = Field(Integral(e, dims=:)); outputs = merge(model.velocities, model.tracers, (; e, E)). filename = ""test.jld2""; simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); et = FieldTimeSeries(filename, ""e""); bt = FieldTimeSeries(filename, ""b""); Et = FieldTimeSeries(filename, ""E""); times = wt.times; Nt = length(times). using GLMakie; fig = Figure(resolution=(900, 450)). axw = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)"", title=""Vertical velocity""); axe = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)"", title=""Kinetic energy""); axb = Axis(fig[1, 3], xlabel=""x (m)"", ylabel=""z (m)"", title=""Buoyancy""); axE = Axis(fig[2, 1:3], xlabel=""Time (s)"", ylabel=""Volume averaged kinetic energy""). n = Observable(1). wn = @lift interior(wt[$n], :, 1, :); en = @lift interior(et[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). x, y, z = nodes(et). wlim = maximum(abs, wt); elim = maximum(abs, et). heatmap!(axw, x, z, wn, colorrange=(-wlim, wlim), colormap=:balance); heatmap!(axe, x, z, en, colorrange=(0, elim), colormap=:solar); heatmap!(axb, x, z, bn, colorrange=(0, 1e-3), colormap=:thermal). t = @lift times[$n]; lines!(axE, times, Et[:]); vlines!(axE, t). display(fig). record(fig, ""test.mp4"", 1:Nt) do nn; @info ""Recording frame $nn of $Nt""; n[] = nn; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476:2095,energy,energy,2095,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476,2,['energy'],['energy']
Energy Efficiency,"ally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily specifiable. If we want an easy default, then maybe it could do some version of the unique directories? Or maybe have `overwrite_existing = false` (the default) just rename existing files?. I'm not sure of the best approach but as someone who's conservative about overwriting by default I'm tempted to err on the side of caution. > Another abstraction I think would be useful is a utility for building multiple outputs. Imagine this:; > ; > ```julia; > indices = (xy=(:, :, k), xz=(:, 1, :), yz=(1, :, :)); > sliced_outputs!(simulation, outputs, indices; schedule=TimeInterval(1), filename=""sliced""); > ```; > ; > this would append `filename` with the keys of `indices`, eg we would get 3 outputs titled `""sliced_xy""`, `""sliced_xz""`, and `""sliced_yz""`. Love this idea! Hoping that you can also pass e.g. `(surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :))` to get `sliced_surface`, `sliced_zonal`, and `sliced_meridional`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:2551,schedul,schedule,2551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,1,['schedul'],['schedule']
Energy Efficiency,"alo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `98.07% <100.00%> (+0.21%)` | :arrow_up: |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <100.00%> (-0.25%)` | :arrow_down: |; | [src/Simulations/simulation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3NpbXVsYXRpb24uamw=) | `68.75% <0.00%> (-6.25%)` | :arrow_down: |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `92.30% <0.00%> (+0.47%)` | :arrow_up: |; | [src/Buoyancy/seawater\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L3NlYXdhdGVyX2J1b3lhbmN5Lmps) | `74.07% <0.00%> (+3.48%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=footer). Last update [d80be8c...f384f90](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385:3267,Power,Powered,3267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385,1,['Power'],['Powered']
Energy Efficiency,"also worth checking out . https://github.com/rafaqz/DimensionalData.jl. the `Time` object is a ""selector"" in their terminology. IF we have something similar here, we could eventually consider sub typing `AbstractDimArray` (which has been proposed before), which gives us a lot of powerful functionality. Someone passionate about that stuff has to take that on for a full implementation but at least we are consistent with it, which helps",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696136206:280,power,powerful,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696136206,1,['power'],['powerful']
Energy Efficiency,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:1804,reduce,reduce,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,1,['reduce'],['reduce']
Energy Efficiency,"ananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <77.55%> (-14.67%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9mX3BsYW5lLmps) | `80.00% <80.00%> (ø)` | |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `82.60% <82.60%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | ... and [20 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=footer). Last update [eeb62d1...d5dfc74](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480:3289,Power,Powered,3289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480,1,['Power'],['Powered']
Energy Efficiency,"angeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, ...; @ Oceananigans.OutputWriters ~/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [9] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :T, :S), Tuple{Field{Face, Center, Center, Nothing, ...; @ Oceananigans.OutputWriters ./none:0; [10] iterate; @ ./generator.jl:47 [inlined]; [11] merge(a::NamedTuple{(), Tuple{}}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers....; @ Base ./namedtuple.jl:303; [12] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, ...; @ Base ./namedtuple.jl:123; [13] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, ....; @ Oceananigans.OutputWriters ~/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:179; [14] top-level scope; @ REPL[10]:1; ```. However, if I include halos in the output everything seems OK... ```Julia; simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; with_halos = true,; filename = ""surface"",; overwrite_existing = true); JLD2OutputWriter scheduled on TimeInterval(3.333 minutes):; ├── filepath: ./surface.jld2; ├── 1 outputs: η; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260:3694,schedul,schedule,3694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"anigans.jl/pull/130?src=pr&el=h1) Report; > Merging [#130](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/0947ba57b9f35a5ee721c951da8f6def89db0d70?src=pr&el=desc) will **decrease** coverage by `0.42%`.; > The diff coverage is `72.72%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #130 +/- ##; ==========================================; - Coverage 57.29% 56.87% -0.43% ; ==========================================; Files 19 19 ; Lines 644 647 +3 ; ==========================================; - Hits 369 368 -1 ; - Misses 275 279 +4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.33% <ø> (-4.91%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69.28% <72.72%> (-1.07%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=footer). Last update [0947ba5...f31e0b3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/130#issuecomment-473474188:1757,Power,Powered,1757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/130#issuecomment-473474188,1,['Power'],['Powered']
Energy Efficiency,"ans do we want sprinkled throughout the domain?; x₀ = grid.Lx * rand(N); z₀ = grid.Lz * rand(N) # Locations of the Gaussians. xₚ = x₀ .+ (grid.Lx .* [-2;;-1;;0;;1;;2]) # Make that noise periodic by ""infinite"" horizontal reflection; zₚ = reshape(repeat(z₀, 5), size(xₚ)) # Vertical direction isn't periodic, so we just need to repeat and reshape things . resolved_noise(x, y, z) = sum(@. 1e-6 * exp(-(x-xₚ)^2/σx^2 -(z-zₚ)^2/σz^2)). constant_stratification(x, y, z) = 1e-5 * z; set!(model, u=resolved_noise, b=constant_stratification). u, v, w = model.velocities. simulation = Simulation(model, Δt=20.0, stop_iteration=1e4); progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)). e = (u^2 + w^2) / 2; E = Field(Integral(e, dims=:)); outputs = merge(model.velocities, model.tracers, (; e, E)). filename = ""test.jld2""; simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); et = FieldTimeSeries(filename, ""e""); bt = FieldTimeSeries(filename, ""b""); Et = FieldTimeSeries(filename, ""E""); times = wt.times; Nt = length(times). using GLMakie; fig = Figure(resolution=(900, 450)). axw = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)"", title=""Vertical velocity""); axe = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)"", title=""Kinetic energy""); axb = Axis(fig[1, 3], xlabel=""x (m)"", ylabel=""z (m)"", title=""Buoyancy""); axE = Axis(fig[2, 1:3], xlabel=""Time (s)"", ylabel=""Volume averaged kinetic energy""). n = Observable(1). wn = @lift interior(wt[$n], :, 1, :); en = @lift interior(et[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). x, y, z = nodes(et). wlim = maximum(abs, wt); elim = maximum(abs, et). heatmap!(axw, x, z, wn, colorrange=(-wlim, wlim), colormap=:balance); heatmap!(axe, x, z, en, colorrange=(0, elim), colormap=:solar); heatmap!(axb, x, z, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476:1625,schedul,schedule,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476,1,['schedul'],['schedule']
Energy Efficiency,"ans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: 128×1×1 Field{Center, Face, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU. julia> ∫ᶻQ.u .= 0; ∫ᶻQ.v .= 0;; ```. I call. ```Julia; julia> sum!(∫ᶻQ.u, Ax * model.velocities.u);; ```. Now, when I print out `∫ᶻQ.u` I see that all its elements are supposedly 0:. ```; julia> ∫ᶻQ.u; 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 135×7×1 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, 1:1) with eltype Float64 with indices -2:132×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But this returns the right answer; ```; julia> maximum(∫ᶻQ.u.data); 8.0; ```. The velocity set by `set_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723:1937,reduce,reduced,1937,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723,2,['reduce'],['reduced']
Energy Efficiency,"ans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `70% <0%> (ø)` | :arrow_up: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <0%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `52.54% <0%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <0%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <0%> (ø)` | |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `88.7% <0%> (+1.2%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=footer). Last update [8c1c776...ee0b40e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/380#issuecomment-525911444:3708,Power,Powered,3708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380#issuecomment-525911444,1,['Power'],['Powered']
Energy Efficiency,"ans; using Oceananigans.Utils; using Oceananigans.Units. grid = RegularRectilinearGrid(size=(4, 4, 4), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:1277,schedul,schedule,1277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633,1,['schedul'],['schedule']
Energy Efficiency,"args{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:55; [3] default_dimensions(output::Dict{String, Field{…} where {…}}, grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:126; [4] initialize_nc_file!(filepath::String, outputs::Dict{…}, schedule::IterationInterval, array_type::Type{…}, indices::Tuple{…}, with_halos::Bool, global_attributes::Dict{…}, output_attributes::Dict{…}, dimensions::Dict{…}, overwrite_existing::Bool, deflatelevel::Int64, grid::ImmersedBoundaryGrid{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:755; [5] NetCDFOutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, grid::ImmersedBoundaryGrid{…}, dir::String, array_type::Type, indices::Tuple{…}, with_halos::Bool, global_attributes::Dict{…}, output_attributes::Dict{…}, dimensions::Dict{…}, overwrite_existing::Nothing, deflatelevel::Int64, part::Int64, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, verbose::Bool); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:486; [6] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775:2471,schedul,schedule,2471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775,2,['schedul'],['schedule']
Energy Efficiency,arth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ E,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:9204,Energy,Energy,9204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Energy'],['Energy']
Energy Efficiency,"ase.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:2207,reduce,reduce,2207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"ask=sponge_mask, target=0.0); forcing_sponge = (; u=uvw_sponge, v=uvw_sponge, w=uvw_sponge). model = HydrostaticFreeSurfaceModel(grid=grid, boundary_conditions=bcs,; momentum_advection=nothing, # Linear to compare with analytical solution.; closure=turbulence_closure,; forcing=forcing_sponge,; buoyancy=nothing,; coriolis=FPlane(f=f)). simulation = Simulation(model; Δt=Δt, stop_time=te). start_time = time_ns(); function log_message(sim); prog = 100*time(sim)/sim.stop_time; @printf(""[%05.2f%%] t: %1.1f Ti, Δt: %s, max|u, v, w|: %1.2f, %1.2f, %1.1e m s⁻¹, walltime: %s\n"",; prog, time(sim)/Ti, prettytime(sim.Δt),; maximum(abs, sim.model.velocities.u), maximum(abs, sim.model.velocities.v), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); end. simulation.callbacks[:progress] = Callback(log_message, IterationInterval(1)); outputs = (; u=model.velocities.u, v=model.velocities.v); simulation.output_writers[:fields2D] = NetCDFOutputWriter(model, outputs,; schedule=TimeInterval(outdt),; filename=fout,; overwrite_existing=true). run!(simulation). # Compare equilibrated numerical solution to the steady analytical solution. # Analytical solution to the steady problem (Estrade et al., 2008, Equation 15):; # u + i*v = (u₀ + i*v₀) * sinh(c*(z + h))/cosh(c*h) + 2*i*v₀ * ((1 - S₁) / (γ*T₁ - T₂)) * (1 - cosh(c*z)/cosh(c*h)). ds = Dataset(fout, ""r""); x, z = Array(ds[""xC""]), Array(ds[""zC""]). nl = size(ds[""u""])[end] - laststeps_avg; unum = mean(ds[""u""][:, 1, :, nl:end], dims=3)[:, : , 1]; vnum = mean(ds[""v""][:, 1, :, nl:end], dims=3)[:, : , 1]; unum = 0.5*(unum[2:end, :] + unum[1:end-1, :]) # Move u from xF to xC. h = @. hmin - slope*x. ɣ = f/abs(f); c = (1 + im*ɣ) * π/D; nz, nx = length(z), length(x). honD = h/D; hD = π*honD; honDmi = 0. α = @. (cosh(hD) * cos(hD))^2 + (sinh(hD) * sin(hD))^2; S₁ = @. cosh(hD) * cos(hD) * 1/α; S₂ = @. sinh(hD) * sin(ɣ * hD) * 1/α; T₁ = @. cosh(hD) * sinh(hD) * 1/α; T₂ = @. cos(hD) * sin(ɣ * hD) * 1/α. # Estrade et al.'s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2254094925:5145,schedul,schedule,5145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2254094925,1,['schedul'],['schedule']
Energy Efficiency,"aster](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/232aab2b8c3dc5cf6bc59931a197fde588d6be57?el=desc) will **increase** coverage by `0.28%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1078 +/- ##; ==========================================; + Coverage 56.91% 57.20% +0.28% ; ==========================================; Files 162 162 ; Lines 3811 3881 +70 ; ==========================================; + Hits 2169 2220 +51 ; - Misses 1642 1661 +19 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `59.75% <0.00%> (+2.61%)` | :arrow_up: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `68.08% <0.00%> (+3.79%)` | :arrow_up: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `82.22% <0.00%> (+4.44%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=footer). Last update [232aab2...96e4113](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-711070198:1903,Power,Powered,1903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-711070198,1,['Power'],['Powered']
Energy Efficiency,"at the moment, the default time stepping function is designed with the non-hydrostatic model in mind, so the logical steps of a time step (or substep for RK3) are. ```julia; step_variables!(...); calculate_pressure_correction!(...) ; pressure_correct_velocities!(...); compute_new_tendencies!(...); ```; In the hydrostatic model, we are extending the `step_variables!` function to include a `step_free_surface!` function that calculates `η` and we set ; ```julia; calculate_pressure_correction!(::HydrostaticFreeSurfaceModel, ...) = nothing; ```; I would like to calculate the free surface in the `calculate_pressure_correction!` function to unify conceptually the `NonhydrostaticModel` and the `HydrostaticFreeSurfaceModel`, minimize the amount of code, and reduce the necessity for extending the time-stepping function.; This will make it easier to implement new time-stepping schemes that work for both the models",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3895:759,reduce,reduce,759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3895,1,['reduce'],['reduce']
Energy Efficiency,"at, Bounded));. julia> bottom(x) = - underlying_grid.Lz + 500 * exp(-x^2 / (2*(20e3)^2));. julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom));. julia> c = Field{Center, Nothing, Nothing}(grid); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand()); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.952381, min=0.952381, mean=0.952381. julia> lines(c). julia> c; 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=NaN, min=NaN, mean=NaN; ```. After plotting a field then it has NaNs. Is this OK?; Of course, we expect that because we masked it in immersed regions. Is the issue here the show me",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749:1002,reduce,reduced,1002,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749,1,['reduce'],['reduced']
Energy Efficiency,"ation experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:1212,Green,Green,1212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['Green'],['Green']
Energy Efficiency,"averaged_c); 0.404525 seconds (150.90 k allocations: 10.221 MiB, 98.74% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.412531 seconds (150.90 k allocations: 10.219 MiB, 98.85% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.007040 seconds (204 allocations: 44.438 KiB); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:3997,reduce,reduced,3997,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,"ay has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstracti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1827,Adapt,Adapt,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Energy Efficiency,"b3BpY19kaWZmdXNpdml0eS5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `0% <0%> (ø)` | |; | [src/TurbulenceClosures/closure\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX3R1cGxlcy5qbA==) | `50% <100%> (-50%)` | :arrow_down: |; | [...mplementations/constant\_anisotropic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2NvbnN0YW50X2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `33.33% <26.31%> (-66.67%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `66.66% <33.33%> (-13.59%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=footer). Last update [8666964...7a765f2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/518#issuecomment-548737546:3192,Power,Powered,3192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/518#issuecomment-548737546,1,['Power'],['Powered']
Energy Efficiency,"b3JzLmps) | `100.00% <0.00%> (ø)` | |; | [...urbulenceClosures/viscous\_dissipation\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92aXNjb3VzX2Rpc3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <0.00%> (ø)` | |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100.00% <0.00%> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `37.93% <0.00%> (+1.08%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=footer). Last update [f18daed...0358145](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/782#issuecomment-652577566:3749,Power,Powered,3749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782#issuecomment-652577566,1,['Power'],['Powered']
Energy Efficiency,"bG93V2F0ZXJNb2RlbHMvc2V0X3NoYWxsb3dfd2F0ZXJfbW9kZWwuamw=) | `0.00% <0.00%> (ø)` | |; | [...c/Models/ShallowWaterModels/shallow\_water\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc2hhbGxvd193YXRlcl9tb2RlbC5qbA==) | `0.00% <0.00%> (ø)` | |; | [...els/ShallowWaterModels/show\_shallow\_water\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc2hvd19zaGFsbG93X3dhdGVyX21vZGVsLmps) | `0.00% <0.00%> (ø)` | |; | [...allowWaterModels/solution\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc29sdXRpb25fYW5kX3RyYWNlcl90ZW5kZW5jaWVzLmps) | `0.00% <0.00%> (ø)` | |; | [src/Models/ShallowWaterModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvdXBkYXRlX3N0YXRlLmps) | `0.00% <0.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `75.00% <ø> (ø)` | |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=footer). Last update [7c8c0cf...6112c6c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729133987:3724,Power,Powered,3724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729133987,1,['Power'],['Powered']
Energy Efficiency,"bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=10.0, max_change=1.1, max_Δt=1minute,cell_advection_timescale = accurate_cell_advection_timescale). start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=wizard, stop_time=40minutes, iteration_interval=10,; progress=progress_message); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586:3674,schedul,schedule,3674,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586,1,['schedul'],['schedule']
Energy Efficiency,"bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_solver(reduced_precision_grid); pressure_solver = ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=1000, regularization=1/N^3). model = NonhydrostaticModel(; grid, boundary_conditions, pressure_solver); simulation = Simulation(model; Δt=0.1, stop_iteration=1000); conjure_time_step_wizard!(simulation, cfl=0.5). u, v, w = model.velocities; δ = ∂x(u) + ∂y(v) + ∂z(w). function progress(sim); model = sim.model; u, v, w = model.velocities; @printf(""Iter: %d, time: %.1f, Δt: %.2e, max|δ|: %.2e"",; iteration(sim), time(sim), sim.Δt, maximum(abs, δ)). r = model.pressure_solver.conjugate_gradient_solver.residual; @printf("", solver iterations: %d, max|r|: %.2e\n"",; iteration(model.pressure_solver), maximum(abs, r)); end. add_callback!(simulation, progress). simulation.output_writers[:fields] =; JLD2OutputWriter(model, model.velocities; filename=""3831.jld2"", schedule=IterationInterval(10), overwrite_existing=true). run!(simulation). using GLMakie. ds = FieldDataset(""3831.jld2""); fig = Figure(size=(1000, 500)). n = Observable(1); times = ds[""u""].times; title = @lift @sprintf(""time = %s"", prettytime(times[$n])). Nx, Ny, Nz = size(grid); j = round(Int, Ny/2); k = round(Int, Nz/2); u_surface = @lift view(ds[""u""][$n], :, :, k); u_slice = @lift view(ds[""u""][$n], :, j, :). ax1 = Axis(fig[1, 1]; title = ""u (xy)"", xlabel=""x"", ylabel=""y""); hm1 = heatmap!(ax1, u_surface, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 2], hm1, label=""m/s""). ax2 = Axis(fig[1, 3]; title = ""u (xz)"", xlabel=""x"", ylabel=""z""); hm2 = heatmap!(ax2, u_slice, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 4], hm2, label=""m/s""). fig[0, :] = Label(fig, title). record(fig, ""3831.mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848:2464,schedul,schedule,2464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848,1,['schedul'],['schedule']
Energy Efficiency,"best to avoid lowercase `l` I think. Why don't we just keep capital `N` for now. I think we could have some changes coming down the pipe that would greatly facilitate this change (macro that pastes our triple loop, so reduce that massive amount of boilerplate and can change syntax in single place rather than 30 different locations). I thought `RegularCartesianGrid(FT, nx, ny, nz; length) ` could dispatch on its 4 positional args. What is the conflicting function `RegularCartesianGrid` that has 4 positional args, and why can't dispatch be used there?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204333:218,reduce,reduce,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204333,1,['reduce'],['reduce']
Energy Efficiency,"blow up. This can be illustrated with the following example:. ```julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded), size = (64, 32), x = (0, 400), z = (0, 100)). model = NonhydrostaticModel(; grid, timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; buoyancy = BuoyancyTracer(),; tracers = :b,; ). noise(x, y, z) = 1e-6 * rand(); @inline constant_stratification(x, y, z) = 1e-5 * z; set!(model, u = noise, b = constant_stratification). using Statistics: mean; model.velocities.u.data.parent .-= mean(model.velocities.u). simulation = Simulation(model, Δt = 100, stop_time = 1day); wizard = TimeStepWizard(max_change=1.1, cfl=0.7); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4)). B = Field(model.tracers.b + model.background_fields.tracers.b); simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; model.velocities..., B);; filename = ""bbl.nc"",; schedule = TimeInterval(10minutes),; overwrite_existing = true); run!(simulation); ```. The example above sets up a 2D (xz) domain in which `b` is initially (stably) linearly stratified . All the boundary conditions are default, and the only other IC modification is to add a zero-mean small-scale noise (1e-6 m/s) to `u`. I'd expect this to remain quasi-quiescent. Instead, this is what I get:. https://user-images.githubusercontent.com/13205162/220440495-ab5466f3-5ad9-4c68-81c2-5ada1b422318.mp4. The code to plot the animation can be found [here](https://pastebin.com/ZB41VFPE). The same thing happens when `b=0` initially and the linear stratification is instead included as a `BackgroundVelocity`. For example, if I remove the drag boundary condition from the [tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/#) and add the same zero-mean noise, the same issue happens:. https://user-images.githubusercontent.com/13205162/220441379-9f8c83ce-2414-45e1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935:1098,schedul,schedule,1098,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935,1,['schedul'],['schedule']
Energy Efficiency,"bstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <0.00%> (-33.34%)` | :arrow_down: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `61.11% <0.00%> (-23.10%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (-22.23%)` | :arrow_down: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <0.00%> (-20.00%)` | :arrow_down: |; | ... and [37 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=footer). Last update [6502f07...e778d2d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/720#issuecomment-605402183:3576,Power,Powered,3576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/720#issuecomment-605402183,1,['Power'],['Powered']
Energy Efficiency,"c, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}}, outputs::NamedTuple{(:a_field,), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, array_type::Type, max_filesize::Float64, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{Symbol}, verbose::Bool, part::Int64, jld2_kw::Dict{Symbol, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/jld2_output_writer.jl:179; [13] top-level scope; @ REPL[17]:1; [14] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:65055,schedul,schedule,65055,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061,1,['schedul'],['schedule']
Energy Efficiency,"c/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86.11% <ø> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.56% <0%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `52.74% <0%> (-0.59%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX3R1cGxlcy5qbA==) | `100% <100%> (ø)` | |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `70% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=footer). Last update [2803ace...590f224](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/517#issuecomment-548111479:2771,Power,Powered,2771,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/517#issuecomment-548111479,1,['Power'],['Powered']
Energy Efficiency,"c3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `100% <ø> (+85.71%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <ø> (ø)` | :arrow_up: |; | [src/Operators/momentum\_advection\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9tb21lbnR1bV9hZHZlY3Rpb25fb3BlcmF0b3JzLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | ... and [40 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=footer). Last update [9fbbc93...8e51fdc](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-560540863:3641,Power,Powered,3641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-560540863,1,['Power'],['Powered']
Energy Efficiency,"c3RydWN0aW9uLmps) | `0.00% <0.00%> (-60.00%)` | :arrow_down: |; | [src/Coriolis/beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2JldGFfcGxhbmUuamw=) | `0.00% <0.00%> (-58.83%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `0.00% <0.00%> (-58.07%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `0.00% <0.00%> (-54.17%)` | :arrow_down: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `28.94% <0.00%> (-50.01%)` | :arrow_down: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `0.00% <0.00%> (-44.28%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `47.36% <0.00%> (-32.64%)` | :arrow_down: |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=footer). Last update [03a6f85...c717dd5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894:3598,Power,Powered,3598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894,1,['Power'],['Powered']
Energy Efficiency,"c=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `71.42% <0%> (+4.76%)` | :arrow_up: |; | [src/Operators/interpolation\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9pbnRlcnBvbGF0aW9uX29wZXJhdG9ycy5qbA==) | `64.28% <0%> (+4.76%)` | :arrow_up: |; | [src/Operators/derivative\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9kZXJpdmF0aXZlX29wZXJhdG9ycy5qbA==) | `90.62% <0%> (+32%)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `100% <0%> (+50%)` | :arrow_up: |; | [...ure\_implementations/leith\_enstrophy\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2xlaXRoX2Vuc3Ryb3BoeV9kaWZmdXNpdml0eS5qbA==) | `98.38% <0%> (+66.12%)` | :arrow_up: |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `100% <0%> (+85.71%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=footer). Last update [a511fdd...e187583](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-562859953:3263,Power,Powered,3263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-562859953,1,['Power'],['Powered']
Energy Efficiency,"c=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69% <100%> (-2.98%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `88.57% <100%> (+37.14%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (+0.37%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `66.66% <61.29%> (+7.51%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <71.42%> (-0.66%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `83.33% <75%> (+20.83%)` | :arrow_up: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=footer). Last update [a26da9c...db0165c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942485:3456,Power,Powered,3456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942485,1,['Power'],['Powered']
Energy Efficiency,"cCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:3282,reduce,reducedim,3282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reducedim']
Energy Efficiency,"ceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `69.23% <0.00%> (-30.77%)` | :arrow_down: |; | [src/Advection/weno\_reconstruction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX3JlY29uc3RydWN0aW9uLmps) | `63.15% <0.00%> (-27.17%)` | :arrow_down: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `40.00% <0.00%> (-26.67%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `5.40% <0.00%> (-21.63%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `83.33% <0.00%> (-16.67%)` | :arrow_down: |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `65.00% <0.00%> (-1.67%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | ... and [92 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=footer). Last update [e808a82...ba06f1a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1000#issuecomment-700426227:3452,Power,Powered,3452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1000#issuecomment-700426227,1,['Power'],['Powered']
Energy Efficiency,"ceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `74.19% <0%> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.71% <100%> (+0.24%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.85% <100%> (+0.17%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.05% <86.36%> (+18.76%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.14% <90%> (+3.86%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.33% <91.66%> (-0.8%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=footer). Last update [e65a74a...379df34](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527186190:3007,Power,Powered,3007,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527186190,1,['Power'],['Powered']
Energy Efficiency,"changes in this PR. instead of doing individual halo filling for each fill, ex:; ```; fill_halo_regions(<:Tuple, args...); for field in fields ; fill_halo_regions!(field, args...); end; ```. we'll lump all the fields together in a kernel,; (Reduced Fields and Windowed Fields will have to be done separately). This PR also removes `architecture` from `fill_halo_regions!` signature",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335:241,Reduce,Reduced,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335,1,['Reduce'],['Reduced']
Energy Efficiency,"chine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.05% <0%> (+1.09%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `82.38% <0%> (+2.27%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=footer). Last update [d32cf20...db00c29](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-533606372:2990,Power,Powered,2990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-533606372,1,['Power'],['Powered']
Energy Efficiency,"chine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <ø> (ø)` | :arrow_up: |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `75.86% <0%> (+10.34%)` | :arrow_up: |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `50% <0%> (-50%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `79.31% <0%> (-4.33%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `61.05% <0%> (-2.78%)` | :arrow_down: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `51.85% <0%> (-9.02%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.81% <100%> (+0.25%)` | :arrow_up: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `88% <0%> (+1.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=footer). Last update [d27ab4f...30319ec](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570#issuecomment-566756764:2817,Power,Powered,2817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570#issuecomment-566756764,1,['Power'],['Powered']
Energy Efficiency,"ckages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407 [inlined]; [23] initialize_free_sur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11641,Adapt,Adapt,11641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['Adapt'],['Adapt']
Energy Efficiency,"ckages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKerne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2099,Adapt,Adapt,2099,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `85.71% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `87.5% <ø> (+3.12%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.96% <100%> (+0.34%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `9.09% <0%> (-13.64%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.98% <0%> (-5.8%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=footer). Last update [b6b27af...6d0b6d5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/101#issuecomment-468943943:2836,Power,Powered,2836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/101#issuecomment-468943943,2,['Power'],['Powered']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/382?src=pr&el=h1) Report; > Merging [#382](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/8c1c776b50df17ff10735e57488f22b20d455303?src=pr&el=desc) will **increase** coverage by `0.13%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #382 +/- ##; =========================================; + Coverage 78.37% 78.5% +0.13% ; =========================================; Files 22 22 ; Lines 1244 1247 +3 ; =========================================; + Hits 975 979 +4 ; + Misses 269 268 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77% <100%> (+0.5%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `98.4% <0%> (+0.78%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=footer). Last update [8c1c776...424d943](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525955144:1736,Power,Powered,1736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525955144,1,['Power'],['Powered']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/475?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #475 +/- ##; ==========================================; - Coverage 72.07% 69.12% -2.95% ; ==========================================; Files 26 26 ; Lines 1418 1490 +72 ; ==========================================; + Hits 1022 1030 +8 ; - Misses 396 460 +64; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `48.83% <0%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.34% <20%> (-25.91%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `60.18% <29.41%> (-29.96%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.97% <95.23%> (+0.94%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=footer). Last update [211e18c...9a622f0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-541976850:2277,Power,Powered,2277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-541976850,1,['Power'],['Powered']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/613?src=pr&el=h1) Report; > Merging [#613](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/f080635b93bdab9da7d1189ed21f27523c0ff810?src=pr&el=desc) will **not change** coverage.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #613 +/- ##; =======================================; Coverage 74.55% 74.55% ; =======================================; Files 117 117 ; Lines 2209 2209 ; =======================================; Hits 1647 1647 ; Misses 562 562; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/BoundaryConditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=footer). Last update [f080635...e714993](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/613#issuecomment-581647856:1736,Power,Powered,1736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/613#issuecomment-581647856,1,['Power'],['Powered']
Energy Efficiency,"cmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <0.00%> (-16.67%)` | :arrow_down: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <0.00%> (-13.34%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `48.38% <0.00%> (-3.54%)` | :arrow_down: |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | | |; | [...vection/topologically\_conditional\_interpolation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90b3BvbG9naWNhbGx5X2NvbmRpdGlvbmFsX2ludGVycG9sYXRpb24uamw=) | | |; | ... and [184 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=footer). Last update [0fb5286...ab3e539](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-571334236:3499,Power,Powered,3499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-571334236,1,['Power'],['Powered']
Energy Efficiency,"codecov.io/gh/CliMA/Oceananigans.jl/commit/80fb511ff5a5bb641481b6209ca101ea8c4b8149&el=desc) will **decrease** coverage by `0.11%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #807 +/- ##; ==========================================; - Coverage 71.15% 71.04% -0.12% ; ==========================================; Files 186 186 ; Lines 4839 4824 -15 ; ==========================================; - Hits 3443 3427 -16 ; - Misses 1396 1397 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `90.74% <100.00%> (-0.49%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <100.00%> (-5.32%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=footer). Last update [80fb511...7e95ea6](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101:1917,Power,Powered,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101,1,['Power'],['Powered']
Energy Efficiency,"codecov.io/gh/climate-machine/Oceananigans.jl/commit/cde6246ac753b206d81167dbc024521e8c7276c7?src=pr&el=desc) will **decrease** coverage by `0.08%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #172 +/- ##; ==========================================; - Coverage 68.79% 68.71% -0.09% ; ==========================================; Files 18 18 ; Lines 657 652 -5 ; ==========================================; - Hits 452 448 -4 ; + Misses 205 204 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <100%> (+0.02%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=footer). Last update [cde6246...c3a3c3d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481421290:1917,Power,Powered,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481421290,1,['Power'],['Powered']
Energy Efficiency,"codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #352 +/- ##; ==========================================; + Coverage 72.86% 72.89% +0.03% ; ==========================================; Files 22 22 ; Lines 1157 1214 +57 ; ==========================================; + Hits 843 885 +42 ; - Misses 314 329 +15; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `43.9% <0%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `61.42% <100%> (+1.72%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `50% <47.56%> (+37.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=footer). Last update [7a4142c...5bbb71e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223462:2263,Power,Powered,2263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223462,1,['Power'],['Powered']
Energy Efficiency,"commit/e83d621859dd660e4576024ab461dafa46ff45bc?src=pr&el=desc) will **increase** coverage by `0.26%`.; > The diff coverage is `78.57%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #490 +/- ##; ==========================================; + Coverage 73.22% 73.48% +0.26% ; ==========================================; Files 27 27 ; Lines 1505 1516 +11 ; ==========================================; + Hits 1102 1114 +12 ; + Misses 403 402 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `68.18% <78.57%> (+8.18%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `68.53% <0%> (+4.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=footer). Last update [e83d621...de5764b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/490#issuecomment-544486641:1963,Power,Powered,1963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/490#issuecomment-544486641,1,['Power'],['Powered']
Energy Efficiency,"complex geometries in the 1980s. That also would not require us to change; the solver. You carry out Green's function calculations in a rectangular; region where the delta-functions vorticities are placed at the positions of; the irregular boundary within the larger rectangular region. I will look; them out. John. On Sat, Mar 28, 2020 at 11:20 AM Gregory L. Wagner <notifications@github.com>; wrote:. > @johncmarshall54 <https://github.com/johncmarshall54> agreed, that's a; > challenge we have to confront.; >; > If we implement immersed boundaries using the ""continuous forcing; > technique"", then a boundary may be defined essentially by a masking; > function. In this case, we might be able to ""label"" each boundary / masking; > function with a name or number.; >; > The boundary condition objects we then give to fields would have to define; > a condition to be applied both at the boundaries of the numerical grid; > (which we currently support), as well as any immersed boundaries, where; > immersed boundaries are referenced by name or number.; >; > By the way, if we use a continuous forcing technique, we do not have to; > change the pressure solver. This is a major simplification. Recent work; > suggests there is no disadvantage in terms of accuracy in using the; > continuous forcing technique, either. I'm not sure if this is too good to; > believe or not --- we should discuss and take a deeper look at the; > literature.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605461456>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQHGXSSKOU7EIXSLBTRJYIVFANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623:1924,Green,Green,1924,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623,1,['Green'],['Green']
Energy Efficiency,"compressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7084,energy,energy,7084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['energy'],['energy']
Energy Efficiency,"convert_diffusivity(FT, κ), strain_rate); end; end; ```. where `strain_rate = Traceless()` would inform the turbulence closure to use the traceless rate of strain. Stress divergences are computed here:. https://github.com/climate-machine/Oceananigans.jl/blob/042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc/src/TurbulenceClosures/closure_operators.jl#L38. For example, one component of the stress divergence is:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, closure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, Σ₁₁, U.u, U.v, U.w); ```. We can thus *extend* functionality via dispatch:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, ::TracelessStrainRateClosure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, traceless_Σ₁₁, U.u, U.v, U.w); ```. where `TracelessStrainRateClosure` is an alias for a closure that requires the traceless strain rate. > A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. This is how the system already works for closures that don't have eddy diffusivities. Is something different from the current system being proposed?. > @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Currently, the `calculate_diffusivities!` functions receives `buoyancy`, `velocities`, and `tracers`, as arguments:. https://github.com/climate-machine/Oceananigans.jl/blob/042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L176. If a different abstraction is needed we can change the `calculate_diffusivities` function appropriately. As for ensuring that compressible models always use the correct strain rate, this can be handled within the `CompressibleModel` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479:2428,energy,energy,2428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479,1,['energy'],['energy']
Energy Efficiency,"coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:1419,schedul,schedule,1419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633,1,['schedul'],['schedule']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=h1) Report; > Merging [#1161](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=desc) (8124ad7) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/0c2b51293d324836846f31ab93c7515b05e797b5?el=desc) (0c2b512) will **increase** coverage by `0.38%`.; > The diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1161 +/- ##; ==========================================; + Coverage 57.01% 57.39% +0.38% ; ==========================================; Files 162 162 ; Lines 3913 3962 +49 ; ==========================================; + Hits 2231 2274 +43 ; - Misses 1682 1688 +6 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `85.54% <66.66%> (-2.62%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.30% <0.00%> (+2.64%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=footer). Last update [0c2b512...8124ad7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1161#issuecomment-724397486:1744,Power,Powered,1744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1161#issuecomment-724397486,1,['Power'],['Powered']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/92d77b028d39014e2818d2d1fe56038fd1810256&el=desc) will **increase** coverage by `0.05%`.; > The diff coverage is `84.61%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #745 +/- ##; ==========================================; + Coverage 77.05% 77.10% +0.05% ; ==========================================; Files 123 124 +1 ; Lines 2462 2477 +15 ; ==========================================; + Hits 1897 1910 +13 ; - Misses 565 567 +2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/Forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvRm9yY2luZy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Forcing/relaxation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcmVsYXhhdGlvbi5qbA==) | `84.61% <84.61%> (ø)` | |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `80.00% <0.00%> (+5.00%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=footer). Last update [92d77b0...63f9f11](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/745#issuecomment-622493232:1838,Power,Powered,1838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/745#issuecomment-622493232,1,['Power'],['Powered']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/7f957d7762b61ee4e51b360944428d5b660d50bf&el=desc) will **increase** coverage by `0.04%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #772 +/- ##; ==========================================; + Coverage 77.65% 77.70% +0.04% ; ==========================================; Files 165 165 ; Lines 4404 4413 +9 ; ==========================================; + Hits 3420 3429 +9 ; Misses 984 984 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `100.00% <ø> (ø)` | |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `84.61% <100.00%> (+4.61%)` | :arrow_up: |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=footer). Last update [7f957d7...c19f69c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/772#issuecomment-641394370:1838,Power,Powered,1838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/772#issuecomment-641394370,1,['Power'],['Powered']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=h1) Report; > Merging [#794](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/d383b6a27fc95837b591bd1e68e1aaca50f97da6&el=desc) will **decrease** coverage by `0.62%`.; > The diff coverage is `0.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #794 +/- ##; ==========================================; - Coverage 71.67% 71.05% -0.63% ; ==========================================; Files 184 186 +2 ; Lines 4781 4823 +42 ; ==========================================; Hits 3427 3427 ; - Misses 1354 1396 +42 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | `0.00% <0.00%> (ø)` | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=footer). Last update [d383b6a...c6d7bbe](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657608828:1746,Power,Powered,1746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657608828,1,['Power'],['Powered']
Energy Efficiency,"cov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=h1) Report; > Merging [#228](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/ca03838d46fd4905379a1bc08697be5bcfcf99ef?src=pr&el=desc) will **increase** coverage by `0.29%`.; > The diff coverage is `50%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #228 +/- ##; ==========================================; + Coverage 67.25% 67.55% +0.29% ; ==========================================; Files 18 18 ; Lines 675 675 ; ==========================================; + Hits 454 456 +2 ; + Misses 221 219 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <50%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.35% <0%> (+3.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=footer). Last update [ca03838...0f59662](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220658:1709,Power,Powered,1709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220658,1,['Power'],['Powered']
Energy Efficiency,"cov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=h1) Report; > Merging [#228](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/ca03838d46fd4905379a1bc08697be5bcfcf99ef?src=pr&el=desc) will **increase** coverage by `0.29%`.; > The diff coverage is `50%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #228 +/- ##; ==========================================; + Coverage 67.25% 67.55% +0.29% ; ==========================================; Files 18 18 ; Lines 675 675 ; ==========================================; + Hits 454 456 +2 ; + Misses 221 219 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <50%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.35% <0%> (+3.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=footer). Last update [ca03838...4bb6f50](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220644:1709,Power,Powered,1709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220644,1,['Power'],['Powered']
Energy Efficiency,"coverage by `0.03%`.; > The diff coverage is `85.36%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #464 +/- ##; ==========================================; - Coverage 73.34% 73.31% -0.04% ; ==========================================; Files 27 27 ; Lines 1508 1525 +17 ; ==========================================; + Hits 1106 1118 +12 ; - Misses 402 407 +5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `47.67% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `79.54% <66.66%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `83.33% <86.84%> (-10.22%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `80.64% <0%> (+3.22%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=footer). Last update [41a2b55...cab311e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-545240667:2045,Power,Powered,2045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-545240667,1,['Power'],['Powered']
Energy Efficiency,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:4284,reduce,reduced,4284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['reduce'],['reduced']
Energy Efficiency,"cs. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; -",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:1081,schedul,schedule,1081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,1,['schedul'],['schedule']
Energy Efficiency,"cted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #237 +/- ##; ==========================================; + Coverage 73.92% 74.04% +0.12% ; ==========================================; Files 23 23 ; Lines 859 863 +4 ; ==========================================; + Hits 635 639 +4 ; Misses 224 224; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `83.33% <ø> (+16.66%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `83.72% <50%> (-0.99%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `67.74% <86.95%> (+12.56%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.54% <0%> (-5.41%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=footer). Last update [1e693f8...f7eb047](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/237#issuecomment-495868818:2107,Power,Powered,2107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/237#issuecomment-495868818,2,['Power'],['Powered']
Energy Efficiency,"cted. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7988,Energy,Energy,7988,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Energy'],['Energy']
Energy Efficiency,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1787,Adapt,Adapt,1787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['Adapt'],['Adapt']
Energy Efficiency,"d = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.00649",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6102,adapt,adapt,6102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['adapt'],['adapt']
Energy Efficiency,"d specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case,. For `GridFittedImmersedBoundary` the normal direction can be easily and efficiently inferred from the masking function by evaluating it at offset `i`, `j`, `k`. If fluid is adjacent to solid in any of those directions, you are on a boundary with a normal in the `x, y, z` direction (respectively), and the sign of the normal direction can be inferred from the offset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517:2081,efficient,efficiently,2081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517,1,['efficient'],['efficiently']
Energy Efficiency,"d]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:541 [inlined]; [5] Δzᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.jl:317 [inlined]; [12] macro expansion; @ ./simdloop.jl:77 [inlined]; [13] _mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:316; [14] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:324; [15] sum!(f::Function, r::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:1034; [16] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}; condition::Nothing, mask::Int64, kwargs::@Kwargs{}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:696; [17] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:690; [18] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitAuxiliaryFields(grid::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, CPU}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:237; [19] materialize_free_surface(free_surface::SplitExplicitFreeSurface{…}, velocities::@NamedTuple{…}, grid::ImmersedBoundaryGrid{…})",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:2632,reduce,reducedim,2632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['reduce'],['reducedim']
Energy Efficiency,"decov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmllbGRfc2xpY2VyLmps) | `69.69% <0.00%> (-6.97%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `51.92% <0.00%> (-5.53%)` | :arrow_down: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `40.00% <ø> (ø)` | |; | [src/Utils/output\_writer\_diagnostic\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL291dHB1dF93cml0ZXJfZGlhZ25vc3RpY191dGlscy5qbA==) | `83.33% <ø> (+1.19%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.31% <33.33%> (-6.26%)` | :arrow_down: |; | [src/Utils/schedules.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3NjaGVkdWxlcy5qbA==) | `45.45% <45.45%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `85.29% <66.66%> (-0.22%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `82.65% <72.22%> (-10.38%)` | :arrow_down: |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-712120955:2456,schedul,schedules,2456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-712120955,1,['schedul'],['schedules']
Energy Efficiency,"decov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=h1) Report; > Merging [#302](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/c3428825442f8d155b3128a0f79797ba8f070f68?src=pr&el=desc) will **increase** coverage by `0.84%`.; > The diff coverage is `92.53%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #302 +/- ##; ==========================================; + Coverage 71.8% 72.64% +0.84% ; ==========================================; Files 24 24 ; Lines 1000 1031 +31 ; ==========================================; + Hits 718 749 +31 ; Misses 282 282; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `20% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `81.3% <92.42%> (+3.16%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=footer). Last update [c342882...a0e8a14](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302#issuecomment-506989260:1724,Power,Powered,1724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302#issuecomment-506989260,1,['Power'],['Powered']
Energy Efficiency,"decov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=h1) Report; > Merging [#915](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/6d349e1d85d61ff997f249881cd58232de865996?el=desc) will **increase** coverage by `0.07%`.; > The diff coverage is `96.07%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #915 +/- ##; ==========================================; + Coverage 72.60% 72.67% +0.07% ; ==========================================; Files 191 191 ; Lines 5610 5622 +12 ; ==========================================; + Hits 4073 4086 +13 ; + Misses 1537 1536 -1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `77.63% <91.66%> (-0.15%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `93.62% <100.00%> (+0.31%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=footer). Last update [6d349e1...22e9b04](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/915#issuecomment-687316456:1727,Power,Powered,1727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915#issuecomment-687316456,1,['Power'],['Powered']
Energy Efficiency,"define multiple times:; 1. Slices (`xy_surface`, `xy_subsurface`, `xy_middepth`, `xy_bottom`, `xz`, `yz`).; 2. Sets of computed fields (`horizontal_averages`, `volume_averages`). # Saving collections of slices. For number 1, I can imagine an abstraction, perhaps a collection of output writers like `NetCDFOutputWriters`, that allows you to specify a number of slice outputs for all fields:. ```julia; slices = (all = FieldSlicer(),; xy_surface = FieldSlicer(k=grid.Nz),; xy_subsurface = FieldSlicer(k=k_subsurface),; xy_middepth = FieldSlicer(k=round(Int, grid.Nz/2)),; xy_bottom = FieldSlicer(k=1),; xz = FieldSlicer(j=1),; yz = FieldSlicer(i=1)). simulation.output_writers[:slices] = NetCDFOutputWriters(filepath_prefix=""eady_turbulence"", slices=slices, ...); ```. This would save all fields in `merge(model.velocities, model.tracers)` to `eady_turbulence_all.nc`, `eady_turbulence_xy_surface.nc`, etc. with appropriate slicing. You could pass in one schedule for all slices, or a named tuple of schedules if you want different schedules for different output writers. I think it makes sense to have a `filepath_prefix` for the collection of output writers, e.g. `NetCDFOutputWriters`, while just `filepath` for individual output writers, e.g. `NetCDFOutputWriter`. I thought about adding this functionality to the `Simulation` constructor with kwargs like `output=:netcdf` or `output=:jld2` but felt like the number of extra kwargs would just make it messy. # Saving collections of computed fields. For number 2, we could perhaps automate some of this to avoid boilerplate like https://github.com/glwagner/EadyTurbulence/blob/6581af1cd867d8ad69dac7ea09deb3078c505c24/initial_value_problem/eady_initial_value_problem.jl#L149-L163. Not sure if we want yet another super-constructor but one idea is to add something like `AveragedNetCDFOutputWriter`. ```julia; averages = (u=u, v=v, b=b, ζ²=ζ², b²=b², bz=∂z(b)). simulations.output_writers[:horizontal_averages] = AveragedNetCDFOutputWriter(model, ave",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726162256:1143,schedul,schedule,1143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726162256,3,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"del = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:1098,schedul,schedule,1098,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['schedul'],['schedule']
Energy Efficiency,"delT is the timestep, not something one chooses, isn't it?; Before squaring this away as done we need to discuss together and include; J-M and Chris in the discussions.; John. On Thu, May 23, 2019 at 9:32 AM Ali Ramadhan <notifications@github.com>; wrote:. > Never mind, think I figured it out. You were right: the div(u) is supposed; > to be divided by Δt.; >; > Not sure I understand what the MITgcm manual §2.9 is saying, but now the; > velocity field is indeed incompressible for Δt ≠ 1 (I tested Δt = 0.05 and; > Δt = 5).; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/228?email_source=notifications&email_token=AKXUEQQ2YLNKD6G7F7623W3PW2MGHA5CNFSM4HOZAKC2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWCHHII#issuecomment-495219617>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWMDGLIY7UABLVET4DPW2MGHANCNFSM4HOZAKCQ>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495369875:1084,Green,Green,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495369875,1,['Green'],['Green']
Energy Efficiency,"dencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). set!(model, c1=1, c2=1). Δt = .01 #1/64 # Nice floating-point number; simulation = Simulation(model, Δt=Δt, stop_time=150Δt). ∫c1_dxdy = Field(Average(model.tracers.c1, dims=(1, 2))); ∫c2_dxdy = Field(Average(model.tracers.c2, dims=(1, 2))); ; nc_outputs = Dict(""c1"" => ∫c1_dxdy, ""c2"" => ∫c2_dxdy); nc_dimensions = Dict(""c1"" => (""zC"",), ""c2"" => (""zC"",)). single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; window_nΔt = 3; window = window_nΔt*Δt; interval_nΔt = 5; interval = interval_nΔt*Δt; stride = 1. single_nc_output = Dict(""c1"" => ∫c1_dxdy); single_nc_dimension = Dict(""c1"" => (""zC"",)). simulation.output_writers[:single_output_time_average] =; NetCDFOutputWriter(model, single_nc_output,; array_type = Array{Float64},; verbose = true,; filename = single_time_average_nc_filepath,; schedule = AveragedTimeInterval(interval, window = window, stride = stride),; dimensions = single_nc_dimension,; overwrite_existing = true); run!(simulation). ##### For each λ, horizontal average should evaluate to; #####; ##### c̄(z, t) = ∫₀¹ ∫₀¹ exp{- λ(x, y, z) * t} dx dy; ##### = 1 / (Nx*Ny) * Σᵢ₌₁ᴺˣ Σⱼ₌₁ᴺʸ exp{- λ(i, j, k) * t}; #####; ##### which we can compute analytically. # ds = NCDataset(horizontal_average_nc_filepath). Nx, Ny, Nz = size(grid); xs, ys, zs = nodes(model.tracers.c1). c̄1(z, t) = 1 / (Nx * Ny) * sum(exp(-λ1(x, y, z) * t) for x in xs for y in ys); c̄2(z, t) = 1 / (Nx * Ny) * sum(exp(-λ2(x, y, z) * t) for x in xs for y in ys). rtol = 1e-5 # need custom rtol for isapprox because roundoff errors accumulate (?). # Compute time averages...; c̄1(ts) = 1/length(ts) * sum(c̄1.(zs, t) for t in ts); c̄2(ts) = 1/length(ts) * sum(c̄2.(zs, t) for t in ts). #####; ##### Test strided windowed time average against analytic solution; ##### for *single* NetCDF output;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073:3125,schedul,schedule,3125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073,1,['schedul'],['schedule']
Energy Efficiency,"diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #401 +/- ##; ==========================================; - Coverage 71.74% 71.46% -0.28% ; ==========================================; Files 23 23 ; Lines 1412 1416 +4 ; ==========================================; - Hits 1013 1012 -1 ; - Misses 399 404 +5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.47% <ø> (-0.25%)` | :arrow_down: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95.12% <100%> (+0.12%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.97% <64.28%> (-9.88%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=footer). Last update [f77d3e6...0408059](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531079520:2073,Power,Powered,2073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531079520,1,['Power'],['Powered']
Energy Efficiency,"diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/store\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9zdG9yZV90ZW5kZW5jaWVzLmps) | `72.72% <0.00%> (ø)` | |; | [src/TimeSteppers/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9jbG9jay5qbA==) | | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | | |; | [.../Models/ShallowWaterModels/calculate\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvY2FsY3VsYXRlX3RlbmRlbmNpZXMuamw=) | | |; | [.../IncompressibleModels/show\_incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9zaG93X2luY29tcHJlc3NpYmxlX21vZGVsLmps) | | |; | ... and [28 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=footer). Last update [3108501...8043370](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-719683146:3374,Power,Powered,3374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-719683146,1,['Power'],['Powered']
Energy Efficiency,"diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <0.00%> (-5.00%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/tuple\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3R1cGxlX3V0aWxzLmps) | `44.44% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <0.00%> (ø)` | |; | ... and [35 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=footer). Last update [24e9c2c...c9ed348](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566:3231,Power,Powered,3231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566,1,['Power'],['Powered']
Energy Efficiency,"diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | | |; | [...erification/lid\_driven\_cavity/lid\_driven\_cavity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2xpZF9kcml2ZW5fY2F2aXR5L2xpZF9kcml2ZW5fY2F2aXR5Lmps) | | |; | [test/test\_surface\_waves.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | | |; | [...regression\_tests/thermal\_bubble\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3RoZXJtYWxfYnViYmxlX3JlZ3Jlc3Npb25fdGVzdC5qbA==) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | ... and [58 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=footer). Last update [ee14f8a...1b1dbba](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991:3159,Power,Powered,3159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991,1,['Power'],['Powered']
Energy Efficiency,"does seem to solve the problem. Here's a MWE to demonstrate:. ```julia; using Oceananigans. grid_base = RectilinearGrid(topology = (Bounded, Periodic, Bounded),; size = (16, 20, 4), extent = (800, 1000, 100),); ; @inline east_wall(x, y, z) = x > 400; grid = ImmersedBoundaryGrid(grid_base, GridFittedBoundary(east_wall)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3, buoyancy = BuoyancyTracer(), tracers = :b,). N² = 6e-6; b∞(x, y, z) = N² * z; set!(model, b=b∞); ; simulation = Simulation(model, Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606:1227,schedul,schedule,1227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606,1,['schedul'],['schedule']
Energy Efficiency,"down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `83.56% <0%> (-4.68%)` | :arrow_down: |; | [src/Operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `81.25% <0%> (-2.97%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `67.77% <0%> (-0.77%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.21% <0%> (+0.12%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.47% <0%> (+0.19%)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `84.37% <0%> (+1.04%)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `84.61% <0%> (+4.01%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=footer). Last update [7bbdd3d...d50e02d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/503#issuecomment-546029136:2933,Power,Powered,2933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/503#issuecomment-546029136,1,['Power'],['Powered']
Energy Efficiency,"driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1683,Monitor,Monitor,1683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['Monitor'],['Monitor']
Energy Efficiency,"ds = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ di",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:1916,schedul,schedule,1916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130,1,['schedul'],['schedule']
Energy Efficiency,"e 72.07% 69.12% -2.95% ; ==========================================; Files 26 26 ; Lines 1418 1490 +72 ; ==========================================; + Hits 1022 1030 +8 ; - Misses 396 460 +64; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `81.57% <0%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `48.83% <0%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.34% <20%> (-25.91%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `60.18% <29.41%> (-29.96%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.97% <95.23%> (+0.94%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=footer). Last update [211e18c...8eae176](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/476#issuecomment-541986378:2441,Power,Powered,2441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476#issuecomment-541986378,1,['Power'],['Powered']
Energy Efficiency,"e `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through which averaging is specified. Eventually, we should use the ""scheduling"" concept for both callafter function in `run!(simulation)` and the `TimeStepWizard` (separately), which will get rid of the `iteration_interval` argument in `run!(simulation)`. PS: should we use `WindowAveragedTimeInterval` rather than `AveragedTimeInterval`? I wasn't sure if the added verbosity added clarity here (the important part is the ""Averaging"") but I'm open to considering it. Resolves #1019 ; Resolves #853 ; Resolves #845",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:1924,schedul,schedule,1924,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"e base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own output and we have a utility function that post-processes the output files and merges them at the end (this seems easier than writing another output writer).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:2422,allocate,allocate,2422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['allocate'],['allocate']
Energy Efficiency,"e function b_initial(x::R, y::R, z::R) where {R<:Real}; ϵ = 100 * eps(R); return (Δb / Ly) * y + randn() * ϵ; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (-Lx / 2, Lx / 2),; y = (0.0, Ly),; z = (0.0, Lz),; topology = (Periodic, Bounded, Bounded),; halo = (4, 4, 4),; ). @inline function is_ib(x::R, y::R, z::R) where {R<:Real}; return z > z_top(y); end. ImmersedBoundaryGrid(; underlying_grid,; GridFittedBoundary(is_ib); ); end. # Coriolis; coriolis = FPlane(f₀). # Buoyancy; buoyancy = BuoyancyTracer(). # Closure; closure = ScalarDiffusivity(ν = viscosity, κ = diffusivity). # Pressure Solver; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; verbose = false; ). # Model; model = NonhydrostaticModel(;; grid = ib_grid,; timestepper = time_stepper,; advection = advection,; tracers = (:b, ),; coriolis = coriolis,; buoyancy = buoyancy,; closure = closure,; pressure_solver = pressure_solver,; ). # Initial Value; set!(model, b = b_initial). # Simulation; simulation = Simulation(model; Δt = Δt, stop_iteration = 1000). # Set Output; output_fields = merge(model.velocities, model.tracers). simulation.output_writers[:output_3d] = NetCDFOutputWriter(; model,; output_fields,; filename = ""output.nc"",; schedule = IterationInterval(output_interval),; overwrite_existing = true,; deflatelevel = deflatelevel,; ). # Set Progress Function; function print_simulation_progress(simulation). model = simulation.model; i, t = model.clock.iteration, model.clock.time. @info Printf.@sprintf(""Iteration: %d, Time: %.2f Earth Days"", i, t / 86400.0). return nothing; end. simulation.callbacks[:progress] = Callback(; print_simulation_progress,; IterationInterval(100),; ). # ---------------------------------------------------------------------- #; # Run the Simulation; run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577:3127,schedul,schedule,3127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577,1,['schedul'],['schedule']
Energy Efficiency,"e the time step is too large, or because the physical problem cannot be resolved on the specified grid, which can cause energy to accumulate at the grid scale, eventually leading to blow up. This example may be exhibiting both. As @navidcy demonstrates, reducing the time-step allows for a few time-steps to be taken without blowing up. However, the scale of the physics --- a [Rayleigh-Taylor-type gravitational instability](https://en.wikipedia.org/wiki/Rayleigh%E2%80%93Taylor_instability) --- still appears to be quite small. The characteristic scale of the turbulent motions that result from your initial condition depends on the diffusivities that are prescribed. > Taking a look at my textbook, both the diffusivities look too small for the real world, especially the horizontal κh, as you mentioned. If I'm not mistaken, eddy diffusivity is much greater in magnitude than molecular diffusivity (and therefore more important), with typical vertical values of 10^-5 m^2/s, and horizontal eddy diffusivities range anywhere from 1m^2/sec to 10^4 m^2/sec. The turbulent eddy diffusivity is a property of turbulence, and thus of the physical scenario being simulated. So we can't say whether certain values are too large or too small, especially for an initial value problem like this. The numbers you've cited are typical numbers used for large-scale oceanographic problems (motions with scales of 10s of kilometers or more). However, the problem you are trying to simulate is very small scale, with a domain just 500 meters in each direction. and grid spacing down to 2 meters. In addition, its unlikely that putting this problem on a beta plane will change your results, because the domain is too small and the velocities too large for the effect of beta to influence your dynamics. . What kind of problem would you like to simulate? Perhaps we can help define a mathematical problem that is both simulate-able, and serves as a reasonable approximation for the physics you would like to explore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731116328:2015,meter,meters,2015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731116328,2,['meter'],['meters']
Energy Efficiency,"e v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:2666,schedul,schedule,2666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['schedul'],['schedule']
Energy Efficiency,"e)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = GPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:4269,adapt,adaptive,4269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['adapt'],['adaptive']
Energy Efficiency,"e-07, 0.000e+00, 5.593e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 2.025e-10, next Δt: 1.050 ms; [ Info: ... simulation initialization complete (5.237 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.569 seconds).; [00.00%] i: 1000, t: 27.405 seconds, wall time: 7.989 seconds, max(u): (4.452e-07, 0.000e+00, 5.593e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 2.025e-10, next Δt: 138.076 ms; [00.11%] i: 2000, t: 1.009 hours, wall time: 4.283 seconds, max(u): (4.449e-07, 0.000e+00, 5.591e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 2.023e-10, next Δt: 18.157 seconds; [08.39%] i: 3000, t: 3.354 days, wall time: 4.340 seconds, max(u): (4.195e-07, 0.000e+00, 5.393e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.879e-10, next Δt: 10 minutes; [25.75%] i: 4000, t: 10.299 days, wall time: 4.455 seconds, max(u): (3.739e-07, 0.000e+00, 4.983e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.632e-10, next Δt: 10 minutes; [43.11%] i: 5000, t: 17.243 days, wall time: 4.470 seconds, max(u): (3.365e-07, 0.000e+00, 4.596e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.440e-10, next Δt: 10 minutes; [60.47%] i: 6000, t: 24.188 days, wall time: 4.402 seconds, max(u): (3.049e-07, 0.000e+00, 4.242e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.286e-10, next Δt: 10 minutes; [77.83%] i: 7000, t: 31.132 days, wall time: 4.416 seconds, max(u): (2.779e-07, 0.000e+00, 3.925e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.160e-10, next Δt: 10 minutes; [95.19%] i: 8000, t: 38.077 days, wall time: 4.495 seconds, max(u): (2.545e-07, 0.000e+00, 3.739e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.055e-10, next Δt: 10 minutes; [ Info: Simulation is stopping after running for 45.330 seconds.; [ Info: Simulation time 40 days equals or exceeds stop time 40 days.; ```; This is the expected behavior as no spurious kinetic energy is introduced. @glwagner @simone-silvestri @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3796:4456,energy,energy,4456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796,1,['energy'],['energy']
Energy Efficiency,"e-machine/Oceananigans.jl/pull/385?src=pr&el=h1) Report; > Merging [#385](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/a2b7c0e59c2f224f4fc978668cb2b85b45543981?src=pr&el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `80%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #385 +/- ##; ==========================================; + Coverage 70.57% 70.58% +0.01% ; ==========================================; Files 23 23 ; Lines 1383 1387 +4 ; ==========================================; + Hits 976 979 +3 ; - Misses 407 408 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.12% <100%> (+0.15%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86.27% <66.66%> (-1.23%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=footer). Last update [a2b7c0e...0c07933](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/385#issuecomment-526284168:1742,Power,Powered,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/385#issuecomment-526284168,1,['Power'],['Powered']
Energy Efficiency,"e-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/poisson\_solver\_gpu.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcG9pc3Nvbl9zb2x2ZXJfZ3B1Lmps) | `0% <0%> (ø)` | |; | [src/Grids/Grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `100% <100%> (ø)` | |; | [src/Solvers/poisson\_solver\_cpu.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcG9pc3Nvbl9zb2x2ZXJfY3B1Lmps) | `100% <100%> (ø)` | |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100% <100%> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <100%> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <100%> (ø)` | |; | ... and [36 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=footer). Last update [4b8ff03...9060a5f](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-548115284:3495,Power,Powered,3495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-548115284,1,['Power'],['Powered']
Energy Efficiency,"e.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Val{true}, ::CuDeviceArray{Float64, 4, 1}, ::CuDeviceArray{Float64, 3, 1}; call_kwargs::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, Int64}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:171; [7] (::CUDA.HostKernel{typeof(CUDA.partial_mapreduce_grid), Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 1, CuDeviceArray{Float64, 3, 1}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, Tuple{}}, CuDeviceArray{Float64, 3, 1}}})(::Function, ::Vararg{Any, N} where N; threads::Int64, blocks::Int64, kwargs::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:shmem,), Tuple{Int64}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:367; [8] mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{Float64, 1, CuArray{Float64, 3}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, A::CuArray{Float64, 3}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/mapreduce.jl:228; [9] mapreducedim!; @ ~/.julia/packages/CUDA/3VnCC/src/mapreduce.jl:142 [inlined]; [10] mapreducedim!; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/mapreduce.jl:10 [inlined]; [11] #sum!#699; @ ./reducedim.jl:895 [inlined]; [12] #sum!#700; @ ./reducedim.jl:897 [inlined]; [13] mean!(R::SubArray{Float64, 1, CuArray{Float64, 3}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, A::CuArray{Float64, 3}); @ Statistics /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Statistics/src/Statistics.jl:131; [14] top-level scope; @ REPL[19]:1; [15] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845617107:4409,reduce,reducedim,4409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845617107,2,['reduce'],['reducedim']
Energy Efficiency,"e.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:4433,reduce,reduce,4433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"e/Oceananigans.jl/pull/623?src=pr&el=h1) Report; > Merging [#623](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/73bea229721624d65d4e2b2b79810622cf221993?src=pr&el=desc) will **increase** coverage by `0.09%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #623 +/- ##; ==========================================; + Coverage 74.49% 74.58% +0.09% ; ==========================================; Files 118 118 ; Lines 2227 2231 +4 ; ==========================================; + Hits 1659 1664 +5 ; + Misses 568 567 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Models/model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `100% <ø> (+8.33%)` | :arrow_up: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `93.93% <100%> (+0.6%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=footer). Last update [73bea22...7014037](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/623#issuecomment-585468829:1750,Power,Powered,1750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/623#issuecomment-585468829,1,['Power'],['Powered']
Energy Efficiency,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:1590,schedul,schedule,1590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,3,['schedul'],['schedule']
Energy Efficiency,"eSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b), Tuple{Nothing, Nothing, Nothing, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing}, Nothing, CPU, ImplicitFreeSurface{Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:10911,Reduce,ReducedField,10911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Reduce'],['ReducedField']
Energy Efficiency,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:15694,schedul,schedule,15694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['schedul'],['schedule']
Energy Efficiency,"eans that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this chan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1395,meter,meter,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,1,['meter'],['meter']
Energy Efficiency,"ection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <ø> (ø)` | |; | [src/Advection/Advection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9BZHZlY3Rpb24uamw=) | `50.00% <ø> (ø)` | |; | [src/Advection/tracer\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `80.00% <ø> (ø)` | |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `76.92% <0.00%> (-6.42%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `96.55% <0.00%> (-1.70%)` | :arrow_down: |; | ... and [22 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=footer). Last update [d274364...d03718b](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014#issuecomment-704467105:3268,Power,Powered,3268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014#issuecomment-704467105,1,['Power'],['Powered']
Energy Efficiency,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493:2809,power,power,2809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493,1,['power'],['power']
Energy Efficiency,"em like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:2088,Reduce,ReducedField,2088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['Reduce'],['ReducedField']
Energy Efficiency,"ence = -2.008467701332351 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.076] INFO 2D diffusion (Periodic, Periodic, Bounded) L₁ rate of convergence = -2.0083073827620237 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.193] INFO 2D diffusion (Periodic, Periodic, Bounded) L∞ rate of convergence = -1.947766867108851 (expected ≈ -2.0, atol = 0.06); [2020/09/01 13:48:50.194] INFO 2D diffusion (Periodic, Bounded, Bounded) L₁ rate of convergence = -2.003208945092345 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.194] INFO 2D diffusion (Periodic, Bounded, Bounded) L∞ rate of convergence = -1.965491374875283 (expected ≈ -2.0, atol = 0.06); [2020/09/01 13:48:50.194] INFO 2D diffusion (Bounded, Bounded, Bounded) L₁ rate of convergence = -1.9995730043199613 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.194] INFO 2D diffusion (Bounded, Bounded, Bounded) L∞ rate of convergence = -1.984678368453777 (expected ≈ -2.0, atol = 0.06); [2020/09/01 13:52:28.324] INFO Taylor-Green L₁ rate of convergence = -2.0004700529312727 (expected ≈ -2.0, atol = 0.001); [2020/09/01 13:52:28.369] INFO Taylor-Green L∞ rate of convergence = -1.95032035517191 (expected ≈ -2.0, atol = 0.05); [2020/09/01 14:11:26.553] INFO Forced flow free slip (x, y) L₁ rate of convergence = -1.999738241539891 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:11:26.598] INFO Forced flow free slip (x, y) L∞ rate of convergence = -1.9992989311721168 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:11:26.611] INFO Forced flow free slip (x, z) L₁ rate of convergence = -1.999738243255539 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:11:26.611] INFO Forced flow free slip (x, z) L∞ rate of convergence = -1.999298932806858 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:15:04.586] INFO Forced flow fixed slip (x, y) L₁ rate of convergence = -1.9978175950101218 (expected ≈ -2.0, atol = 0.05); [2020/09/01 14:15:04.627] INFO Forced flow fixed slip (x, y) L∞ rate of convergence = -1.935360007296416 (expected ≈ -2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-685075187:9233,Green,Green,9233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-685075187,1,['Green'],['Green']
Energy Efficiency,"enter, Face; using Oceananigans.Fields: KernelComputedField; using Oceananigans.Operators; @kernel function isotropic_viscous_dissipation_ccc!(ϵ, grid, ν, u, v, w); i, j, k = @index(Global, NTuple). Σˣˣ = ∂xᶜᵃᵃ(i, j, k, grid, u); Σʸʸ = ∂yᵃᶜᵃ(i, j, k, grid, v); Σᶻᶻ = ∂zᵃᵃᶜ(i, j, k, grid, w). Σˣʸ = (ℑxyᶜᶜᵃ(i, j, k, grid, ∂yᵃᶠᵃ, u) + ℑxyᶜᶜᵃ(i, j, k, grid, ∂xᶠᵃᵃ, v)) / 2; Σˣᶻ = (ℑxzᶜᵃᶜ(i, j, k, grid, ∂zᵃᵃᶠ, u) + ℑxzᶜᵃᶜ(i, j, k, grid, ∂xᶠᵃᵃ, w)) / 2; Σʸᶻ = (ℑyzᵃᶜᶜ(i, j, k, grid, ∂zᵃᵃᶠ, v) + ℑyzᵃᶜᶜ(i, j, k, grid, ∂yᵃᶠᵃ, w)) / 2. @inbounds ϵ[i, j, k] = 2 * (Σˣˣ^2 + Σʸʸ^2 + Σᶻᶻ^2 + 2 * (Σˣʸ^2 + Σˣᶻ^2 + Σʸᶻ^2)); end; ε_i = KernelComputedField(Center, Center, Center, isotropic_viscous_dissipation_ccc!, model;; computed_dependencies=(κ, u, v, w)). # Vertical vorticity [s⁻¹]; tke = KineticEnergy(model, u, v, w). outputs = (tke=tke, ε_i=ε_i). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(100minutes),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg2] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(100minutes; window=99.99minutes, stride=1),; filepath = ""avg2.eady.nc"",; mode = ""c""); #----. #++++ Run simulation; println(""Running!""); run!(simulation); #-----; ```. This runs without any problem or warning. When I plot the TKE the results are as expected. The plots below are averaged in space. TKE is pretty much what I expected, meaning both outputs differ very little:. ![Screenshot from 2021-03-29 07-43-44](https://user-images.githubusercontent.com/13205162/112854425-af77f080-9062-11eb-9617-96e4fe334ec9.png). Dissipation is not what I expected since the difference between snapshot and time-averages is way too large:. ![Screenshot from 2021-03-29 07-44-20](https://user-images.githubusercontent.com/13205162/112854571-d7675400-9062-11eb-8d94-58bddd42bb24.png). Am I missing something obvious here? Does any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517:4897,schedul,schedule,4897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517,1,['schedul'],['schedule']
Energy Efficiency,"ently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. * A very important usage of `Average`, however, is using it to reduce ""lazily evaluated data"". This is the case of taking an average of a ""`Computation`"". To take the average of a `Computation`, we have to trigger the generation of the data to be averaged. To support this functionality we have permitted `Average.field` to be defined as a `Computation`, and dispatched on this special case to ensure that the data is generated before the average is invoked. * One way to normalize these user-interfaces is to generalize the concept of an `AbstractField` to be ""lazy"" in general. There is one special case that does *not* require computation --- the ordinary case of a `Field`. But we can create an infrastructure where all `AbstractField`s are expected to have a function like `compute!` (or perhaps `evaluate!`). In that framework, we would always call `evaluate!` on `Average.field` before averaging it. Because `evaluate!(::Field) = nothing`, we preserve the basic functionality of `Average` when it acts on a basic `Field` and its data does not need to be generated. * Note that currently `Computation` data is stored in bare `Array`s. However, it should probably be stored as `Field`, and interacting with a `Computation` should feel the same as interacting with a field (with functions like `data`, `interior`, `getindex`, etc). We may also want to change the name of `Computation` to something that reflects its behavior a little more clearly. Perhaps `ComputedField`, or something. * `Average` itself should *also* subtype `AbstractField` within this framework. An `Average` is just a special type of computation that requires evaluation, and also reduces a field along a certain dimension. For this to work well, we need a `ReducedField` type (eg #525)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391:2019,reduce,reduces,2019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391,2,"['Reduce', 'reduce']","['ReducedField', 'reduces']"
Energy Efficiency,"er(; grid;; preconditioner = fft_poisson_solver(grid.underlying_grid),; maxiter = 100; ); ). simulation = Simulation(model; Δt=0.1, stop_time=600). function progress(sim); model = sim.model; @printf(; ""iteration: %d, time: %.4f, U_max=(%.2e, %.2e, %.2e)\n"",; iteration(sim),; time(sim),; maximum(abs, model.velocities.u),; maximum(abs, model.velocities.v),; maximum(abs, model.velocities.w); ). @printf(; "" reltol=%.2e, abstol=%.2e, solver iterations: %d, residual: (mean=%.2e, abs(max)=%.2e)\n"",; model.pressure_solver.conjugate_gradient_solver.reltol,; model.pressure_solver.conjugate_gradient_solver.abstol,; iteration(model.pressure_solver),; mean(model.pressure_solver.conjugate_gradient_solver.residual),; maximum(abs, model.pressure_solver.conjugate_gradient_solver.residual); ); end. simulation.callbacks[:progress] = Callback(progress, IterationInterval(1)). nan_checker = NaNChecker(fields=model.velocities, erroring=true); simulation.callbacks[:nan_checker] = Callback(nan_checker, IterationInterval(1)). simulation.output_writers[:fields] =; JLD2OutputWriter(model, model.velocities; filename=""3831.jld2"", schedule=TimeInterval(10), overwrite_existing=true). run!(simulation). using CairoMakie. ds = FieldDataset(""3831.jld2""). times = ds[""u""].times; xu, yu, zu = nodes(ds[""u""][1]). n = Observable(1). fig = Figure(size=(1000, 500)). title = @lift @sprintf(""time = %s"", prettytime(times[$n])). u_surface = @lift interior(ds[""u""][$n], :, :, 16); u_slice = @lift interior(ds[""u""][$n], :, 8, :). ax1 = Axis(fig[1, 1]; title = ""u (surface)"", xlabel=""x"", ylabel=""y""); hm1 = heatmap!(ax1, xu, yu, u_surface, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 2], hm1, label=""m/s""). ax2 = Axis(fig[1, 3]; title = ""u (xz-slice)"", xlabel=""x"", ylabel=""z""); hm2 = heatmap!(ax2, xu, yu, u_slice, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 4], hm2, label=""m/s""). fig[0, :] = Label(fig, title). record(fig, ""3831.mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412606395:2256,schedul,schedule,2256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412606395,1,['schedul'],['schedule']
Energy Efficiency,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1426,adapt,adapts,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['adapt'],['adapts']
Energy Efficiency,"er](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/716356088a610da1fe75f00b38e3646f046edbb4?src=pr&el=desc) will **increase** coverage by `9.94%`.; > The diff coverage is `78.94%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #140 +/- ##; ==========================================; + Coverage 56.03% 65.97% +9.94% ; ==========================================; Files 19 19 ; Lines 605 629 +24 ; ==========================================; + Hits 339 415 +76 ; + Misses 266 214 -52; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.78% <78.94%> (+79.78%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.72% <0%> (+0.63%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=footer). Last update [7163560...371af73](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633131:1905,Power,Powered,1905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633131,1,['Power'],['Powered']
Energy Efficiency,"er_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: L",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:17669,Adapt,Adapt,17669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Energy Efficiency,"eraged' effects of surface waves on near-surface motions. I propose that we use the Lagrangian-mean interpretation for our velocity field in adding this term, rather than an Eulerian-mean interpretation. The Lagrangian-mean interpretation has the advantage of . 1. Avoiding ""accidental"" initialization of large near-inertial oscillations due to initial conditions that are out of equilibrium with the surface wave field (eg the initial conditions in [McWilliams et al 1997](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38));. 2. Requiring the least modification of physics, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/443:1239,energy,energy,1239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443,1,['energy'],['energy']
Energy Efficiency,"eral. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2267,Reduce,ReducedField,2267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,1,['Reduce'],['ReducedField']
Energy Efficiency,"erators.identity4), CPU, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64}, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{Array{Float32, N} where N}, field_slicer::FieldSlicer{Colon, Colon, Colon}, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, mode::String, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/Research/OC2/src/OutputWriters/netcdf_output_writer.jl:319; [4] top-level scope; @ REPL[34]:1; ```. seems like this has something to do with. https://github.com/CliMA/Oceananigans.jl/blob/6df3e36f0bc8b0cbf7c075b235da678b8d035055/src/OutputWriters/netcdf_output_writer.jl#L39-L45. That's because of the z dimension. It follows that . https://github.com/CliMA/Oceananigans.jl/blob/6df3e36f0bc8b0cbf7c075b235da678b8d035055/src/Grids/grid_utils.jl#L162. returns a range and then `.parent()` is problematic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920:24640,schedul,schedule,24640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920,1,['schedul'],['schedule']
Energy Efficiency,"erging [#612](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/88a4f8f08d976bb0029ea337202bf94fe292374d?src=pr&el=desc) will **increase** coverage by `0.04%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #612 +/- ##; ==========================================; + Coverage 74.51% 74.55% +0.04% ; ==========================================; Files 117 117 ; Lines 2209 2209 ; ==========================================; + Hits 1646 1647 +1 ; + Misses 563 562 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `93.33% <100%> (ø)` | :arrow_up: |; | [src/Buoyancy/nonlinear\_equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L25vbmxpbmVhcl9lcXVhdGlvbl9vZl9zdGF0ZS5qbA==) | `75% <0%> (+4.16%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=footer). Last update [88a4f8f...7d4e5b6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612#issuecomment-581598656:1802,Power,Powered,1802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612#issuecomment-581598656,1,['Power'],['Powered']
Energy Efficiency,"ersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.jl:317 [inlined]; [12] macro expansion; @ ./simdloop.jl:77 [inlined]; [13] _mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:316; [14] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:324; [15] sum!(f::Function, r::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:1034; [16] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}; condition::Nothing, mask::Int64, kwargs::@Kwargs{}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:696; [17] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:690; [18] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitAuxiliaryFields(grid::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, CPU}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:237; [19] materialize_free_surface(free_surface::SplitExplicitFreeSurface{…}, velocities::@NamedTuple{…}, grid::ImmersedBoundaryGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_ex",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:2759,reduce,reducedim,2759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['reduce'],['reducedim']
Energy Efficiency,"es A b,c. ; 2. **Naming convention**: The prognostic MEKE equation is used to inform the GM coefficient via `kappa_GM = c * sqrt(2 MEKE) * L_mix` with a mixing length `L_mix`, but also to energetically constrain the backscatter in the momentum equation. See this schematic, modified from Figure 1, Jansen et al. (2019):; ![MEKE_schematic](https://user-images.githubusercontent.com/23617395/167711268-23732094-80aa-476e-8f13-fd6cd8659e8c.png); So how about `PrognosticMEKEDiffusivity` and `PrognosticMEKEBackscatter`? Probably good to keep these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:1563,energy,energy,1563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['energy'],['energy']
Energy Efficiency,"es because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:1140,schedul,schedule,1140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,1,['schedul'],['schedule']
Energy Efficiency,es │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬────,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:8800,Energy,Energy,8800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Energy'],['Energy']
Energy Efficiency,"es](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.09% <ø> (+2.49%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `88.7% <ø> (+2.43%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `73.39% <100%> (-2.74%)` | :arrow_down: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `74.19% <61.11%> (-9.6%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <88.23%> (+5.54%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `90.9% <0%> (-9.1%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=footer). Last update [2749d07...770125d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/386#issuecomment-526924398:2653,Power,Powered,2653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/386#issuecomment-526924398,2,['Power'],['Powered']
Energy Efficiency,"etArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1555,reduce,reduce,1555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"ex this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:1555,reduce,reducedim,1555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,1,['reduce'],['reducedim']
Energy Efficiency,f2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.3; [53c48c17] FixedPointNumbers v0.8.5; [0c68f7d7] GPUArrays v10.2.3; [46192b85] GPUArraysCore v0.1.6; [61eb1bfa] GPUCompiler v0.26.7; [c27321d9] Glob v1.3.1; [615f187c] IfElse v0.1.1;,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:16102,Adapt,Adapt,16102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Adapt'],['Adapt']
Energy Efficiency,"f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11070,Adapt,Adapt,11070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"f?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9mX3BsYW5lLmps) | `0.00% <0.00%> (-62.50%)` | :arrow_down: |; | [src/Advection/weno\_reconstruction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX3JlY29uc3RydWN0aW9uLmps) | `0.00% <0.00%> (-60.00%)` | :arrow_down: |; | [src/Coriolis/beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2JldGFfcGxhbmUuamw=) | `0.00% <0.00%> (-58.83%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `0.00% <0.00%> (-58.07%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `0.00% <0.00%> (-54.17%)` | :arrow_down: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `28.94% <0.00%> (-50.01%)` | :arrow_down: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `0.00% <0.00%> (-44.28%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `47.36% <0.00%> (-32.64%)` | :arrow_down: |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894:2615,reduce,reduced,2615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894,1,['reduce'],['reduced']
Energy Efficiency,fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:2033,Adapt,Adapt,2033,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Adapt'],['Adapt']
Energy Efficiency,"ff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.71% <ø> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `100.00% <ø> (ø)` | |; | [src/Models/show\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9zaG93X21vZGVscy5qbA==) | `0.00% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100.00% <ø> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <ø> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=footer). Last update [03f1aa5...586529d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799#issuecomment-658184692:3398,Power,Powered,3398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799#issuecomment-658184692,1,['Power'],['Powered']
Energy Efficiency,"ffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); @ GPUArrays ~/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [22] #maximum!#803; @ ./reducedim.jl:1018 [inlined]; [23] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:16605,reduce,reducedim,16605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806,1,['reduce'],['reducedim']
Energy Efficiency,"field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to creating the possibility for nice pseudo-animations via `UnicodePlots.jl`). I'm not 100% sure how to do this; one places to start could be https://github.com/ronisbr/TextUserInterfaces.jl. Any work on any of these ideas could be useful! I'd be happy to Skype to talk more and clarify any questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:3738,monitor,monitoring,3738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,2,"['monitor', 'reduce']","['monitoring', 'reduce']"
Energy Efficiency,"file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #803 +/- ##; ==========================================; + Coverage 71.05% 71.24% +0.18% ; ==========================================; Files 186 186 ; Lines 4823 4854 +31 ; ==========================================; + Hits 3427 3458 +31 ; Misses 1396 1396 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [examples/one\_dimensional\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `79.54% <0.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `94.11% <0.00%> (+3.37%)` | :arrow_up: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `69.64% <0.00%> (+10.66%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=footer). Last update [b022627...2572835](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/803#issuecomment-660244336:2094,Power,Powered,2094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/803#issuecomment-660244336,1,['Power'],['Powered']
Energy Efficiency,"fsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, Nothing, Nothing, Nothing, NamedTuple{(), Tuple{}}}, outputs::NamedTuple{(:u, :v, :w), Tuple{typeof(subsample_u), typeof(subsample_v), typeof(subsample_w)}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Nothing, deflatelevel::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/netcdf_output_writer.jl:422; [4] top-level scope; @ In[8]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594:24796,schedul,schedule,24796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594,1,['schedul'],['schedule']
Energy Efficiency,"g); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:2939,reduce,reducedim,2939,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reducedim']
Energy Efficiency,"gans.jl/pull/402?src=pr&el=h1) Report; > Merging [#402](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/f77d3e6ef455fa3b7ed177c1af0e6a163b048a83?src=pr&el=desc) will **increase** coverage by `0.09%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #402 +/- ##; ==========================================; + Coverage 71.74% 71.83% +0.09% ; ==========================================; Files 23 23 ; Lines 1412 1413 +1 ; ==========================================; + Hits 1013 1015 +2 ; + Misses 399 398 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `84.74% <100%> (+1.69%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.63% <0%> (+0.01%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=footer). Last update [f77d3e6...77a2c9a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/402#issuecomment-531193966:1760,Power,Powered,1760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402#issuecomment-531193966,1,['Power'],['Powered']
Energy Efficiency,"gans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `71.11% <0%> (-9.85%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.54% <0%> (-0.57%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=footer). Last update [d32cf20...3ce561b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532807303:2833,Power,Powered,2833,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532807303,1,['Power'],['Powered']
Energy Efficiency,"ge by `0.43%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #685 +/- ##; ==========================================; - Coverage 77.99% 77.56% -0.44% ; ==========================================; Files 120 120 ; Lines 2413 2478 +65 ; ==========================================; + Hits 1882 1922 +40 ; - Misses 531 556 +25 ; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `53.84% <0.00%> (-29.49%)` | :arrow_down: |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `71.42% <0.00%> (-28.58%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `75.17% <0.00%> (-0.73%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=footer). Last update [74cfb85...6eb8db9](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595584245:2044,Power,Powered,2044,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595584245,1,['Power'],['Powered']
Energy Efficiency,"gence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | [...ts/one\_dimensional\_gaussian\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9nYXVzc2lhbl9hZHZlY3Rpb25fZGlmZnVzaW9uLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X29wZXJhdG9ycy5qbA==) | | |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=footer). Last update [d383b6a...ad6a215](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230:3305,Power,Powered,3305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230,1,['Power'],['Powered']
Energy Efficiency,"gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=h1) Report; > Merging [#585](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/588890004e69cfc7db10472b12a9840b8a9ad7b6?src=pr&el=desc) will **increase** coverage by `0.97%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #585 +/- ##; ==========================================; + Coverage 72.17% 73.14% +0.97% ; ==========================================; Files 70 70 ; Lines 2016 2011 -5 ; ==========================================; + Hits 1455 1471 +16 ; + Misses 561 540 -21; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `61.05% <0%> (ø)` | :arrow_up: |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `76.19% <0%> (+76.19%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=footer). Last update [5888900...01ec7b4](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/585#issuecomment-568143084:1733,Power,Powered,1733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585#issuecomment-568143084,1,['Power'],['Powered']
Energy Efficiency,"gly random (time) chunks of the simulations, and then everything comes back to normal before happening again in other chunks. Here's a MWE where I create a grid with channel-like topology which has an immersed boundary at `x=400meters` that acts as an East wall. I initialize it with a uniform stratification of `6e-6/second` and zero velocities everywhere. ```julia; using Oceananigans. grid_base = RectilinearGrid(topology = (Bounded, Periodic, Bounded),; size = (16, 20, 4), extent = (800, 1000, 100),). @inline east_wall(x, y, z) = x > 400; grid = ImmersedBoundaryGrid(grid_base, GridFittedBoundary(east_wall)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; buoyancy = BuoyancyTracer(), tracers = :b,; ). N² = 6e-6; b∞(x, y, z) = N² * z; set!(model, b=b∞). simulation = Simulation(model, Δt=25, stop_time=1e4,); simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. Here are some snapshots of the pressure (the blue line is where the immersed boundary is):. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/8904fd81-70ee-465b-a664-3eb6042f94ca). And here's a plot of the standard deviation of pressure over the whole domain as a function of time where we can visualize when this issue happens:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/86e5687e-0290-45ac-80d9-0cc2552f2b7d). [Here](https://pastebin.com/XArt8Bik) is the code I used to generate these figures in case anyone's interested in playing around with it. A bit of context: I noticed this issue a long time ago, and @whitleyv before me (I believe @amrapallig also mentioned coming across this issue at some point). It hasn't been an issue in the past, but now that I need to close a KE balance in a domain where the pressure contributions don't vanish I find that this issue prevents me from obtaining any sort of reasonab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593:1140,schedul,schedule,1140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593,1,['schedul'],['schedule']
Energy Efficiency,"go with constant time step because ```TimeStepWizard``` was not working with stretched grid. I am pasting the code where I am using Time wizard-; ```; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.gri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586:1369,meter,meters,1369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586,1,['meter'],['meters']
Energy Efficiency,"h. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6982,energy,energy,6982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['energy'],['energy']
Energy Efficiency,"h/climate-machine/Oceananigans.jl/pull/326?src=pr&el=h1) Report; > Merging [#326](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/66670ad782b66db7906d407ab9217ec0f26a7bb2?src=pr&el=desc) will **increase** coverage by `1.31%`.; > The diff coverage is `81.1%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #326 +/- ##; ==========================================; + Coverage 74.74% 76.06% +1.31% ; ==========================================; Files 22 22 ; Lines 1176 1224 +48 ; ==========================================; + Hits 879 931 +52 ; + Misses 297 293 -4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `75.93% <81.1%> (+11.18%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=footer). Last update [66670ad...4e72d35](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974978:1734,Power,Powered,1734,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974978,1,['Power'],['Powered']
Energy Efficiency,"h1) Report; > Merging [#992](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/e808a821d78949b0482b8372533e992cabb5d65f?el=desc) will **not change** coverage.; > The diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #992 +/- ##; =======================================; Coverage 72.04% 72.04% ; =======================================; Files 218 218 ; Lines 6379 6379 ; =======================================; Hits 4596 4596 ; Misses 1783 1783 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <ø> (ø)` | |; | [src/Fields/new\_data.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `76.92% <50.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `88.88% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=footer). Last update [e808a82...9054b82](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/992#issuecomment-700346993:1797,Power,Powered,1797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/992#issuecomment-700346993,1,['Power'],['Powered']
Energy Efficiency,"h](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #183 +/- ##; ===========================================; - Coverage 68.81% 57.86% -10.96% ; ===========================================; Files 18 19 +1 ; Lines 651 776 +125 ; ===========================================; + Hits 448 449 +1 ; - Misses 203 327 +124; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/dst3fl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9kc3QzZmwuamw=) | `0% <0%> (ø)` | |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `10% <0%> (-23.34%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=footer). Last update [6c272ad...63f7bb2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975517:2123,Power,Powered,2123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975517,1,['Power'],['Powered']
Energy Efficiency,"h](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #183 +/- ##; ===========================================; - Coverage 68.81% 57.86% -10.96% ; ===========================================; Files 18 19 +1 ; Lines 651 776 +125 ; ===========================================; + Hits 448 449 +1 ; - Misses 203 327 +124; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/dst3fl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9kc3QzZmwuamw=) | `0% <0%> (ø)` | |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `10% <0%> (-23.34%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=footer). Last update [6c272ad...7ff5f20](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975519:2123,Power,Powered,2123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975519,1,['Power'],['Powered']
Energy Efficiency,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:1425,reduce,reduce,1425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,2,"['Reduce', 'reduce']","['ReducedField', 'reduce']"
Energy Efficiency,"halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `81.25% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `43.9% <ø> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `59.7% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `70% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.58% <100%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `62.02% <50%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=footer). Last update [848edd9...7e48630](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/349#issuecomment-520158094:2732,Power,Powered,2732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/349#issuecomment-520158094,2,['Power'],['Powered']
Energy Efficiency,"hat I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":; > ; > Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems.; > ; > We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:1077,power,power,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['power'],['power']
Energy Efficiency,"have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2269,energy,energy,2269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['energy'],['energy']
Energy Efficiency,"hine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.85% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.05% <100%> (+1.69%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.48% <100%> (+1.14%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.71% <0%> (+0.54%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <0%> (+14.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `62.02% <0%> (+15.18%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <0%> (+16.66%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <0%> (+57.61%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=footer). Last update [079cb53...bd0ce51](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530062190:2819,Power,Powered,2819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530062190,1,['Power'],['Powered']
Energy Efficiency,"https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/fbbb5f81b851bb838c8796efba36a3021cb89f0e?el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `80.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #889 +/- ##; ==========================================; + Coverage 70.99% 71.00% +0.01% ; ==========================================; Files 188 188 ; Lines 5230 5229 -1 ; ==========================================; Hits 3713 3713 ; + Misses 1517 1516 -1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `75.00% <ø> (+3.57%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.07% <66.66%> (-0.55%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `88.42% <100.00%> (+0.24%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=footer). Last update [fbbb5f8...1db3d80](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/889#issuecomment-684069273:1826,Power,Powered,1826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/889#issuecomment-684069273,1,['Power'],['Powered']
Energy Efficiency,"https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `92.00% <80.00%> (+3.57%)` | :arrow_up: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (+0.74%)` | :arrow_up: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `71.42% <100.00%> (+8.09%)` | :arrow_up: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <100.00%> (+0.05%)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | ... and [17 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=footer). Last update [f0c2821...60fd8ea](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898:3479,Power,Powered,3479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898,1,['Power'],['Powered']
Energy Efficiency,"https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `80.33% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <100%> (-1.34%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.56% <100%> (-1.58%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <100%> (ø)` | |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <60.39%> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <74.35%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=footer). Last update [cacb753...059d826](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/505#issuecomment-546596353:2655,Power,Powered,2655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/505#issuecomment-546596353,1,['Power'],['Powered']
Energy Efficiency,"iMA/Oceananigans.jl/pull/1090?src=pr&el=desc) (ca40ce0) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165?el=desc) (5aafe8e) will **decrease** coverage by `0.38%`.; > The diff coverage is `0.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1090 +/- ##; ==========================================; - Coverage 57.39% 57.01% -0.39% ; ==========================================; Files 161 162 +1 ; Lines 3887 3913 +26 ; ==========================================; Hits 2231 2231 ; - Misses 1656 1682 +26 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `25.00% <ø> (ø)` | |; | [src/Fields/interpolate.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9pbnRlcnBvbGF0ZS5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `73.80% <0.00%> (+1.71%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=footer). Last update [5aafe8e...ca40ce0](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1090#issuecomment-713241303:1850,Power,Powered,1850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090#issuecomment-713241303,1,['Power'],['Powered']
Energy Efficiency,"iMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `82.50% <30.00%> (-4.78%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `60.37% <83.33%> (+7.43%)` | :arrow_up: |; | [src/BoundaryConditions/zero\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy96ZXJvX2hhbG9fcmVnaW9ucy5qbA==) | `78.94% <87.50%> (+2.47%)` | :arrow_up: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `94.44% <94.44%> (ø)` | |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (ø)` | |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `96.42% <100.00%> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.33% <100.00%> (-0.01%)` | :arrow_down: |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=footer). Last update [0f33c1d...69d5cd7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/930#issuecomment-690826704:3276,Power,Powered,3276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930#issuecomment-690826704,1,['Power'],['Powered']
Energy Efficiency,"ia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:1556,Adapt,Adapt,1556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['Adapt'],['Adapt']
Energy Efficiency,"icFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:34 [inlined]; │ [23] update_state!; │ @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:31 [inlined]; │ [24] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, clock::Clock{Float32, Float32}, momentum_advection::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, tracer_advection::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, buoyancy::BuoyancyTracer, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{Nothing, Nothing, Nothing, Float64, Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, tracers::Tuple{Symbol, Symbol}, forcing::@NamedTuple{}, closure::CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretizat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:153964,Energy,EnergyConserving,153964,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['Energy'],['EnergyConserving']
Energy Efficiency,"ich is kind of similar to #73 #85. I suppose we can interpret every term in the momentum equation as an ""arbitrary function"". The design I've been using is to define a type that represents part of the governing equation to make the equation modular and changeable by the user. Definitely suggest alternative designs if good alternatives come to mind. > Is a closure always meant to replace the viscous dissipation (𝜈∇²u) operators? Will Smag/AMD replace the Laplacian diffusion operators (e.g. κ∇²T) as well?. I am proposing that we consider using this conceptual model for a ""closure"". Perhaps a better name than ""closure"" is `Dissipation`... ? All of the turbulent closures we are considering introduce a ""turbulent"" viscosity and diffusivity which is typically much larger than the molecular value. Thus a ""molecular"" isotropic diffusivity can be interpreted as the limiting case of a turbulent closure. The reason it might be good design is because turbulent closures can modify boundary conditions (which depend on viscosity/diffusivity), and because we may want to use common implicit time-stepping methods for the turbulent diffusivity in addition to a ""molecular"" diffusivity. > Out of curiousity, can these closures be framed as ODEProblems using DifferentialEquations.jl?. A subgrid turbulent kinetic energy variable in a typical turbulence closure obeys a three-dimensional PDE and is advected, diffused, dissipated, and interacts with terms in the momentum and tracer equation via nonlinear terms. It is a first-class solution variable similar to the velocity field or active tracers. See equation 12 in [Moeng 1984](https://journals.ametsoc.org/doi/pdf/10.1175/1520-0469%281984%29041%3C2052%3AALESMF%3E2.0.CO%3B2). > Sounds like #115 (and #59 (comment)) should be resolved before this closure abstraction is merged in?. I think it makes sense to resolve #107, #115, and #59 before implementing anything; especially #59 because this affects the function signature we use for the closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089:1424,energy,energy,1424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089,1,['energy'],['energy']
Energy Efficiency,idia-smi -q. ==============NVSMI LOG==============. Timestamp : Tue Feb 21 07:30:33 2023; Driver Version : 525.60.13; CUDA Version : 12.0. Attached GPUs : 1; GPU 00000000:3D:00.0; Product Name : Tesla V100-SXM2-32GB; Product Brand : Tesla; Product Architecture : Volta; Display Mode : Enabled; Display Active : Disabled; Persistence Mode : Enabled; MIG Mode; Current : N/A; Pending : N/A; Accounting Mode : Disabled; Accounting Mode Buffer Size : 4000; Driver Model; Current : N/A; Pending : N/A; Serial Number : 1562019007305; GPU UUID : GPU-afa33ac3-cef0-ac1a-9dfd-491463f321e9; Minor Number : 0; VBIOS Version : 88.00.80.00.01; MultiGPU Board : No; Board ID : 0x3d00; Board Part Number : 900-2G503-0010-000; GPU Part Number : 1DB5-896-A1; Module ID : 0; Inforom Version; Image Version : G503.0203.00.05; OEM Object : 1.1; ECC Object : 5.0; Power Management Object : N/A; GPU Operation Mode; Current : N/A; Pending : N/A; GSP Firmware Version : N/A; GPU Virtualization Mode; Virtualization Mode : None; Host VGPU Mode : N/A; IBMNPU; Relaxed Ordering Mode : N/A; PCI; Bus : 0x3D; Device : 0x00; Domain : 0x0000; Device Id : 0x1DB510DE; Bus Id : 00000000:3D:00.0; Sub System Id : 0x124910DE; GPU Link Info; PCIe Generation; Max : 3; Current : 3; Device Current : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:19856,Power,Power,19856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Power'],['Power']
Energy Efficiency,"ields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/output_construction.jl:50; [8] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [9] iterate; @ ./generator.jl:47 [inlined]; [10] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:364; [11] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [12] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::TimeInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:190; [13] top-level scope; @ ~/github/Oceananigans.jl/test.jl:19; [14] include(fname::String); @ Base.MainInclude ./client.jl:489; [15] top-level scope; @ REPL[1]:1; in expression starting at /Users/jmtzmo/github/Oceananigans.jl/test.jl:19; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:5563,schedul,schedule,5563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['schedul'],['schedule']
Energy Efficiency,"ies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:8196,Energy,Energy,8196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Energy'],['Energy']
Energy Efficiency,"iff-dmVyaWZpY2F0aW9uL3BlcmlvZGljX2FkdmVjdGlvbi9wZXJpb2RpY19hZHZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/Advection/upwind\_biased\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2ZpZnRoX29yZGVyLmps) | `65.00% <65.00%> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <0.00%> (-5.00%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/tuple\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3R1cGxlX3V0aWxzLmps) | `44.44% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=footer). Last update [24e9c2c...c4faf06](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/994#issuecomment-700312179:3212,Power,Powered,3212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/994#issuecomment-700312179,1,['Power'],['Powered']
Energy Efficiency,"iff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <100.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.71% <100.00%> (+0.18%)` | :arrow_up: |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `90.00% <100.00%> (-1.67%)` | :arrow_down: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `96.07% <100.00%> (-0.54%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `96.15% <0.00%> (+0.15%)` | :arrow_up: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (+3.33%)` | :arrow_up: |; | [src/AbstractOperations/grid\_validation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9ncmlkX3ZhbGlkYXRpb24uamw=) | `75.00% <0.00%> (+8.33%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=footer). Last update [ae33e4c...94c13c7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/757#issuecomment-632822673:3183,Power,Powered,3183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757#issuecomment-632822673,1,['Power'],['Powered']
Energy Efficiency,"iff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0.00%> (-6.67%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32.00% <0.00%> (-2.10%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `85.10% <0.00%> (-0.61%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100.00% <0.00%> (ø)` | |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [43 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=footer). Last update [bff7abc...ec426ad](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704#issuecomment-599780254:3507,Power,Powered,3507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704#issuecomment-599780254,1,['Power'],['Powered']
Energy Efficiency,"igans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, Float32, @NamedTuple{momentum::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, b::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, e::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, Nothing, @NamedTuple{u::typeof(Oceananigans.Forcings.zeroforcing), v::typeof(Oceananigans.Forcings.zeroforcing), η::typeof(Oceananigans.Forcings.zeroforcing), b::typeof(Oceananigans.Forcings.zeroforcing), e::typeof(Oceananigans.Forcings.zeroforcing)}, Nothing, Nothing, @NamedTuple{u::Field{Face, Center, Center, Nothing, LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:28497,Energy,EnergyConserving,28497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,4,['Energy'],['EnergyConserving']
Energy Efficiency,"igans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `46.15% <ø> (-39.57%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `70.37% <100.00%> (-3.71%)` | :arrow_down: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `100.00% <100.00%> (ø)` | |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (-30.01%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `83.33% <0.00%> (-11.67%)` | :arrow_down: |; | ... and [92 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=footer). Last update [cec16b0...5cbac0d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-657840369:3040,Power,Powered,3040,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-657840369,1,['Power'],['Powered']
Energy Efficiency,"igansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and also generalizes to distributed architectures, etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3594:1804,adapt,adapt,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594,1,['adapt'],['adapt']
Energy Efficiency,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:2248,adapt,adapt,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,1,['adapt'],['adapt']
Energy Efficiency,"iles](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (+0.37%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `71.7% <100%> (-0.28%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `52.3% <56%> (-6.85%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `58.06% <58.06%> (-41.94%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `66% <0%> (+26%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=footer). Last update [ac7dc2a...a473fee](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942484:2650,Power,Powered,2650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942484,1,['Power'],['Powered']
Energy Efficiency,"ime = 3days). wizard = TimeStepWizard(max_change=1.01, cfl=0.2, diffusive_cfl=0.1, max_Δt=0.2/√N²∞); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). KE = Average((u^2 + w^2) / 2); PE = Average(b^2/(2*N²∞)); outputs = (; u, w, b, KE, PE). simulation.output_writers[:writer] = NetCDFOutputWriter(model, outputs;; filename = ""mwe.nc"",; schedule = TimeInterval(1hour),; with_halos = false,; overwrite_existing = true); run!(simulation). using Rasters, Plots; fpath_xz1 = simulation.output_writers[:writer].filepath; ds_xz1 = RasterStack(fpath_xz1); u_lims = (-amp, +amp). times = dims(ds_xz1, :Ti); anim = @animate for frame in 1:length(times); p1 = heatmap(ds_xz1[:u][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""u""); p2 = heatmap(ds_xz1[:w][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""w""); p3 = heatmap(ds_xz1[:b][Ti=frame, yC=1]', title=""b""); p4 = plot(ds_xz1[:KE]); plot!(p4, ds_xz1[:PE]); vline!(p4, [times[frame]], label=""time"", linestyle=:dash). fullplot = plot(p1, p2, p3, p4, layout = Plots.grid(2, 2), size=(1000, 600)); end. mp4(anim, ""mwe.mp4"", fps=16). ```. I expected this simulation to slowly lose or approximately conserve total energy. Instead I get these grid-scale noises popping up and a build up of kinetic and potential energy seemingly out of nowhere:. https://user-images.githubusercontent.com/13205162/228424859-905f3dd6-b167-440b-b073-af09008f4f04.mp4. Notes: . - Even if I add a background diffusivity with a reasonable value, the energy buildup still happens; - The energy buildup does not happen without a background buoyancy; - When `gravity_unit_vector == NegativeZDirection()` the KE stays approximately the same, but the PE increases. Although that might be due to the boundary conditions, I'm not sure at this point.; - When I start this with a larger velocity amplitude the small scale noise becomes less evident, but there's still an increase in the total energy (KE and PE) of the flow. Any guesses as to what might be causing this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036:2514,energy,energy,2514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036,5,['energy'],['energy']
Energy Efficiency,"imestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). return simula",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1447,schedul,schedule,1447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2180,adapt,adaptive,2180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['adapt'],['adaptive']
Energy Efficiency,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1960,adapt,adaptive,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['adapt'],['adaptive']
Energy Efficiency,"ine/Oceananigans.jl/pull/288?src=pr&el=h1) Report; > Merging [#288](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/40dbd96fd45a30867063c476b3eecbe13db1fb5c?src=pr&el=desc) will **decrease** coverage by `0.07%`.; > The diff coverage is `42.85%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #288 +/- ##; ==========================================; - Coverage 68.36% 68.29% -0.08% ; ==========================================; Files 22 22 ; Lines 882 880 -2 ; ==========================================; - Hits 603 601 -2 ; Misses 279 279; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `80.64% <100%> (-1.18%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.09% <33.33%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=footer). Last update [40dbd96...51bc9e0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-504026989:1748,Power,Powered,1748,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-504026989,1,['Power'],['Powered']
Energy Efficiency,"ine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.54% <0%> (-0.57%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.05% <0%> (+1.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=footer). Last update [d32cf20...d88b63f](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/435#issuecomment-536922587:2827,Power,Powered,2827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/435#issuecomment-536922587,1,['Power'],['Powered']
Energy Efficiency,"ing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Symbol}, Float32, Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, Float32, @NamedTuple{momentum::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, b::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, e::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, Nothing, @NamedTuple{u::typeof(Oceananigans.Forcings.zeroforcing), v::typeof(Oceananigans.Forcings.zeroforcing), η::typeof(Oceananigans.Forcings.zeroforcing), b::typeof(Oceananigans.Forcings.zeroforcing), e::typeof(Oceananigans.Forcings.zeroforcing)}, Nothing, Nothing, @NamedTuple{u::Field{Face, Center, Center, Nothing, LatitudeLongitudeGri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:28375,Energy,EnergyConserving,28375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,12,['Energy'],['EnergyConserving']
Energy Efficiency,"ing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:13096,Reduce,ReducedField,13096,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Reduce'],['ReducedField']
Energy Efficiency,"ing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Solvers.PreconditionedConjugateGradientSolver{CPU, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:13774,Reduce,ReducedField,13774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Reduce'],['ReducedField']
Energy Efficiency,"io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <ø> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `91.78% <69.23%> (-6.70%)` | :arrow_down: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <85.71%> (+0.99%)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `89.18% <100.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <100.00%> (+5.31%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=footer). Last update [994eae3...a77b356](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251:2625,Power,Powered,2625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251,1,['Power'],['Powered']
Energy Efficiency,"io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | | |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | | |; | [src/Operators/derivative\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9kZXJpdmF0aXZlX29wZXJhdG9ycy5qbA==) | | |; | [src/Operators/tracer\_advection\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | | |; | [...ure\_implementations/leith\_enstrophy\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2xlaXRoX2Vuc3Ryb3BoeV9kaWZmdXNpdml0eS5qbA==) | | |; | [...nce\_closure\_implementations/blasius\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2JsYXNpdXNfc21hZ29yaW5za3kuamw=) | | |; | ... and [75 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=footer). Last update [91e5626...45bf8a8](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500250532:3522,Power,Powered,3522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500250532,1,['Power'],['Powered']
Energy Efficiency,"iodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=0.5. julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN. julia> using Statistics: norm. julia> norm(f1); 2.29128784747",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998:1028,reduce,reduced,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998,1,['reduce'],['reduced']
Energy Efficiency,"iodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, typeof(condition_greater_3), Int64, Float64}); @ GPUArrays ~/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [17] #sum!#796; @ ./reducedim.jl:1018 [inlined]; [18] sum!(f::Function, r::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCond",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:17303,reduce,reducedim,17303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['reduce'],['reducedim']
Energy Efficiency,"ion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `71.42% <0.00%> (ø)` | |; | [.../IncompressibleModels/show\_incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9zaG93X2luY29tcHJlc3NpYmxlX21vZGVsLmps) | `0.00% <ø> (ø)` | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `40.00% <ø> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `87.50% <0.00%> (ø)` | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `60.00% <ø> (ø)` | |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <ø> (ø)` | |; | ... and [8 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=footer). Last update [03a6f85...0386f31](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1174#issuecomment-727277449:3743,Power,Powered,3743,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1174#issuecomment-727277449,1,['Power'],['Powered']
Energy Efficiency,"ions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#v_bottom_drag#30""}}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}}, ReducedField{Center, Center, Nothing, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, 1, FieldBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}}}}, ::HorizontallyCurvilinearAnisotropicDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, Float64, NamedTuple{(), Tuple{}}, NamedTuple{(), Tuple{}}}, ::Nothing); Closest candidates are:; (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{LX, LY, Nothing, k, F, P, D, N, ℑ} where {F, P, D, N, ℑ})(::Any, ::Any, ::Any, ::Any, ::Any) where {LX, LY, k} at /home/chris/projects/onan-2021-08-06/src/BoundaryConditions/continuou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1928:2346,Reduce,ReducedField,2346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928,1,['Reduce'],['ReducedField']
Energy Efficiency,it blows up at some point... . https://github.com/CliMA/Oceananigans.jl/assets/7112768/b8396af4-810e-4584-85d6-18431deb4bc4. I even reduced the tilmestep but not sure if it's that or corner-related artifacts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747335909:132,reduce,reduced,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747335909,1,['reduce'],['reduced']
Energy Efficiency,"ith eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1460,reduce,reduce,1460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"itions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.identity3), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; [6] top-level scope; @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:30922,schedul,schedule,30922,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784,1,['schedul'],['schedule']
Energy Efficiency,"jL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `30.00% <0.00%> (-4.10%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `61.53% <0.00%> (+2.56%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <0.00%> (+6.34%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (+11.11%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <0.00%> (+32.35%)` | :arrow_up: |; | [src/Solvers/plan\_transforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `100.00% <0.00%> (+33.33%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=footer). Last update [9b9e8e2...1c31ca5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/758#issuecomment-632044290:3478,Power,Powered,3478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/758#issuecomment-632044290,1,['Power'],['Powered']
Energy Efficiency,"jL2dyaWRzLmps) | `94.59% <ø> (ø)` | :arrow_up: |; | [src/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `0% <0%> (ø)` | |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.9% <100%> (+0.43%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `86.86% <100%> (+2.81%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `12.5% <40%> (+12.5%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `38.46% <50%> (+1.61%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=footer). Last update [7e29af4...c863622](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127823:3239,Power,Powered,3239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127823,1,['Power'],['Powered']
Energy Efficiency,"jl/pull/922/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #922 +/- ##; ==========================================; + Coverage 72.78% 72.79% +0.01% ; ==========================================; Files 192 192 ; Lines 5643 5649 +6 ; ==========================================; + Hits 4107 4112 +5 ; - Misses 1536 1537 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <ø> (ø)` | |; | [src/AbstractOperations/multiary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9tdWx0aWFyeV9vcGVyYXRpb25zLmps) | `86.36% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `85.71% <0.00%> (-3.18%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `96.29% <0.00%> (+0.14%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=footer). Last update [01b2481...ba87adc](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084:2154,Power,Powered,2154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084,1,['Power'],['Powered']
Energy Efficiency,"jl/pull/932/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <ø> (ø)` | |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <ø> (ø)` | |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `93.61% <ø> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.25% <ø> (-0.08%)` | :arrow_down: |; | [...ests/ConvergenceTests/DoublyPeriodicTaylorGreen.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRG91Ymx5UGVyaW9kaWNUYXlsb3JHcmVlbi5qbA==) | `0.00% <0.00%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=footer). Last update [3b45ce5...82d362a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932#issuecomment-691237401:3389,Power,Powered,3389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932#issuecomment-691237401,1,['Power'],['Powered']
Energy Efficiency,"julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(size=(16, 16, 16), extent = (500, 500, 120)). n_tracers = 6; tracer_symbols = [ Symbol(:τ,i) for i in 1:n_tracers ]; model = NonhydrostaticModel(; grid, tracers = (tracer_symbols...,)); @info model. uᵢ(x, y, z) = 1e-2 * randn(); set!(model, w=uᵢ). tracer_IC_odd(x, y, z) = sin(2π*z/grid.Lz); for i in 1:n_tracers; @info ""Setting tracer $i""; expression = Meta.parse(""set!(model, τ$i=tracer_IC_odd)""); eval(expression); end. simulation = Simulation(model, Δt=30, stop_time=0.15hours). u, v, w = model.velocities. wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, which in some cases (my case for example) is very important. - Not pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931:1293,schedul,schedule,1293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931,1,['schedul'],['schedule']
Energy Efficiency,"just a comment: pressure correction (as done now) is just one piece of an implicit in time; component of the time stepping. The more general form would be: explicit part (AB or RK or just ; simple forward) then implicit part (including: pressure correction, implicit vertical for ; diffusion/viscosity or/and advection, implicit relaxation/damping). On Tue, Feb 12, 2019 at 06:58:27PM -0800, Ali Ramadhan wrote:; > Yeah I think the current time stepping algorithm (essentially what the MITgcm does) is pretty custom so it's probably not shared by other equations/methods, but the pressure correction step is pretty common to finite volume Navier-Stokes solvers and it should be possible to generalize it.; > ; > I'm thinking it might be good to tackle ""generic time stepping"" in two steps. 1. Getting the current version of the time stepping algorithm running efficiently on GPUs for milestone v0.4 and then 2. we can redesign for v0.5 and include more generic time stepping.; > ; > ; > -- ; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub:; > https://github.com/ali-ramadhan/Oceananigans.jl/issues/49#issuecomment-463036545",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463042259:860,efficient,efficiently,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463042259,1,['efficient'],['efficiently']
Energy Efficiency,"l/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=footer). Last update [7a47b92...a20cf39](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:3694,Power,Powered,3694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['Power'],['Powered']
Energy Efficiency,"l/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jb25zdGFudF9pc290cm9waWNfZGlmZnVzaXZpdHkuamw=) | `100% <100%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92ZXJzdGFwcGVuX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [...ulenceClosures/constant\_anisotropic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jb25zdGFudF9hbmlzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100% <100%> (ø)` | |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `85.43% <100%> (+1.92%)` | :arrow_up: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `23.8% <25%> (-1.2%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `77.41% <68.42%> (-10.09%)` | :arrow_down: |; | ... and [8 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=footer). Last update [99b1a70...5d796b5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541188654:3715,Power,Powered,3715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541188654,1,['Power'],['Powered']
Energy Efficiency,"l/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Advection/upwind\_biased\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2FkdmVjdGl2ZV9mbHV4ZXMuamw=) | `100.00% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Advection/weno\_nth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX250aF9vcmRlci5qbA==) | `53.19% <53.19%> (ø)` | |; | [src/Advection/centered\_fourth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9mb3VydGhfb3JkZXIuamw=) | `64.28% <57.14%> (ø)` | |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `66.66% <66.66%> (+1.66%)` | :arrow_up: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `80.46% <80.46%> (ø)` | |; | ... and [69 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=footer). Last update [d80be8c...7612a01](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-573978399:3428,Power,Powered,3428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-573978399,1,['Power'],['Powered']
Energy Efficiency,"l/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `75.86% <0.00%> (-10.81%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `53.84% <0.00%> (-5.13%)` | :arrow_down: |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `90.00% <0.00%> (-3.75%)` | :arrow_down: |; | [src/Fields/function\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9mdW5jdGlvbl9maWVsZC5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `0.00% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `82.35% <0.00%> (+1.10%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=footer). Last update [e9583ce...19cd67a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/933#issuecomment-691108830:3524,Power,Powered,3524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/933#issuecomment-691108830,1,['Power'],['Powered']
Energy Efficiency,"l=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/54d8aa1ee1218ffed70232a277cc8cff5b72dc5b?src=pr&el=desc) will **decrease** coverage by `0.07%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #303 +/- ##; ==========================================; - Coverage 71.8% 71.72% -0.08% ; ==========================================; Files 24 24 ; Lines 1000 1001 +1 ; ==========================================; Hits 718 718 ; - Misses 282 283 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `58.33% <0%> (-1.67%)` | :arrow_down: |; | [src/time\_step\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcF91dGlscy5qbA==) | `0% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=footer). Last update [54d8aa1...4ac5bb2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/303#issuecomment-506990525:1887,Power,Powered,1887,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/303#issuecomment-506990525,1,['Power'],['Powered']
Energy Efficiency,"lZF9maWVsZC5qbA==) | `94.44% <ø> (ø)` | |; | [src/Fields/function\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9mdW5jdGlvbl9maWVsZC5qbA==) | `23.07% <0.00%> (ø)` | |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `76.47% <50.00%> (-10.20%)` | :arrow_down: |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <66.66%> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <75.00%> (-4.87%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `89.47% <76.92%> (-6.83%)` | :arrow_down: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `77.77% <77.77%> (ø)` | |; | ... and [9 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=footer). Last update [e9583ce...ba8fc61](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-690822059:3453,Power,Powered,3453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-690822059,1,['Power'],['Powered']
Energy Efficiency,"l](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2RpYWdub3N0aWNzX2tlcm5lbHMuamw=) | `0.00% <0.00%> (-100.00%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `36.36% <0.00%> (+1.06%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `36.84% <ø> (ø)` | |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `75.00% <0.00%> (-25.00%)` | :arrow_down: |; | ... and [80 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=footer). Last update [ecc0fda...8a9755b](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378:3396,Power,Powered,3396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378,1,['Power'],['Powered']
Energy Efficiency,"l](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `100% <100%> (+43.75%)` | :arrow_up: |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <100%> (ø)` | :arrow_up: |; | [...bulence\_closures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdHVyYnVsZW5jZV9jbG9zdXJlX2RpYWdub3N0aWNzLmps) | `20% <20%> (ø)` | |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `70.21% <25%> (+5.76%)` | :arrow_up: |; | [...rc/turbulence\_closures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdHVyYnVsZW5jZV9jbG9zdXJlX3V0aWxzLmps) | `62.5% <62.5%> (ø)` | |; | ... and [4 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=footer). Last update [dd122e9...17e7f14](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/407#issuecomment-531510704:3698,Power,Powered,3698,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/407#issuecomment-531510704,1,['Power'],['Powered']
Energy Efficiency,"l`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simula",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:1802,reduce,reduce,1802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['reduce'],['reduce']
Energy Efficiency,"lationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); # reduced_precision_grid = with_number_type(grid.underlying_grid); preconditioner = fft_poisson_solver(grid.underlying_grid); pressure_solver = ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=20). model = NonhydrostaticModel(; grid, boundary_conditions, pressure_solver); simulation = Simulation(model; Δt=0.1, stop_iteration=1000); conjure_time_step_wizard!(simulation, cfl=0.5). u, v, w = model.velocities; δ = ∂x(u) + ∂y(v) + ∂z(w). function progress(sim); model = sim.model; u, v, w = model.velocities; @printf(""Iter: %d, time: %.1f, Δt: %.2e, max|δ|: %.2e"",; iteration(sim), time(sim), sim.Δt, maximum(abs, δ)). r = model.pressure_solver.conjugate_gradient_solver.residual; @printf("", solver iterations: %d, max|r|: %.2e\n"",; iteration(model.pressure_solver), maximum(abs, r)); end. add_callback!(simulation, progress). simulation.output_writers[:fields] =; JLD2OutputWriter(model, model.velocities; filename=""3831.jld2"", schedule=IterationInterval(10), overwrite_existing=true). run!(simulation). using GLMakie. ds = FieldDataset(""3831.jld2""); fig = Figure(size=(1000, 500)). n = Observable(1); times = ds[""u""].times; title = @lift @sprintf(""time = %s"", prettytime(times[$n])). Nx, Ny, Nz = size(grid); j = round(Int, Ny/2); k = round(Int, Nz/2); u_surface = @lift view(ds[""u""][$n], :, :, k); u_slice = @lift view(ds[""u""][$n], :, j, :). ax1 = Axis(fig[1, 1]; title = ""u (xy)"", xlabel=""x"", ylabel=""y""); hm1 = heatmap!(ax1, u_surface, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 2], hm1, label=""m/s""). ax2 = Axis(fig[1, 3]; title = ""u (xz)"", xlabel=""x"", ylabel=""z""); hm2 = heatmap!(ax2, u_slice, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 4], hm2, label=""m/s""). fig[0, :] = Label(fig, title). record(fig, ""3831.mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3889:3045,schedul,schedule,3045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3889,1,['schedul'],['schedule']
Energy Efficiency,"lc3RzL0NvbnZlcmdlbmNlVGVzdHMvYW5hbHlzaXMuamw=) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [...nvergence\_tests/ConvergenceTests/file\_wrangling.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvZmlsZV93cmFuZ2xpbmcuamw=) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [test/test\_pressure\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ByZXNzdXJlX3NvbHZlcnMuamw=) | | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [...\_tests/ConvergenceTests/TwoDimensionalDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvVHdvRGltZW5zaW9uYWxEaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=footer). Last update [162159d...a538a52](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968:3345,Power,Powered,3345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968,1,['Power'],['Powered']
Energy Efficiency,"lcy92ZWxvY2l0eV90cmFjZXJfZ3JhZGllbnRzLmps) | `69.72% <ø> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `25% <ø> (ø)` | |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `64.44% <0%> (ø)` | |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.12% <100%> (-0.18%)` | :arrow_down: |; | ... and [11 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=footer). Last update [a9e34a7...7fe8a47](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532091518:3543,Power,Powered,3543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532091518,1,['Power'],['Powered']
Energy Efficiency,"lenceClosures.HyperbolicTangentRiDependentTapering}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:b,), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:\u03bb, :initial_buoyancy), Tuple{Float64, typeof(WenoNeverworld.initial_buoyancy_parabola)}}, typeof(WenoNeverworld.buoyancy_top_relaxation)}}}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to xnode); Stacktrace:; [1] node; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/grid_utils.jl:230; [2] buoyancy_top_relaxation; @ /nobackup1c/users/ssilvest/WenoNeverworld.jl/src/weno_neverworld.jl:47; [3] getbc; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BoundaryConditions/discrete_boundary_function.jl:41; [4] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy_tracer.jl:18; [5] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy.jl:76; [6] macro expansion; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl:190; [7] gpu_compute_ri_based_diffusivities!; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/KernelAbstractions/C8flJ/src/macros.jl:81; [8] gpu_compute_ri_based_diffusivities!; ```. Instances of `xnode` (and I would have to guess also `ynode` and `znode`) are not adapted to fit the new syntax",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:6944,adapt,adapted,6944,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['adapt'],['adapted']
Energy Efficiency,"lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1669,monitor,monitor,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['monitor'],['monitor']
Energy Efficiency,"licitTimeDiscretization(); ν, κ=(; b=κᵇ)); ```. _Then_, you need to compute `Ri` in a `Simulation.callback` (you also need to fill it's halo regions, which is a bit annoying but we show you how below). This is pretty advanced usage (and there are subtleties as I mention below) so I'll write a script that implements Pacanowski-Philander as an example. Note that it is currently a limitation of our turbulence closures that viscosities diffusivities must be defined at `(Center, Center, Center)`. #2295 makes some changes that will permit this restriction to be relaxed in the future, but we aren't quite there yet. ## Solution 2: precreate `velocities` and `tracers`. Another solution is to pre-create `velocities` and `tracers` by pre-creating a ""fake model"". Then, the viscosity / diffusivities can be defined directly as abstract operations of `fake_model.velocities` and `fake_model.tracers`, and these named tuples can be passed on to a ""true"" model. This _could_ be slightly more efficient than computing and storing `Ri` every time-step. This would look something like. ```julia; grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=nothing). velocities = fake_model.velocities; tracers = fake_model.tracers; Ri = ∂z(b) / (∂z(u)^2 + ∂z(v)^2). ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. ν = @at (Center, Center, Center) ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = @at (Center, Center, Center) κ₀ + κ₁ / (1 + c * Ri^(n+1)); closure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdams",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:2158,efficient,efficient,2158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186,1,['efficient'],['efficient']
Energy Efficiency,"limate-machine/Oceananigans.jl/pull/519?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #519 +/- ##; ==========================================; - Coverage 64.61% 64.15% -0.47% ; ==========================================; Files 68 69 +1 ; Lines 1950 1964 +14 ; ==========================================; Hits 1260 1260 ; - Misses 690 704 +14; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | [src/SurfaceWaves.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1N1cmZhY2VXYXZlcy5qbA==) | `0% <0%> (ø)` | |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=footer). Last update [08294f7...972fbd1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/519#issuecomment-548595850:2278,Power,Powered,2278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/519#issuecomment-548595850,1,['Power'],['Powered']
Energy Efficiency,"limate-machine/Oceananigans.jl/pull/584?src=pr&el=h1) Report; > Merging [#584](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/588890004e69cfc7db10472b12a9840b8a9ad7b6?src=pr&el=desc) will **increase** coverage by `0.65%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #584 +/- ##; ==========================================; + Coverage 72.17% 72.82% +0.65% ; ==========================================; Files 70 70 ; Lines 2016 2050 +34 ; ==========================================; + Hits 1455 1493 +38 ; + Misses 561 557 -4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `62.5% <0%> (+1.44%)` | :arrow_up: |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `59.25% <0%> (+59.25%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=footer). Last update [5888900...b7cae54](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/584#issuecomment-568103734:1737,Power,Powered,1737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/584#issuecomment-568103734,1,['Power'],['Powered']
Energy Efficiency,"ll/1047/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <0.00%> (ø)` | |; | [...ests/ConvergenceTests/DoublyPeriodicTaylorGreen.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRG91Ymx5UGVyaW9kaWNUYXlsb3JHcmVlbi5qbA==) | `0.00% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <0.00%> (ø)` | |; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | `0.00% <0.00%> (ø)` | |; | [...ergence\_tests/ConvergenceTests/ConvergenceTests.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvQ29udmVyZ2VuY2VUZXN0cy5qbA==) | `0.00% <0.00%> (ø)` | |; | ... and [95 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=footer). Last update [d100853...116f81c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132:3420,Power,Powered,3420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132,1,['Power'],['Powered']
Energy Efficiency,"llect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ┌───────────────┬─────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Stretched │ 7.122 s │ 7.122 s │ 7.122 s │ 7.122 s │ 949.91 KiB │ 1716 │ 1 │; │ CPU │ StretchedSmoothness │ 11.042 s │ 11.042 s │ 11.042 s │ 11.042 s │ 956.47 KiB │ 1716 │ 1 │; │ CPU │ Uniform │ 6.373 s │ 6.373 s │ 6.373 s │ 6.373 s │ 945.38 KiB │ 1706 │ 1 │; │ CPU │ ZFormulation │ 7.725 s │ 7.725 s │ 7.725 s │ 7.725 s │ 945.38 KiB │ 1706 │ 1 │; │ GPU │ Stretched │ 25.646 ms │ 25.920 ms │ 26.501 ms │ 32.101 ms │ 2.15 MiB │ 30442 │ 10 │; │ GPU │ StretchedSmoothness │ 109.080 ms │ 109.493 ms │ 109.676 ms │ 111.118 ms │ 3.78 MiB │ 134069 │ 10 │; │ GPU │ Uniform │ 25.133 ms │ 25.394 ms │ 25.468 ms │ 26.710 ms │ 2.06 MiB │ 27799 │ 10 │; │ GPU │ ZFormulation │ 30.554 ms │ 32.780 ms │ 32.569 ms │ 32.922 ms │ 2.20 MiB │ 37382 │ 10 │; └───────────────┴─────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; ```; Apparently on a much larger grid than what I tested, StretchedSmoothness is much less efficient, another reason to try to avoid it if not strictly necessary!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:5463,efficient,efficient,5463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['efficient'],['efficient']
Energy Efficiency,"lliptic]]; git-tree-sha1 = ""71c79e77221ab3a29918aaf6db4f217b89138608""; uuid = ""b305315f-e792-5b7a-8f41-49f472929428""; version = ""1.0.1"". [[ExprTools]]; git-tree-sha1 = ""10407a39b87f29d47ebaca8edbc75d7c302ff93e""; uuid = ""e2ba6199-217a-4e67-a87a-7c52f15ade04""; version = ""0.1.3"". [[FFTW]]; deps = [""AbstractFFTs"", ""FFTW_jll"", ""IntelOpenMP_jll"", ""Libdl"", ""LinearAlgebra"", ""MKL_jll"", ""Reexport""]; git-tree-sha1 = ""1b48dbde42f307e48685fa9213d8b9f8c0d87594""; uuid = ""7a1cc6ca-52ef-59f5-83cd-3a7055c09341""; version = ""1.3.2"". [[FFTW_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""5a0d4b6a22a34d17d53543bd124f4b08ed78e8b0""; uuid = ""f5851436-0d7a-5f13-b9de-f02708fd171a""; version = ""3.3.9+7"". [[FileIO]]; deps = [""Pkg"", ""Requires"", ""UUIDs""]; git-tree-sha1 = ""b647ed22f176a4f12eabe2afd90d19a95af2e8ca""; uuid = ""5789e2e9-d7fb-5bc7-8068-2c6fae9b9549""; version = ""1.8.0"". [[GPUArrays]]; deps = [""AbstractFFTs"", ""Adapt"", ""LinearAlgebra"", ""Printf"", ""Random"", ""Serialization""]; git-tree-sha1 = ""9c95b2fd5c16bc7f97371e9f92f0fef77e0f5957""; uuid = ""0c68f7d7-f131-5f86-a1c3-88cf8149b2d7""; version = ""6.2.2"". [[GPUCompiler]]; deps = [""DataStructures"", ""InteractiveUtils"", ""LLVM"", ""Libdl"", ""Scratch"", ""Serialization"", ""TimerOutputs"", ""UUIDs""]; git-tree-sha1 = ""c853c810b52a80f9aad79ab109207889e57f41ef""; uuid = ""61eb1bfa-7361-4325-ad38-22787b887f55""; version = ""0.8.3"". [[Glob]]; git-tree-sha1 = ""4df9f7e06108728ebf00a0a11edee4b29a482bb2""; uuid = ""c27321d9-0574-5035-807b-f59d2c89b15c""; version = ""1.3.0"". [[HDF5_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""LibCURL_jll"", ""Libdl"", ""OpenSSL_jll"", ""Pkg"", ""Zlib_jll""]; git-tree-sha1 = ""fd83fa0bde42e01952757f01149dd968c06c4dba""; uuid = ""0234f1f7-429e-5d53-9886-15a909be8d59""; version = ""1.12.0+1"". [[IfElse]]; git-tree-sha1 = ""28e837ff3e7a6c3cdb252ce49fb412c8eb3caeef""; uuid = ""615f187c-cbe4-4ef1-ba3b-2fcf58d6d173""; version = ""0.1.0"". [[IntelOpenMP_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""d979e54b71da82f3a65",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:5373,Adapt,Adapt,5373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"loat64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:1093,schedul,schedule,1093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,1,['schedul'],['schedule']
Energy Efficiency,"lse` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`), and the `mask` (which at the moment is just a number). You can construct it with `condition_operand(field, condition, mask)`. But most of the time you probably won't need it (reductions automatically construct a `ConditionalOperation` when specifying a condition through the keyword argument). @glwagner `condition_operand` is used because we needed to define it in `Fields.jl` which is added before `AbstractOperations.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:1865,reduce,reduce,1865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235,1,['reduce'],['reduce']
Energy Efficiency,"lux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). #Incompressible model initiation ; model = IncompressibleModel(architecture = CPU(),; timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=fo, β=beta),; buoyancy = buoyancy,; closure = IsotropicDiffusivity(ν=v, κ=k),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-4 * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl=0.3, Δt=0.10, max_change=1.1, max_Δt=0.1minute). wmax = FieldMaximum(abs, model.velocities.w); umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v). start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, umax = %.1e ms⁻¹, vmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), wmax(sim.model),umax(sim.model), vmax(sim.model),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time=10minutes, iteration_interval=10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = ""open_ocean_convection2"",; schedule = TimeInterval(0.2minute),; force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289:3310,schedul,schedule,3310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289,1,['schedul'],['schedule']
Energy Efficiency,"lux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.21% <0.00%> (-34.35%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `56.00% <0.00%> (-30.67%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `75.00% <0.00%> (-21.56%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `71.42% <0.00%> (-20.24%)` | :arrow_down: |; | [src/Solvers/index\_permutations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaW5kZXhfcGVybXV0YXRpb25zLmps) | `0.00% <0.00%> (-20.00%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-16.85%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.62% <0.00%> (-16.73%)` | :arrow_down: |; | ... and [172 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=footer). Last update [17f8cc6...19f23f1](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/870#issuecomment-681312161:3598,Power,Powered,3598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/870#issuecomment-681312161,1,['Power'],['Powered']
Energy Efficiency,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525:1154,reduce,reduced,1154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525,9,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,"m/5797727/161127315-8230c1fb-9207-45ed-9fe8-f65b157a905a.png). ## Full code:; ```julia; using Oceananigans; using Oceananigans.Units. # define the size and max depth of the simulation; const Ny = 100; const Nz = 48 # number of points in z; const H = 1000 # maximum depth. # create the grid of the model; grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(-(Ny/2)kilometers, (Ny/2)kilometers),; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). # define the turbulence closure of the model; horizontal_closure = ScalarDiffusivity(ν=1, κ=1); vertical_closure = ScalarDiffusivity(ν=1e-5, κ=1e-5). coriolis = FPlane(latitude=60). #--------------- Instantiate Model. # create the model; model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers = (:b),; buoyancy = BuoyancyTracer()). #--------------- Initial Conditions. const g = 9.82 # gravity; const ρₒ = 1026 # reference density. # background density profile based on Argo data; @inline bg(z) = 0.25*tanh(0.0027*(-653.3-z))-6.8*z/1e5+1027.56. # decay function for fronts; @inline decay(z) = (tanh((z+500)/300)+1)/2. @inline front(x, y, z, cy) = tanh((y-cy)/12kilometers); @inline D(x, y, z) = bg(z) + 0.8*decay(z)*front(x, y, z, 0)/4; @inline B(x, y, z) = -(g/ρₒ)*D(x, y, z). # setting the initial conditions; set!(model; b=B). #--------------- Simulation. simulation = Simulation(model, Δt = 10seconds, stop_time = 10minutes). wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=6minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(5)). # merge light and h to the outputs; outputs = merge(model.velocities, model.tracers) # make a NamedTuple with all outputs. # writing the output; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, outputs, filepath = ""data/output.nc"",; schedule=IterationInterval(1)). # run the simulation; run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2405:3330,schedul,schedule,3330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2405,1,['schedul'],['schedule']
Energy Efficiency,"m/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Fields/averaged_field.jl#L62 but that didn't help. Adding a `sleep(0.01)` afterwards helped a bit (reduced the number of occurences of this issue). It's not a useful hack but it may suggest that a race condition is involved?. X-Ref: This is a minimal reproduction of https://github.com/CliMA/LESbrary.jl/issues/118; X-Ref: https://github.com/JuliaGPU/CUDA.jl/issues/929 (Attempt at reproducing but turned out to be a REPL issue). # Minimal working example. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(256, 256, 128), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); simulation = Simulation(model, Δt=1, stop_time=100). set!(model, u=1, v=1, T=1). U = AveragedField(model.velocities.u, dims=(1, 2)); V = AveragedField(model.velocities.v, dims=(1, 2)); T = AveragedField(model.tracers.T, dims=(1, 2)). simulation.output_writers[:jld2] =; JLD2OutputWriter(model, (; U, V, T),; prefix = ""stats"",; schedule = TimeInterval(10),; force = true). simulation.output_writers[:nc] =; NetCDFOutputWriter(model, (; U, V, T),; filepath = ""stats.nc"",; schedule = TimeInterval(10),; mode = ""c""). run!(simulation); ```. ## Looking at the NetCDF output. ```julia; using NCDatasets; ds = NCDataset(""stats.nc""); ds[""T""][:]; ```. ```; 128×11 Matrix{Float32}: ; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767:1402,schedul,schedule,1402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767,1,['schedul'],['schedule']
Energy Efficiency,"machine/Oceananigans.jl/pull/418?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #418 +/- ##; ==========================================; + Coverage 73.28% 76.87% +3.59% ; ==========================================; Files 25 25 ; Lines 1426 1427 +1 ; ==========================================; + Hits 1045 1097 +52 ; + Misses 381 330 -51; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `86.88% <0%> (+1.63%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `85.57% <0%> (+12.76%)` | :arrow_up: |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `86.23% <0%> (+16.51%)` | :arrow_up: |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `84.74% <0%> (+32.2%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=footer). Last update [a9e34a7...2dff13a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532833457:2282,Power,Powered,2282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532833457,1,['Power'],['Powered']
Energy Efficiency,"machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9zbWFnb3JpbnNreS5qbA==) | `77.33% <100%> (ø)` | :arrow_up: |; | [src/forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL2ZvcmNpbmcuamw=) | `53.84% <100%> (ø)` | :arrow_up: |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92ZXJzdGFwcGVuX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <16.66%> (ø)` | |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25% <25%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <33.33%> (ø)` | |; | ... and [26 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=footer). Last update [7bbdd3d...f61dbc6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-541339268:3602,Power,Powered,3602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-541339268,1,['Power'],['Powered']
Energy Efficiency,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7089,Adapt,Adapt,7089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Energy Efficiency,"masc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:1754,reduce,reducedim,1754,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,5,['reduce'],['reducedim']
Energy Efficiency,"ment OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.Offse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1416,reduce,reduce,1416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `61.53% <0.00%> (+2.56%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <0.00%> (+6.34%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (+11.11%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <0.00%> (+32.35%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=footer). Last update [533abcd...45c9255](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/742#issuecomment-622097623:3337,Power,Powered,3337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742#issuecomment-622097623,1,['Power'],['Powered']
Energy Efficiency,"more like are the arguments of the constructors of the respective types `CuSparseMatrixCSC` and `SparseMatrixCSC`, which are also the fields of the respective types. (respectively, the dimensions, the integer vector of column pointers, the integer vector of row position and the float vector of nonzero elements) . you should be able to manipulate those efficiently",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109796895:354,efficient,efficiently,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109796895,1,['efficient'],['efficiently']
Energy Efficiency,"n . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:4483,adapt,adaptive,4483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['adapt'],['adaptive']
Energy Efficiency,n the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:8599,Energy,Energy,8599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Energy'],['Energy']
Energy Efficiency,"n=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #662 +/- ##; =========================================; + Coverage 78.06% 78.2% +0.14% ; =========================================; Files 118 118 ; Lines 2362 2368 +6 ; =========================================; + Hits 1844 1852 +8 ; + Misses 518 516 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100%> (+3.17%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `96.29% <100%> (+3.7%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.07% <100%> (-0.31%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `91.17% <88.88%> (+5.46%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=footer). Last update [042f8cf...90e9560](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/662#issuecomment-592911845:2222,Power,Powered,2222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/662#issuecomment-592911845,1,['Power'],['Powered']
Energy Efficiency,"nBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_solver(reduced_precision_grid); pressure_solver = ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=20). model = NonhydrostaticModel(; grid, boundary_conditions, pressure_solver); simulation = Simulation(model; Δt=0.1, stop_iteration=1000); conjure_time_step_wizard!(simulation, cfl=0.5). u, v, w = model.velocities; δ = ∂x(u) + ∂y(v) + ∂z(w). function progress(sim); model = sim.model; u, v, w = model.velocities; @printf(""Iter: %d, time: %.1f, Δt: %.2e, max|δ|: %.2e"",; iteration(sim), time(sim), sim.Δt, maximum(abs, δ)). r = model.pressure_solver.conjugate_gradient_solver.residual; @printf("", solver iterations: %d, max|r|: %.2e\n"",; iteration(model.pressure_solver), maximum(abs, r)); end. add_callback!(simulation, progress). simulation.output_writers[:fields] =; JLD2OutputWriter(model, model.velocities; filename=""3831.jld2"", schedule=IterationInterval(10), overwrite_existing=true). run!(simulation). using GLMakie. ds = FieldDataset(""3831.jld2""); fig = Figure(size=(1000, 500)). n = Observable(1); times = ds[""u""].times; title = @lift @sprintf(""time = %s"", prettytime(times[$n])). Nx, Ny, Nz = size(grid); j = round(Int, Ny/2); k = round(Int, Nz/2); u_surface = @lift view(ds[""u""][$n], :, :, k); u_slice = @lift view(ds[""u""][$n], :, j, :). ax1 = Axis(fig[1, 1]; title = ""u (xy)"", xlabel=""x"", ylabel=""y""); hm1 = heatmap!(ax1, u_surface, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 2], hm1, label=""m/s""). ax2 = Axis(fig[1, 3]; title = ""u (xz)"", xlabel=""x"", ylabel=""z""); hm2 = heatmap!(ax2, u_slice, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 4], hm2, label=""m/s""). fig[0, :] = Label(fig, title). record(fig, ""3831.mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426:3224,schedul,schedule,3224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426,1,['schedul'],['schedule']
Energy Efficiency,"ncies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:2071,Adapt,Adapt,2071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['Adapt'],['Adapt']
Energy Efficiency,"nd a ""non-hydrostatic"" component. The vertical momentum equation in `NonhydrostaticModel` is. $$ \partial_t w = - \partial_z p + b + G_w' $$. where $G_w'$ collects the contributions to the vertical momentum tendency other than pressure gradient and buoyancy. Prior to this PR, the kinematic pressure $p$ is decomposed into (note that in this Boussinesq formulation, a hydrostatic component has already been removed from $p$) . $$ p = p_h' + p_n $$. with the hydrostatic anomaly $p_h'$ defined by. $$ p_h' = - \int^0_z b \mathrm{d} z $$. Using the hydrostatic pressure anomaly eliminates buoyancy from the vertical momentum equation, such that. $$ \partial_t w = - \partial_z p_n + G_w' $$. Buoyancy forces enter the dynamics via horizontal gradients of the hydrostatic pressure anomaly. For example, x-gradient of the kinematic pressure becomes. $$ \partial_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:1158,reduce,reduces,1158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['reduce'],['reduces']
Energy Efficiency,"nded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOperation` has a `Nothing` location (in fact, this might be a useful abstraction for binary operations between `ReducedField`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:5390,Reduce,ReducedField,5390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,2,['Reduce'],['ReducedField']
Energy Efficiency,"ndexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:3185,reduce,reducedim,3185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reducedim']
Energy Efficiency,"nditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); cfl=AdvectiveCFL(0.1); start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, cfl: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; cfl(model), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=0.1, stop_time=40minutes, iteration_interval=10,; progress=progress_message,parameters=(;cfl)); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:3310,schedul,schedule,3310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['schedul'],['schedule']
Energy Efficiency,"nditions/fill\_halo\_regions\_flat.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc19mbGF0Lmps) | `0.00% <0.00%> (-100.00%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `8.77% <0.00%> (-87.78%)` | :arrow_down: |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `0.00% <0.00%> (-85.08%)` | :arrow_down: |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `0.00% <0.00%> (-84.00%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `0.00% <0.00%> (-79.17%)` | :arrow_down: |; | ... and [121 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=footer). Last update [7687ab6...616ee5f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1025#issuecomment-707938629:3887,Power,Powered,3887,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1025#issuecomment-707938629,1,['Power'],['Powered']
Energy Efficiency,"ndom""]; git-tree-sha1 = ""6a8a2a625ab0dea913aba95c11370589e0239ff0""; uuid = ""1914dd2f-81c6-5fcd-8719-6d5c9610ff09""; version = ""0.5.6"". [[Markdown]]; deps = [""Base64""]; uuid = ""d6f4376e-aef5-505a-96c1-9c027394607a"". [[MbedTLS_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""0eef589dd1c26a3ac9d753fe1a8bcad63f956fa6""; uuid = ""c8ffd9c3-330d-5841-b78e-0817d7145fa1""; version = ""2.16.8+1"". [[MicrosoftMPI_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""e5c90234b3967684c9c6f87b4a54549b4ce21836""; uuid = ""9237b28f-5490-5468-be7b-bb81f5f5e6cf""; version = ""10.1.3+0"". [[Mmap]]; uuid = ""a63ad114-7e13-5084-954f-fe012c677804"". [[NCDatasets]]; deps = [""CFTime"", ""DataStructures"", ""Dates"", ""NetCDF_jll"", ""Printf""]; git-tree-sha1 = ""b71d83c87d80f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:10403,Adapt,Adapt,10403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore ─ v1.7.2; Installed Tables ───────── v1.6.0; Installed Parsers ──────── v2.0.5; Installed StaticArrays ─── v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] +",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:1041,Adapt,Adapt,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Adapt'],['Adapt']
Energy Efficiency,"nes 676 754 +78 ; ==========================================; + Hits 449 523 +74 ; - Misses 227 231 +4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcGVyYXRvcnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `86.86% <100%> (+2.81%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.9% <100%> (+0.43%)` | :arrow_up: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `86.71% <86.11%> (+0.84%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=footer). Last update [7e29af4...ac6ed18](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127822:2526,Power,Powered,2526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127822,1,['Power'],['Powered']
Energy Efficiency,"ng, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:12305,Reduce,ReducedField,12305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Reduce'],['ReducedField']
Energy Efficiency,"ng. John; >; > On Tue, Jun 25, 2019, 7:49 PM Gregory L. Wagner <notifications@github.com>; > wrote:; >; > > Adaptive time-stepping is useful for a wide class of problems. The general; > > strategy is to use the CFL number to compute a stable time-step. This is; > > especially useful in problems with lots of time variability --- for; > > example, LES of a seasonal cycle. In addition, the CFL computation can be; > > used to stabilize the spin-up of a model, during which a transition to; > > turbulence occurs.; > >; > > Some complexity is introduced by the fact that we use Adams-Bashforth time; > > stepping (as opposed to a RK-method, which is more common and more stable),; > > since it means we need to re-initialize the ""previous source terms"" with a; > > forward Euler step when the time step is changed.; > >; > > I have been using adaptive time-stepping in my work, which along with a; > > strategy for handling model spinup / transition to turbulence, has proven; > > to be an important practical feature that makes running experimental; > > simulations under different conditions much easier, since all I need to do; > > is set my boundary conditions, and let the model run. I am then able to; > > start dozens of LES per day (if I want to) without having to choose my time; > > step size through a mistake-prone and time-consuming trial-and-error; > > process --- and I am guaranteed not to waste resources with a too-short; > > time-step.; > >; > > —; > > You are receiving this because you commented.; > > Reply to this email directly, view it on GitHub; > > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQVQYODJTMVZ46AOA3TP4JLCFA5CNFSM4H3I7NT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODYRBT7Q#issuecomment-505551358>,; > > or mute the thread; > > <https://github.com/notifications/unsubscribe-auth/AKXUEQS54XWGGG7MKQWZZELP4JLCFANCNFSM4H3I7NTQ>; > > .; > >; >; > —; > You are receiving this because you are ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637:1141,adapt,adaptive,1141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637,1,['adapt'],['adaptive']
Energy Efficiency,"ng_grid.Lz + 500 * exp(-x^2 / (2*(20e3)^2));. julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom));. julia> c = Field{Center, Nothing, Nothing}(grid); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand()); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.952381, min=0.952381, mean=0.952381. julia> lines(c). julia> c; 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=NaN, min=NaN, mean=NaN; ```. After plotting a field then it has NaNs. Is this OK?; Of course, we expect that because we masked it in immersed regions. Is the issue here the show method? Should it be ignoring immersed regions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749:1563,reduce,reduced,1563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749,1,['reduce'],['reduced']
Energy Efficiency,"nigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `66.66% <66.66%> (ø)` | |; | [src/TurbulenceClosures/diffusivity\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9kaWZmdXNpdml0eV9maWVsZHMuamw=) | `100.00% <100.00%> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <0.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `94.93% <0.00%> (+2.30%)` | :arrow_up: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `74.54% <0.00%> (+3.49%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=footer). Last update [6d349e1...bbb2e4c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/914#issuecomment-688933336:3150,Power,Powered,3150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/914#issuecomment-688933336,1,['Power'],['Powered']
Energy Efficiency,"nigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. grid_base = RectilinearGrid(CPU(), size=(24, 24, 6), extent=(500, 500, 100)); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(-50)); @info grid. model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,); @info """" model; v_i(x, y, z,) = 0.1 + 1e-2*randn(); set!(model, v=v_i). simulation = Simulation(model, Δt=10seconds, stop_time=0.5day,). using Oceananigans.AbstractOperations: @at; using Oceananigans.Grids: Center, Face. ccc_scratch = Field{Center, Center, Center}(model.grid); u, v, w = model.velocities. u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data). outputs = (; u1, v1,); overwrite_existing = true. simname = ""mwe.nc""; simulation.output_writers[:hr1_writer] =; NetCDFOutputWriter(model, outputs,; filename = ""data/hr1.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). xz_average(F) = Field(Average(F, dims=(1,3))); outputs_avg = map(xz_average, outputs). simulation.output_writers[:avg_writer] =; NetCDFOutputWriter(model, outputs_avg,; filename = ""data/avg.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). run!(simulation); ```. The output for `hr1_writer` appears to be fine, but when I open the outputs for `ave_writer` I get that both outputs are always _exactly_ the same, and they have the value that the xz-average of `u1` should:. ![Screenshot_20220526_114754](https://user-images.githubusercontent.com/13205162/170556118-5e7cfb5b-6491-4e1e-919c-2ea9d5db5211.png). The two left pictures are `u1` and `v1` from `avg_writer`. The figure on the right is the xy-average computed separately. In other words: in this example the xz-average of `u1` gets computed correctly, but the xz-average of `v1` gets assigned the value of the xz-average of `u1`. A couple of notes:. - Us",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581:1108,schedul,schedule,1108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581,1,['schedul'],['schedule']
Energy Efficiency,"nlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:2613,reduce,reduce,2613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"nostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:1042,allocate,allocate,1042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,1,['allocate'],['allocate']
Energy Efficiency,"ns, you could try using arrays to set the initial conditions instead. Your script contains these lines:. ```julia; rng = MersenneTwister(1234); Random.seed!(rng, 1414); Ξ(z) = randn(rng) * z / model.grid.Lz * (1 + z / model.grid.Lz) ; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); ```. You can try replacing these lines with something like. ```julia; Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) *. shape; Ξu = randn(size(u)...) *. shape; Ξw = randn(size(w)...) *. shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35); ```. I'd be curious to know if this works. Here are a few more tips and best practices for raising issues here:. * Please reduce your code to minimum working examples. The script that was linked contains a lot of extraneous code (including comments copy/pasted from an example) that is irrelevant to the issue we are discussing. Reducing your code to a minimum example is kind to the community and will help people answer your questions faster. * If you can, avoid linking to code and instead paste your code directly into the issue. * Use [github's markdown formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) (such as triple backticks, ""```"") to format code and julia prompt instructions. * Finally, I strongly recommend using environments to manage the Oceananigans version (though I don't think this is intrinsic to the issue, it will help us rule out a lot of possible issues if we can focus on one Oceananigans version). We have written some tips in our wiki: https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092:1516,reduce,reduce,1516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092,1,['reduce'],['reduce']
Energy Efficiency,"ns.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; It looks like there are problems also if trying to save the windowed field by itself; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835:2191,schedul,schedule,2191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835,1,['schedul'],['schedule']
Energy Efficiency,"ns.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}}, typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.identity3), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64}, Tuple{Int64}}(Statistics.mean!, BinaryOperation at (Center, Center, Center); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; └── tree:; * at (Center, Center, Center);    ├── - at (Center, Center, Center);    │   ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;    │   └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;    └── - at (Center, Center, Center);       ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;       └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU, (1,)); ```. cc @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2364:9045,reduce,reduced,9045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2364,2,['reduce'],['reduced']
Energy Efficiency,"ns/solution\_and\_model\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zb2x1dGlvbl9hbmRfbW9kZWxfYm91bmRhcnlfY29uZGl0aW9ucy5qbA==) | `94.59% <0%> (+5.4%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.68% <0%> (+6.55%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <0%> (+22.22%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `61.76% <0%> (+26.47%)` | :arrow_up: |; | [src/Solvers/plan\_transforms.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `100% <0%> (+33.33%)` | :arrow_up: |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `98.11% <0%> (+56.6%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=footer). Last update [0f1f5ab...99f7404](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797:3611,Power,Powered,3611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797,1,['Power'],['Powered']
Energy Efficiency,"nstants:; set!(model, T = itemp, S = isal). #Setting up a simulation ; using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Dates\src\periods.jl:53; zero(::Colorant) at C:\Users\My Account\.julia\packages\ColorTypes\6m8P7\src\traits.jl:477; zero(::TaylorSeries.Taylor1) at C:\Users\My Account\.julia\packages\TaylorSeries\tveWm\src\arithmetic.jl:37; ... Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base .\number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils C:\Use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946:5409,schedul,schedule,5409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946,1,['schedul'],['schedule']
Energy Efficiency,"nt in this case is calculated as. ```math; c_s^2 = \frac{\langle L_{ij} M_{ij}\rangle}{\langle M_{ij} M_{ij} \rangle},; ```; where $M_{ij}$ and $L_{ij}$ are obtained by applying the Germano identity and minimizing the error. $\langle \cdot \rangle$ is an average which usually is implemented as planar averaging. I'm implementing it here with an arbitrary `DirectionalAveraging` procedure that can average in whatever direction the user wants. Following a suggestion by @glwagner in #3637, I'm also starting to put the pieces in place for a more general averaging procedure so that eventually we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fie",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:1287,efficient,efficient,1287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['efficient'],['efficient']
Energy Efficiency,"nt_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:1255,reduce,reduce,1255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,1,['reduce'],['reduce']
Energy Efficiency,"nteresting that the code will still be called `Oceananigans` :-D. I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1009,reduce,reduce,1009,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['reduce'],['reduce']
Energy Efficiency,"nto [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/47b46131e951c906dc38c29125395792762de57e?src=pr&el=desc) will **increase** coverage by `3.21%`.; > The diff coverage is `77.77%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #140 +/- ##; ========================================; + Coverage 56.78% 60% +3.21% ; ========================================; Files 19 19 ; Lines 597 620 +23 ; ========================================; + Hits 339 372 +33 ; + Misses 258 248 -10; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `37.64% <77.77%> (+37.64%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.72% <0%> (+0.63%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=footer). Last update [47b4613...b880a9b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633129:1896,Power,Powered,1896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633129,1,['Power'],['Powered']
Energy Efficiency,"o = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.add_sum), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.mul_prod), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::Union{typeof(Base._extrema_rf), typeof(max), typeof(min)}, ::Bool, ::AbstractArray) where T at reducedim.jl:84; ...; Stacktrace:; [1] initialize_reduced_field!; ```; I'm trying to figure out why would this fail in v1.8.0-rc1 but not on v1.7 but no luck so far.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663:2132,reduce,reducedim,2132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663,3,['reduce'],['reducedim']
Energy Efficiency,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2859,energy,energy,2859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,2,['energy'],['energy']
Energy Efficiency,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2116,adapt,adapt,2116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['adapt'],['adapt']
Energy Efficiency,"o/gh/CliMA/Oceananigans.jl/commit/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251?el=desc) will **increase** coverage by `0.36%`.; > The diff coverage is `90.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1082 +/- ##; ==========================================; + Coverage 56.79% 57.16% +0.36% ; ==========================================; Files 161 161 ; Lines 3796 3838 +42 ; ==========================================; + Hits 2156 2194 +38 ; - Misses 1640 1644 +4 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `83.01% <80.00%> (-1.30%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `88.15% <86.36%> (+0.22%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `87.77% <95.65%> (+2.48%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=footer). Last update [e1026b0...d018eae](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1082#issuecomment-712562035:1927,Power,Powered,1927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082#issuecomment-712562035,1,['Power'],['Powered']
Energy Efficiency,"o/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=h1) Report; > Merging [#205](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/7f03edacd8acbded7bb1377c80b6995fc6c925b1?src=pr&el=desc) will **decrease** coverage by `0.09%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #205 +/- ##; =========================================; - Coverage 66.51% 66.42% -0.1% ; =========================================; Files 18 18 ; Lines 675 676 +1 ; =========================================; Hits 449 449 ; - Misses 226 227 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=footer). Last update [7f03eda...899ef72](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/205#issuecomment-485808891:1731,Power,Powered,1731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/205#issuecomment-485808891,2,['Power'],['Powered']
Energy Efficiency,"oc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSpheres.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1602/files#diff-20a2fde3ffb57dacaf2440040602aa34df63d347b81a5f18153845e523173d85>; > (16); > - *A*; > validation/cubed_sphere_eddying_aquaplanet/animate_on_map_projection.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1602/files#diff-3e851a92e09dfbd624c25fc1b1788c34f3dcd632f708d910b8c4825d3d77fc37>; > (98); > - *A*; > validation/cubed_sphere_eddying_aquaplanet/cubed_sphere_eddying_aquaplanet.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:1439,energy,energy,1439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['energy'],['energy']
Energy Efficiency,"ocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:5565,schedul,schedule,5565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['schedul'],['schedule']
Energy Efficiency,"ode; > will still be called Oceananigans :-D; >; > I'm not sure I understand point 4 completely. The ocean model also has the; > concept of a model ""state""; for example, ghost cell values and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:1200,reduce,reduce,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['reduce'],['reduce']
Energy Efficiency,"odecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=h1) Report; > Merging [#249](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/b746a0bce63642a8beb9e6771b4b43cd17368ba6?src=pr&el=desc) will **decrease** coverage by `0.73%`.; > The diff coverage is `28.57%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #249 +/- ##; ==========================================; - Coverage 74.71% 73.97% -0.74% ; ==========================================; Files 23 24 +1 ; Lines 866 876 +10 ; ==========================================; + Hits 647 648 +1 ; - Misses 219 228 +9; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (+16.66%)` | :arrow_up: |; | [src/architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/diff?src=pr&el=tree#diff-c3JjL2FyY2hpdGVjdHVyZXMuamw=) | `28.57% <28.57%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=footer). Last update [b746a0b...b40c347](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496661941:1723,Power,Powered,1723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496661941,1,['Power'],['Powered']
Energy Efficiency,"odecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=h1) Report; > Merging [#381](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/289b1e3f8bb0012bfee30f1d8eb12f75179c2c4b?src=pr&el=desc) will **increase** coverage by `0.42%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #381 +/- ##; ==========================================; + Coverage 71.65% 72.07% +0.42% ; ==========================================; Files 26 26 ; Lines 1418 1418 ; ==========================================; + Hits 1016 1022 +6 ; + Misses 402 396 -6; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.66% <0%> (+3.38%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <0%> (+4.39%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=footer). Last update [289b1e3...55ae7b1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/381#issuecomment-525894779:1706,Power,Powered,1706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/381#issuecomment-525894779,1,['Power'],['Powered']
Energy Efficiency,"odel::NonhydrostaticModel{…}, callbacks::Vector{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:31; > [11] #apply_regionally!#56; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:121 [inlined]; > [12] apply_regionally!; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; > [13] macro expansion; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:206 [inlined]; > [14] update_state!(model::NonhydrostaticModel{…}, callbacks::Vector{…}; compute_tendencies::Bool); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:47; > [15] update_state!; > @ ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19 [inlined]; > [16] update_state!(model::NonhydrostaticModel{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19; > [17] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{…}, closure::Nothing, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@NamedTuple{}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198; > [18] top-level scope; > @ REPL[5]:1; > Some type information was truncated. Use `show(err)` to see complete types.; > ```. Ok I fixed that. Probably we should use a `Field` rather than `ones` for the test and examples, because it automatically adapts to GPU, distributed, etc, so its a bit better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708:5212,adapt,adapts,5212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708,1,['adapt'],['adapts']
Energy Efficiency,"ogy=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; #",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1260,schedul,schedule,1260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"ok, then we shift the bathymetry as a pressure term in the momentum and initialize ; `h = bathymetry` in the global simulation. for the NaNs, it might be a problem of implementation, changing `h` to total depth might fix it... ; I'll change it now. @francispoulin you can try; ```; simulation.output_writers[:surface_fields] = JLD2OutputWriter(model, merge(model.solution, (; ζ)),; schedule = TimeInterval(save_interval),; filename = output_prefix * ""_surface"",; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129071864:382,schedul,schedule,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129071864,1,['schedul'],['schedule']
Energy Efficiency,"ology=(Periodic, Periodic, Flat));; c = CenterField(grid);; summed_c = Field(Reduction(sum!, c, dims=1)); @time compute!(summed_c); @time compute!(summed_c); ```. which produces. ```julia; julia> @time compute!(summed_c); 0.103867 seconds (153.65 k allocations: 10.584 MiB, 13.85% gc time, 99.78% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(summed_c); 0.000114 seconds (60 allocations: 3.000 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:1084,reduce,reduced,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['reduce'],['reduced']
Energy Efficiency,"ommit/27493f3682e4996af2e2abf4be240abe6384a3fd?src=pr&el=desc) will **increase** coverage by `0.37%`.; > The diff coverage is `76.19%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #438 +/- ##; ==========================================; + Coverage 73.46% 73.83% +0.37% ; ==========================================; Files 27 27 ; Lines 1515 1525 +10 ; ==========================================; + Hits 1113 1126 +13 ; + Misses 402 399 -3; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `76.19% <76.19%> (+16.19%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `68.53% <0%> (+4.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=footer). Last update [27493f3...88427a6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537980716:1964,Power,Powered,1964,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537980716,1,['Power'],['Powered']
Energy Efficiency,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:2303,reduce,reduces,2303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,1,['reduce'],['reduces']
Energy Efficiency,"on to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/108606976-94430280-738b-11eb-8e29-a30f25c33ab6.png"">. Note that all `h_* = 1` for the purposes of our discussion, and that in Oceananigans notation we have `Δx_g = Δxᶜᶠᶜ` (the grid length at the location of the y-velocity) and `Δx_c = Δxᶠᶜᶜ`. For a flux-form advection scheme, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#coriolis-terms) states that for a hydrostatic implementation we would have. <img width=""253"" alt=""image"" src=""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:1514,energy,energy,1514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799,1,['energy'],['energy']
Energy Efficiency,"ondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing}, Nothing, CPU, ImplicitFreeSurface{Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:11627,Reduce,ReducedField,11627,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Reduce'],['ReducedField']
Energy Efficiency,"onvergenceTests/ForcedFlowFreeSlip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRm9yY2VkRmxvd0ZyZWVTbGlwLmps) | | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | | |; | [...vergence\_tests/analyze\_single\_forced\_fixed\_slip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL2FuYWx5emVfc2luZ2xlX2ZvcmNlZF9maXhlZF9zbGlwLmps) | | |; | [test/test\_regression.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3JlZ3Jlc3Npb24uamw=) | | |; | [examples/ocean\_convection\_with\_plankton.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [...tion/convergence\_tests/analyze\_forced\_free\_slip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL2FuYWx5emVfZm9yY2VkX2ZyZWVfc2xpcC5qbA==) | | |; | ... and [50 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=footer). Last update [d383b6a...76c651a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/793#issuecomment-657517751:3403,Power,Powered,3403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/793#issuecomment-657517751,1,['Power'],['Powered']
Energy Efficiency,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:3615,adapt,adapt,3615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['adapt'],['adapt']
Energy Efficiency,"op_time=0.5day,). using Oceananigans.AbstractOperations: @at; using Oceananigans.Grids: Center, Face. ccc_scratch = Field{Center, Center, Center}(model.grid); u, v, w = model.velocities. u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data). outputs = (; u1, v1,); overwrite_existing = true. simname = ""mwe.nc""; simulation.output_writers[:hr1_writer] =; NetCDFOutputWriter(model, outputs,; filename = ""data/hr1.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). xz_average(F) = Field(Average(F, dims=(1,3))); outputs_avg = map(xz_average, outputs). simulation.output_writers[:avg_writer] =; NetCDFOutputWriter(model, outputs_avg,; filename = ""data/avg.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). run!(simulation); ```. The output for `hr1_writer` appears to be fine, but when I open the outputs for `ave_writer` I get that both outputs are always _exactly_ the same, and they have the value that the xz-average of `u1` should:. ![Screenshot_20220526_114754](https://user-images.githubusercontent.com/13205162/170556118-5e7cfb5b-6491-4e1e-919c-2ea9d5db5211.png). The two left pictures are `u1` and `v1` from `avg_writer`. The figure on the right is the xy-average computed separately. In other words: in this example the xz-average of `u1` gets computed correctly, but the xz-average of `v1` gets assigned the value of the xz-average of `u1`. A couple of notes:. - Using a regular grid instead of an immersed grid solves the issue (although I can't do that since that's the point of my whole simulation); - Removing the scratch space specification solves the issue, but I also can't do that since I'm severely constrained in memory and this reduces my memory footprint in about 50% (maybe after https://github.com/CliMA/Oceananigans.jl/pull/2523 is merged). I've got no idea what's causing this, so any help is appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581:2414,reduce,reduces,2414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581,1,['reduce'],['reduces']
Energy Efficiency,"ore generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, filename) ; update_schedule!(schedule, filepath); ```. Make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:1372,schedul,schedules,1372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,6,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"ostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1141,adapt,adapt,1141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapt']
Energy Efficiency,"ot a problem conceptually. But it might indeed lead to big velocities that they may require smaller dt to tame the CFL. That's not a problem of the code though... It's something the user should be aware. A similar issue comes up, e.g., if you set up a highly unstable stratification. In that case the code will blow up unless you choose your dt appropriately (see, e.g., #1190). Now, in an attempt to show that having `z` periodic is not an issue, I tried to simulate the rising bubble with periodic boundary conditions. I got this puzzling result. Did I do anything wrong?. ```Julia; using Oceananigans, Oceananigans.Grids, Plots. grid = RegularCartesianGrid(size = (1, 64, 64),; x = (0, 1), y = (-4, 4), z = (-4, 4),; topology = (Periodic, Periodic, Periodic)). model = IncompressibleModel(grid = grid,; architecture = CPU(),; advection = Oceananigans.Advection.WENO5(),; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = IsotropicDiffusivity(ν=1e-3, κ=1e-3)). @info ""Simulating a rising buoyant bubble with"" model. set!(model, b = (x, y, z) -> exp(-y^2 - z^2)). simulation = Simulation(model, Δt=0.01, stop_iteration=1000). using Oceananigans.OutputWriters. simulation.output_writers[:fields] = JLD2OutputWriter(model, (model.tracers.b,),; schedule = TimeInterval(0.1),; prefix = ""bubble"",; force = true). run!(simulation). using JLD2. file = jldopen(simulation.output_writers[:fields].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). b = model.tracers.b. y, z = ynodes(b), znodes(b). # Analyze the data. anim = @animate for (i, iteration) in enumerate(iterations); b_snapshot = file[""timeseries/1/$iteration""][1, :, :]. plt = contourf(y, z, b_snapshot',; xlabel = ""y"", ylabel = ""z"", title = ""Buoyancy"",; xlim = (grid.yF[1], grid.yF[end]), ylim = (grid.zF[1], grid.zF[end]),; aspectratio = :equal, linewidth = 0); end. gif(anim, ""bubble.gif"", fps = 8) # hide; ```. ![bubble](https://user-images.githubusercontent.com/7112768/100959619-cd30bf80-3572-11eb-84a7-89f304ef7ccc.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737639915:1307,schedul,schedule,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737639915,1,['schedul'],['schedule']
Energy Efficiency,"oundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(abs), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); │ @ GPUArrays /glade/work/tomasc/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; │ [22] #maximum!#707; │ @ ./reducedim.jl:895 [inlined]; │ [23] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:12374,reduce,reducedim,12374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['reduce'],['reducedim']
Energy Efficiency,"oundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.87% <100.00%> (ø)` | |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `86.20% <100.00%> (+0.49%)` | :arrow_up: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `91.22% <100.00%> (+0.15%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `77.08% <100.00%> (+3.61%)` | :arrow_up: |; | [...ions/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3ZlcnN0YXBwZW5fYW5pc290cm9waWNfbWluaW11bV9kaXNzaXBhdGlvbi5qbA==) | `88.05% <100.00%> (+0.18%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=footer). Last update [847d446...9220221](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/820#issuecomment-663134610:3197,Power,Powered,3197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/820#issuecomment-663134610,1,['Power'],['Powered']
Energy Efficiency,"ov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `65.62% <100%> (+2.29%)` | :arrow_up: |; | [src/closures/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `76.66% <22.22%> (-18.79%)` | :arrow_down: |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `51.63% <40.54%> (-6.81%)` | :arrow_down: |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `52.77% <51.61%> (+34.59%)` | :arrow_up: |; | [src/closures/anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `96.96% <96.96%> (ø)` | |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `39.16% <0%> (-60.01%)` | :arrow_down: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=footer). Last update [8fdff75...11e3043](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508958002:3396,Power,Powered,3396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508958002,2,['Power'],['Powered']
Energy Efficiency,"ov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `91.66% <ø> (ø)` | |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `98.11% <ø> (+56.6%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `73.68% <ø> (ø)` | :arrow_up: |; | [src/Solvers/channel\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvY2hhbm5lbF9wcmVzc3VyZV9zb2x2ZXIuamw=) | `98.63% <ø> (+68.49%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <ø> (ø)` | :arrow_up: |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <ø> (ø)` | :arrow_up: |; | ... and [137 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=footer). Last update [77a22ef...4b78751](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335:3574,Power,Powered,3574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335,1,['Power'],['Powered']
Energy Efficiency,"overage by `0.29%`.; > The diff coverage is `55%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #444 +/- ##; =========================================; - Coverage 71.85% 71.55% -0.3% ; =========================================; Files 25 26 +1 ; Lines 1400 1417 +17 ; =========================================; + Hits 1006 1014 +8 ; - Misses 394 403 +9; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `81.57% <ø> (-0.48%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `47.67% <45.45%> (-1.68%)` | :arrow_down: |; | [src/forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL2ZvcmNpbmcuamw=) | `66.66% <66.66%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=footer). Last update [4b7e5bc...5a6c772](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539584456:2046,Power,Powered,2046,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539584456,1,['Power'],['Powered']
Energy Efficiency,"ow to go about fully incorporating a vertically; > stretched grid, true finite volume operators, and the new FFT+tridiagonal; > Poisson solvers needed to solve for the pressure on a stretched grid.; >; > Seems like a good idea to split it up into steps with one pull request per; > step:; >; > 1. Reverse the k index. Currently PR #462; > <https://github.com/climate-machine/Oceananigans.jl/pull/462>.; > 2. Revise the RegularCartesianGrid struct so we're happy with it.; > Currently PR #464; > <https://github.com/climate-machine/Oceananigans.jl/pull/464>.; > 3. Add finite volume operators as a separate piece of code.; > Technically they won't be tested in this PR and could have mistakes.; > Currently PR #283; > <https://github.com/climate-machine/Oceananigans.jl/pull/283>; > 4. Nuke the old operators and start using the same set of finite; > volume operators for both Oceananigans.Operators and; > closure_operators.jl. This will test that the finite volume operators; > reduce down to the operators that currently work, but doesn't test them on; > a stretched grid.; > 5. Implement a VerticallyStretchedCartesianGrid. Might have to iterate; > bit to figure out what we need, e.g. I think we'll want ΔzC to include the; > distance between the first cell center and the halo cell center, etc.; > 6. Implement CPU and GPU pressure solvers for vertically stretched; > grids with tests. There will be two: one for horizontally periodic domains; > and another for channel models. I've figured most of this stuff out in; > Jupyter notebooks.; > 7. Ensure that models with vertically stretched grids pass basic; > tests: e.g. incompressibility, tracer conservation, etc. This will test the; > finite volume operators.; > 8. Run a model with a VerticallyStretchedCartesianGrid but with; > uniform grid spacing and make sure it produces the same numbers as a model; > with RegularCartesianGrid. This is a sanity check.; > 9. Run additional tests for vertically stretched grids: e.g. vertical; > diffusi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187:1622,reduce,reduce,1622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187,1,['reduce'],['reduce']
Energy Efficiency,"ow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:1171,reduce,reduce,1171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,2,['reduce'],['reduce']
Energy Efficiency,"ow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `86.07% <100%> (+6.28%)` | :arrow_up: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `94.59% <100%> (+1.49%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `34.78% <25%> (+1.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `36.84% <48.57%> (-6.71%)` | :arrow_down: |; | ... and [6 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=footer). Last update [bbc8643...387aeda](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-475444615:3277,Power,Powered,3277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-475444615,1,['Power'],['Powered']
Energy Efficiency,"p inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is probably an improvement. We can still provide the keywords `stop_time` and `stop_iteration` in the `Simulation` constructor as a convenience; however rather than being properties of `Simulation` we will create callback objects that get scheduled every iteration and add them to `simulation.callbacks`. I think we should also provide a few other features, like to ability to pass `Δt` to `run!`, perhaps along with a few other `run!`-specific objects.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138:1835,schedul,schedule,1835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138,4,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:7871,Adapt,Adapt,7871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,1,['Adapt'],['Adapt']
Energy Efficiency,"paced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=0.5. julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN. julia> using Statistics: norm. julia> norm(f1); 2.29128784747792. julia> norm(f2); 0.0; ```. Maybe we have not set correctly the index of the residuals?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998:1647,reduce,reduced,1647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998,1,['reduce'],['reduced']
Energy Efficiency,"packages/Oceananigans/X0YQn/src/ImmersedBoundaries/mask_immersed_field.jl:6; [4] iterate; @ ./generator.jl:47 [inlined]; [5] collect(itr::Base.Generator{NamedTuple{(:u, :v, :η, :b), Tuple{Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.FunctionField{Center, Face, Center, Clock{Float64}, Nothing, typeof(V), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:3747,Reduce,ReducedField,3747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,1,['Reduce'],['ReducedField']
Energy Efficiency,"pbWVfc3RlcHBpbmcuamw=) | `92.59% <0.00%> (-2.65%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `87.50% <0.00%> (-1.39%)` | :arrow_down: |; | [src/Utils/with\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...bulence\_closure\_implementations/nothing\_closure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL25vdGhpbmdfY2xvc3VyZS5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `84.84% <0.00%> (ø)` | |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `85.07% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.44% <0.00%> (+0.82%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=footer). Last update [10949b0...369c7ba](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/948#issuecomment-694124632:3524,Power,Powered,3524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948#issuecomment-694124632,1,['Power'],['Powered']
Energy Efficiency,"pen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3ZlcnN0YXBwZW5fYW5pc290cm9waWNfbWluaW11bV9kaXNzaXBhdGlvbi5qbA==) | `86.81% <0.00%> (-1.07%)` | :arrow_down: |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `85.00% <0.00%> (-0.72%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `90.54% <0.00%> (-0.54%)` | :arrow_down: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `75.00% <0.00%> (+1.53%)` | :arrow_up: |; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `23.63% <0.00%> (+1.76%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=footer). Last update [847d446...d0e01fa](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/817#issuecomment-663198061:3085,Power,Powered,3085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/817#issuecomment-663198061,1,['Power'],['Powered']
Energy Efficiency,"ping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:1516,reduce,reduce,1516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,1,['reduce'],['reduce']
Energy Efficiency,"ple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv = 150meters # virtual h (stratification) ; S = 2.8 # m/s; c=2750kilometers # center of the storm; l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:5277,schedul,schedule,5277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['schedul'],['schedule']
Energy Efficiency,"plifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:3432,reduce,reduced,3432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['reduce'],['reduced']
Energy Efficiency,"pping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is probably an improvement. We can still provide the keywords `stop_time` and `stop_iteration` in the `Simulation` constructor as a convenience; however rather than being properties of `Simulation` we w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138:1588,schedul,schedule,1588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138,1,['schedul'],['schedule']
Energy Efficiency,"ppingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1830,reduce,reduce,1830,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `92.00% <100.00%> (+8.00%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL0xvZ2dlci5qbA==) | `79.16% <0.00%> (-9.73%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0.00%> (-6.67%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32.00% <0.00%> (-2.10%)` | :arrow_down: |; | ... and [46 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=footer). Last update [bff7abc...b83618c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599283973:3756,Power,Powered,3756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599283973,1,['Power'],['Powered']
Energy Efficiency,"proved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. denotes the interpolation of a field from `caa` to `faa`. Note that the destination of the operation is implied. Using composition, we also define double interpolations, such as. `▶xy_ffa`,. which interpolates a field located at `ffa` (x face, y face, and any z location) to `cca`. . There are 12 such double interpolation operators and they are essential for specifying eddy diffusivity closures based on strain rate. I think that using composition to its fullest will ultimately reduce the code length, make the code easier to maintain, and will probably make the code more robust by reducing the number of possible bugs. I think these should eventually be moved into `/src/operators/`, but I also think this should wait for a future PR. Ultimately I believe all the operators should be overhauled to match the pattern introduced in this PR. This PR partially partially solves #217 and will replace #218.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:3271,reduce,reduce,3271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,1,['reduce'],['reduce']
Energy Efficiency,"ps://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `83.33% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `77.77% <0.00%> (ø)` | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `50.00% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/IncompressibleModels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9jbG9jay5qbA==) | `53.84% <0.00%> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=footer). Last update [03a6f85...f307336](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1184#issuecomment-727480160:3699,Power,Powered,3699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1184#issuecomment-727480160,1,['Power'],['Powered']
Energy Efficiency,"ps://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `71.42% <0%> (-11.91%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `81.17% <100%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95% <100%> (+0.4%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.47% <100%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `26.08% <45.45%> (+13.58%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `41.53% <45.61%> (+6.75%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `81.11% <57.14%> (-2.61%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `57.57% <90.9%> (+11.62%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=footer). Last update [b746a0b...e4ae7bd](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496941099:2793,Power,Powered,2793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496941099,1,['Power'],['Powered']
Energy Efficiency,"ps://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.3% <ø> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.14% <100%> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `56.25% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.65% <100%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <100%> (ø)` | :arrow_up: |; | ... and [9 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=footer). Last update [5cd0e33...e5556a7](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/406#issuecomment-531502548:3524,Power,Powered,3524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406#issuecomment-531502548,1,['Power'],['Powered']
Energy Efficiency,"ptionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through which averaging is specified. Eventually, we should use the ""scheduling"" concept for both callafter function in `run!(simulation)` and the `TimeStepWizard` (separately), which will get rid of the `iteration_interval` argument in `run!(simulation)`. PS: should we use `WindowAveragedTimeInterval` rather than `AveragedTimeInterval`? I wasn't sure if the added verbosity added",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:1707,schedul,schedule,1707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,1,['schedul'],['schedule']
Energy Efficiency,"pull/815/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0cy5qbA==) | `77.77% <ø> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `73.46% <57.14%> (ø)` | |; | [src/Advection/Advection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9BZHZlY3Rpb24uamw=) | `100.00% <100.00%> (ø)` | |; | [src/Advection/centered\_second\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9zZWNvbmRfb3JkZXIuamw=) | `100.00% <100.00%> (ø)` | |; | [src/Advection/momentum\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9tb21lbnR1bV9hZHZlY3Rpb25fb3BlcmF0b3JzLmps) | `100.00% <100.00%> (ø)` | |; | [src/Advection/tracer\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100.00%> (ø)` | |; | ... and [7 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=footer). Last update [1dbe86c...d42428d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/815#issuecomment-662674506:3329,Power,Powered,3329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/815#issuecomment-662674506,1,['Power'],['Powered']
Energy Efficiency,"pull/945/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [...ce\_tests/ConvergenceTests/PointExponentialDecay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvUG9pbnRFeHBvbmVudGlhbERlY2F5Lmps) | `0.00% <ø> (ø)` | |; | [...ation/convergence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | `0.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `91.83% <66.66%> (-1.79%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `83.33% <81.81%> (+13.33%)` | :arrow_up: |; | ... and [11 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=footer). Last update [10949b0...0b7899a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129:3416,Power,Powered,3416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129,1,['Power'],['Powered']
Energy Efficiency,"put unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/pii/S1463500314001796) (Petersen et al 2015); * [GVC in a nonhydrostatic compressible atmospheric model ENDgame](https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.3368) (Kavcic and Thuburn, 2018); * [Correct calculation of pressure gradients in a finite volume model](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=vsSBQiBsJugAAAAA:GHaDu6afxrLQ4NIdCDiGWl47xClDdYRdM-CSFlZ8kGxQMAOov7vSHAKp_Ch5hQ9OsousvG8sCg) (Adcroft et al 2008); [An “adaptive”, semi-Lagrangian GVC](https://www.sciencedirect.com/science/article/pii/S1463500302000604) (Burchard and Beckers 2004) See also a [3D description](https://www.sciencedirect.com/science/article/pii/S1463500309002248?casa_token=l2d7ijIAiN8AAAAA:kVzMMRqaP2d6U0QDaqB1vqfWKHjIpGWZr0EovdkMJtxHxGSb_xEQ8SlG3OtYkb2mz-6ggmGwGA) (Hofmeister et al 2010) and [realistic test case](https://www.sciencedirect.com/science/article/pii/S1463500311000801?casa_token=CkEoHLOnIxMAAAAA:QWjy9Ck26XOhdWf5K-IaJghogprZ06FDTuCZeORuBO69lWLcRYiWkz4uFtoXRLbfTATnuk932w) (Hofmeister et al 2011); [“z star” GVC in MITgcm](https://www.sciencedirect.com/science/article/pii/S1463500303000544) (Adcroft and Campin 2004)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:4652,adapt,adaptive,4652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['adapt'],['adaptive']
Energy Efficiency,"r * v; @inline immersed_drag_u(x, z, t, u, p) = - p.r * u; @inline immersed_drag_v(x, z, t, v, p) = - p.r * v. wind_stress_bc_u = FluxBoundaryCondition(wind_stress_u, parameters=(; τx₀, Twind)); wind_stress_bc_v = FluxBoundaryCondition(wind_stress_v, parameters=(; τy₀, Twind)). drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u), parameters=(; r)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:v), parameters=(; r)); immersed_drag_bc_u = FluxBoundaryCondition(immersed_drag_u, field_dependencies=(:u), parameters=(; r)); immersed_drag_bc_v = FluxBoundaryCondition(immersed_drag_v, field_dependencies=(:v), parameters=(; r)). u_bcs = FieldBoundaryConditions(top=wind_stress_bc_u, bottom=drag_bc_u, immersed=immersed_drag_bc_u); v_bcs=FieldBoundaryConditions(top=wind_stress_bc_v, bottom=drag_bc_v, immersed=immersed_drag_bc_v); bcs = (; u=u_bcs, v=v_bcs). turbulence_closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(), ν=Av). model = HydrostaticFreeSurfaceModel(grid=grid, boundary_conditions=bcs,; momentum_advection=nothing, # Linear to compare with analytical solution.; closure=turbulence_closure,; buoyancy=nothing,; coriolis=FPlane(f=f)). g = 0.01; cgw = dx/sqrt(g*hmin); Δt₀ = cgw*maxcfl/5; simulation = Simulation(model; Δt=Δt₀, stop_time=te). start_time = time_ns(); function log_message(sim); prog = 100*time(sim)/sim.stop_time; @printf(""[%05.2f%%] t: %1.1f Ti, Δt: %s, max|u, v, w|: %1.2f, %1.2f, %1.1e m s⁻¹, walltime: %s\n"",; prog, time(sim)/Ti, prettytime(sim.Δt),; maximum(abs, sim.model.velocities.u), maximum(abs, sim.model.velocities.v), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); end. simulation.callbacks[:progress] = Callback(log_message, TimeInterval(logdt)); outputs = (; u=model.velocities.u, v=model.velocities.v); simulation.output_writers[:fields2D] = NetCDFOutputWriter(model, outputs,; schedule=TimeInterval(outdt),; filename=fout,; overwrite_existing=true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906:4079,schedul,schedule,4079,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906,1,['schedul'],['schedule']
Energy Efficiency,"r&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/3f3ef52eaa68d8e28901d7acbed5d99960798307?src=pr&el=desc) will **increase** coverage by `0.15%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #496 +/- ##; ==========================================; + Coverage 73.31% 73.46% +0.15% ; ==========================================; Files 27 27 ; Lines 1525 1515 -10 ; ==========================================; - Hits 1118 1113 -5 ; + Misses 407 402 -5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.31% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `88.23% <ø> (+8.68%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=footer). Last update [3f3ef52...2373483](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/496#issuecomment-545579286:1884,Power,Powered,1884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496#issuecomment-545579286,1,['Power'],['Powered']
Energy Efficiency,"r&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `39.28% <0%> (-35.3%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `77.24% <0%> (-1.68%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `60.29% <100%> (+0.61%)` | :arrow_up: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `52.77% <66.66%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <0%> (-58.55%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `16.21% <0%> (-16.22%)` | :arrow_down: |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `9.67% <0%> (-3.23%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=footer). Last update [16c363e...4738b6b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515218612:3293,Power,Powered,3293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515218612,1,['Power'],['Powered']
Energy Efficiency,"r.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `84% <0%> (-1.72%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `65% <0%> (-1.67%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.89% <0%> (+0.22%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `90% <0%> (+4.28%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80% <0%> (+30%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=footer). Last update [2ae1cbb...9ceb221](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860:3208,Power,Powered,3208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860,1,['Power'],['Powered']
Energy Efficiency,"r/package_linux64/build/usr/share/julia/stdlib/v1.6/Statistics/src/Statistics.jl:131; [14] compute!; @ ~/Oceananigans.jl/src/Fields/averaged_field.jl:62 [inlined]; [15] compute!(avg::AveragedField{Nothing, Nothing, Center, Oceananigans.Fields.FieldStatus{Float64}, GPU, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, 2, Field{Center, Center, Center, GPU, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/averaged_field.jl:61; [16] top-level scope; @ REPL[35]:1; [17] top-level scope; @ ~/.julia/dev/CUDA/src/initialization.jl:50; ```. using. ```diff; diff --git a/src/mapreduce.jl b/src/mapreduce.jl; index f9489dcf..11c0aee0 100644; --- a/src/mapreduce.jl; +++ b/src/mapreduce.jl; @@ -209,6 +209,10 @@ function GPUArrays.mapreducedim!(f::F, op::OP, R::AnyCuArray{T},; shmem = reduce_shmem; blocks = reduce_blocks*other_blocks; ; + @show threads; + @show blocks; + @show reduce_blocks; +; # perform the actual reduction; if reduce_blocks == 1; # we can cover the dimensions to reduce using a single block; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157:10476,reduce,reduce,10476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157,1,['reduce'],['reduce']
Energy Efficiency,"rModel(; grid=grid,; gravitational_acceleration=9.81,; coriolis=FPlane(f=1),; ). #SMOOTH RANDOM FUNCTION; using Random; Random.seed!(17). n = 16; m = 16; len = n * m * 4. global alea; alea = rand(-1:1, (n, m, 4)). function rand_smth(x::Float64, y::Float64); X = x / 1000000; Y = y / 1000000; val = 0; for i in 1:n; for j in 1:m; ar = alea[i,j,1]; br = alea[i,j,2]; cr = alea[i,j,3]; dr = alea[i,j,4]; val += ar * cos(i * x) * cos(j * y); val += br * cos(i * x) * sin(j * y); val += cr * sin(i * x) * cos(j * y); val += dr * sin(i * x) * sin(j * y); end; end; return val; end; #End of smooth random function. H = 1kilometer # unperturbed layer depth. h₀(x, y, t) = H + rand_smth(x,y). set!(model, h=h₀). uh, vh, h = model.solution. simulation = Simulation(model, Δt=0.002, stop_iteration=10000). using Oceananigans.OutputWriters: JLD2OutputWriter, IterationInterval. simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.solution,; filename = ""simkm1.jld2"",; schedule=IterationInterval(4),; overwrite_existing = true). run!(simulation). using JLD2. file = jldopen(simulation.output_writers[:fields].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). xh, yh, zh = nodes(h). using Plots. @info ""Making a neat movie of height..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; h_snapshot = file[""timeseries/h/$iteration""][:, :, 1]. h_lim = 1.5meter; h_levels = range(H - h_lim, stop = H + h_lim, length=40). kwargs = (xlabel=""x"", ylabel=""y"", aspectratio=1, linewidth=0, colorbar=true,; xlims=(-model.grid.Lx/2, model.grid.Lx/2), ylims=(-model.grid.Ly/2, model.grid.Ly/2)). h_plot = contourf(xh, yh, clamp.(h_snapshot', H - h_lim, H + h_lim);; color = :balance,; levels = h_levels,; clims = (H - h_lim, H + h_lim),; kwargs...). plot(h_plot, title=""Height"", layout=(1), size=(600, 500)); end. mp4(anim, ""simkm1.mp4"", fps = 64) # hide. ```; **Initial random height func",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2671:2055,schedul,schedule,2055,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2671,1,['schedul'],['schedule']
Energy Efficiency,"rRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Solvers.PreconditionedConjugateGradientSolver{CPU, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.implicit_free_surface_linear_operation!), Float64, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Nothing, Nothing}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:14905,Reduce,ReducedField,14905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Reduce'],['ReducedField']
Energy Efficiency,"rations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `64.51% <0.00%> (-6.92%)` | :arrow_down: |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <ø> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `90.33% <ø> (-0.75%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `92.30% <100.00%> (+0.20%)` | :arrow_up: |; | [src/Fields/pressure\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9wcmVzc3VyZV9maWVsZC5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/OutputWriters/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvd2luZG93ZWRfdGltZV9hdmVyYWdlLmps) | `97.05% <100.00%> (+3.51%)` | :arrow_up: |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.38% <100.00%> (+0.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=footer). Last update [d6ce0fe...98b825f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/964#issuecomment-695015162:2749,Power,Powered,2749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/964#issuecomment-695015162,1,['Power'],['Powered']
Energy Efficiency,"rc=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `70.00% <0.00%> (-11.82%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `78.37% <0.00%> (-10.82%)` | :arrow_down: |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `85.13% <0.00%> (-8.29%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (-8.10%)` | :arrow_down: |; | ... and [90 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=footer). Last update [681fa0b...3a08525](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/829#issuecomment-668439380:3484,Power,Powered,3484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/829#issuecomment-668439380,1,['Power'],['Powered']
Energy Efficiency,"rc=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `70.00% <0.00%> (-11.82%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `78.37% <0.00%> (-10.82%)` | :arrow_down: |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `85.13% <0.00%> (-8.29%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (-8.10%)` | :arrow_down: |; | ... and [89 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=footer). Last update [8fe4d65...89b7350](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/832#issuecomment-668891485:3484,Power,Powered,3484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/832#issuecomment-668891485,1,['Power'],['Powered']
Energy Efficiency,"rc=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.87% <0.00%> (+0.66%)` | :arrow_up: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Buoyancy/linear\_equation\_of\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L2xpbmVhcl9lcXVhdGlvbl9vZl9zdGF0ZS5qbA==) | `29.41% <0.00%> (+1.63%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `95.83% <0.00%> (+1.95%)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `79.72% <0.00%> (+2.09%)` | :arrow_up: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `87.87% <0.00%> (+2.58%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.80% <0.00%> (+2.91%)` | :arrow_up: |; | [src/OutputWriters/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvd2luZG93ZWRfdGltZV9hdmVyYWdlLmps) | `100.00% <0.00%> (+2.94%)` | :arrow_up: |; | ... and [30 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/995#issuecomment-700325228:2520,reduce,reduced,2520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/995#issuecomment-700325228,1,['reduce'],['reduced']
Energy Efficiency,"rcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). Nx, Ny, Nz = size(grid); xs, ys, zs = nodes(model.tracers.c1). c̄1(z, t) = 1 / (Nx * Ny) * sum(exp(-λ1(x, y, z) * t) for x in xs for y in ys); c̄2(z, t) = 1 / (Nx * Ny) * sum(exp(-λ2(x, y, z) * t) for x in xs for y in ys). rtol = 1e-5 # need custom rtol for isapprox because roundoff errors accumulate (?). # Compute time averages...; c̄1(ts) = 1/length(ts) * sum(c̄1.(zs, t) for t in ts); c̄2(ts) = 1/length(ts) * sum(c̄2.(zs, t) for t in ts). #####; ##### Test strided windowed time average against analytic solution; ##### for *single* NetCDF output; #####; single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; single_ds = NCDataset(single_time_average_nc_filepath). attribute_names = (""schedule"", ""interval"", ""output time interval"",; ""time_averaging_window"", ""time averaging window"",; ""time_averaging_stride"", ""time averaging stride""). for name in attribute_names; @test haskey(single_ds.attrib, name) && !isnothing(single_ds.attrib[name]); end. window_size = window_nΔt; window = window_size*Δt. time = single_ds[""time""][:]; data_plot = single_ds[""c1""][1:4, :]; c̄1_timeaverage = zeros(4,length(time[1:end])); for (n, t) in enumerate(time[1:end]); averaging_times = [t - n*Δt for n in 0:stride:window_size-1 if t - n*Δt >= 0]; # @info n,t,averaging_times, c̄1(averaging_times); c̄1_timeaverage[:,n] = c̄1(averaging_times); # @test all(isapprox.(single_ds[""c1""][:, n+1], c̄1(averaging_times), rtol=rtol)); end. # Plot each of the four lines; pl = plot(); plot!(time, data_plot[1, :], label=""1"", color=:blue, legend=:topright); plot!(time, data_plot[2, :], label=""2"", color=:red); plot!(time, data_plot[3, :], label=""3"", color=:orange); plot!(time, data_plot[4, :], label=""4"", color=:green). plot!(time[1:end],c̄1_timeaverage[1,:], color=:black, lines",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:5543,schedul,schedule,5543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,1,['schedul'],['schedule']
Energy Efficiency,"ree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #107 +/- ##; ==========================================; + Coverage 52.71% 53.15% +0.44% ; ==========================================; Files 19 19 ; Lines 645 649 +4 ; ==========================================; + Hits 340 345 +5 ; + Misses 305 304 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `93.1% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69.15% <100%> (+1.19%)` | :arrow_up: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `85.71% <88.88%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `81.81% <0%> (+9.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=footer). Last update [3cd4ae3...998ee38](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/107#issuecomment-469743151:2117,Power,Powered,2117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/107#issuecomment-469743151,1,['Power'],['Powered']
Energy Efficiency,revamp of lagrangian particles to make sure that they work on a `LatitudeLongitudeGrid` and on an `ImmersedBoundaryGrid` (and adaptation to all the new changes to Oceananigans). closes #2397 ; closes #2395,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2658:126,adapt,adaptation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2658,1,['adapt'],['adaptation']
Energy Efficiency,"riodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But I get similar numbers for `Average`. I think the compilation path may depend on the machine you're using (which could make sense)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:2651,reduce,reduced,2651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['reduce'],['reduced']
Energy Efficiency,"row_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `42.85% <100%> (+6.01%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `85% <100%> (-1.37%)` | :arrow_down: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95.23% <100%> (+0.64%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `52.94% <33.33%> (-28.24%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.9% <44.82%> (+6.12%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `82.24% <76.47%> (-1.78%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=footer). Last update [9260f02...dc2a79c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/167#issuecomment-483002596:3270,Power,Powered,3270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/167#issuecomment-483002596,1,['Power'],['Powered']
Energy Efficiency,"rray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1640,reduce,reduce,1640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"rray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:422 [inlined]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:541 [inlined]; [5] Δzᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.jl:317 [inlined]; [12] macro expansion; @ ./simdloop.jl:77 [inlined]; [13] _mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:316; [14] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:324; [15] sum!(f::Function, r::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:1034; [16] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}; condition::Nothing, mask::Int64, kwargs::@Kwargs{}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:696; [17] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:690; [18] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitAuxiliaryFields(grid::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, CPU}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_explicit_fr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:2482,reduce,reducedim,2482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['reduce'],['reducedim']
Energy Efficiency,"rrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, typeof(Oceananigans.Operators.identity3), typeof(∂x), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/Research/OC.jl/src/OutputWriters/netcdf_output_writer.jl:349; [4] top-level scope; @ REPL[113]:1; ```. I think it's coming from . https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/src/OutputWriters/netcdf_output_writer.jl#L349",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:25011,schedul,schedule,25011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508,1,['schedul'],['schedule']
Energy Efficiency,"rror.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /gla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:1655,reduce,reducedim,1655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,1,['reduce'],['reducedim']
Energy Efficiency,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:2389,adapt,adapting,2389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624,1,['adapt'],['adapting']
Energy Efficiency,"rsion? If the version is 0.58.2, can you please post the full code?. I got the code below from a slack message and it ran with no problems:. ```julia; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.gri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:1179,meter,meters,1179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['meter'],['meters']
Energy Efficiency,"rs{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [22] #maximum!#713; @ ./reducedim.jl:895 [inlined]; [23] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:13626,reduce,reducedim,13626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['reduce'],['reducedim']
Energy Efficiency,rth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:8998,Energy,Energy,8998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Energy'],['Energy']
Energy Efficiency,"run!`. Right now `run!` is barebones. It will take one more argument `pickup` when #1082 is merged. I think `run!` should have more kwargs like `diagnostics`, any of the `stop_criteria`, `Δt`, and `progress`, since these parameters are currently _only_ used in `run!`. We currently require these parameters to be specified in the `Simulation` constructor`:. https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/src/Simulations/simulation.jl#L51-L60. However, I think its better if we encourage them to be set in `run!` where they are used (producing scripts that are more ""locally understandable""). Note that storing these parameters in `Simulation` is really a convenience feature (eg if you want to reference them after using `run!`, you can) rather than essential to how `run!` functions. This would clean up cases where users want to embed `run!` within a loop, because they can then write. ```julia; for i = 1:10; run!(simulation, stop_iteration=model.clock.iteration+10); end; ```. or even (see below). ```julia; for i = 1:10; run!(simulation, stop=Iteration(model.clock.iteration+10)); end; ```. rather than the [slightly more convoluted approach](https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/examples/ocean_convection_with_plankton.jl#L83-L84) (its not a lot of code, but slightly more confusing I think) that is still used in some examples. `run!` might also need a make-over, since I think we should do away with `iteration_interval` and use `AbstractSchedules` for `progress` (or perhaps ""`callafter`"") and the `TimeStepWizard`. We may also want to design `AbstractCriteria` that mirror the design of `AbstractSchedules` for stopping a simulation, so we can have a similar interface for stop criteria as output scheduling, eg something like `stop=SimulationTime(1day)`. I suggest we collect and discussl the extant issues we see with the current design of `Simulation` here. PS do we need `Simulation.parameters`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1095:1882,schedul,scheduling,1882,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1095,1,['schedul'],['scheduling']
Energy Efficiency,"runcation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3.20, Expected = 3; Method = Center4ᵗʰ, Rate of Convergence = 3.98, Expected = 4; Method = CenteredFourthOrder(), Rate of Convergence = 2.45, Expected = 4; Method = Upwind5ᵗʰ, Rate of Convergence = 4.97, Expected = 5; Method = UpwindBiasedFifthOrder(), Rate of Conv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1255,reduce,reduces,1255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595,1,['reduce'],['reduces']
Energy Efficiency,"ry\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.46% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9jb25kaXRpb24uamw=) | `72.72% <78.57%> (+16.47%)` | :arrow_up: |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <90.69%> (+6.95%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `90.00% <93.33%> (+6.00%)` | :arrow_up: |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <100.00%> (ø)` | |; | ... and [13 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=footer). Last update [fbbb5f8...1503288](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190:3611,Power,Powered,3611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190,1,['Power'],['Powered']
Energy Efficiency,"s eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:1877,Reduce,ReducedField,1877,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['Reduce'],['ReducedField']
Energy Efficiency,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m⁻¹; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:3100,schedul,schedule,3100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166,1,['schedul'],['schedule']
Energy Efficiency,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1829,adapt,adapt,1829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,1,['adapt'],['adapt']
Energy Efficiency,"s.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:4516,reduce,reduce,4516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17032,schedul,schedule,17032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,1,['schedul'],['schedule']
Energy Efficiency,"s.jl/pull/234?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/closures/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `100% <100%> (ø)` | |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `100% <100%> (ø)` | |; | [src/closures/constant\_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `100% <100%> (ø)` | |; | [src/closures/velocity\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3ZlbG9jaXR5X2dyYWRpZW50cy5qbA==) | `73.68% <73.68%> (ø)` | |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `93.38% <93.38%> (ø)` | |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=footer). Last update [1bd2036...62af7d5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495651029:2708,Power,Powered,2708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495651029,1,['Power'],['Powered']
Energy Efficiency,"s://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #863 +/- ##; ==========================================; - Coverage 70.90% 70.81% -0.09% ; ==========================================; Files 187 187 ; Lines 5180 5171 -9 ; ==========================================; - Hits 3673 3662 -11 ; - Misses 1507 1509 +2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `95.23% <ø> (-0.12%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `92.78% <ø> (-0.18%)` | :arrow_down: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `80.51% <0.00%> (-1.30%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=footer). Last update [810a3a1...e05c400](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954:2113,Power,Powered,2113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954,1,['Power'],['Powered']
Energy Efficiency,"s; using Oceananigans.Utils. using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics: FieldMaximum; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval. grid = RegularCartesianGrid(size=(256, 256, 64), extent=(4, 4, 0.1)). buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=0)). H=0.1 #dimension in vertical direction; W=4 #dimension in south-north direction; L=4 #dimension in east-west direction; Ra=1e9 #rayleigh number; Ro=0.24 #Horizontal Rossby number; v=2e-6 #diffusive viscocity; k=1e-6 #diffusivity ; l=W/2 #center of gaussian field; m=L/2 #center of gausian field. Bo=0.72e-4 #maximum surface flux. fo=0.5 #coriolis parameter. beta=3.75e-3. #Surface forcing; heat_flux(x,y,t) = Bo*exp(-0.5*((x-l)^2+(y-m)^2)). dTdz = 0 # K m⁻¹. T_bcs = TracerBoundaryConditions(grid,; top = BoundaryCondition(Flux, heat_flux),; bottom = BoundaryCondition(Gradient, dTdz)). #velocity boundary condition; u₁₀ = 1.0e-1 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻². u_bcs = UVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). #Incompressible model initiation ; model = IncompressibleModel(architecture = CPU(),; timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=fo, β=beta),; buoyancy = buoyancy,; closure = IsotropicDiffusivity(ν=v, κ=k),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Te",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289:1070,meter,meters,1070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289,1,['meter'],['meters']
Energy Efficiency,"sCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:1707,reduce,reducedim,1707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,1,['reduce'],['reducedim']
Energy Efficiency,"sCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:3086,reduce,reducedim,3086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reducedim']
Energy Efficiency,"salinity could be put in as a passive tracer, perhaps, with zero flux at; the top and bottom. Should be conserved. On Wed, May 29, 2019 at 5:20 PM Ali Ramadhan <notifications@github.com>; wrote:. > Does linear stratification count as *non-trivially stratified*?; >; > But yeah, adding a bit of salinity in there would be good for the test,; > maybe not so much for the example.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/220?email_source=notifications&email_token=AKXUEQVL36NP3PVX5LIWX2LPX3XTTA5CNFSM4HM5MOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWQVUCQ#issuecomment-497113610>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTN73LJYCI4JDUXTYLPX3XTTANCNFSM4HM5MOYA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/220#issuecomment-497114228:957,Green,Green,957,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/220#issuecomment-497114228,1,['Green'],['Green']
Energy Efficiency,"sb3N1cmVfb3BlcmF0b3JzLmps) | `95.34% <100%> (+0.3%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `83.13% <100%> (+2.02%)` | :arrow_up: |; | [src/closures/constant\_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `63.33% <38.88%> (-36.67%)` | :arrow_down: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `0% <0%> (-100%)` | :arrow_down: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `65.59% <0%> (-20.58%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `12.5% <0%> (-13.59%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `45.94% <0%> (-11.63%)` | :arrow_down: |; | ... and [5 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=footer). Last update [22b7121...1fdaf74](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496324424:3476,Power,Powered,3476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496324424,1,['Power'],['Powered']
Energy Efficiency,"setArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.jul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:3858,reduce,reduce,3858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=footer). Last update [9ef95e7...0e304f4](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/747#issuecomment-628274090:3430,Power,Powered,3430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/747#issuecomment-628274090,1,['Power'],['Powered']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=footer). Last update [92d77b0...8c02fb5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/752#issuecomment-629570073:3430,Power,Powered,3430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/752#issuecomment-629570073,1,['Power'],['Powered']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=footer). Last update [1e8704c...ad40bb1](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/753#issuecomment-629586678:3430,Power,Powered,3430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753#issuecomment-629586678,1,['Power'],['Powered']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=footer). Last update [57f633e...a320923](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/754#issuecomment-629587934:3475,Power,Powered,3475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/754#issuecomment-629587934,1,['Power'],['Powered']
Energy Efficiency,"should be ready to go, the last details to address (but it's an easy change I can make quickly) are; 1) the location of the free surface; 2) the location and type of the right-hand side; 3) the location and type of the internal fields for the PCG. From what I understood we agreed on; 1) located at `Face`s on `grid.Nz+1` (I am a bit worried that this will give a problem in the outputs when we want to save the surface files with `indices = (:, :, grid.Nz)`; 2) `ReducedField` (location `Nothing`); 2) `ReducedField`s (location `Nothing`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897:464,Reduce,ReducedField,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897,2,['Reduce'],['ReducedField']
Energy Efficiency,"simulation = Simulation(model, Δt=10.0, stop_iteration=1000); progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). u, v, w = model.velocities; e = (u^2 + w^2) / 2; E = Field(Integral(e, dims=:)); outputs = merge(model.velocities, model.tracers, (; e, E)). filename = ""test.jld2""; simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); et = FieldTimeSeries(filename, ""e""); bt = FieldTimeSeries(filename, ""b""); Et = FieldTimeSeries(filename, ""E""); times = wt.times; Nt = length(times). fig = Figure(resolution=(1800, 900)). axw = Axis(fig[2, 1], xlabel=""x (m)"", ylabel=""z (m)"", title=""Vertical velocity""); axe = Axis(fig[2, 2], xlabel=""x (m)"", ylabel=""z (m)"", title=""Kinetic energy""); axb = Axis(fig[2, 3], xlabel=""x (m)"", ylabel=""z (m)"", title=""Buoyancy""); axE = Axis(fig[3, 1:3], xlabel=""Time (s)"", ylabel=""Volume averaged kinetic energy""). slider = Slider(fig[1, 1:2], range=1:Nt, startvalue=1); n = slider.value. wn = @lift interior(wt[$n], :, 1, :); en = @lift interior(et[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). x, y, z = nodes(et). wlim = maximum(abs, wt); elim = maximum(abs, et). heatmap!(axw, x, z, wn, colorrange=(-wlim, wlim), colormap=:balance); heatmap!(axe, x, z, en, colorrange=(0, elim), colormap=:solar); heatmap!(axb, x, z, bn, colorrange=(0, 1e-3), colormap=:thermal). t = @lift times[$n]; lines!(axE, times, Et[:]); vlines!(axE, t). display(fig). record(fig, ""test.mp4"", 1:Nt) do nn; @info ""Recording frame $nn of $Nt""; n[] = nn; end; ```. github won't let me attach the movie or image but basically at first energy decreases, then there is a lot of grid scale noise with wave dynamics. So nothing is resolved, and the energy oscillates around. Perhaps later it increases. This might need a background diffusivity?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442576976:2287,energy,energy,2287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442576976,2,['energy'],['energy']
Energy Efficiency,"sing Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(Float64); set!(model1, u=-0.05, v=0,T=thermoc,S=sal). simulation = Simulation(model1, Δt=10., stop_time=80second, iteration_interval=4). function init_save_some_metadata!(file, model); file[""author""] = ""oofs""; return nothing; end. simulation.output_writers[:tracers] = JLD2OutputWriter(model1, model1.tracers,; prefix = ""Temp Data"",; schedule = TimeInterval(10second),; init = init_save_some_metadata!). run!(simulation). using Plots, JLD2, Printf, Oceananigans.Grids; x, y, z = nodes(model1.tracers.T). file = jldopen(simulation.output_writers[:tracers].filepath); iterations = parse.(Int, keys(file[""timeseries/t""])); anim = @animate for (i, iter) in enumerate(iterations). @info ""Drawing frame $i from iteration $iter..."". Temp = transpose(file[""timeseries/T/$iter""][125,:,:]); timeofthing=file[""timeseries/t/$iter""]; ; display(Temp). contourf(y, z, Temp, title = ""Temperature Profile at x=14000, t=$timeofthing"",levels = 0:1:30,linewidth=0,xlabel = ""y"",ylabel = ""z"",); end; gif(anim, ""10s Timestep INFINITE TEMPERATURE REPRODUCER.gif"", fps = 1); ```. And here are some gifs showcasing the issue from the code above with slight modifications. I also forgot to change the name of my plots; they are centered in the x-direction, but are not at x=14000m. Sorry about that.; 1 second timestep; ![1 second timestep INFINITE TEMPERATURE REPRODUCER](https:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190:2502,schedul,schedule,2502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190,1,['schedul'],['schedule']
Energy Efficiency,"sing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothing},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:1337,reduce,reduce,1337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,1,['reduce'],['reduce']
Energy Efficiency,"so one way to do this is to say `adapt(Array, A)` which then requires no knowledge where A was an Array or a CuArray or a complicated model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/171#issuecomment-481430614:33,adapt,adapt,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/171#issuecomment-481430614,1,['adapt'],['adapt']
Energy Efficiency,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1610,efficient,efficient,1610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,1,['efficient'],['efficient']
Energy Efficiency,"src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel(; grid, timestepper, advection, closure). # Initial conditions:; rng = MersenneTwister(seed); u, v = if initial_condition == ""random""; u = rand(rng, actual_size...); v = rand(rng, actual_size...); u .-= mean(u); v .-= mean(v); u, v; else; error(""Unknown initial condition: $initial_condition""); end. set!(model; u=u, v=v). sim = Simulation(model; Δt, stop_time); sim.callbacks[:progress] = Callback(; s -> @info ""Iteration $(iteration(s)) at time $(time(s))"", IterationInterval(100); ). ω, speed = begin; u, v, _ = model.velocities; ω = ∂x(v) - ∂y(u); speed = sqrt(u^2 + v^2); ω, speed; end. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end; ; sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; filename=datadir(""simulations"", savename(d, ""jld2"")),; overwrite_existing=true,; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); return sim; end. Δt = 0.2; size = (128, 128); extent = (1, 1); Δx = extent[1] / size[1]; stop_time = 10.0; topology = (Periodic, Periodic, Flat); architecture = CPU(); timestepper = :RungeKutta3; advection = nothing; closure = nothing; initial_condition = ""random""; seed = 0. params = @strdict size extent topology architecture timestepper advection closure Δt stop_time Δx initial_condition seed. sim = makesim(params); run!(sim); ```; </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2829:2876,schedul,schedule,2876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829,1,['schedul'],['schedule']
Energy Efficiency,"src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/22d76926a9a3687e58de4a36568d55c7e3ca73ba&el=desc) will **increase** coverage by `0.11%`.; > The diff coverage is `85.71%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #744 +/- ##; ==========================================; + Coverage 77.16% 77.28% +0.11% ; ==========================================; Files 125 125 ; Lines 2483 2487 +4 ; ==========================================; + Hits 1916 1922 +6 ; + Misses 567 565 -2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/Forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvRm9yY2luZy5qbA==) | `100.00% <ø> (+50.00%)` | :arrow_up: |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `75.00% <60.00%> (+8.33%)` | :arrow_up: |; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `100.00% <100.00%> (+16.66%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=footer). Last update [22d7692...f1dea29](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/744#issuecomment-622618325:1879,Power,Powered,1879,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744#issuecomment-622618325,1,['Power'],['Powered']
Energy Efficiency,"ster](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/5c573ea1e8038c7cd7023e6675c9f3270ffa8f58?src=pr&el=desc) will **increase** coverage by `1.88%`.; > The diff coverage is `61.53%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #350 +/- ##; ==========================================; + Coverage 72.86% 74.74% +1.88% ; ==========================================; Files 22 22 ; Lines 1157 1176 +19 ; ==========================================; + Hits 843 879 +36 ; + Misses 314 297 -17; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `57.14% <0%> (-2.56%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `64.74% <84.21%> (+20.84%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=footer). Last update [5c573ea...cc18413](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164879:1903,Power,Powered,1903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164879,1,['Power'],['Powered']
Energy Efficiency,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1960,reduce,reduce,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,1,['reduce'],['reduce']
Energy Efficiency,"t `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:1035,reduce,reduce,1035,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,1,['reduce'],['reduce']
Energy Efficiency,"t always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behind the default, that expensive simulations are rare so it doesn't make sense to default it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364:1306,schedul,schedule,1306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364,1,['schedul'],['schedule']
Energy Efficiency,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1042,efficient,efficient,1042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,1,['efficient'],['efficient']
Energy Efficiency,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2704,power,power,2704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['power'],['power']
Energy Efficiency,"t the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as you wouldn't have to change the Fields module. Also, the NonhydrostaticModel will become ""agnostic"" to the architecture in this way. Actually maybe this direction is much better (I will change the PR to reflect this option)... In the end, what do you think? How should we solve this `grid` vs `architecture` conundrum avoiding the definition of a `DistributedModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:3084,allocate,allocate,3084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,2,['allocate'],['allocate']
Energy Efficiency,"t wall, and I'm including a bit of noise in the same west wall to kick off a plume. ```julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(topology = (Bounded, Flat, Periodic), size = (16, 16),; x = (0, 1), z = (0, 1)). buoyancy = BuoyancyTracer(); model = NonhydrostaticModel(; grid, tracers = (:b),; buoyancy = buoyancy,; boundary_conditions = (; b = FieldBoundaryConditions(west=FluxBoundaryCondition(5e-9))),);. noise(x, y, z) = 1e-3 * randn() * exp(-(10x)^2/grid.Lx^2); set!(model, u=noise, w=noise). simulation = Simulation(model, Δt=1, stop_time=10minutes);. wizard = TimeStepWizard(cfl=0.8, min_Δt=0.001seconds); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). outputs = (; model.tracers.b, model.velocities.u, model.velocities.w,; pHY = model.pressures.pHY′, pNH = model.pressures.pNHS,; p = sum(model.pressures),); output_filename = ""2d-zper""; simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs, ; schedule = TimeInterval(10seconds),; filename = output_filename,; overwrite_existing = true); run!(simulation). @info ""Begin plotting""; using Rasters; filename = simulation.output_writers[:fields].filepath; ds = RasterStack(filename). using GLMakie. set_theme!(Theme(fontsize = 20)); fig = Figure(). kwargs = (xlabel=""x"", ylabel=""z"", height=150, width=250); ax1 = Axis(fig[2, 1]; title = ""w"", kwargs...);; ax2 = Axis(fig[2, 2]; title = ""b"", kwargs...);; ax3 = Axis(fig[2, 3]; title = ""pHY"", kwargs...);; ax4 = Axis(fig[2, 4]; title = ""pNH"", kwargs...);; ax5 = Axis(fig[2, 5]; title = ""total pressure"", kwargs...);. # Next we use `Observable`s to lift the values and plot heatmaps and their colorbars. n = Observable(1). speed_magnitude = 2e-2; using Statistics; temp_magnitude = max(std(ds.b), 1e-12). wₙ = @lift ds.w[Ti=$n, yC=Near(0)]; hm1 = heatmap!(ax1, wₙ; colormap = :balance, colorrange=(-speed_magnitude, speed_magnitude)); Colorbar(fig[3, 1], hm1, vertical=false, height=8, ticklabelsize=14). bₙ = @lift ds.b[Ti=$n,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290:1409,schedul,schedule,1409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290,1,['schedul'],['schedule']
Energy Efficiency,"t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1375,schedul,schedule,1375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"t/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:3138,reduce,reducedim,3138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reducedim']
Energy Efficiency,"ta3,; closure = ScalarDiffusivity(ν=1e-6, κ=1e-6),; tracers = :b,; buoyancy = BuoyancyTracer(),; background_fields = (; b=B)) # `background_fields` is a `NamedTuple`. A = 0.01; u_ic(x, y, z) = A * randn(); w_ic(x, y, z) = A * randn(). set!(model, u=u_ic, w=w_ic). simulation = Simulation(model, Δt=0.01, stop_iteration=200). wizard = TimeStepWizard(cfl=0.3, diffusive_cfl=0.3, max_change=1.2, max_Δt=1); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(1)). progress(sim) = @printf(""i: % 6d, sim time: % 1.3f, wall time: % 10s, Δt: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\n"",; iteration(sim), time(sim), prettytime(sim.run_wall_time),; sim.Δt,; AdvectiveCFL(sim.Δt)(sim.model),; DiffusiveCFL(sim.Δt)(sim.model)). simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""background_field_test.jld2""; simulation.output_writers[:velocities] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),; filename = filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); bt = FieldTimeSeries(filename, ""b""); t = wt.times; Nt = length(t); n = Observable(1). wn = @lift interior(wt[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). fig = Figure(resolution=(1500, 700)); axw = Axis(fig[1, 1]); axb = Axis(fig[1, 2]). heatmap!(axw, wn); heatmap!(axb, bn). topostr = string(Oceananigans.Grids.topology(grid, 3)). record(fig, ""vertically_$topostr.mp4"", 1:Nt, framerate=12) do nn; @info ""Drawing frame $nn of $Nt...""; n[] = nn; end; ```. # `vertically_Bounded.mp4`. https://github.com/CliMA/Oceananigans.jl/assets/15271942/8b63ae62-1a44-47c2-931b-9db154adddc2. # `vertically_Periodic.mp4`. https://github.com/CliMA/Oceananigans.jl/assets/15271942/8af44a0f-451e-4f58-a6f0-e204a4e65bd3. The easiest fix is to eliminate the pressure separation. Another solution is to fix the hydrostatic pressure algorithm. We should also note that the vertical tridiagonal solve is not corr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782230866:1376,schedul,schedule,1376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782230866,1,['schedul'],['schedule']
Energy Efficiency,"tacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[11]:1; Some type information was truncated. Use `show(err)` to see complete types. ```; However, by specifying the indices it works; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1), indices = (:, :, grid.Nz)); JLD2OutputWriter scheduled on IterationInterval(1):; ├── filepath: ./test1.jld2; ├── 1 outputs: c; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; ├── file_splitting: NoFileSplitting; └── file size: 20.0 KiB. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835:3386,schedul,schedule,3386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835,3,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"take up a lot of space. ```; (base) fpoulin@vortex2:~/software/Oceananigans.jl$ julia --project=docs/ docs/make.jl; [ Info: generating markdown page from `~/software/Oceananigans.jl/examples/one_dimensional_diffusion.jl`; [ Info: writing result to `~/software/Oceananigans.jl/docs/src/generated/one_dimensional_diffusion.md`; [ Info: SetupBuildDirectory: setting up build directory.; [ Info: Doctest: running doctests.; ┌ Error: doctest failure in src/model_setup/output_writers.md:55-76; │ ; │ ```jldoctest netcdf1; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:1130,schedul,schedule,1130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"taticModel(grid = grid, timestepper = :RungeKutta3,); @info """" model; v_i(x, y, z,) = 0.1 + 1e-2*randn(); set!(model, v=v_i). simulation = Simulation(model, Δt=10seconds, stop_time=0.5day,). using Oceananigans.AbstractOperations: @at; using Oceananigans.Grids: Center, Face. ccc_scratch = Field{Center, Center, Center}(model.grid); u, v, w = model.velocities. u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data). outputs = (; u1, v1,); overwrite_existing = true. simname = ""mwe.nc""; simulation.output_writers[:hr1_writer] =; NetCDFOutputWriter(model, outputs,; filename = ""data/hr1.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). xz_average(F) = Field(Average(F, dims=(1,3))); outputs_avg = map(xz_average, outputs). simulation.output_writers[:avg_writer] =; NetCDFOutputWriter(model, outputs_avg,; filename = ""data/avg.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). run!(simulation); ```. The output for `hr1_writer` appears to be fine, but when I open the outputs for `ave_writer` I get that both outputs are always _exactly_ the same, and they have the value that the xz-average of `u1` should:. ![Screenshot_20220526_114754](https://user-images.githubusercontent.com/13205162/170556118-5e7cfb5b-6491-4e1e-919c-2ea9d5db5211.png). The two left pictures are `u1` and `v1` from `avg_writer`. The figure on the right is the xy-average computed separately. In other words: in this example the xz-average of `u1` gets computed correctly, but the xz-average of `v1` gets assigned the value of the xz-average of `u1`. A couple of notes:. - Using a regular grid instead of an immersed grid solves the issue (although I can't do that since that's the point of my whole simulation); - Removing the scratch space specification solves the issue, but I also can't do that since I'm severely constrained in memory and this reduces m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581:1391,schedul,schedule,1391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581,1,['schedul'],['schedule']
Energy Efficiency,"te-machine/Oceananigans.jl/pull/621/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #621 +/- ##; ==========================================; + Coverage 74.53% 74.87% +0.34% ; ==========================================; Files 117 118 +1 ; Lines 2246 2277 +31 ; ==========================================; + Hits 1674 1705 +31 ; Misses 572 572 ; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Diagnostics/nan\_checker.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL25hbl9jaGVja2VyLmps) | `33.33% <0.00%> (-46.67%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `40.00% <0.00%> (-13.34%)` | :arrow_down: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100.00% <0.00%> (ø)` | :arrow_up: |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.75% <0.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=footer). Last update [eb9b07f...397c15d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584907682:2146,Power,Powered,2146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584907682,1,['Power'],['Powered']
Energy Efficiency,"th 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=Inf. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN; ```. I am still struggling with the `mean` though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383:1023,reduce,reduced,1023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383,2,['reduce'],['reduced']
Energy Efficiency,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:7822,power,powerful,7822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,2,['power'],['powerful']
Energy Efficiency,th │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `C,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:9416,Energy,Energy,9416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Energy'],['Energy']
Energy Efficiency,"that should be ; ```; julia> ∫ᶻ_Axᶠᶜᶜ = Field{Face, Center, Nothing}(with_halo((3, 3, 1), grid), indices = (:, :, grid.Nz)); 4×4×1 Field{Face, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.0, min=0.0, mean=0.0; ```. there are a couple of things to smooth out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247523200:160,reduce,reduced,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247523200,1,['reduce'],['reduced']
Energy Efficiency,"the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another futur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:7321,adapt,adapts,7321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,2,['adapt'],"['adapting', 'adapts']"
Energy Efficiency,"these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows wh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2054,energy,energy,2054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['energy'],['energy']
Energy Efficiency,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2476,reduce,reduced,2476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,"['adapt', 'reduce']","['adapt', 'reduced']"
Energy Efficiency,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1200,adapt,adaptive,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['adapt'],['adaptive']
Energy Efficiency,"tion, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:4477,reduce,reduce,4477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"to calculate `Ub` you can probably use a global reduction. Before that you probably want to have a field to store the flux at edge of the domain:; ```julia; function get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow{Nothing}}, ::Val{:west}, size, offset, loc, arch, grid, Δt, clock, fields, args...; kwargs...); u = fields.u; F₁ = bc.condition.boundary_flux; launch!(arch, grid, :yz, _update_boundary_flux!, F₁, grids, u, Val(:west)); Uᵇ = sum(F₁) / (grid.Ly * grid.Lz). return (Uᵇ, ); end. @kernel function _update_boundary_velocity(F₁, grid, u, ::Val{:west}); j, k = @index(Global, NTuple); @inbounds F₁[1, j, k] = u[1, j, k] * Axᶜᶜᶠ(1, j, k, grid); end; ```; I am not sure about the `(grid.Ly * grid.Lz)` part. We would like to reduce over the active cells in case there is some bathymetry on the outflow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977332894:740,reduce,reduce,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977332894,1,['reduce'],['reduce']
Energy Efficiency,"to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:2848,reduce,reduce,2848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reduce']
Energy Efficiency,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253:223,Adapt,Adapt,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253,1,['Adapt'],['Adapt']
Energy Efficiency,"tor{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.implicit_free_surface_linear_operation!), Float64, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Nothing, Nothing}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:15604,Reduce,ReducedField,15604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Reduce'],['ReducedField']
Energy Efficiency,"tor{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:3824,reduce,reduce,3824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"tor{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:4394,reduce,reduce,4394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"tput writers you need; > ; > ```julia; > u_subsampled = XFaceField(subset_grid); > ; > function subsample_u(model); > u = model.velocities.u; > interpolate!(u_subsampled, u); > return u_subsampled; > end; > ; > outputs = (; u=subsample_u); > ```. I tried. ```julia; subset_grid = RectilinearGrid(arch,; size = (grid.Nx, grid.Ny, div(grid.Nz, 20)),; extent = (grid.Lx, grid.Ly, grid.Lz); ). u_subsampled = XFaceField(subset_grid); v_subsampled = YFaceField(subset_grid); w_subsampled = ZFaceField(subset_grid). function subsample_u(model); u = model.velocities.u; interpolate!(u_subsampled, u); return u_subsampled; end. function subsample_v(model); v = model.velocities.v; interpolate!(v_subsampled, v); return v_subsampled; end. function subsample_w(model); w = model.velocities.w; interpolate!(w_subsampled, w); return w_subsampled; end. subset_outputs = (; u = subsample_u, v = subsample_v, w = subsample_w); ```. and. ```julia; simulation.output_writers[:xyz] = NetCDFOutputWriter(model, subset_outputs,; schedule = TimeInterval(300),; filename = ""test.nc"",; with_halos = false,; array_type = Array{Float32},; ); ```. is returning the following error. ```julia; Custom output v needs dimensions!. Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] define_output_variable!(dataset::NCDatasets.NCDataset{Nothing}, output::Function, name::String, array_type::Type, deflatelevel::Int64, output_attributes::Dict{String, String}, dimensions::Dict{Any, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/netcdf_output_writer.jl:448; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594:1050,schedul,schedule,1050,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594,1,['schedul'],['schedule']
Energy Efficiency,"tree#diff-c3JjL0ZpZWxkcy96ZXJvX2ZpZWxkLmps) | `50.00% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `79.09% <0.00%> (+0.96%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `96.87% <0.00%> (+1.63%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `85.71% <0.00%> (+2.38%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `96.15% <0.00%> (+2.40%)` | :arrow_up: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `42.85% <0.00%> (+2.85%)` | :arrow_up: |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `82.35% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=footer). Last update [d274364...253bb6e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1038#issuecomment-707642154:3483,Power,Powered,3483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1038#issuecomment-707642154,1,['Power'],['Powered']
Energy Efficiency,"tring); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:2987,reduce,reducedim,2987,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['reduce'],['reducedim']
Energy Efficiency,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:2015,reduce,reduce,2015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['reduce'],['reduce']
Energy Efficiency,"ts) * sum(c̄2.(zs, t) for t in ts). #####; ##### Test strided windowed time average against analytic solution; ##### for *single* NetCDF output; #####; single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; single_ds = NCDataset(single_time_average_nc_filepath). attribute_names = (""schedule"", ""interval"", ""output time interval"",; ""time_averaging_window"", ""time averaging window"",; ""time_averaging_stride"", ""time averaging stride""). for name in attribute_names; @test haskey(single_ds.attrib, name) && !isnothing(single_ds.attrib[name]); end. window_size = window_nΔt; window = window_size*Δt. time = single_ds[""time""][:]; data_plot = single_ds[""c1""][1:4, :]; c̄1_timeaverage = zeros(4,length(time[1:end])); for (n, t) in enumerate(time[1:end]); averaging_times = [t - n*Δt for n in 0:stride:window_size-1 if t - n*Δt >= 0]; # @info n,t,averaging_times, c̄1(averaging_times); c̄1_timeaverage[:,n] = c̄1(averaging_times); # @test all(isapprox.(single_ds[""c1""][:, n+1], c̄1(averaging_times), rtol=rtol)); end. # Plot each of the four lines; pl = plot(); plot!(time, data_plot[1, :], label=""1"", color=:blue, legend=:topright); plot!(time, data_plot[2, :], label=""2"", color=:red); plot!(time, data_plot[3, :], label=""3"", color=:orange); plot!(time, data_plot[4, :], label=""4"", color=:green). plot!(time[1:end],c̄1_timeaverage[1,:], color=:black, linestyle=:dash, label=""1-analytic""); plot!(time[1:end],c̄1_timeaverage[2,:], color=:black, linestyle=:dash, label=""2-analytic""); plot!(time[1:end],c̄1_timeaverage[3,:], color=:black, linestyle=:dash, label=""3-analytic""); plot!(time[1:end],c̄1_timeaverage[4,:], color=:black, linestyle=:dash, label=""4-analytic""); ; tt = 0:window:T2; for i in 1:length(tt); plot!([tt[i], tt[i]],[0,1],color=:grey,label=""""); end; title!(pl, string(""Δt="",Δt,"", average window="",window_nΔt,""Δt"")) # Add the title to the plot; ylims!(pl,(minimum(c̄1_timeaverage[4,:]),maximum(c̄1_timeaverage[4,:]))); xlims!(pl,(0,T2)); close(single_ds); display(pl); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:6540,green,green,6540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,1,['green'],['green']
Energy Efficiency,"u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; └ @ Documenter.DocTests ~/.julia/packages/Documenter/lul8Y/src/DocTests.jl:369; ┌ Error: doctest failure in src/model_setup/output_writers.md:78-90; │ . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:3350,schedul,scheduled,3350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130,1,['schedul'],['scheduled']
Energy Efficiency,"u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt))",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1426,schedul,schedule,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.20% <0.00%> (-1.04%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/fill\_halo\_regions\_value\_gradient.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc192YWx1ZV9ncmFkaWVudC5qbA==) | `28.30% <0.00%> (ø)` | |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=footer). Last update [f13a0a2...a40305f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714:3664,Power,Powered,3664,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714,1,['Power'],['Powered']
Energy Efficiency,"uite different when working with GPUs and I honestly don't even know where to begin. Below is an excerpt of my run script that shows the initial and boundary condition creation with a CPU architecture. If anyone can share resources on how to code this for a GPU or just explain it if it is easy, I would greatly appreciate the help!. ```; ρₒ = 1025; ############## Boundary conditions ###################; ## Pulling the boundary conditions from the data csv; df = CSV.read(""data_inputs/kma_buoy_fluxes_soulik.csv"", DataFrame);. seconds = df.time[:]*86400; # convert to seconds; secs = [tnow - seconds[1] for tnow in seconds]; # set first time stamp to 0; secs = [s - 518400 for s in secs]; # Move 0 time stamp to later in the time series. ## make the splines; spl_taux = Spline1D(secs, df.taux/(ρₒ), k=1);; spl_tauy = Spline1D(secs, df.tauy/(ρₒ), k=1);; spl_latHF = Spline1D(secs, df.lat_hf/(ρₒ * cᴾ), k=1);; spl_senHF = Spline1D(secs, df.sens_hf/(ρₒ * cᴾ), k=1);. ## turn the splines into functional arguments; @inline Fxn_taux(x,y,t) = spl_taux(t);; @inline Fxn_tauy(x,y,t) = spl_tauy(t);; @inline Fxn_HFlx(x,y,t) = spl_latHF(t) + spl_senHF(t); # K m⁻¹ s⁻¹, surface _temperature_ flux. ############# Initial conditions #############; ## Initial surface stress condition; Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile. ## Temperature and Salinity initial condition. # Intialize from glider data; df_i = CSV.read(""data_inputs/initial_prof.csv"",DataFrame); Temp = df_i.temp[:]; Salinity = df_i.sal[:]; depth=df_i.depth[:]. spl_temp = Spline1D(depth,Temp,k=1); spl_sal = Spline1D(depth,Salinity,k=1). @inline tempset_prof(x,y,z) = spl_temp(z); @inline salset_prof(x,y,z) = spl_sal(z); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509:2162,reduce,reduce,2162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509,1,['reduce'],['reduce']
Energy Efficiency,"ull/325?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #325 +/- ##; ==========================================; - Coverage 60.71% 60.33% -0.38% ; ==========================================; Files 24 22 -2 ; Lines 1255 1243 -12 ; ==========================================; - Hits 762 750 -12 ; Misses 493 493; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `77.41% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.3% <100%> (+6.59%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `71.98% <66.66%> (-0.27%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40% <66.66%> (-2%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=footer). Last update [aa601c7...f7894de](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517482768:2309,Power,Powered,2309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517482768,1,['Power'],['Powered']
Energy Efficiency,"ull/671?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `53.84% <0.00%> (-29.49%)` | :arrow_down: |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `71.42% <0.00%> (-28.58%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `75.17% <0.00%> (-0.73%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `66.66% <0.00%> (+2.56%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `96.22% <0.00%> (+11.61%)` | :arrow_up: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `75.00% <0.00%> (+12.50%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=footer). Last update [74cfb85...ef8f0a3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/671#issuecomment-595367281:2711,Power,Powered,2711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/671#issuecomment-595367281,1,['Power'],['Powered']
Energy Efficiency,"unctions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1278,Adapt,Adapt,1278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Energy Efficiency,"undaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, typeof(mask_immersed_field!)}); @ Base ./tuple.jl:331; [7] Tuple(itr::Base.Generator{NamedTuple{(:u, :v, :η, :b), Tuple{Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.FunctionField{Center, Face, Center, Clock{Float64}, Nothing, typeof(V), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:8420,Reduce,ReducedField,8420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,1,['Reduce'],['ReducedField']
Energy Efficiency,"up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `80.11% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `72.81% <ø> (ø)` | :arrow_up: |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `64.93% <ø> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <100%> (+1.37%)` | :arrow_up: |; | ... and [5 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=footer). Last update [cf55bcd...1dfa8a6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/410#issuecomment-531594177:3382,Power,Powered,3382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410#issuecomment-531594177,1,['Power'],['Powered']
Energy Efficiency,"ur existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only works for systems sizes that are powers of 2. As we need to solve a system of `Nz+1` equations, this means models with `2^m - 1` vertical levels will be the most efficient. If we can use it here, then we might need a non-cyclic reduction solver for models without `2^m - 1` vertical levels.; * Probably not within this scope of this PR, but this solver should work on CPUs and GPUs and will eliminate the need for two different solvers, so we can probably unify solvers. We may still want to use cyclic reduction wherever we can. We should be able to use it for uniform vertical spacing and `Nz = 2^m - 1`. @maleadt's implementation was ~3x faster than the cuSPARSE implementation and ~22x faster than the serial implementation, so it would be a huge speedup. cc @sandreza as I might ask you questions about this. This work is based off:; https://gist.github.com/christophernhill/8952075d6e95df28adf36f5dff64115a; https://gist.github.com/christophernhill/a43317694c6d65ecd27758c1bdcd",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306:2382,power,powers,2382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306,1,['power'],['powers']
Energy Efficiency,"ures, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:2096,power,powerful,2096,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['power'],['powerful']
Energy Efficiency,"uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1327,schedul,schedule,1327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"v.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `30.00% <0.00%> (-4.10%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `96.42% <0.00%> (-3.58%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `84.90% <0.00%> (+0.29%)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `37.93% <0.00%> (+1.08%)` | :arrow_up: |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=footer). Last update [e5c7aaf...d063105](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-636191089:3619,Power,Powered,3619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-636191089,1,['Power'],['Powered']
Energy Efficiency,"v.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=h1) Report; > Merging [#571](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/70a9308e59cb620632e3539ba4e0f2cab2aeab29?src=pr&el=desc) will **decrease** coverage by `0.06%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #571 +/- ##; ==========================================; - Coverage 69.42% 69.35% -0.07% ; ==========================================; Files 71 71 ; Lines 2054 2056 +2 ; ==========================================; Hits 1426 1426 ; - Misses 628 630 +2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `61.53% <ø> (ø)` | :arrow_up: |; | [src/SurfaceWaves.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/diff?src=pr&el=tree#diff-c3JjL1N1cmZhY2VXYXZlcy5qbA==) | `0% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=footer). Last update [70a9308...2e8228e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/571#issuecomment-565757907:1728,Power,Powered,1728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/571#issuecomment-565757907,1,['Power'],['Powered']
Energy Efficiency,"vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `50.00% <0.00%> (ø)` | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | `0.00% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/IncompressibleModels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...Models/IncompressibleModels/pressure\_correction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `83.33% <0.00%> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=footer). Last update [03a6f85...f933fbd](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1187#issuecomment-727718192:3783,Power,Powered,3783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1187#issuecomment-727718192,1,['Power'],['Powered']
Energy Efficiency,"vbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | | |; | [examples/netcdf\_ouput\_example.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvbmV0Y2RmX291cHV0X2V4YW1wbGUuamw=) | | |; | [...sts/ocean\_large\_eddy\_simulation\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL29jZWFuX2xhcmdlX2VkZHlfc2ltdWxhdGlvbl9yZWdyZXNzaW9uX3Rlc3Quamw=) | | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | | |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=footer). Last update [162159d...17a22a9](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854:3111,Power,Powered,3111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854,1,['Power'],['Powered']
Energy Efficiency,"vbnMuamw=) | `16.66% <ø> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `42.85% <ø> (ø)` | :arrow_up: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.53% <ø> (ø)` | :arrow_up: |; | [src/Solvers/solver\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVyX3V0aWxzLmps) | `100% <ø> (+17.39%)` | :arrow_up: |; | ... and [148 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=footer). Last update [18428b0...9288c58](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744:3558,Power,Powered,3558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744,1,['Power'],['Powered']
Energy Efficiency,"veUtils]]; deps = [""Markdown""]; uuid = ""b77e0a4c-d291-57a0-90e8-8db25a27a240"". [[IteratorInterfaceExtensions]]; git-tree-sha1 = ""a3f24677c21f5bbe9d2a714f95dcd58337fb2856""; uuid = ""82899510-4779-5014-852e-03e436cf321d""; version = ""1.0.0"". [[JLD2]]; deps = [""DataStructures"", ""FileIO"", ""MacroTools"", ""Mmap"", ""Pkg"", ""Printf"", ""Reexport"", ""Requires"", ""TranscodingStreams"", ""UUIDs""]; git-tree-sha1 = ""d4962712594ec5d39e0b10745e44e3a06abec0d2""; uuid = ""033835bb-8acc-5ee8-8aae-3f567f8a3819""; version = ""0.4.4"". [[JLLWrappers]]; deps = [""Preferences""]; git-tree-sha1 = ""642a199af8b68253517b80bd3bfd17eb4e84df6e""; uuid = ""692b3bcd-3c85-4b1f-b108-f13ce0eb3210""; version = ""1.3.0"". [[JSON3]]; deps = [""Dates"", ""Mmap"", ""Parsers"", ""StructTypes"", ""UUIDs""]; git-tree-sha1 = ""65798ad6ddb0d7068f2b1885e0b0d876efca16f5""; uuid = ""0f8b85d8-7281-11e9-16c2-39a750bddbf1""; version = ""1.8.1"". [[KernelAbstractions]]; deps = [""Adapt"", ""CUDA"", ""Cassette"", ""InteractiveUtils"", ""MacroTools"", ""SpecialFunctions"", ""StaticArrays"", ""UUIDs""]; git-tree-sha1 = ""f16c8dfdd75ae4fa927fcf3aa71e1dbbd195befb""; uuid = ""63c18a36-062a-441e-b654-da1e3ab1ce7c""; version = ""0.5.5"". [[LLVM]]; deps = [""CEnum"", ""Libdl"", ""Printf"", ""Unicode""]; git-tree-sha1 = ""b616937c31337576360cb9fb872ec7633af7b194""; uuid = ""929cbde3-209d-540e-8aea-75f648917ca0""; version = ""3.6.0"". [[LazyArtifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""4bb5499a1fc437342ea9ab7e319ede5a457c0968""; uuid = ""4af54fe1-eca0-43a8-85a7-787d91b784e3""; version = ""1.3.0"". [[LibCURL_jll]]; deps = [""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""897d962c20031e6012bba7b3dcb7a667170dad17""; uuid = ""deac9b47-8bc7-5906-a0fe-35ac56dc84c0""; version = ""7.70.0+2"". [[LibGit2]]; deps = [""Printf""]; uuid = ""76f85450-5226-5b5a-8eaa-529ad045b433"". [[LibSSH2_jll]]; deps = [""Libdl"", ""MbedTLS_jll"", ""Pkg""]; git-tree-sha1 = ""717705533148132e5466f2924b9a3657b16158e8""; uuid = ""29816b5a-b9ab-546f-933c-edad1886dfa8""; version = ""1.9.0+3"". [[Libdl]]; uuid = ""8f399da",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:7453,Adapt,Adapt,7453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"verdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.002765",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6088,Adapt,Adapt,6088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['Adapt'],['Adapt']
Energy Efficiency,"w=) | `25% <0%> (-8.34%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `63.33% <0%> (-6.67%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.7% <0%> (-1.3%)` | :arrow_down: |; | [src/Operators/interpolation\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9pbnRlcnBvbGF0aW9uX29wZXJhdG9ycy5qbA==) | `59.01% <0%> (-0.51%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.35% <0%> (-0.34%)` | :arrow_down: |; | [src/Coriolis/no\_rotation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vX3JvdGF0aW9uLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [9 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=footer). Last update [1f4465d...d25abdb](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/622#issuecomment-584704187:3742,Power,Powered,3742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/622#issuecomment-584704187,1,['Power'],['Powered']
Energy Efficiency,"w_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `93.54% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `64.44% <100%> (ø)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.31% <50%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `80.59% <72.72%> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.27% <87.23%> (+0.13%)` | :arrow_up: |; | [src/Operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `84.21% <92.3%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.08% <92.85%> (-0.13%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=footer). Last update [5114a22...419f176](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542464744:3234,Power,Powered,3234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542464744,1,['Power'],['Powered']
Energy Efficiency,"why wouldn't they be just defined at cell centers?; Suggest make that assumption.; John. On Mon, Oct 21, 2019 at 2:29 PM Ali Ramadhan <notifications@github.com>; wrote:. > Title sounds ridiculous but @jm-c <https://github.com/jm-c> mentioned; > that for stretched grids, models (e.g. WRF) usually place the cell center; > halfway between the two cell faces, but some models relax this choice so; > that you can specify cell centers to be slightly offset from the true; > center.; >; > I guess they won't be ""cell centers"" anymore, but just opening an issue in; > case there's anything to discuss.; >; > Without assuming cell centers are halfway between the two faces then; > interpolation operators are a bit more complicated; >; > @inline ℑz_aac(i, j, k, grid::VerticallyStretchedCartesianGrid, f) =; >; > @inbounds ((grid.zC[k] - grid.zF[k]) * f[k, j, i] + (grid.zF[k+1] - grid.zC[k]) * f[k+1, j, i]) / grid.ΔzF[k]; >; > and if we assume e.g. grid.zC[k] - grid.zF[k] = grid.ΔzF[k]/2 then the; > interpolation operators simplify.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/491?email_source=notifications&email_token=AKXUEQROF3YBCYTVKZUUNMLQPXYINA5CNFSM4JDC6IX2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HTI3OWQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQAZQL25R7ZQ4S7J63QPXYINANCNFSM4JDC6IXQ>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-544660984:1572,Green,Green,1572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-544660984,1,['Green'],['Green']
Energy Efficiency,"width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #109 +/- ##; =======================================; Coverage 52.71% 52.71% ; =======================================; Files 19 19 ; Lines 645 645 ; =======================================; Hits 340 340 ; Misses 305 305; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `46.45% <25%> (ø)` | |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `87.5% <50%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.96% <50%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=footer). Last update [3cd4ae3...08d8495](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/109#issuecomment-470193436:2199,Power,Powered,2199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/109#issuecomment-470193436,1,['Power'],['Powered']
Energy Efficiency,"wn: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <0.00%> (-0.86%)` | :arrow_down: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `77.77% <ø> (+7.77%)` | :arrow_up: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `64.28% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `82.35% <0.00%> (-5.89%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `9.09% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <ø> (ø)` | |; | ... and [21 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=footer). Last update [c5f47e0...c35af73](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057#issuecomment-708214357:3393,Power,Powered,3393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057#issuecomment-708214357,1,['Power'],['Powered']
Energy Efficiency,"xing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:1279,reduce,reduce,1279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,1,['reduce'],['reduce']
Energy Efficiency,"y spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25; > ; > julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); > 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; > ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); > ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25; > ; > julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; > └── max=0.875, min=0.125, mean=0.5; > ; > julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; > └── max=-Inf, min=Inf, mean=NaN; > ; > julia> using Statistics: no",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689:1072,reduce,reduced,1072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689,1,['reduce'],['reduced']
Energy Efficiency,"ynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation opera",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:3562,power,power,3562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['power'],['power']
Energy Efficiency,"y}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2426,adapt,adapt,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Energy Efficiency,"z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). ut = FieldTimeSeries(filename, ""u""); wt = FieldTimeSeries(filename, ""w""). times = ut.times; Nt = length(times). n = Observable(1). un = @lift interior(ut[$n], :, 1, :); wn = @lift interior(wt[$n], :, 1, :). xu, yu, zu = nodes(ut); xw, yw, zw = nodes(wt). fig = Figure(resolution=(800, 300)). axu = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)""); axw = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)""). heatmap!(axu, xu, zu, un); heatmap!(axw, xw, zw, wn). record(fig, ""surface_wave_induced_flow.mp4"", 1:Nt, framerate=12) do nn; n[] = nn; end; ```. The result is. https://github.com/CliMA/Oceananigans.jl/assets/15271942/643ca8b4-0943-461d-8016-08bbba24faad. where the left panel is `u` and the right panel is `w`. @BrodiePearson I don't think we should add a new example for this feature (examples are expensive, because they have to run every time we run CI / build the documentation). However, another avenue to ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:2039,schedul,schedule,2039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085,1,['schedul'],['schedule']
Energy Efficiency,"zation=nothing` yields. ```julia; julia> include(""mwe.jl""); [ Info: Initializing simulation...; Iter: 0, time: 0.0, Δt: 1.10e-01, max|d|: 0.00e+00, mean(p): 0.00e+00, solver iterations: 0, max|r|: 0.00e+00; [ Info: ... simulation initialization complete (2.973 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (17.534 ms).; Iter: 1, time: 0.1, Δt: 1.10e-01, max|d|: 4.30e-04, mean(p): -1.22e-16, solver iterations: 10, max|r|: 1.17e-02; Iter: 2, time: 0.2, Δt: 1.10e-01, max|d|: 2.24e-04, mean(p): 3.78e-17, solver iterations: 10, max|r|: 6.10e-03; Iter: 3, time: 0.3, Δt: 1.10e-01, max|d|: 1.16e-04, mean(p): 8.26e-17, solver iterations: 10, max|r|: 3.15e-03; ```. So in conclusion:. * regularization stabilizes the CG iteration for our current example. Without regularization, CG is unstable and diverges if we take too many iterations; * Interestingly however, the solver converges more quickly for a small number of iterations (eg `maxiter=10`) without regularization (where we apply the constraint that mean(p) = 0 instead); * My current recommendation is to cap `maxiter` at a small number, or to use `regularization` if not capping it. I think there is probably more work to do. First, I am not sure that the regularization is applied correctly; the rather bland results suggest there could be improvement. Second, and separately, I am wondering if there is another way to stabilize the non-regularized CG iteration by applying the linear constraint _within_ the CG solver (eg to the search direction). It seems that the solver may be more efficient if we apply the linear constraint directly (setting mean(p)=0) rather than modifying the linear operator. This does make sense to me, because when we modify the linear operator the CG algorithm is also tasked with finding mean(p) whereas when we apply the constraint, we insert our desired solution for mean(p) directly. Feedback welcome, I think we should merge this PR and continue work in future PRs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420098775:5760,efficient,efficient,5760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420098775,1,['efficient'],['efficient']
Energy Efficiency,"{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, typeof(mask_immersed_field!)}); @ Base ./array.jl:678; [6] _totuple(::Type{Tuple}, ::Base.Generator{NamedTuple{(:u, :v, :η, :b), Tuple{Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.FunctionField{Center, Face, Center, Clock{Float64}, Nothing, typeof(V), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:6091,Reduce,ReducedField,6091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,1,['Reduce'],['ReducedField']
Energy Efficiency,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:340; [19] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:3641,reduce,reducedim,3641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['reduce'],['reducedim']
Energy Efficiency,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #340",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:8826,reduce,reducedim,8826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,1,['reduce'],['reducedim']
Energy Efficiency,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5172,reduce,reducedim,5172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,1,['reduce'],['reducedim']
Energy Efficiency,"| :arrow_up: |; | [...vection/topologically\_conditional\_interpolation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90b3BvbG9naWNhbGx5X2NvbmRpdGlvbmFsX2ludGVycG9sYXRpb24uamw=) | `60.00% <60.00%> (ø)` | |; | [src/Advection/centered\_fourth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9mb3VydGhfb3JkZXIuamw=) | `64.28% <62.50%> (+64.28%)` | :arrow_up: |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `65.00% <65.00%> (ø)` | |; | [src/Advection/centered\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9hZHZlY3RpdmVfZmx1eGVzLmps) | `100.00% <100.00%> (ø)` | |; | [src/Advection/upwind\_biased\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2FkdmVjdGl2ZV9mbHV4ZXMuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | ... and [6 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=footer). Last update [7260ce8...5f6a3a0](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/972#issuecomment-699121507:3299,Power,Powered,3299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972#issuecomment-699121507,1,['Power'],['Powered']
Energy Efficiency,"| :arrow_up: |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `58.44% <100%> (-34.82%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `80.68% <100%> (+0.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `45.76% <28%> (-13.07%)` | :arrow_down: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `64.51% <66.66%> (-1.45%)` | :arrow_down: |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `18.18% <0%> (-81.82%)` | :arrow_down: |; | [src/closures/velocity\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3ZlbG9jaXR5X2dyYWRpZW50cy5qbA==) | `0% <0%> (-73.69%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=footer). Last update [9204afe...5f743c1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/253#issuecomment-498649321:3308,Power,Powered,3308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253#issuecomment-498649321,1,['Power'],['Powered']
Energy Efficiency,"| [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | `51.06% <ø> (ø)` | |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `95.23% <100.00%> (+0.23%)` | :arrow_up: |; | [...sts/ocean\_large\_eddy\_simulation\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL29jZWFuX2xhcmdlX2VkZHlfc2ltdWxhdGlvbl9yZWdyZXNzaW9uX3Rlc3Quamw=) | `100.00% <100.00%> (ø)` | |; | [...egression\_tests/rayleigh\_benard\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3JheWxlaWdoX2JlbmFyZF9yZWdyZXNzaW9uX3Rlc3Quamw=) | `100.00% <100.00%> (ø)` | |; | [...regression\_tests/thermal\_bubble\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3RoZXJtYWxfYnViYmxlX3JlZ3Jlc3Npb25fdGVzdC5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_regression.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3JlZ3Jlc3Npb24uamw=) | `100.00% <100.00%> (ø)` | |; | ... and [26 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=footer). Last update [0f33c1d...8fe7c2a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/943#issuecomment-692271816:3536,Power,Powered,3536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/943#issuecomment-692271816,1,['Power'],['Powered']
Energy Efficiency,"| |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | | |; | [test/test\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2J1b3lhbmN5Lmps) | | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=footer). Last update [b444acf...639be06](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202:3199,Power,Powered,3199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202,1,['Power'],['Powered']
Energy Efficiency,"|; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a while.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:2199,efficient,efficient,2199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['efficient'],['efficient']
Energy Efficiency,"|; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <81.81%> (-1.59%)` | :arrow_down: |; | [src/Solvers/discrete\_eigenvalues.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvZGlzY3JldGVfZWlnZW52YWx1ZXMuamw=) | `85.71% <83.33%> (ø)` | |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `96.61% <96.49%> (-3.39%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.52% <98.18%> (+0.31%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `84.00% <100.00%> (ø)` | |; | [src/Grids/Grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `71.42% <100.00%> (+7.79%)` | :arrow_up: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=footer). Last update [7e22384...d72cde3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/733#issuecomment-618603846:3558,Power,Powered,3558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/733#issuecomment-618603846,1,['Power'],['Powered']
Energy Efficiency,"|; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `74.57% <ø> (-6.82%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `89.28% <100%> (-4.47%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `66.12% <100%> (-1.22%)` | :arrow_down: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `39.16% <0%> (-60.01%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `26.08% <0%> (-26.09%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.17% <0%> (-7.14%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=footer). Last update [8fdff75...d8da673](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-508952011:2954,Power,Powered,2954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-508952011,2,['Power'],['Powered']
Energy Efficiency,"|; |---|---|---|; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `52.94% <50.00%> (ø)` | |; | [src/OutputWriters/fetch\_output.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmV0Y2hfb3V0cHV0Lmps) | `60.00% <60.00%> (ø)` | |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `90.90% <96.00%> (-0.62%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `93.91% <100.00%> (+0.28%)` | :arrow_up: |; | [src/Utils/output\_writer\_diagnostic\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL291dHB1dF93cml0ZXJfZGlhZ25vc3RpY191dGlscy5qbA==) | `100.00% <0.00%> (+8.69%)` | :arrow_up: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `87.50% <0.00%> (+12.50%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=footer). Last update [0f33c1d...8d7f82e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/927#issuecomment-690372678:2713,Power,Powered,2713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/927#issuecomment-690372678,1,['Power'],['Powered']
Energy Efficiency,"}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/mapreduce.jl:169; [21] mapreducedim!(f::Function, op::Function, R::SubArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, A::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Float64, typeof(Oceananigans.Grids.zspacing), Tuple{Center, Center, Center}}); @ GPUArrays /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/mapreduce.jl:10; [22] #minimum!#808; @ ./reducedim.jl:1018 [inlined]; [23] minimum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, a::KernelFunctionOperation{Center, Center, Center, Rectilinear",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457:8839,reduce,reducedim,8839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457,1,['reduce'],['reducedim']
Energy Efficiency,"}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64});",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:1600,reduce,reduce,1600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['reduce'],['reduce']
Energy Efficiency,"}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, FieldSlicer{UnitRange{Int64}, Colon, Colon}, Tuple{Int64, Int64, Int64}}(4×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; └── data: 6×3×3 OffsetArray(::Array{Float64, 3}, 0:5, 0:2, 0:2) with eltype Float64 with indices 0:5×0:2×0:2; └── max=4.0, min=1.0, mean=2.5, FieldSlicer{UnitRange{Int64}, Colon, Colon}(3:4, Colon(), Colon(), false), (1, 2, 3)); ```. One can apparently do the following and get the right result:. ```julia; julia> av2 = Field(Average(field, dims=(1,2,3), condition=(i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] > 0.5)); 1×1×1 Field{Nothing, Nothing, Nothing} reduced over dims = (1, 2, 3) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: 4×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── operand: mean! over dims (1, 2, 3) of Conditioned Field at (Center, Center, Center); └── status: time=0.0. julia> compute!(av2); interior(av2). julia> interior(av2); 1×1×1 view(::Array{Float64, 3}, 1:1, 1:1, 1:1) with eltype Float64:; [:, :, 1] =; 3.5; ```. Let me know if I'm not missing anything and I'll open a PR to remove `WindowedSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022373316:3394,reduce,reduced,3394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022373316,1,['reduce'],['reduced']
Energy Efficiency,"~Also bumps to 0.68.8.~. The application for this kind of regridding is from a field that, while living on a 3D grid, is reduced in x and y. Because the field is reduced in x and y it's a valid source field for a target field that's on a 1D grid. We should probably add a test to this PR (regridding from a reduced field on a 3D grid to a non-reduced field on a 1D grid). cc @adelinehillier @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2186:121,reduce,reduced,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186,4,['reduce'],['reduced']
Energy Efficiency,"~~I think I have two remaining problems to get all of the existing tests working:~~; - ~~Hydrostatic regression tests: these still failed locally when I restored the `fill_halo_region!` behaviour for hydrostatic models so I'm not sure why they're failing. I will investigate more.~~; - ~~Multi region grids: these give `update_boundary_conditions!` a `MultiRegionObject` which I am not familiar with. Can I just call `update_boundary_conditions!` on each `regional_object`? (cc: @simone-silvestri)~~. ~~Hopefully, the other tests now pass and I've reduced the changes that we need to make to them here.~~. I think these are solved now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150072166:548,reduce,reduced,548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150072166,1,['reduce'],['reduced']
Energy Efficiency,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384:10,adapt,adapts,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384,1,['adapt'],['adapts']
Energy Efficiency,~~~; (Oceananigans) pkg> status; Project Oceananigans v0.40.0; Status `/gpfs7kw/linkhome/rech/genbes01/use25mx/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics. shell> module list; Currently Loaded Modulefiles:; 1) cuda/10.2 2) julia/1.5.2 ; ~~~,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295:153,Adapt,Adapt,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295,1,['Adapt'],['Adapt']
Energy Efficiency,"ø)` | |; | [examples/netcdf\_ouput\_example.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvbmV0Y2RmX291cHV0X2V4YW1wbGUuamw=) | `0.00% <ø> (ø)` | |; | [examples/ocean\_convection\_with\_plankton.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | `0.00% <ø> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <ø> (ø)` | |; | [examples/one\_dimensional\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <ø> (ø)` | |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `81.81% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `100.00% <ø> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `86.00% <ø> (ø)` | |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=footer). Last update [66ddeb7...81d21f3](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/836#issuecomment-669319153:3242,Power,Powered,3242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/836#issuecomment-669319153,1,['Power'],['Powered']
Energy Efficiency,"└── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.403323 seconds (150.90 k allocations: 10.217 MiB, 98.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.404525 seconds (150.90 k allocations: 10.221 MiB, 98.74% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.412531 seconds (150.90 k allocations: 10.219 MiB, 98.85% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearG",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:2661,reduce,reduced,2661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,"└── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.404525 seconds (150.90 k allocations: 10.221 MiB, 98.74% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.412531 seconds (150.90 k allocations: 10.219 MiB, 98.85% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.007040 seconds (204 allocations: 44.438 KiB); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├──",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:3344,reduce,reduced,3344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,🕵️ https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138:31,Adapt,Adapt,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138,1,['Adapt'],['Adapt']
Energy Efficiency,"🤖 Beep boop. I am GabrieleBOT. 🤖 Good news! I found a way to reduce unnecessary precompilations! Have you ever noticed that when you move to a GPU node from a CPU one (or viceversa), everything has to be recompiled again? Or sometimes it seems that you are always precompiling... Well, this is partially because the nodes on the Caltech cluster have different architectures, and Julia compiles for the native one, but when you move to a new architecture, the compiled code has to be invalidated and recompiled again. With the latest version of climacommon, I force Julia to always compile for all the possible targets in our cluster. Buildkite pipelines partially do this with the JULIA_TARGET_CPU, but the strings there are incorrect. This PR fixes that too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3541:61,reduce,reduce,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3541,1,['reduce'],['reduce']
Integrability," &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-size: 13px;""><br class=""Apple-interchange-newline""></d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:6223,wrap,wrappers,6223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['wrap'],['wrappers']
Integrability," (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedThirdOrder`, `UpwindBiasedFifthOrder`, `WENO5`), the symmetric interpolation for advecting velocities is a symmetric scheme of order `n-1`. So that's `CenteredSecondOrder`, `CenteredFourthOrder`, and `CenteredF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:1215,interface,interface,1215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724,1,['interface'],['interface']
Integrability," 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. and. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2);. julia> tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:4211,wrap,wrap,4211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['wrap'],['wrap']
Integrability," A hydrostatic Boussinesq model would be super useful too of course. I think we should talk. We are working on a similar model using discontinuous Galerkin numerics over at [ClimateMachine.jl](https://github.com/CliMA/ClimateMachine.jl) and these projects would have overlapping goals. Nevertheless I would personally find it extremely useful to be able to run `Oceananigans.IncompressibleModel`s with a `HydrostaticPressureSolver` and `ExplicitFreeSurface` since I could use it to benchmark / compare with the DG functionality that I'm working on for `ClimateMachine`, and the relative advantages of high-order finite volume methods compared with DG may still be in question, at least for structured grids (meaning that an Oceananigans development effort is not a waste of time). Perhaps a zoom conversation on that topic is in order. I agree with the framework / level-of-difficulty that you've laid out for student projects!. As for deciding FourierFlows vs Oceananigans, that's up to you for sure and depends basically on whether you are okay staying with doubly-periodic systems (what FourierFlows currently supports) or whether you want to do problems with boundaries (what Oceananigans promises). FourierFlows is a nice tool for idealized problems and theoretical work (and you can run pretty large problems these days since it has GPU support); Oceananigans is evolving more towards a tool for ocean modeling that is capable of doing idealized problems, but flexible enough to use for large eddy simulation and realistic non-hydrostatic modeling, in bounded domains and hopefully irregular domains as well, eventually, using immersed boundaries. Switching between the two would be a dream... ! I'm afraid this is too futuristic for Oceananigans. It may be possible to build FV functionality into FourierFlows (which is generally more flexible than Oceananigans, but has fewer features for the specific problem of the nonhydrostatic Boussinesq equations), but that's not a small piece of work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226:1211,depend,depends,1211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226,1,['depend'],['depends']
Integrability," Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1535,depend,dependencies,1535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['depend'],['dependencies']
Integrability," GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:209 [inlined]; [15] solve!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, so",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:1134,wrap,wrappers,1134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['wrap'],['wrappers']
Integrability," LaTeXStrings; ✓ InvertedIndices; ✓ ExprTools; ✓ DataAPI; ✓ Requires; ✓ CompilerSupportLibraries_jll; ✓ OrderedCollections; ✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.v",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:4378,depend,dependencies,4378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependencies']
Integrability," This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variabl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2407,depend,dependence,2407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['depend'],['dependence']
Integrability," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:2056,Message,Message,2056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,1,['Message'],['Message']
Integrability," by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:1343,depend,dependabot,1343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability," extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Also if I bypass tuples altogether the result seems to be correct:. ```julia; julia> @inline ufunc2(i, j, k, grid, u) = u[i, j, k];. julia> u′ = model.velocities.u - Field(Average(model.velocities.u));. julia> @compute f3 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc2, model.grid, u′));. julia> interior(f3); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Are KFOs meant to be used only wi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455:1471,wrap,wrap,1471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455,1,['wrap'],['wrap']
Integrability," field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:5080,wrap,wrapper,5080,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['wrap'],['wrapper']
Integrability," from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:1359,depend,depends,1359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['depend'],['depends']
Integrability," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2128,interface,interface,2128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,1,['interface'],['interface']
Integrability," get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, fil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:1086,interface,interface,1086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,1,['interface'],['interface']
Integrability," how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either including a y-gradient in v, a z-gradient in w to balance the x-gradient of u or by removing the x-gradient in u (not sure what pressure decides to do here, but I suspect it will add lateral flow components). In principle, this is a different dynamical case because if you introduce lateral velocity then tendencies will not be null anymore and the flow is not steady anymore. In this case, the flow can experience numerical instabilities when `CFL > 1`. The out-of-bounds issue is not the problem of the CFL being larger than the grid size, it's a problem of the CFL being larger than the size of the halo. You see this issue when the CFL is larger than the grid size because you initialize your particles at `x = 0`. If you initialize your particles at `x = Lx` you will have out-of-bounds problems with a much lower CFL (still larger than 1). This said we have a couple of ways to tackle this problem; - we issue a warning when CFL > 1 (in theory we should not run a simulation with CFL > 1 but that might be desired when we prescribe the velocity); - we wrap around the particle location if it falls outside of the domain in the periodic direction. The issue of CPU vs GPU sounds quite concerning, I ll try to investigate what is going on in your script",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:3052,wrap,wrap,3052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277,1,['wrap'],['wrap']
Integrability," initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS mus",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1726,rout,routine,1726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability," linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1822,rout,routine,1822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability," macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined]; │ [12] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1539,synchroniz,synchronize,1539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronize']
Integrability," model = NonhydrostaticModel(grid = grid); ```. Running this on a CPU works, but on a GPU is throws me this error:. ```; ERROR: TaskFailedException. nested task error: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(2, 4)}, typeof(Oceananigans.BoundaryConditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, U",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:1691,depend,dependencies,1691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,1,['depend'],['dependencies']
Integrability," mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal in both the schemes. the `zweno = true` flag just switches between these two formulations. Now, I believe that `stretched_smoothness` does not have a such big impact because if you assure that the reconstruction is correct, then all stencil correctly interpolate to the face and weights will still be between 0 and 1. This might be more impactful for grids that are much more non-uniform (or ""irregular"") than what we usually use.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:3053,depend,depends,3053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,1,['depend'],['depends']
Integrability," motions are “resolved”, so; that near the wall the SGS diffusivities should vanish. This is because the; near wall motions are nearly laminar (very strongly sheared) with only; small turbulence fluctuations. The interaction of the flow with the wall is; not part of the AMD model, which means that this part of the flow must; either be resolved or modeled with a “wall model”, which somehow accounts; for the effect of wall effects on the nonlinear subgrid scale; diffusivities. When the nonlinear diffusivities are calculated in Oceananigans, the; constant molecular contribution is added so that the resulting diffusivity; field is the sum of the nonlinear and molecular components. Therefore to; calculate the nonlinear part correctly from a saved diffusivity field, the; molecular value must subtracted. This behavior is identical between; RozemaAnisotropicMinimumDissipation and; VerstappenAnisotropicMinimimDissipation. Because of the fact that this experiment requires near wall motions to be; resolved to be correct, the results should depend strongly on resolution. On Sun, Aug 18, 2019 at 7:11 AM Ali Ramadhan <notifications@github.com>; wrote:. > Temperature and velocity profiles look qualitatively correct which is; > promising but the sub-grid-scale viscosity and diffusivity don't match. At; > least the order of magnitude on each is roughly correct.; >; > Most notably their version of AMD allows the SGS ν and κ to go below the; > background values, which seems essential for ν, although not sure what that; > physically means. Seems that the VerstappenAnisotropicMinimumDissipation; > closure in the new-closures branch allows for this so I'll try rerunning; > with it.; >; > The SGS profiles seem kind of noisy but maybe I just need to bump up the; > resolution.; >; > The SGS/turbulent Prandtl number is still too low but this should get; > fixed if the SGS ν and κ profiles are right.; >; > The wall velocity Uw=1 so the x-axis is U/Uw.; > [image: plots_stratified_couette_flow_u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-522322493:1588,depend,depend,1588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-522322493,1,['depend'],['depend']
Integrability," only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally acros",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:2096,integrat,integrate,2096,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['integrat'],['integrate']
Integrability," same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in the general case a call to `zspacings(::ImmersedBoundaryGrid)` _must_ return a 3D array (or `Field`, or `AbstractOp`...)).; - if we wanna keep the user-interface consistent (i.e. always return the same type of object) then we lose on simplicity (e.g. a call to `zspacings(::RectilinearGrid)` would always return _something_ 3D, even if the grid is regular). @navidcy @glwagner is this a fair assessment of the situation? Feel free to edit the text above if not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:2409,interface,interface,2409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,2,['interface'],['interface']
Integrability," stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that shear production and buoyancy flux include the _total_ contribution, not just the contribution from CATKE diffusion (@simone-silvestri this is especially important if we want to pair CATKE with a mass flux scheme). Does anyone else have any suggestion or things on their wishlist?. cc @adelinehillier @sandreza @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2450:1719,depend,dependent,1719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450,1,['depend'],['dependent']
Integrability," that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:1218,interface,interface,1218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,1,['interface'],['interface']
Integrability," volume method. We evolve the average value of fields, integrated over a cell volume. In this integral formulation there are two contributions to the tendency of a field: fluxes across cell interfaces (advective and diffusive usually, but also possibly others via user-defined forcing), and interior ""sources"" (such as pressure gradients, Coriolis forces, gravitational forces). When users invoke `Gradient` or `Value` boundary conditions, then the same model is used for fluxes across interior cell interfaces as for ""exterior"" interfaces (domain boundaries). Thus if users set `closure=nothing` and zero out diffusive fluxes, boundary fluxes are _always_ zero regardless of what `Gradient` or `Value` are specified. More specifically, we enforce `Gradient` or `Value` boundary conditions by filling halo regions and then calculating exterior fluxes using the same kernel that's evaluated in the interior. As @francispoulin points out this is not some quirk of our algorithm or numerics; this follows from the properties of the underlying PDE. Something different happens when `Flux` boundary conditions are specified and this is where I was wrong above. With `Flux` boundary conditions, users are really specifying two _different_ models for fluxes: one across ""interior"" cell interfaces, and another for fluxes across domain boundaries. Setting `closure=nothing` in this case only nullifies _interior_ diffusive fluxes. But since boundary fluxes are explicitly specified in this case, they still do have an impact on interior tendency values. . A further subtlety is that `Value` and `Gradient` boundary conditions do actually have an impact if there is non-zero `NormalFlow` advecting the field across a boundary; in this case the flux is _advective_ (first-order) and thus mathematically consistent with the underlying PDE. So we should probably amend the warning to read:. > `Value` and `Gradient` boundary conditions are not enforced across `Impenetrable` boundaries when `isnothing(closure)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191:1603,interface,interfaces,1603,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191,1,['interface'],['interfaces']
Integrability," we could also omit `Flat` dimensions from the size display, eg. ```julia; ""3-element RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 1-element halo""; ```. ```julia; ""128×128 RectilinearGrid{Float64} on CPU with topology (Periodic, Periodic, Flat) and 1×1 halo""; ```. If we also change `interior` to drop `Flat` dimensions then I think this makes sense (otherwise it might not). In addition to type information, `show` also gives information about _values_. Here this is the extent of the domain and the grid spacings. For example:. ```julia; julia> rand(3, 3); 3×3 Matrix{Float64}:; 0.460633 0.134952 0.0366328; 0.6353 0.0632607 0.0657011; 0.339457 0.720342 0.0417144; ```. for this we can use a tabular display like `domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]`. However, I think a better possibility is to explicitly show the locations of the faces using a strategy similar to how `julia` shows row vectors:. ```julia; julia> collect(reshape(0:0.1:10, 1, 101)); 1×101 Matrix{Float64}:; 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 … 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0; ```. so we might have, depending on the width of the display:. ```julia; 1×1×101 RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 0×0×1 halo; z faces: [0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 … 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0]; ```. etc. Or, putting a ""domain summary"" out front, something like. ```julia; 1×1×101 RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 0×0×1 halo; z ∈ [0.0, 10.0] with faces [0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 … 9.4 9.5 9.6 9.7 9.8 9.9 10.0]; ```. We can do something similar for spacings, though as others have noted I think it is useful to show _statistics_ rather than list all the values for that case. We probably want to indicate whether we are talking about spacings at Center or Face, so. ```julia; z spacings: stretched with minimum(Δzᵃᵃᶜ) = 0.2, maximum(Δzᵃᵃᶜ) = 0.5; ```. is an option.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971870818:1881,depend,depending,1881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971870818,1,['depend'],['depending']
Integrability," | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:1958,depend,depend,1958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['depend'],['depend']
Integrability,"""Field-dependent"" boundary condition functions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897:7,depend,dependent,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897,1,['depend'],['dependent']
Integrability,"# Motivation. This issue is a summary of some not-so-recent discussions with @glwagner that have over time convinced me that adding some native post-processing and data analysis capabilities to Oceananigans.jl by relying on `Oceananigans.AbstractOperations` under the hood would be a killer feature. This would eventually allow users to compute new/complex terms, close budgets, etc. on any grid without worrying about the staggered grid. So it might finally fulfill the dream of going from idea -> model/simulation -> analysis -> paper purely in Julia and (most importantly) without needing to know anything about the staggered grid. Since the interface remains very similar between the different models and grid, this could potentially allow future users to easily switch between different equation sets and grids while keeping the same analysis script. I thought we opened an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493:645,interface,interface,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493,1,['interface'],['interface']
Integrability,"# Progress update. I decided to take a stab at the simplest case: triply-periodic on the CPU. Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:440,depend,dependencies,440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,2,"['depend', 'inject']","['dependencies', 'injects']"
Integrability,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:627,wrap,wrap,627,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['wrap'],['wrap']
Integrability,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308:390,inject,injection,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308,1,['inject'],['injection']
Integrability,"#1654 is still open so you'll need to merge that branch into yours to use it. To use an immersed boundary you wrap your `grid` in `ImmersedBoundaryGrid`. For the internal tide example this looks like. ```julia; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-842551645:110,wrap,wrap,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-842551645,1,['wrap'],['wrap']
Integrability,"(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = 300,equation_of_state=LinearEquationOfState(α=alpha, β=saline)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),. timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=f, β=beta),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed.; dTz = 81.2762. Tᵢ(x, y, z) = 30 + dTz * z + dTz * model.grid.Lz * 1e-6 * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-8 * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl=1.5, Δt=0.001, max_change=1.1, max_Δt=0.2minute). wmax = FieldMaximum(abs, model.velocities.w). start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), wmax(sim.model),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time=15minutes, iteration_interval=10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = ""modified_open_ocean_convection2"",; schedule = TimeInterval(0.2minute),; force = true). run!(simulation)````",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1432:2844,message,message,2844,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432,1,['message'],['message']
Integrability,(0.89.0) Better `Simulation` interface and some miscellaneous improvements + remove `MEWSVerticalDiffusivity`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3282:29,interface,interface,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3282,1,['interface'],['interface']
Integrability,(0.89.2) Fix various bugs in auto adding bgc tracers and setting up field dependant forcing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323:74,depend,dependant,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323,1,['depend'],['dependant']
Integrability,"(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Utils/kernel_launching.jl:95; [7] fill_south_and_north_halo!(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, ::Tuple{Int64, Int64}, ::Tuple{Int64, Int64}, ::Tuple{Center, Center, Nothing}, ::GPU, ::CUDAKernels.CudaEvent, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRange",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:1783,depend,dependencies,1783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['depend'],['dependencies']
Integrability,"(c, bc, size, offset, loc, arch, grid, args...; kwargs...)` etc. but couldn't work out how to stop it tupel-ing them. So instead I made it so that boundary condition kernels can have arguments which are computed before their kernel is launched:; ```julia; function fill_west_and_east_halo!(c, west_bc, east_bc, size, offset, loc, arch, grid, args...; kwargs...); west_bc_args = get_boundary_arguments(west_bc, Val(:west), size, offset, loc, arch, grid, args...; kwargs...); east_bc_args = get_boundary_arguments(east_bc, Val(:east), size, offset, loc, arch, grid, args...; kwargs...). return launch!(arch, grid, KernelParameters(size, offset),; _fill_west_and_east_halo!, c, west_bc, east_bc, loc, grid, west_bc_args, east_bc_args, Tuple(args); kwargs...); end; ```. Where the default behaviour is:; ```; get_boundary_arguments(args...; kwargs...) = (); get_boundary_arguments(bcs::Tuple, args...; kwargs...) = Tuple(get_boundary_arguments(bc, args...; kwargs...) for bc in BCS); ```; But we can add methods like this:; ```; get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow}, side, size, offset, loc, arch, grid, args...; kwargs...) = (@info typeof(bc); (bc.classification.bulk_speed, )) # fallback. function get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow{Nothing}}, ::Val{:west}, size, offset, loc, arch, grid, Δt, clock, fields, args...; kwargs...); u = fields.u. # THIS WILL NOT BE GPU FRIENDLY; Uᵇ = sum([u[1, j, k] * Axᶜᶜᶠ(1, j, k, grid) for j=1:grid.Ny, k=1:grid.Nz]) / (grid.Ly * grid.Lz). return (Uᵇ, ); end; ```. If everyone is happy with this my next issue is working out how to calculate $U^b$ in a way that will work on GPU since boundary conditions are defined before Fields so I can't use `Average`. . I also made a subdirectory for these boundary conditions but then I realised it would be easiest to not have different classifications depending on where $U^b$ is coming from so I didn't have to make as many different things so I'll move them back at some point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977320058:2090,depend,depending,2090,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977320058,1,['depend'],['depending']
Integrability,"(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into complex solid objects. I think this is in scope for Oceananigans since it is not a concept in coupling between two fluids, like the air-sea case handled by ClimaOcean is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:5589,depend,dependence,5589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,2,"['depend', 'interface']","['dependence', 'interface']"
Integrability,"). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue). Note that previously this was deemed difficult because we typically throw away locations when adapting `Field` to the GPU (see eg #746), which means that the above solution might break broadcasting with reduced fields. But I only realized (duh...) that we can easily add special `adapt_structure` methods for the case that some locations are reduced, which solves the problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:1540,interface,interface,1540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,1,['interface'],['interface']
Integrability,"); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk formulae that include heat fluxes, salt fluxes, and trace gas fluxes; * automated generation + checking of interface boundary condition arrays. A short feature wish list might be. * budget preserving interpolation between horizontal grids of different resolution; * multi-rate time-stepping / sub-stepping of 'fast' model components; * compressible atmospheric model (:-D). Once I get this going on the GPU and tweak parameters I'll post a visualization. For now we'll have to be satisfied with. ![image](https://user-images.githubusercontent.com/15271942/127759981-e9b15398-8484-4e63-ad29-3ef7f9462472.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1916:2105,interface,interface,2105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916,1,['interface'],['interface']
Integrability,"* Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordina",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:1170,depend,dependent,1170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['depend'],['dependent']
Integrability,", :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:50335,depend,dependencies,50335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['depend'],['dependencies']
Integrability,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:32010,message,message,32010,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,1,['message'],['message']
Integrability,", i, j, k); ); end. params = AnisotropicDiffusion(𝜈h, 𝜈v, ...); closure = TurbulentDiffusivity(𝜈∇²u, ..., params); ```. and then, in the time_stepping,. ```julia; ...; # u-momentum equation; @inbounds Gu[i, j, k] = (-u∇u(u, v, w, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + fCor*avg_xy(v, Nx, Ny, i, j, k); - δx_c2f(pHY′, Nx, i, j, k) / (Δx * ρ₀); + closure.u(u, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + F.u(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)); ```. does that make sense? Please criticize. The LES closures will involve much more complicated functions. LES closures like [""Constant Smagorinsky""](https://en.wikipedia.org/wiki/Large_eddy_simulation#Smagorinsky%E2%80%93Lilly_model) and [""Anisotropic Minimum Dissipation"" (AMD)](https://aip.scitation.org/doi/abs/10.1063/1.4928700) fall into the category of ""eddy diffusivity closures"", in that the closure is expressed as a locally evaluated nonlinear eddy viscosity and diffusivity (see also the [dedaLES documentation](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) for AMD). As discussed long ago with @jm-c, the implementation of an eddy diffusivity closure on a staggered grid requires computing the eddy viscosity at cell centers and on all three faces. In our new notation, these four locations are . * `(Center, Center, Center)` ; * `(Interface, Center, Center)`; * `(Center, Interface, Center)`; * `(Center, Center, Interface)`. In order to calculate the stress divergence for eddy viscosities, therefore, we need the eddy viscosity at `(Center, Center, Center)` . On the other hand, to compute tracer fluxes we need the eddy diffusivity at the three other locations. Something to consider. @jm-c may have more to say on the matter. Looking at the [AMD formulas](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) it seems that some averaging/interpolation is necessary to calculate the terms that contribute to the eddy viscosity in the correct locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120:3149,Interface,Interface,3149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120,3,['Interface'],['Interface']
Integrability,", moving it an ocean; direction. This would lead to some interesting research papers. John. On Wed, Jan 29, 2020, 9:57 PM Ali Ramadhan <notifications@github.com> wrote:. > Over at JULES.jl <https://github.com/thabbott/JULES.jl> @thabbott; > <https://github.com/thabbott>, @RaphaelRR <https://github.com/RaphaelRR>,; > and I have been building a compressible non-hydrostatic model on top of; > Oceananigans.jl for atmospheric simulations. It follows the numerics of the; > Advanced Research WRF Model as described in Klemp et al. (2007) and; > Skamarock et al. (2019).; >; > With three qualitative verification experiments I think it's ready to be; > tagged as v0.1.; >; > I'm opening this issue to discuss the possibility of merging JULES.jl into; > Oceananigans.jl which would add a CompressibleModel type (discussed a bit; > in #566 <https://github.com/climate-machine/Oceananigans.jl/issues/566>).; > The two models share a lot of the infrastructure we've already built for; > Oceananigans, and in integrating the two we will readily get a GPU-ready; > research-grade compressible atmosphere model.; >; > Verification experiments:; >; > 1. Hydrostatic adjustment in an isothermal atmosphere [very; > qualitative, see Bannon (1995)]; > 2. Dry rising thermal bubble: thabbott/JULES.jl#31; > <https://github.com/thabbott/JULES.jl/pull/31>; > 3. Nonlinear density current (PR incoming); >; > Dry rising thermal bubble can be compared with figure 5 of Wicker and; > Skamarock (1998), figure 7 of Jahn et al. (2015), and; > https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html.; >; > Nonlinear density current can be compared with figure 1 of Straka et al.; > (1993) and; > https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html.; >; > Things we can hopefully share between IncompressibleModel and; > `CompressibleModel:; >; > 1. Operators; > 2. Grids; > 3. Coriolis; > 4. Forcing functions; > 5. Boundary conditions; > 6. Turbulence closures; > 7. Diagnostics; > 8. Output write",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579977300:1122,integrat,integrating,1122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579977300,1,['integrat'],['integrating']
Integrability,"- [x] Try comparing with an analytical solution, e.g. Poiseuille flow or Couette flow. This would test the pressure solver.; - [x] See if there's a difference between `Float64` on the CPU and GPU beyond machine epsilon.; - [x] Compare with MITgcm, both running `Float64` on the same CPU.; - [ ] Try comparing with MITgcm at different time steps to look at time-dependence.; - [ ] Try `Float128`. Might not play nice with the GPU.; - [x] We can try some of the stuff from #161 but that might be more work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/168:361,depend,dependence,361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/168,1,['depend'],['dependence']
Integrability,"- `Docs/Physics/HydrostaticFreeSurfaceModel`; At the moment docs mention that we obtain $w(x, y, z, t)$ by integrating the mass conservation equation from bottom to top but we need to integrate from bottom to depth $z$. This PR fixes this. - `Docs/Physics/NonHydrostaticModel`; The rotation rate term due to surface waves was missing a sign.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3150:107,integrat,integrating,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3150,2,['integrat'],"['integrate', 'integrating']"
Integrability,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:1858,depend,depend,1858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['depend'],['depend']
Integrability,"-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a small number at a specified fraction of the domain height `hᵢ` by solving. ```julia; Σ′ = stretching * exp(-stretching * hᵢ) / (1 - exp(-stretching)) = ϵ; ```. for `stretching`. In the above, `ϵ` is a small parameter controlling the smallness of `Σ′` at the normalized height. Both `ϵ` and `hᵢ` are parameters. Aside from being not quite right, there's something a little off about this approach. I think `stretching` should somehow depend on `refinement`; eg when `refinement = 1` then no stretching is needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1810:2435,depend,depend,2435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810,1,['depend'],['depend']
Integrability,".com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">Julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:4634,depend,dependabot,4634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,".com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8914,depend,dependabot-automerge-start,8914,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],"['dependabot-automerge-end', 'dependabot-automerge-start']"
Integrability,".jl:211; [5] view(f::Field{…}, i::CartesianIndices{…}, j::Function, k::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:308; [6] view(f::Field{…}, i::CartesianIndices{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:339; [7] _reverse!(A::Field{…}, dims::Tuple{…}); @ Base ./arraymath.jl:95; [8] _reverse!; @ ./arraymath.jl:71 [inlined]; [9] #reverse!#274; @ ./arraymath.jl:70 [inlined]; [10] _reverse(A::Field{…}, dims::Function); @ Base ./arraymath.jl:60; [11] reverse(A::Field{Face, Center, Center, Nothing, ZRegOrthogonalSphericalShellGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}); @ Base ./arraymath.jl:59; [12] top-level scope; @ REPL[199]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; If the vector is formed by extracting multiple elements from the first dimension of the field on the RHS (as opposed to the second dimension as above), e.g.,; ```julia; julia> u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; no error message pops up but `u[region][Nc+1, 1-Hc:0, k]` is filled with junk values as shown below:; ```julia; 1×4×1 Field{Face, Center, Center} on OrthogonalSphericalShellGrid on CPU; ├── grid: 4×4×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 4×4×1 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (5:5, -3:0, 1:1); └── data: 1×4×1 OffsetArray(view(::Array{Float64, 3}, 9:9, 1:4, 2:2), 5:5, -3:0, 1:1) with eltype Float64 with indices 5:5×-3:0×1:1; └── max=2.1234e-314, min=5.0e-324, mean=5.30853e-315; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721:3213,message,message,3213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721,1,['message'],['message']
Integrability,".tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] doc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:6917,depend,dependent,6917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['depend'],['dependent']
Integrability,"/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2578/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:5719,wrap,wrappers,5719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['wrap'],['wrappers']
Integrability,"00207786 -0.000570261 -0.00113736 -0.0011126 -0.00095512 -0.000668289 0.000187081 -2.50371e-5 -0.000234227 -3.30057e-5 7.37231e-5 4.74698e-5 0.0; 0.0 3.44085e-5 6.01794e-5 0.000160129 -5.71002e-5 -0.000251935 -0.000348341 0.000175676 0.000452654 0.000757255 0.000292256 1.47004e-5 -4.29739e-5 0.0; 0.0 0.000127176 0.000354777 0.000538542 0.000684584 0.000355887 0.000248227 0.000121747 -8.66234e-5 -5.15146e-5 0.000247927 0.000267242 0.000177876 0.0; 0.0 -0.000112676 -0.000247409 -0.000271409 -0.00044693 0.000199694 0.000249875 -0.000585559 -0.00072856 -0.000851675 -0.000696049 -0.000430978 -0.00022939 0.0; 0.0 -6.48691e-5 -0.0002854 -0.0005231 -0.000241099 -0.000523152 -0.000253047 … 0.000609541 0.0009479 0.000772055 0.000367521 0.000193174 8.25992e-5 0.0. julia> ds[""wτ2_yavg""] == ds[""wτ1_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ3_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ4_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ5_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ6_yavg""]; true; ```. So seems that all is good? So the problem comes when I continue the integration longer?; But why do the `info` statements appear in this order?. ```Julia; [ Info: Initializing simulation...; [ Info: Writing to NetCDF: ./test.nc...; [ Info: Computing NetCDF outputs for time index 1: [""wτ3"", ""wτ2_yavg"", ""wτ6_yavg"", ""wτ1"", ""wτ5_yavg"", ""wτ6"", ""wτ2"", ""wτ5"", ""wτ4"", ""wτ1_yavg"", ""wτ4_yavg"", ""wτ3_yavg""]...; [ Info: Computing wτ3 done: time=439.823 ms; [ Info: Computing wτ2_yavg done: time=3.404 seconds; [ Info: Computing wτ6_yavg done: time=3.018 seconds; [ Info: Computing wτ1 done: time=225.326 ms; [ Info: Computing wτ5_yavg done: time=2.950 seconds; [ Info: Computing wτ6 done: time=292.708 μs; [ Info: Computing wτ2 done: time=192.674 ms; [ Info: Computing wτ5 done: time=190.263 ms; [ Info: Computing wτ4 done: time=193.185 ms; [ Info: Computing wτ1_yavg done: time=1.210 seconds; [ Info: Computing wτ4_yavg done: time=2.954 seconds; [ Info: Computing wτ3_yavg done: time=2.953 seconds; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387:7736,integrat,integration,7736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387,1,['integrat'],['integration']
Integrability,"09</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/e9d953d306cac42c94058f27c6564ec50d97d913""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@depend",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8401,Depend,Dependabot,8401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,"['Depend', 'depend']","['Dependabot', 'dependabot-badges']"
Integrability,"1. Yes you're right. Currently Oceananigans.jl is only non-hydrostatic. We've considered adding a hydrostatic mode (shouldn't be hard to implement) but haven't really needed it yet so we've stuck with non-hydrostatic mode as we mostly do small-scale simulations (also see issue #72). Do you need to run in hydrostatic mode?. 2. Ah interesting. Like on a regular Cartesian grid but with some grid cells cut out so you effectively have a cylindrical domain but with jagged walls (that get smoother as you increase the resolution)? It's not a built-in feature but you could use the forcing functions to add topography via an immersed boundary method (basically damping the velocity to zero inside the boundary). For an example of this, see PR #693: Viscous flow around a cylinder verification experiment. We're happy to help with setting up this kind of stuff too. 3. No we don't have any mesoscale eddy parameterizations. Actually we don't really have any parameterizations in Oceananigans.jl besides turbulent diffusivity/viscosity closures as we've been mostly focused on running small-scale simulations that resolve the turbulence and trying to figure out the best parameterization from the data. Depending on what you need though, it might not be too hard to implement. It's worth discussing if you need something like GM Redi. 4. Hmmm, this isn't something that we've done as adding topography isn't really a built-in feature yet but it should be possible to impose a no-slip boundary condition at a cylindrical wall using a custom forcing function though, not an Oceananigans.jl boundary condition. I'm not 100% sure but if you want no-slip my guess is that you probably want to use a Value/Dirchlet boundary condition. I think @glwagner would know more about whether it's possible to properly implement a no-slip Value/Dirchlet BC on a curved boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640688002:1198,Depend,Depending,1198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640688002,1,['Depend'],['Depending']
Integrability,"13""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8500,depend,dependency-name,8500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['depend'],['dependency-name']
Integrability,"2e807a80-d36d-11eb-924a-074ca0ad127c.png). ### Tracer Conservation; We can also look at tracer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_dudy_diff](https://user-images.githubusercontent.com/67593861/122987679-dc405900-d36e-11eb-895a-0f66daf9a473.png). Any thought on these results would be greatly appreciated, or if there is something else that might be good to look at with this particular test case. Further refinements to the grid are taking quite a long time to run on my PC, but they can be done. These were run with a viscosity of 0 for the isotropic closure. I want to look at the viscous cases of these to see if the results change at all with added viscosity. I'm also working on some cylinder validation metrics for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:1544,Integrat,Integrated,1544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,2,"['Integrat', 'integrat']","['Integrated', 'integrated']"
Integrability,"4+1, Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₁ = φnode(3Nx÷4+1, Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 4; λ₂ = λnode(Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₂ = φnode(Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 3; λ₃ = λnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₃ = φnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 6; λ₄ = λnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₄ = φnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). δR = 2; θ₀ = 1. θᵢ(λ, φ, z) = θ₀ * exp(-((λ - λ₁)^2 + (φ - φ₁)^2) / 2δR^2) +; θ₀ * exp(-((λ - λ₂)^2 + (φ - φ₂)^2) / 2δR^2) +; θ₀ * exp(-((λ - λ₃)^2 + (φ - φ₃)^2) / 2δR^2) + ; θ₀ * exp(-((λ - λ₄)^2 + (φ - φ₄)^2) / 2δR^2). set!(model, θ = θᵢ). θ = model.tracers.θ; fill_halo_regions!(θ). Δt = 0.0015; stop_iteration = 8000. simulation = Simulation(model; Δt, stop_iteration). # Print a progress message; using Printf. progress_message(sim) = @printf(""Iteration: %04d, time: %s, Δt: %s, wall time: %s\n"",; iteration(sim), prettytime(sim), prettytime(sim.Δt),; prettytime(sim.run_wall_time)). simulation.callbacks[:progress] = Callback(progress_message, IterationInterval(100)). tracer_fields = Field[]. function save_tracer(sim); push!(tracer_fields, deepcopy(sim.model.tracers.θ)); end. simulation.callbacks[:save_tracer] = Callback(save_tracer, IterationInterval(20)). run!(simulation). @info ""Making an animation from the saved data..."". n = Observable(1). Θₙ = []; for region in 1:6; push!(Θₙ, @lift parent(getregion(tracer_fields[$n], region)[:, :, grid.Nz])); end. function where_to_plot(region); region == 1 && return (3, 1); region == 2 && return (3, 2); region == 3 && return (2, 2); region == 4 && return (2, 3); region == 5 && return (1, 3); region == 6 && return (1, 4); end. function heatlatlon!(ax::Axis, field, k=1; kwargs...). LX, LY, LZ = location(field). grid = field.grid; _, (λ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1717770543:3301,message,message,3301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1717770543,1,['message'],['message']
Integrability,"4,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::Function, ::Type{T} where T; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:296; [19] macro expansion at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:108 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [21] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol, ::typeof(Oceananigans.Solvers.calculate_pressure_right_hand_side!), ::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; dependencies::KernelAbstractions.CudaEvent, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/alir/Oceananigans.jl/src/Utils/kernel_launching.jl:67; [22] solve_for_pressure!(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3,Nothing}}, ::Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3,Nothing},CUDA.CuArray{Float64,3,Nothing},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:11922,depend,dependencies,11922,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['depend'],['dependencies']
Integrability,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:19603,message,message,19603,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['message'],['message']
Integrability,"6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:2105,integrat,integrates,2105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['integrat'],['integrates']
Integrability,"67.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) = prettytime(Δt); pretty_Δt(Δt::TimeStepWizard) = prettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: Str",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1818,message,messages,1818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['message'],['messages']
Integrability,"70 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 17 _advective_momentum_flux_Vw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1970 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 17 overdub; 1970 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 2094 0 @Oceananigans/src/Advection/weno_fifth_order.jl 226 overdub; 2183 0 @Base/operators.jl 560 +(::Float64, ::Float64, ::Float64); 2262 0 @Base/operators.jl 560 overdub; 2381 0 @Oceananigans/src/Advection/weno_fifth_order.jl 216 overdub; 2395 0 @Oceananigans/src/Advection/weno_fifth_order.jl 211 overdub; 2471 0 @Oceananigans/src/Advection/weno_fifth_order.jl 231 overdub; 3033 3033 @KernelAbstractions/src/compiler/contract.jl 18 add_float_contract; 3033 0 @KernelAbstractions/src/compiler.jl 45 overdub; 3688 0 @Oceananigans/src/Operators/difference_operators.jl 26 overdub; 4069 0 @Oceananigans/src/Advection/tracer_advection_operators.jl 28 div_Uc(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twic...; 4069 0 @Oceananigans/src/Advection/tracer_advection_operators.jl 28 overdub; 4202 0 @Oceananigans/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl 186 overdub; 4469 4469 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl ? overdub; 4570 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 57 div_𝐯u(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twic...; 4570 0 @Oce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:41498,contract,contract,41498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:12421,depend,dependency-tracking,12421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['depend'],['dependency-tracking']
Integrability,"://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:9004,Depend,Dependabot,9004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['Depend'],['Dependabot']
Integrability,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:9707,depend,dependabot,9707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,11,"['Depend', 'depend']","['Dependabot', 'dependabot', 'dependency']"
Integrability,"</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-action",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:3219,depend,dependabot,3219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,"<a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:4386,depend,dependabot,4386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,"<img width=""356"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/170514466-0fe28fcd-def6-4034-abf6-9c794b4c42f7.png"">. Depends on who ""we"" is",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2577#issuecomment-1138666471:139,Depend,Depends,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2577#issuecomment-1138666471,1,['Depend'],['Depends']
Integrability,"= FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; forcing = (T=heat_source_term,),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). #Setting Initial Conditions ; using CSV; using DataFrames; initial_temperature = Matrix(CSV.read(""initial_temperature.csv"", DataFrame)); itemp = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; itemp[x,y,:] = initial_temperature; end; end. initial_salinity = Matrix(CSV.read(""initial_salinity.csv"", DataFrame)); isal = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; isal[x,y,:] = initial_salinity; end; end. # `set!` the `model` fields using functions or constants:; set!(model, T = itemp, S = isal). #Setting up a simulation ; using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\sha",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946:4793,message,message,4793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946,1,['message'],['message']
Integrability,"= VectorInvariant(),; free_surface = free_surface,; coriolis = coriolis,; tracers = :c,; tracer_advection = WENO(),; buoyancy = nothing,; closure = nothing). g = model.free_surface.gravitational_acceleration; R = grid.radius; Ω = model.coriolis.rotation_rate. uᵢ(λ, φ, z) = 0.1 * cosd(φ) * sind(λ); ηᵢ(λ, φ, z) = (0.1 * Ω * R + 0.1^2 / 2) * sind(φ)^2 / g * sind(λ); cᵢ(λ, φ, z) = Gaussian(λ - 1, φ - 5, 10). set!(model, u=uᵢ, η=ηᵢ, c=cᵢ). Δt = 0.1 * Δ_min(grid) / sqrt(g * grid.Lz) . for _ in 1:20; time_step!(model, Δt); end. return merge(model.velocities, model.tracers, (; η = model.free_surface.η)); end. Nx = 32; Ny = 32. grid = LatitudeLongitudeGrid(CPU(), size = (Nx, Ny, 1),; halo = (3, 3, 3),; latitude = (-80, 80),; longitude = (-160, 160),; z = (-1, 0),; radius = 1,; topology=(Bounded, Bounded, Bounded)). us, vs, ws, cs, ηs = solid_body_rotation_test(grid). regions = 2; P = XPartition. @info "" Testing $regions $(P)s on $(typeof(grid).name.wrapper) on the $arch""; u, v, w, c, η = solid_body_rotation_test(grid; P=P, regions=regions). u = reconstruct_global_field(u); v = reconstruct_global_field(v); w = reconstruct_global_field(w); c = reconstruct_global_field(c); η = reconstruct_global_field(η). using GLMakie. function plot_to_compare(field1, field2). λ, φ, z = nodes(field1). fig = Figure(fontsize=30); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); ax3 = Axis(fig[1, 3]). heatmap!(ax1, λ, φ, interior(field1, :, :, 1)); heatmap!(ax2, λ, φ, interior(field2, :, :, 1)); heatmap!(ax3, λ, φ, interior(field1, :, :, 1) .- interior(field2, :, :, 1)). return fig; end. @show @test all(isapprox(u, us, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(v, vs, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(w, ws, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(c, cs, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(η, ηs, atol=1e-20, rtol = 1e-15)); ```. The test for `c` fails. When you then plot. ```Julia; fig = plot_to_compare(cs, c); fig; ```. <img width=""1290"" alt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1506325737:1896,wrap,wrapper,1896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1506325737,1,['wrap'],['wrapper']
Integrability,"> (Anxiously waiting for this to merge so that I can update my scripts :)). I'll merge but just to be sure, the scripts can be updated provided you depend on `Oceananigans#glw/be-meaner` in your environment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872305587:148,depend,depend,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872305587,1,['depend'],['depend']
Integrability,> (Reduced Fields and Windowed Fields will have to be done separately). I think we just need to make sure these routines can handle `Nothing` boundary conditions and we're fine.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736:112,rout,routines,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736,1,['rout'],['routines']
Integrability,"> (There is some inefficiency in the code that I did the wind and wall stress separately, even though they're basically the same thing, but a kind of merge of how I did each would probably be the most general way todo it because I put more work into the wind stress and just have the very simple flat bottomed law of the wall wall stress. Do you mean computational inefficiency, or inefficiency in terms of code length? For flat surfaces, we've designed an interface in ClimaOcean that depends on a roughness length callable object. This allows one to implement new models for the roughness length (which limit to wavy surface or smooth walls, combinations of the two, or other models). More generally our intent is definitely to encapsulate the parts that are not worth repeating elsewhere, and let users / external packages proliferate to do the interesting parts like designing new roughness lengths. Was that your vision too?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2386534371:457,interface,interface,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2386534371,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"> (in theory we should not run a simulation with CFL > 1 but that might be desired when we prescribe the velocity). Aren't there time stepping schemes that can handle CFL > 1? This depends on the time-stepping scheme. Le and Moin 1991 claim that the theoretical limit for RK3 is 1.6. But there are other RK schemes with more stages that can handle even higher CFLs. I'm not sure there is a ""theory"" that places an absolute limit on the CFL for all possible schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773314840:181,depend,depends,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773314840,1,['depend'],['depends']
Integrability,"> * There is a lot happening here. :) I can have a crack reviewing this but I may ask lots of clarifications?; > * Perhaps we need to expand a bit the [finite volume](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/finite_volume/) section in the docs to clarify what, e.g., `Azᶜᶜᵃ` is? How come `Axᶜᶜᵃ` or `Ayᶜᶜᵃ` are not needed btw?. `Axᶜᶜᵃ` and `Ayᶜᶜᵃ` both depend on vertical location, so the constructs you're mentioning would only be valid on a horizontally-curvilinear but _vertically-regular_ grid. I think we should just encode the general form of operators, so we should have things like `Axᶜᶜᶜ` and `Axᶜᶜᶠ` only.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951037471:394,depend,depend,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951037471,1,['depend'],['depend']
Integrability,"> * Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES). I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. (Note that we do illustrate interfacing with other packages like `Random`, `JLD2`, `NCDatasets`, `Plots`, etc --- but showcasing packages in our ""ecosystem"" specifically is certainly in our interest.). > * Use Python/xarrray to read and plot the data. To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain. I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263:538,integrat,integrated,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263,1,['integrat'],['integrated']
Integrability,"> . You can also treat the CFL limitation due to the free surface by using a mode-splitting technique, solving the vertically integrated equations with the small CFL imposed time-step while doing the full 3D calculations with a larger time step. That would allow for a better representation of shorter gravity waves but needs careful designs to ensure a consistent 2D transport with the 3D velocities (e.g. Killworth 1991, Beckers 1991).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248:126,integrat,integrated,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248,1,['integrat'],['integrated']
Integrability,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975:891,interface,interfaces,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975,2,['interface'],"['interface', 'interfaces']"
Integrability,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096:326,interface,interface,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096,2,['interface'],['interface']
Integrability,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:1053,interface,interface,1053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345,1,['interface'],['interface']
Integrability,"> > (Anxiously waiting for this to merge so that I can update my scripts :)); > ; > I'll merge but just to be sure, the scripts can be updated provided you depend on `Oceananigans#glw/be-meaner` in your environment. I'm aware. I just was waiting for this because master already has some other bug fixes that I want, and it hadn't been merged with this branch. > crossed_fingers hope GPU works since we don't have GPU CI right now... ~Hmm, that's a good point. Now that you merged master into this branch it might be worth waiting and I'll just use this branch.~. Oops, too late! haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872308626:156,depend,depend,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872308626,1,['depend'],['depend']
Integrability,"> > 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.); > ; > I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). Also making this change would mean that a bunch of scripts would fail silently. Meaning that, depending on what/where fluxes are prescribed, the fluxes would flip, producing a completely different result, without Oceananigans throwing an error (since I think we wouldn't change the interface). So if we do go that way I think we'd need to be really careful about it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867:854,depend,depending,854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:330,depend,depends,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866,1,['depend'],['depends']
Integrability,"> > > > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > > > ; > > > ; > > > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity.; > > ; > > ; > > A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle.; > ; > I don't think a constant sinking velocity can be implemented in `dynamics` in this setup where `dynamics` comes before advection. You could imagine a particle being advected with its sinking velocity at the `dynamics` step, then later on at the `advect_lagrangian_particles!` it'll be advected by the field velocity at a new location, which will be of a different value. I suppose this is fine if `dynamics` and `advect_lagrangian_particles!` are reversed. For a constant velocity, the only difference that switching the order of function calls makes is the way we interpret the initial condition or final state. For example, if we call `dynamics` _after_ advection, but also shift the initial condition vertical positions by `dt * w_sinking`, then the result would be identical as calling `dynamics` before advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819859736:429,depend,depend,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819859736,1,['depend'],['depend']
Integrability,"> > > @iuryt can we do it in a new PR? I can get it started to illustrate, and you can help me by refining the implementation and getting the tests to pass. What do you think?; > > ; > > ; > > As this new PR will change this current PR, I will work on the new PR first and then come back here.; > ; > @glwagner Should I work on this PR first and then when make the new implementation update the validation scripts again?. Up to you but it seems like you will save yourself some effort if you first update the user interface, and then update the validation scripts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473:514,interface,interface,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473,1,['interface'],['interface']
Integrability,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091:881,depend,depends,881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091,1,['depend'],['depends']
Integrability,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352:278,integrat,integrated,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352,2,"['bridg', 'integrat']","['bridge', 'integrated']"
Integrability,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378:980,depend,depends,980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378,1,['depend'],['depends']
Integrability,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:312,depend,depends,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919,1,['depend'],['depends']
Integrability,"> > > Is this something that is handled on the MIT side ?; > > ; > > ; > > Yeah, it’s something the Oceananigans dev team should sort out! :); > ; > Curious to know if there's any movement on getting this resolved. I can offer some help in getting an allocation request in to Pawsey Supercomputing Centre - I mentioned to @navidcy that I have a solution for doing CI on systems with job schedulers (like Pawsey's Setonix).; > ; > If existing hardware systems at MIT are not available for this, I can also help with procurement, if needed. If you go this route, I can look into providing some time on our systems to get testing rolling. @simone-silvestri can you please help with this? I agree its critical to get this PR merged ASAP, it's already getting stale. I think we should contact Satori folks first directly or via @christophernhill . @Sbozzolo might be able to help if there are AMD machines on the caltech cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997634181:554,rout,route,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997634181,1,['rout'],['route']
Integrability,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081:691,interface,interface,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081,2,['interface'],['interface']
Integrability,"> > > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > > ; > > ; > > Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them.; > ; > Ok got it. What's the purpose of that?. Unless I've missed something I believe that structs with `Tuple{:Symbol}` properties can't be passed to GPU kernels when I manually change the element in bgc model I'm having problems with to a tuple of integers it works",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717571221:627,depend,dependent,627,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717571221,1,['depend'],['dependent']
Integrability,"> > > Very interesting idea. How do you plan to combine the different schemes to get a smooth result?; > > ; > > ; > > We'll use the WENO method, which weights candidate stencils based on a smoothness metric.; > ; > Makes sense, thanks!. The non-trivial part of the method is to use a non-trivial stencil to reconstruct `u` at the interfaces of tracer cells. For both advection and continuity we use the (trivial) second-order reconstruction. ```; u_ijk = u[i, j, k]; ```. Yet high-order reconstructions are possible; for example a fourth-order reconstruction (in the x-direction only) is. ```; u_ijk = 13/12 * u[i, j, k] - 1/24 * u[i-1, j, k] - 1/24 * u[i+1, j, k]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081894372:331,interface,interfaces,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081894372,1,['interface'],['interfaces']
Integrability,"> > > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > > ; > > ; > > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity.; > ; > A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle. I don't think a constant sinking velocity can be implemented in `dynamics` in this setup where `dynamics` comes before advection. You could imagine a particle being advected with its sinking velocity at the `dynamics` step, then later on at the `advect_lagrangian_particles!` it'll be advected by the field velocity at a new location, which will be of a different value. I suppose this is fine if `dynamics` and `advect_lagrangian_particles!` are reversed. However, I think that advection forcing should be run at the same time as `advect_lagrangian_particles!`. This would be important for cases where the additional advection is a function of its location for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819556970:411,depend,depend,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819556970,1,['depend'],['depend']
Integrability,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:338,integrat,integration,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787,1,['integrat'],['integration']
Integrability,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306:807,depend,depends,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306,1,['depend'],['depends']
Integrability,"> > @tomchor @whitleyv what's the ultimate vision for this PR; > ; > I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. For sure! A forcing function could serve as a prototype for the new tendency kernel function that I'm proposing, right? That was my original motivation for proposing the forcing function --- because we would be able to re-use that code (eg all the right conditionals, etc) when we went to implement immersed boundary conditions in the source code. The new tendency kernel function that @simone-silvestri and I are suggesting would be identical to such a forcing function. > I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input. That's true we have to take care with interpolation. I think the first question is what user API we'd like to support; then we can generate source code to match.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345:1006,depend,dependencies,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345,1,['depend'],['dependencies']
Integrability,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1302,integrat,integration,1302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586,1,['integrat'],['integration']
Integrability,"> > AUUUGHHH that was hard but finally found the source of the type instability:; > ; > which type instability; is this related to discussion in #3750?. Yes. That issue documents slow reductions for windowed fields on immersed boundary grids. I hypothesized that it was due to a failure of type inference. Looking into it further I see that `axes(op::AbstractOperation)` cannot be type inferred when indices is not `(:, :, :)` because of the tuple generator. We found the same problem with `axes` for `Field` and fixed it but didn't fix it for AbstractOperations. Reducing windowed fields on immersed boundary grids requires this because they are wrapped in `ConditionalOperation` in order to mask the immersed regions during the reduction. This PR extends the fix we implemented for `Field` to also encompass `AbstractOperation`. It also cleans up conditional operations quite a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438:647,wrap,wrapped,647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438,1,['wrap'],['wrapped']
Integrability,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122:115,depend,dependent,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122,2,['depend'],['dependent']
Integrability,"> > Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions.; > ; > That's an interesting example. This wouldn't generalize to cut cells, right? Perhaps we need an abstraction that represents the distances to the boundary, for use within boundary conditions. That way we can ensure the distance to the boundary is computed correctly regardless of how the boundary is represented. Agreed. Although I think that's for another PR, right?. > As an aside, hasn't it been shown that MOST is not valid in complex terrain? (That wouldn't prevent it from still somehow improving model fidelity, at least in principle.). Yes, although the discrepancy is less severe for neutral stability, which I suspect encompasses most of the simulations people have been using Oceananigans for. Interestingly, there's been a very recent attempt at generalization that [looks pretty promising](https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.130.124001)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1595915982:77,depend,depend,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1595915982,1,['depend'],['depend']
Integrability,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:328,interface,interface,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397,3,"['Depend', 'interface']","['Depending', 'interface']"
Integrability,"> > But it's possible to write code that works for all grids by referencing the kernel functions directly (rather than trying to extract the spacings from the grid properties). That's how we get spacings inside the code, so if we use the same method in the user interface then all is good.; > ; > @glwagner, what do you mean here by ""kernel functions""?. By ""kernel function"" I mean ""a function meant to be used inside a kernel"". In our convention these functions have the first four arguments `i, j, k, grid`. An example is `Δxᶠᶜᶜ(i, j, k, grid)`, which gets the x-spacing at face, center, center. Annoyingly they are all defined via metaprogramming, eg:. https://github.com/CliMA/Oceananigans.jl/blob/f4d7a94faeaa00cc48d0f92a26027a90d917ec62/src/Operators/spacings_and_areas_and_volumes.jl#L93. the 2D spacings though are defined . https://github.com/CliMA/Oceananigans.jl/blob/f4d7a94faeaa00cc48d0f92a26027a90d917ec62/src/Operators/spacings_and_areas_and_volumes.jl#L138",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1641138360:262,interface,interface,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1641138360,1,['interface'],['interface']
Integrability,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:927,depend,depending,927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678,1,['depend'],['depending']
Integrability,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:276,integrat,integrated,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,"['bridg', 'integrat']","['bridge', 'integrated']"
Integrability,"> > Does it make more sense for Open to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set OpenBoundaryCondition(nothing) unless a user sets something else.; > ; > This choice should not merely be a question about user interface / convenience but also about how the code internals work.; > ; > One problem is that the topology refers to both sides. We want to support domains that are, for example, bounded on the west but open on the east.; > ; > We do have an abstraction called `RightConnected` for distributed cases. Possibly, we can implement topologies that represent doubly open and single-sided open.; > ; > But to motivate such an abstraction, I think this needs to have implications on the grid level --- not just a way to generate boundary conditions conveniently. I think there are other solutions for generating boundary conditions conveniently. I see, I think having an open boundary does necessarily have grid level implications because every tracer needs to have some open boundary specified if the grid has an open boundary right? I suppose the other way todo this is to check if some tracer has an open boundary specified and add them to all of the others. It would be a bit confusing to keep having this as a boundary condition applied to a `Bounded` direction though since the grid isn't bounded in the same way anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1966755583:297,interface,interface,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1966755583,1,['interface'],['interface']
Integrability,"> > Even if curvilinear grids are not supported yet for the non-hydrostatic model, I like the idea of moving `validate_momentum_advection` to `Models` like `validate_tracer_advection`.; > ; > does this mean that I should actually write separate versions of `validate_momentum_advection` for `HydrostaticFreeSurfaceModels` and 'NonhydrostaticModel` instead?. Just moving `validate_momentum_advection` to the `Models` module is fine. In the end, `validate_momentum_advection` only depends on the grid and the advection scheme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3344#issuecomment-1769755929:479,depend,depends,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3344#issuecomment-1769755929,1,['depend'],['depends']
Integrability,"> > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. I ran a tracer with initial value of 1 everywhere to look at the concentration leakage. I took the percentage of the difference in the area integrated concentration of the IBM and nonIBM scaled by the initial concentration, ie. `100 x abs(IBM - nonIBM)/ initial`. The results are below. It looks like for a 256 x 256 grid after 200s only about 3 x 10^-5 % of the initial concentration has leaked out, which is pretty good and seems to scale well with refinement!; ![volint_Concentration_leakage](https://user-images.githubusercontent.com/67593861/123316291-b051de80-d4fa-11eb-86e7-4ee969af5703.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867903313:633,integrat,integrated,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867903313,1,['integrat'],['integrated']
Integrability,"> > I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:962,depend,depend,962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,1,['depend'],['depend']
Integrability,"> > I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up.; > ; > I'm actually not sure. All that `NonTraditionalFPlane` does is to tilt the rotation axis of an f-plane based on latitude. So it just projects some component of `f` onto the `y` direction. `GeneralFPlane` (or whatever we end up calling it) can tilt the rotation axis in any arbitrary direction, so it can already do what `NonTraditionalFPlane` does (and more). So really (imho) I don't see much use for `NonTraditionalFPlane` after this gets implemented, except maybe as a convenience function. This should definitely replace `NonTraditionalFPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886716989:115,depend,depends,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886716989,1,['depend'],['depends']
Integrability,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:924,wrap,wrap,924,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884,1,['wrap'],['wrap']
Integrability,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:379,depend,depends,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023,1,['depend'],['depends']
Integrability,"> > I think eq 9 in https://clima.github.io/OceananigansDocumentation/previews/PR2639/numerical_implementation/poisson_solvers/ is correct; am I right?; > > if so, I seem to have trouble deriving eq 10…; > ; > OK, I see the derivation in pages 7-8 of https://www.overleaf.com/project/6042a885d8327860fae7cc5e. I think we need to include a bit more steps from this derivation here... Ageed. It seems that we integrate the continuity equation from the bottom, z=-H, to the surface, z=0, exchange the order of integration and differentiation, and then substitute in the kinetmatic boundary conditions at the top and bottom. But maybe even more detail would be helpful?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064:407,integrat,integrate,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064,2,['integrat'],"['integrate', 'integration']"
Integrability,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:1260,rout,route,1260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247,1,['rout'],['route']
Integrability,"> > I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.; > ; > To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU?. If the precomputation is storing values in an `Array` or `CuArray` (which is already mutable) then no. If you need to precompute a number for every boundary, then yes you need something mutable. But it looks like this would not involve the `BoundaryCondition` itself but rather a component of the boundary condition (eg the `condition` or the `classification`). None of this is hard though. I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558,1,['interface'],['interface']
Integrability,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:87,depend,depends,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237,3,['depend'],"['dependencies', 'depends']"
Integrability,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524:928,depend,depends,928,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524,1,['depend'],['depends']
Integrability,"> > I think we need an required_biogeochemical_auxiliary_fields like required_biogeochemical_tracers because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); > ; > Should the user specify this, or should the biogeochemical model add it its struct (taking in `grid` for this purpose) and evaluate it during `update_biogeochemical_state`?. This is a good point, I think doing it as part of the model in update state is a much better solution",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311540745:300,depend,dependence,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311540745,2,"['depend', 'integrat']","['dependence', 'integrating']"
Integrability,"> > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?. Mainly I think we can get all the same benefits by maintaining a single unified and tidy repository with sub-modules. I don't see Oceananigans as a complex project yet, we're barely at 2,500 lines of code (minus turbulence closure operators which aren't integrated yet). I can see reasons for having a separate repository for examples and tutorials if there are enough of them, but I don't see e.g. the output writers as being logically separate from the main code. As a stand alone package, OceananigansOutput.jl doesn't do anything useful. Something like TurbulenceClosures.jl could though. Keeping things in tidy submodules within a single repository increases code visibility, which I think is important. When I see a package or framework spread across multiply small packages I find it hard to get an idea about what it can do. Another nice thing is we currently have ""unified versioning"" so when releases occur we know everything works together. We don't have to worry about running with Oceananigans v0.x with OceananigansPlotting v0.y and OceananigansOutput#master to fix some issue. From a development perspective, issues and pull requests are now spread across multiple repositories and we can end up with pull requests that depend on other pull requests in other repositories, e.g. when adding in halo regions the main code got refactored but so did the output writers and plotting code would change as well. We can also end up with multiple test suites that need to pass, plus possibly multiple CI pipelines to manage. So right now it's easy to make atomic changes that touch upon multiple pieces of code (and we'll probably be in this stage where we need to refactor frequently for a while). I also don't have to git clone a bunch of repositories just to work on a simple example. But this is getting off-topic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749:354,integrat,integrated,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749,2,"['depend', 'integrat']","['depend', 'integrated']"
Integrability,"> > I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.; > ; > Thought more about this and I think it might be quite complicated to change to this so I will leave for now. That isn't what `fields` means right now (in fact, it doesn't have much of a concrete meaning at all and is defined rather vaguely, as it arbitrary omits some model fields while including others). Possibly, there is scope for another utility that returns something like ""prognostic + background fields, and selected auxiliary fields). Perhaps `forcing_fields` or something. However, I would pause a moment to consider whether this is the most useful abstraction for users. It may actually prove more limiting than helpful from the user perspective, as it is typically the case that a forcing function (such as a sponge layer) should depend only on perturbation fields rather than a ""total"" field representing perturbation + background...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255:198,depend,dependant,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255,2,['depend'],"['depend', 'dependant']"
Integrability,"> > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > ; > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`. I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time $t$ before it is being advected to time $t + \Delta t$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652:293,depend,depends,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652,1,['depend'],['depends']
Integrability,"> > Is it possible to get julia to ignore the manifest (i.e. specify that we want to ignore it in the CI), so that when a user downloads it they can still use the manifest?; > > Having asked that I don't actually know what the manifest does that isn't already taken care of by the Project?; > ; > The Project compat is supposed to take care of everything. It's just that subtle bugs can creep into packages that might cause things to fail for us (for example something subtle can break type inference, causing everything to fail on the GPU). So using the Manifest is a bit more conservative, because we fix all of the packages that don't _need_ to be upgraded. On the other hand, we are better community members by deleting the Manifest because catching those bugs is important for everyone. To be more specific, with Project.toml we specify compat on packages we depend on, but we do not have compat on packages that our dependencies depend on. The Manifest tracks all packages including dependencies of dependencies (and dependencies of those). We've caught issues in the past by comparing the committed Manifest to another Manifest with different packages. Some issues include, a version of MPI_jll that doesn't work on Mac, or some weird bug in ChainRulesCore... things that we don't have explicit compat for...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361792025:864,depend,depend,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361792025,6,['depend'],"['depend', 'dependencies']"
Integrability,"> > Is this something that is handled on the MIT side ?; > ; > Yeah, it’s something the Oceananigans dev team should sort out! :). Curious to know if there's any movement on getting this resolved. I can offer some help in getting an allocation request in to Pawsey Supercomputing Centre - I mentioned to @navidcy that I have a solution for doing CI on systems with job schedulers (like Pawsey's Setonix). . If existing hardware systems at MIT are not available for this, I can also help with procurement, if needed. If you go this route, I can look into providing some time on our systems to get testing rolling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1995881191:531,rout,route,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1995881191,1,['rout'],['route']
Integrability,"> > It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.; > ; > Yeah, my question was in the sense of ""is there Julia functionality to do that"". If it requires us to write a script to manipulate the text, then I agree that it'd be too much of a headache for something rather hacky... I guess what `Pkg` provides is: if we add `Oceananigans` as a dependency, compat for `Oceananigans` is imposed on `benchmarks/Project.toml`. But this complicates the purpose of the benchmarks, which is to execute the local code. Maybe we can add lines at the top of the benchmark script like. ```julia; using Pkg; Pkg.dev(""..""); ```. Then we add the local version of Oceananigans to the `Project.toml` before the script is executed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049:478,depend,dependency,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049,1,['depend'],['dependency']
Integrability,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:348,integrat,integrated,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132,1,['integrat'],['integrated']
Integrability,"> > Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.; > ; > Yes yes yes!; > ; > Can we have alias?. We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805:42,interface,interface,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805,1,['interface'],['interface']
Integrability,"> > Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?; > ; > Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid.; > ; > I agree that we should have a test for that and maybe something in the docs, sometime?. Added a note in docstring + an `@assert` check. See [43cfed7](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/43cfed75cf5601f543f91eef8cdd3c29d90fa05e)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451:154,message,message,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451,1,['message'],['message']
Integrability,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:50,integrat,integrate,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795,8,"['Integrat', 'integrat']","['IntegratedField', 'integrate', 'integrating']"
Integrability,"> > Requires [JuliaGPU/KernelAbstractions.jl#399](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399) # On hold at the moment; > ; > At the top comment it says this PR depends on another KA PR that isn't merged. However, this PR is merged (and tagged). Does this not depend on [JuliaGPU/KernelAbstractions.jl#399](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399) anymore?. Yeap, it doesn't. I edited the first post ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729628669:176,depend,depends,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729628669,2,['depend'],"['depend', 'depends']"
Integrability,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538:673,interface,interface,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538,2,['interface'],['interface']
Integrability,"> > Some good news is that more tests seem to be passing compared to the prevoius PR.; > > One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why.; > > ```; > > Testing Oceananigans; > > # Received cancellation signal, interrupting; > > ```; > ; > I don't know what you saw. But what I see here:; > ; > https://buildkite.com/clima/oceananigans/builds/14750; > ; > is that almost all tests pass. Thanks @navidcy , that does look very promising!. The error that I saw is copied below. I am not quite sure where this comes from though.; ```; [8dfed614] Test; Status `/tmp/jl_pRHyI0/Manifest.toml`; [403513] signal (11.1): Segmentation fault; in expression starting at /storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg/platform_augmentation.jl:102; Allocations: 2907 (Pool: 2899; Big: 8); GC: 0; ERROR: failed process: Process(`/storage5/buildkite-agent/julia-1.10.2/bin/julia -C native -J/storage5/buildkite-agent/julia-1.10.2/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_pRHyI0/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/storage5/buildkite-agent/.julia-14750""]); append!(empty!(Base.DL_LOAD_PATH), String[]); cd(""/storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg""); include(""/storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg/select_artifacts.jl""); ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-libstdcxx30-julia_version+1.10.2`, ProcessSignaled(11)) [0]; Stacktrace:; [1] pipeline_error; @ ./process.jl:565 [inlined]; [2] read(cmd::Cmd); @ Base ./process.jl:449; [3] collect_artifacts(pkg_root::String; platform::Base.BinaryPlatforms.Platform); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:720; [4] collect_artifacts; @ /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458:102,message,messages,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458,1,['message'],['messages']
Integrability,"> > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them. Ok got it. What's the purpose of that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716883676:615,depend,dependent,615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716883676,1,['depend'],['dependent']
Integrability,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:1629,integrat,integration,1629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509,1,['integrat'],['integration']
Integrability,"> > The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:; > ; > ; > First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this.; > You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface.; > > As I said though, I agree it's a good idea to make this kind of thing easier. Actually I realized that `dynamics` is called _before_ advection, which makes it more annoying:. https://github.com/CliMA/Oceananigans.jl/blob/dd893745e50fd7aef945f765df929d2a7510db6e/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L123-L132. That makes it a little trickier. It's still possible, since you can compute a ""fake particle update"", and then add the inertia term, before the ""real update"" that occurs in `advect_lagrangian_particles!`. But it's complicated. Why do we call `dynamics` before advection? Should we switch the order of those two? It also seems like we should update particle properties _after_ we advect the particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649:468,interface,interface,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649,2,['interface'],['interface']
Integrability,"> > This is good after changes.; > > My only question is whether another implementation might be something like; > > ```julia; > > function Base.:(==)(grid1::AbstractGrid, grid2::AbstractGrid); > > !isa(grid2, typeof(grid1).name.wrapper) && return false; > > topology(grid1) == topology(grid2) && return false; > > ; > > x1, y1, z1 = nodes((Face, Face, Face), grid1); > > x2, y2, z2 = nodes((Face, Face, Face), grid2); > > ; > > return x1 == x2 && y1 == y2 && z1 == z2; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > This has different behavior than what's implemented here. In particular, two grids will be identified as equal even if one has ""number spacing"" (eg a constant) whereas the other has array-spacing with all the values equal to that number. In other words, while; > > ```julia; > > julia> 1.0 == ones(2); > > false; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > we may want to identify this case with numeric equality for a grid.; > > The key here is that two grids are ""equal"" if they have the same nodes. The other properties (like spacings) are really implied by the placement of the nodes.; > ; > OK, perhaps then your suggestion is better. What about when two grids are otherwise the same but one lives on GPU and one on CPU. Will the above render them equal? I guess no since, e.g., `z1 == z2` will return false if one is an Array and other a CuArray. Actually, the julia gods have decided that CPU and GPU arrays can be numerically equal:. ```julia; julia> using CUDA. julia> a = rand(3); 3-element Vector{Float64}:; 0.3492331921297629; 0.4354818891776633; 0.684771954777823. julia> a == CuArray(a); true; ```. Since we use `==` on the nodes (which are always arrays), we retain the behavior that a CPU grid and a GPU grid can be _numerically_ identical via `==`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951556601:229,wrap,wrapper,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951556601,1,['wrap'],['wrapper']
Integrability,"> > Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`; > ; > Actually, even putting `@show ""hi""` **just before** `calculate_pressure_correction!` also does the job. Right, `calculate_pressure_correction!` does nothing for the free surface model so it shouldn't matter where it's placed relative to that. Is that the only place within `time_step!` that fixes it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299382102:140,synchroniz,synchronization,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299382102,1,['synchroniz'],['synchronization']
Integrability,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:249,depend,dependent,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304,1,['depend'],['dependent']
Integrability,"> > We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type.; > > Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector).; > ; > Okay, so a longer term plan.; > ; > For the moment we need that `HydrostaticModel` uses traditional f- or beta-plane, or something that does the same thing. It is `NonhydrostaticModel` that will allow for more types of coriolis terms. Understood. Note too that the problem is really specific to a spherical geometry. In a rectangular geometry, a thin aspect ratio approximation is mathematically equivalent to a change in the axis of rotation. In a spherical geometry this is no longer possible and we need to explicitly state that we are making a hydrostatic approximation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888491064:120,depend,depends,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888491064,1,['depend'],['depends']
Integrability,"> > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > ; > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity. A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819491364:392,depend,depend,392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819491364,1,['depend'],['depend']
Integrability,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:829,interface,interface,829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698,1,['interface'],['interface']
Integrability,"> > Yeah, I can change it back to be similar to how it was before?; > ; > I'm not sure exactly how it was before --- but if that works, it works! I can also help (next week, it's Thanksgiving right now over here in the US). Done this now, to make it work with `SomethingBiogeochemistry` I had to add the light attenuation model as a property of the `SomethingBiogeochemistry` so it can integrate, I think it works okay?. Edit for clarity: the default is to have no light attenuation model so if users don't want to integrate one (like the origional phytoplankton growth model) they don't have todo anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1330454554:386,integrat,integrate,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1330454554,2,['integrat'],['integrate']
Integrability,"> > ```julia; > > OpenBoundaryCondition(nothing) # impenetrable; > > OpenBoundaryCondition(1) # external state = 1, no matching scheme; > > OpenBoundaryCondition(external_state, matching_scheme) # explicit matching scheme; > > ```; > ; > This does seem like the best user interface for it. Is keeping the external state in the condition and the matching scheme in `Open` okay then?. We can have this syntax whether or not we separate where the external state and matching scheme are stored. I prefer keeping them together because I believe the source code will be easier to understand in that case. I think we should also discuss with @simone-silvestri.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986537294:272,interface,interface,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986537294,1,['interface'],['interface']
Integrability,"> > `test_dynamics.jl` fail.; > > Is this correct here?; > > https://github.com/CliMA/Oceananigans.jl/blob/ad110ecdc635192c110e229df4fbfa04fc7a2266/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L39-L41; > > ; > > I guess it should be `if formulation == VerticallFormulation() and ...`?; > ; > No that's correct --- we can't use vertically implicit time-stepping with `HorizontalFormulation`.; > ; > The reason is that `HorizontalFormulation` has no vertical terms. Then the error message should be `only supported for `VerticalFormulation or ThreeDimensionalFormulation""`, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185:514,message,message,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185,1,['message'],['message']
Integrability,"> > afaik the second test filter is only needed when assuming that `β` can vary between scales.; > ; > I think you're correct here! Sorry for the confusion here, but I suppose by scale-invariance I mean `β` has a power law dependence on the scale size. And since we were trying to implement the scale-dependent version, `β` would vary across different scales? Hence we need the `α=4` filter as well. Am I understanding Equation (26) in [Bou-Zeid et al. 2005](https://dx.doi.org/10.1063/1.1839152) correctly here?. Ah, I see, I was under the impression you were trying to implement the scale-_invariant_ version, but it does make sense to if you're implementing the scale-dependent version.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187294884:223,depend,dependence,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187294884,3,['depend'],"['dependence', 'dependent']"
Integrability,"> > or in general, coming up with a system that makes sure that the API is compatible with the choice of complex BCs For example, in a script people should not be allowed to do; > > ```julia; > > u, v, w = model.velocities; > > fill_halo_regions!((u, v, w)); > > ```; > ; > I understand the first part, but can you explain why the latter isn't desirable and why it would be hard to come up with something? The way I see it, if we set in stone that `fill_halo_regions!()` needs to have `clock` and `fields(model)` passed, then can't we just remove the method that would make `fill_halo_regions!((u, v, w))` possible?. No, we definitely don't want that. That would make it impossible to use `Fields` without a model. We want simple / default boundary conditions to work without an entire model state. One has to understand the additional arguments to `fill_halo_regions!` as part of a system to support _additional_ features for fields, such as boundary conditions that depend on other parts of the model state. There's a circular depedancy issue: when field boundary conditions depend on other fields, the entire system of fields must be created simultaneously for the computation to work properly. We don't have a _general_ system for this. We just support it within the context of a model, like the hydrostatic or nonhydrostatic model. This works because whenever we fill halo regions _within_ the model time-stepping algorithm, we can indeed incorporate the whole model state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179182260:968,depend,depend,968,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179182260,2,['depend'],['depend']
Integrability,"> @Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the momentum equations.; > ; > If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue. @francispoulin I am interested deriving/testing closures in the 2D Adv-Diff equation in the (general) case of periodic shear flows. A constant shear flow won't do it. More like a velocity field that can be decomposed into a shear flow u(y) (e.g. a cosine in y or sum of cosines) plus a cellular flow (square waves). I am still a newbie over here, so I am open to trying different models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388:396,depend,depending,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388,1,['depend'],['depending']
Integrability,"> @ali-ramadhan and @glwagner is the incmod(), decmod() stuff the right thing to do in this. I am trying to think how this will interact with Halo() code elsewhere? Would we be better off filling halos at various intermediate stages for now. We can then tidy up and use wiser halos later? Any thoughts?. Not sure if this is the final form of this PR, but I suggested we just merge the closures as is, with operators that use `incmod1` and `decmod1`, mostly to integrate the closures ASAP. It's definitely inconsistent with the rest of the fields that actually use halos. We could focus on cleanup of this kind once we verify that the LES closures work, unless this is a pretty urgent issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-509414597:460,integrat,integrate,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-509414597,1,['integrat'],['integrate']
Integrability,"> @ali-ramadhan would it be good to send messages to everyone who has a fork maybe and maybe keep an issue open, so people who have cloned can see?. That's a good idea, I think the only other person who had an issue was @arcavaliere who had an open PR at the time, but otherwise we could tag all the forkers. > Of course it would also be good not to rewrite the history - that pretty much breaks how git works. In theory reviewing PRs should catch this?. Agreed. Yeah it took us a while to find the leak in #509 (JLD2 file wasn't added by us but by examples generating files when built) and the damage was contained to the `gh-pages` branch but the reason it affected the `master` branch was that I also deleted an old regression test file. Now that we're more aware of this issue I think we can stop it from happening again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577237824:41,message,messages,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577237824,1,['message'],['messages']
Integrability,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:1126,wrap,wrapping,1126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['wrap'],['wrapping']
Integrability,"> @glwagner : I understand what you are saying about the traditional approximation.; > ; > If we include the non-tradidtional terms, we obtain the Quasi-Hydrostatic model, as discussed in the MITgcm. This is something we can solve in the `HydrostaticModel`, right?; > ; > I'm not suggesting we change the name of the model but I thought we could use this in either model, but maybe there's a problem because of the pressure solve, which might not allow for this?. We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type. Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888444391:580,depend,depends,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888444391,1,['depend'],['depends']
Integrability,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?. @francispoulin I think he's talking about the fact that the graph on the right (the domain average/integrated momentum) isn't monotonic for IBM cases. Overall it has the correct tendency (loss of momentum) but has small scale fluctuations that aren't physical (i.e. there's no physical mechanism increasing the avg momentum in the domain, so the fluctuations must be numerical in origin).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266:266,integrat,integrated,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266,1,['integrat'],['integrated']
Integrability,"> @glwagner Yes you are right. I tried restarting Julia, and it worked without the error message. Sorry!. no worries!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386940947:89,message,message,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386940947,1,['message'],['message']
Integrability,"> @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ?. I know _chemistry_! Ahaha I like those. `Biogeochemmingaround.jl`? Ok, let's brainstorm. > Thinking more, it would be so the function automatically adds the callbacks to the simulation?. There are multiple possible places where one might update the `biogeochemical_state`. An ""external"" paradigm requires `Callback`. But an ""embedded"" paradigm can hard-code functionality into `update_state(model)!`:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. I think we want to pursue code design that allows these paradigms to be interchanged. I think it's crucial that functionality developed ""externally"" can be ""copy/pasted"" into `Biogeoceananigans.jl`. This probably would be less pretty than it sounds (style, code quality, names...), but I think is still a good organizing principle for the design. > Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point?. I see very much what you're saying. There's an opportunity to also support biogeochemistry on Lagrangian particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174:999,interface,interface,999,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174,1,['interface'],['interface']
Integrability,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:80,interface,interfaces,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847,2,"['integrat', 'interface']","['integrator', 'interfaces']"
Integrability,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895:80,interface,interfaces,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895,2,"['integrat', 'interface']","['integrator', 'interfaces']"
Integrability,"> @jm-c and I talked today and we have an additional point to make (this is related to #115 as well).; > ; > Notice first that the [operators `δz_f2c` and `δz_e2f`](https://github.com/glwagner/Oceananigans.jl/blob/3307031283dab154d32c071c47d9e275f1a6e17e/src/operators/ops_regular_cartesian_grid.jl#L29) are identical:; > ; > ```julia; > @inline function δz_f2c(f, Nz, i, j, k); > if k == Nz; > @inbounds return f[i, j, k]; > else; > @inbounds return f[i, j, k] - f[i, j, k+1]; > end; > end; > ; > @inline function δz_e2f(f, Nz, i, j, k); > if k == Nz; > @inbounds return f[i, j, k]; > else; > @inbounds return f[i, j, k] - f[i, j, k+1]; > end; > end; > ```; > ; > Our solution:; > ; > ```julia; > abstract type Location end; > struct Center end; > struct Interface end; > ; > struct Field{Lx<:Location, Ly<:Location, Lz<:Location, A, G}; > data::A; > grid::G; > end; > ```; > ; > we then need only two `δz` functions that dispatch on `Lz`; for example:; > ; > ```julia; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Center} = ...; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; > ```; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471136259_. Also see discussion that followed for more clarification.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/146:756,Interface,Interface,756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/146,2,['Interface'],['Interface']
Integrability,"> @liuchihl Have you tried running on the CPU to see if you get a more useful error message?. Thanks, I'll give that a try. I could be wrong, but my guess is that the issue might be related to the use of GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429704389:84,message,message,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429704389,1,['message'],['message']
Integrability,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:340,integrat,integration,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702,1,['integrat'],['integration']
Integrability,"> @navidcy thanks, I was able to bring the branch up to date to a more reasonable delta. @glwagner I think there's no need to separate ROCm support and multi-GPU support, since multi-GPU support was mostly dependent on modifications in PencilFFTs.jl. If the PencilFFTs update is small, that makes it a great candidate for a small independent PR. It's especially important here because there is potentially a conflicting PR: https://github.com/CliMA/Oceananigans.jl/pull/2538. Perhaps we can do the distributed FFT PR first if its easy, then continue working on AMD support? There are likely a fair number of users interested in multi GPU. Hopefully we can make the new PR compatible with https://github.com/CliMA/Oceananigans.jl/pull/2538.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1451020491:206,depend,dependent,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1451020491,1,['depend'],['dependent']
Integrability,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980:668,depend,depends,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980,1,['depend'],['depends']
Integrability,"> @simone-silvestri, will you expand this regression to `ImplicitFreeSurface` as well? If not, then perhaps add a note in one of the `@info` messages clarifying e.g. ""... with explicit free surface formulation""?. Good idea, if the test is still cheap!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604:141,message,messages,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604,1,['message'],['messages']
Integrability,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:979,depend,dependencies,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953,1,['depend'],['dependencies']
Integrability,"> @tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`. Not at all! I'm taking long with this PR because I'm not that familiar with the internal workings on `Field`s. I'm currently editing some files right now but honestly it doesn't feel like I'm making any progress, so feel free to help me out. And I appreciate it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051:105,depend,depend,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051,1,['depend'],['depend']
Integrability,"> @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?. The specific purpose atm is to make this code on Oceanostics work (currently it does not):; https://github.com/tomchor/Oceanostics.jl/blob/29a544d3decd833d9f86da05b66a7392197c3b93/src/Oceanostics.jl#L25-L39. The bigger purpose is to make it easier for users to work with viscosities and diffusivities. As far as I know there isn't a unified interface to getting these fields. I've needed that many times in the past in my scripts and had to use `if-else` statements to get ν and κ for each closure. I think it'd help users if Oceananigans could provide a standard interface for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940,4,['interface'],['interface']
Integrability,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:954,Wrap,Wrapping,954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212,1,['Wrap'],['Wrapping']
Integrability,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146:272,depend,depend,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146,1,['depend'],['depend']
Integrability,"> After some thought, I think what we want to do is to implement a way to implicitly time-step components of the model term by term (rather than implementing some way to time-step part of a term implicitly. For the implicit time-stepping API are you thinking of supporting 3D implicit time-stepping or just vertically implicit? I guess 3D implicit could be slow but in the right situations (e.g. low Re) could allow much longer time steps. If we just want to tackle vertically implicit for now, would the implicit time-stepping look pretty similar to OceanTurb's backward Euler: https://glwagner.github.io/OceanTurb.jl/latest/numerics/#Time-integration-methods ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-783471566:641,integrat,integration-methods,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-783471566,1,['integrat'],['integration-methods']
Integrability,"> Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model. Even more than details associated with particular challenging ODEs is the more fundamental software challenge of designing a flexible and useful system for user-specification of ODEs (special fields defined on sets of particles, each associated with an independent ODE that is coupled to the model solution) to be solved on particle trajectories. If we were integrated with DifferentialEquations.jl, this might not be all that hard, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256:668,integrat,integrated,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256,1,['integrat'],['integrated']
Integrability,"> Ah interesting. Does this work because broadcasting over GPU subarray views is a little rough around the edges?; > ; > Also, is it worth adding the MWE from [#1767 (comment)](https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868793917) as a test?. Certainly _something_ is rough... I think it's ""broadcasting over ReducedField"" that's the issue here. Prior to this PR, `mean!` used a broadcast over `R::AbstractReducedField` to compute the normalization. For some reason this has data synchronicity issues on the GPU (I'm at a loss to explain why). This PR just changes that broadcast operation to compute over all members of `R`. The halo regions of `R` (presumably) aren't touched during `sum!`, so doing some extra normalization in the halos doesn't really matter, I guess... (if we want halos to be right we should probably fill them after executing `mean!` in `compute!`, or something). But the _reason_ why this change fixes the issue isn't at all obvious to me. Maybe there's a bad interaction between `KernelAbstractions` (which gets used for the broadcast) and `sum!`? Not sure. Maybe another solution would wrap `sum!` in `CUDA.@sync` (eg the solution here could _implicitly_ synchronize in order to perform the broadcast correctly; otherwise CUDA wouldn't work generally... ?!?). Might be worth testing that, though I don't know which solution we should prefer (if any). In fact, it seems better to avoid using custom broadcasting machinery if possible (which is the current solution)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671:1135,wrap,wrap,1135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671,2,"['synchroniz', 'wrap']","['synchronize', 'wrap']"
Integrability,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:1169,message,message,1169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319,1,['message'],['message']
Integrability,"> Ali, i thought the stretching was sorted now, after the hackathon. Without stretching the code will have limited use. John. Yes well, we know how to do a very fast Poisson solve in a vertically stretched grid but still working on integrating it (PR #306). The fast solver (which relies on cyclic reduction) may need some massaging to work with Neumann boundary conditions for pressure... The plan is to merge the vertically stretched grid with the finite volume operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510488262:232,integrat,integrating,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510488262,1,['integrat'],['integrating']
Integrability,"> All 6 boundaries are something like; > ; > ```julia; > using Oceananigans.AbstractOperations: flip; > ; > east_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); > south_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j, k, grid); > bottom_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k, grid); > ; > west_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i+1, j, k, grid) ; > north_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j+1, k, grid); > top_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k+1, grid); > ```; > ; > something like that. There could be a mistake. Yep I think this would work...; Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not), in that case we would need ; ```; bottom_bounded(LX, LY, LZ, i, j, k, grid) = solid_node(LX, LY, LZ, i, j, k-1, grid) & !solid_node(LX, LY, LZ, i, j, k, grid)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083:1022,Depend,Depends,1022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083,1,['Depend'],['Depends']
Integrability,"> Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?. This PR _defines_ the ""buffer"" as the halo dependent region of the domain. Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056:113,depend,dependent,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056,2,['depend'],['dependent']
Integrability,"> Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions. That's an interesting example. This wouldn't generalize to cut cells, right? Perhaps we need an abstraction that represents the distances to the boundary, for use within boundary conditions. That way we can ensure the distance to the boundary is computed correctly regardless of how the boundary is represented. As an aside, hasn't it been shown that MOST is not valid in complex terrain? (That wouldn't prevent it from still somehow improving model fidelity, at least in principle.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939:75,depend,depend,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939,1,['depend'],['depend']
Integrability,"> Also we get some deprecation warnings. E.g., for; > ; > ```; > SpecifiedTimes(times::Vararg{<:Number}) = SpecifiedTimes(sort([Float64(t) for t in times]), 0); > ```; > ; > we get; > ; > ```; > Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead).; > ```; > ; > I don't understand what that means tho. I think a39445a and [bf06da1](https://github.com/CliMA/Oceananigans.jl/pull/3100/commits/bf06da180131d8cbede895913d21aa9348684095) dealt with this",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566861284:195,Wrap,Wrapping,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566861284,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,"> Also, we should not use β for the haline contraction coefficient.; > ; > _Originally posted by @glwagner in https://github.com/glwagner/OceanTurb.jl/issues/41#issuecomment-506905395_. +1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/20#issuecomment-506906377:43,contract,contraction,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/20#issuecomment-506906377,1,['contract'],['contraction']
Integrability,"> Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though. Doesn't this depend on the setup? The actual ocean bottom is littered with boulders and other features of various sizes, and there's plenty of work in very steep canyons, ie https://en.wikipedia.org/wiki/Scripps_Canyon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067:261,depend,depend,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067,1,['depend'],['depend']
Integrability,"> Am I correct in thinking that we want xspacing, yspacing, zspacing, etc. (+ λ, φ, ξ, η, r) to all be functions of (i, j, k, lx, ly, lz, grid) and return a number?. yes. > Then we want xspacings, yspacings, zspacings, etc. to return an array of spacings (perhaps with a with_halos flag)? Should it be an array or a Field?. The cleanest implementation is to return a `KernelFunctionOperation` that calls `xspacing`, `yspacing`, etc, under the hood. I don't really like `with_halos`, I think that's a plotting issue not a spacing issue. We can solve that via the Makie extension. Or one can write `Field(xspacings(grid, lx, ly, lz), indices=(1:Nx, 1:Ny, 1:Nz))`. `Field` works too as a return type but I don't think we need to always allocate memory for the spacings. One barrier to this was plotting, but this issue is beginning to be solved with the new extension:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L41-L45. > Should the returned array/field be reduced when possible?. The `KernelFunctionOperation` should have `Nothing` locations if the spacings / metrics do not depend on that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822:1147,depend,depend,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822,1,['depend'],['depend']
Integrability,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336:387,depend,dependant,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336,2,['depend'],['dependant']
Integrability,> Another issue to add into this discussion is the fact of how to handle output (e.g. file.nc) with checkpoints and file_splitting. I propose handling this by initializing output files within `run!` rather than during instantiation of the output writer. This is separate from the interface discussion here though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684:280,interface,interface,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684,1,['interface'],['interface']
Integrability,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263:199,interface,interface,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263,1,['interface'],['interface']
Integrability,> Another place I think we need to change is particle advection:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/f3113c492f309846f026e0ac150dc8480f96e0f2/src/LagrangianParticleTracking/update_particle_properties.jl#L157-L161; > ; > Because currently background velocity fields don't get integrated which I think is wrong? At least in the case I was using them for I had to add the background velocities manually. Totally agree particles should be advected with prognostic + background,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482935693:292,integrat,integrated,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482935693,1,['integrat'],['integrated']
Integrability,"> Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?. Sorry I forgot to reply to this sooner. If we use `ch` then we can write the advection term as a divergence form, and then use a lot of the existing code that we have for the other models. This seems easier to me, rather than having to write different solvers for the alternative form of advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447:165,integrat,integrated,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447,1,['integrat'],['integrated']
Integrability,"> As far as I know there isn't a unified interface to getting these fields. The interface for `AbstractScalarDiffusivity` is the function `viscosity(closure, diffusivities)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114,2,['interface'],['interface']
Integrability,"> As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would HydrostaticCurvilinearCoriolis be appropriate?. I haven't added `HydrostaticCurvilinearCoriolis` yet --- I'm planning to implement that once the PR is merged. At the current moment, I've only changed `BetaPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605:100,depend,depends,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605,1,['depend'],['depends']
Integrability,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:197,interface,interface,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990,1,['interface'],['interface']
Integrability,"> Awesome!; > ; > How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?. It is not that large, I figured that with `UInt16` we can cover almost all practical cases. `wet_cell_map` will be a vector of _active_ locations defined by a tuple of indices. Depending on what % of the domain is active, the size of the map will be. `prod(size(grid)) * %active * 3 * sizeof(Type)`. where `Type` is the `UInt` with the minimum size required to represent `maximum(size(grid)))`; In the example of the ocean, where 57% of the domain is active, the map is 42.75% the size of a standard Float64 `Field`:. a UInt16 occupies 2 bytes, so compared to a field, the map is . `(0.57 * 3 * 2) / 8 ≈ 0.4275` . I guess adding the opt in/opt out can be nice and is very easy because of . https://github.com/CliMA/Oceananigans.jl/blob/b7835edbac0a7318d49462addb1c1046014e39c4/src/ImmersedBoundaries/wet_cells_map.jl#L10-L21. which is used now to calculate the map only when we construct the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775:314,Depend,Depending,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775,1,['Depend'],['Depending']
Integrability,"> Before I push my local commits, does Manifest.toml require any changes?. `Manifest.toml` typically has to be synchronized with `Project.toml`, so it probably will have to be updated if you've changed `Project.toml`. In a perfect world (if our package compatibility bounds in `Project.toml` were perfect) then users could generate `Manifest.toml` on their local machine without requiring a committed version. However, it turns out to be a bit annoying to keep compatibility bounds up to date, so we use the `Manifest.toml` as a hack. Since we can't really review changes to the `Manifest.toml` it's best to be conservative about updating packages, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-866286260:111,synchroniz,synchronized,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-866286260,1,['synchroniz'],['synchronized']
Integrability,"> Before proceeding further, I guess we should discuss a bit on whether we want a single parameter for gravitational acceleration (`effective_gravitational_acceleration`, which can encapsulate both gravitational acceleration `g` and reduced gravity `g'` terms) or two parameters (one for `g` and `g'` each), with Navid's code above an example of the latter. I am inclined towards the former as I feel it's cleaner (scientifically and for coding purposes), but happy to go either ways. I didn't really think through my code above so don't pay too much attention to it. :); It was just a placeholder to demonstrate about parametric types. But I don't understand exactly what you suggest. `gravitational_acceleration` is a number, and it the same regardless of the number of layers you have. It's the acceleration that the top-layer surface feels (given that we use the approximation that `ρ_air ≪ ρ_fluid`. The reduced gravities `g'_{k+1/2} = g * (ρ_layer_k+1 - ρ_layer_k) / ρ_layer_k+1` are the gravitational accelerations each of the fluid interfaces feel. So `g'` is a Tuple of `k-1` numbers, where `k` is the number of layers, right? And this parameter is irrelevant for the SingleLayerModel. Were you suggesting to combine these in a single `k`-long tuple, e.g.,. ```julia; gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); ```; which will become a number for single layers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937:1040,interface,interfaces,1040,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937,1,['interface'],['interfaces']
Integrability,"> Building on what @jm-c said, I think we want to design an interface in which an equation is expressed as something like ; > ; > ```; > φ_t = Lφ + Ν(φ); > ```; > ; > where `φ` is the solution (an array of fields in this case, probably), `L` is a linear operator that can be treated implicitly (depending on the time-stepping scheme), and `N(φ)` is a nonlinear operator.; > ; > The challenge is including the pressure correction in this paradigm. I think it should be possible --- we may just have to consider only time-steppers that invoke the special pressure correction substep.; > ; > I think the design should be about more than just 'marking' the terms. We can tackle the problem of designing a time-stepper to step forward an equation of a certain form completely independent from the development of an algorithm to calculate nonlinear terms, pressure corrections, and linear terms for a specific kind of equation. Then we put the pieces together to solve the problem.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/issues/49#issuecomment-463209211_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/95:60,interface,interface,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/95,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"> But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. That's not quite true for the ordinary definition of ""as needed"". Halos and nonlinear diffusivities are only filled or calculated immediately prior to a time-step! If you `set!` the model state (or even if you time-step the model forward), you cannot actually calculate, diagnose, or plot 1) the gradients of fields across boundaries or 2) the nonlinear diffusivities. In fact, it hadn't occurred to me previously but with our current paradigm the LES diffusivity field that is output is actually inconsistent with the velocity field even if they are output at the same `model.clock.time`. So at the moment this is a legitimate concern. Are the ""atmospherigans"" being discussed here of the same form? Are some of these fields related diagnostically to one another, or are they only related diagnostically along a model boundary? (Or something --- its hard for me to generalize from the example given above.). We may want to develop the concept of a model ""state"". We can provide a function `update_state!` that updates all fields (eg halos + fields that depend diagnostically on others like nonlinear diffusivities and possibly others), and use this both in `set!` as needed, during time-stepping, and prior to output. We can also create a system for 'tagging' components of the model that have `update_state!` methods attached to them. For example, some turbulence closures require the computation of perturbations from a horizontal average (eg, the buoyancy perturbation). Such fields would also need to be updated during an `update_state!` call. The lack of such an abstraction is currently a barrier to the implementation of those turbulent closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-583382816:1196,depend,depend,1196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-583382816,1,['depend'],['depend']
Integrability,"> But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet. We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818:319,interface,interface,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818,3,"['Depend', 'interface']","['Depending', 'interface']"
Integrability,"> But it's possible to write code that works for all grids by referencing the kernel functions directly (rather than trying to extract the spacings from the grid properties). That's how we get spacings inside the code, so if we use the same method in the user interface then all is good. @glwagner, what do you mean here by ""kernel functions""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192:260,interface,interface,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192,1,['interface'],['interface']
Integrability,"> But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. (Yes, but also the Manifest includes a lot of updates for various dependencies so that all pkgs versions are resolved with v1.10.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022:164,depend,dependencies,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022,1,['depend'],['dependencies']
Integrability,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:35,interface,interfaces,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470,4,"['integrat', 'interface']","['integrated', 'interface', 'interfaces']"
Integrability,"> Can spatial units be set?. Spatial attributes can be set but Oceananigans.jl assumes meters right now so more unit misattribution. If the time units can be set, then we should be able to set the spatial units. > Are packages like Unitful.jl not mature enough to be used for these purposes? I understand this is a pretty extreme solution for this problem specifically, but It would be pretty cool if Oceananigans could understand units. I think it's mature enough but not I guess we're not sure where to use it (we discussed a bit in #1116). Would be perfect for specifying these kinds of units as long as it's not a heavy dependency. For other simulations, e.g. icy moons, it's nice to use rotation periods. Another place where units are assumed is `prettytime` so the `Simulation` always thinks your units are SI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502:624,depend,dependency,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502,1,['depend'],['dependency']
Integrability,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:9,wrap,wrap,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984,1,['wrap'],['wrap']
Integrability,"> Can you help me figure out what we are using as a reconstruction?. For the velocity field or tracer?. For the tracer it depends on the advection scheme. For the velocity field, I think our method is consistent with either a constant or linear reconstruction. I'm not sure about higher. Not that if we use a different reconstruction for computing tracer fluxes, we'd have to use the same reconstruction for calculating the divergence of the velocity field so that they are consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792:122,depend,depends,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792,1,['depend'],['depends']
Integrability,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:919,depend,depending,919,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939,1,['depend'],['depending']
Integrability,> Can you point me to where in the code this goes down?. It happens in this halo fill:. https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20. after the tendency integration but before the pressure correction,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522:257,integrat,integration,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522,1,['integrat'],['integration']
Integrability,"> Can you use mean on a view into the parent array on the GPU?. Unfortunately no. It's still a non-contiguous view. ```julia; julia> using Statistics, CuArrays; C = rand(128, 128, 128) |> CuArray; @time CuArrays.@sync mean(C, dims=[1, 2]);; 0.000575 seconds (221 allocations: 8.797 KiB). julia> using Statistics, CuArrays; C = rand(128, 128, 128) |> CuArray; @time CuArrays.@sync mean(view(C, 2:127, 2:127, 2:127), dims=[1, 2]);; 18.857220 seconds (10.15 M allocations: 342.416 MiB, 1.11% gc time); ```. A 33,000x slow down lol. > Note also that due to our current convention for fields and indexing, the “correct” horizontal average depends on both the field type and the boundary conditions. Ah good point, that would complicate things...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519600896:634,depend,depends,634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519600896,1,['depend'],['depends']
Integrability,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:353,rout,route,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,3,"['interface', 'rout']","['interface', 'route']"
Integrability,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:205,integrat,integration,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027,1,['integrat'],['integration']
Integrability,"> Changing `force` to `mode` seems totally fine. Agreed. > I think the main issue is to figure out how to merge the interface. JLD2 supports file ""splitting"" which is why a `prefix` and `dir` makes more sense than specifying the whole filepath. We could try to infer `prefix` and `dir` from a `filepath` too, just need to decide if we are ok that users write `filepath` but then the files end up in different places (because of the file splitting). Personally I think it probably makes more sense to change `NetCDF` to take the file `prefix` and `dir` separately than the whole `filepath`. I also think using `dir` and `prefix` is easier than asking for `filepath` and then trying to split it behind the scenes for the JLD2 writer. Here's what I would do as a unified interface:. - `dir`; - `filename`. I think we should use `filename` and not `prefix` since it's more descriptive. Also it gives the opportunity for user to use different extensions which they might want.; - `mode`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1029529033:116,interface,interface,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1029529033,2,['interface'],['interface']
Integrability,"> Comparing the `model.clock.time` seems to be a good solution since RK3 `tick!` increases the stage and `model.clock.time`.; > ; > I'm just curious why `FieldStatus` is required as it's just a container/wrapper around a `Float64`. Couldn't you dispatch on `::Number` and `::Nothing` instead of `::FieldStatus` and `::Nothing`?. I couldn't do that because that would require making `AveragedField` a `mutable struct` (for example), which cannot be used directly on the GPU. The adapt method for `FieldStatus` (which is mutable) returns a `NamedTuple` (similar to `Clock`). I think that's right...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698425183:204,wrap,wrapper,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698425183,1,['wrap'],['wrapper']
Integrability,> Could also switch the Plots.jl backend to use PyPlot then maybe vmin and vmax (or the Plots.jl equivalent) will work correctly?. We would need to add `PyPlot` as a dependency for that to work.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1107#issuecomment-717569694:166,depend,dependency,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1107#issuecomment-717569694,1,['depend'],['dependency']
Integrability,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:696,interface,interface,696,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324,1,['interface'],['interface']
Integrability,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:2,Depend,Depends,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731,2,"['Depend', 'interface']","['Depends', 'interface']"
Integrability,"> Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:296,depend,depends,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561,1,['depend'],['depends']
Integrability,> Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point?. > > Can you point me to where in the code this goes down?; > ; > It happens in this halo fill:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20; > ; > after the tendency integration but before the pressure correction. Where is the halo filling code?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421:387,integrat,integration,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421,1,['integrat'],['integration']
Integrability,"> Do you think this will be ready to merge soon-ish?. Yes I think so. . The main clarifications here are that. 1. The concept of 'buoyancy' is on solid ground for any equation of state, provided we are within the Boussinesq approximation. 2. The dynamic component of the buoyancy gradient (the squared buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:400,contract,contraction,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['contract'],['contraction']
Integrability,"> Do you want to contribute an advection scheme to Oceananigans? A lot of people might benefit from having the kind of advection scheme that you are using! It may not be very much work, since we have an interface for adding new advection schemes. Sure! I'll submit a PR soon. > Do you evolve the tracer fully outside of the `Oceananigans` infrastructure? . Yes, it's fully outside of `Oceananigans`. I just use the velocities from `Oceananigans`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694262045:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694262045,1,['interface'],['interface']
Integrability,"> Does anybody know what is the rationale for `similar(::Field)` to drop the boundary conditions?. I think it depends on how you view ""boundary conditions"". If we adopt a ""weak formulation philosophy"" then boundary conditions are part of the definition of an equation set and don't belong to fields at all. This is how `ImmersedBoundaryGrid` works; inhomogeneous boundary conditions can only be enforced by adding boundary fluxes to a tendency. There's no such thing as a ""boundary condition"" outside the context of time stepping. Unfortunately, `Oceananigans` is not consistent in how this philosophy is applied and when we are on ""non-immersed"" grids we have more of a ""strong formulation"" philosophy. I believe the rationale for not transferring boundary conditions is the expectation that we will eventually adopt a ""weak formulation philosophy"" consistently throughout the code. In that case, non-default boundary conditions are meaningless on anything but prognostic fields that are evolved during time-stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487:110,depend,depends,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487,1,['depend'],['depends']
Integrability,"> Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact. Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854:274,integrat,integrated,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854,2,"['bridg', 'integrat']","['bridge', 'integrated']"
Integrability,"> Does it make more sense for Open to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set OpenBoundaryCondition(nothing) unless a user sets something else. This choice should not merely be a question about user interface / convenience but also about how the code internals work. . One problem is that the topology refers to both sides. We want to support domains that are, for example, bounded on the west but open on the east. We do have an abstraction called `RightConnected` for distributed cases. Possibly, we can implement topologies that represent doubly open and single-sided open. But to motivate such an abstraction, I think this needs to have implications on the grid level --- not just a way to generate boundary conditions conveniently. I think there are other solutions for generating boundary conditions conveniently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965123859:288,interface,interface,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965123859,1,['interface'],['interface']
Integrability,"> Does the magnitude of the velocity error scale with the time-step, or resolution? Perhaps plotting the dependence of the error on some of those parameters can give us confidence that the method is working as expected.; > ; So far I've run two different grid sizes, but I've been changing the time step with the grid size for stability, so I'm not sure. I mean the grid spacing will make it more accurate, so it probably does a better job, but I think the pressure correction is so close to the velocities we're seeing that the time step within the pressure correction has to play a big role. > Victoria, is the velocity normal to the cylinder zero? and perhaps the tangential component too, if you are using no-slip boundary conditions. I have a nice application of all this if you are going in 3-d. John; > […](#). The velocity roughly normal to the cylinder at the top (0-180 degrees) is close to zero. I'm not sure if my normal velocity calculation is off, but the bottom half of the cylinder is showing a lot more variation. ; ![Vnorm_onCylinder](https://user-images.githubusercontent.com/67593861/101094135-ea24bd00-3589-11eb-88e4-bfe756fc6969.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738346186:105,depend,dependence,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738346186,1,['depend'],['dependence']
Integrability,"> Does the magnitude of the velocity error scale with the time-step, or resolution?. I think the expected behavior is that the velocity error in the object scales with the non-hydrostatic pressure gradient times the timestep of the Runge-Kutta substep. Presumably the non-hydrostatic pressure gradient in the object scales as the non-hydrostatic pressure over the length scale of the object. If the strength of the non-hydrostatic pressure field on the object of the boundary is a function of the outer-flow and object configuration, then I don't think grid refinement will help much. We should do a more rigorous validation of this at some point, but at least the dependence on the timestep gives a way to control the velocity error. I also suspect the pattern of the normal velocities in the plot shown may be spurious, as we know the velocity gets very small in all 'solid' nodes fully inside the object. The apparent error on the boundary as a function of angle may have to do with the how the current first-pass implementation sets the solid boundary location on the c-grid. . @christophernhill thanks very much for the offer! It will be good to take you up on that down the line, but let @whitleyv and I do a bit of digging first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012:665,depend,dependence,665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012,1,['depend'],['dependence']
Integrability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:460,depend,depend,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,2,['depend'],['depend']
Integrability,> Error message:. Huh. What's the type of `vz_op`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996:8,message,message,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996,1,['message'],['message']
Integrability,"> Expose the parallelism in RungeKutta3 timestepper and in the update_state! method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in @apply_regionally. This is not strictly necessary right? Just if we want to also support RungeKutta3.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032:241,wrap,wrapping,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032,1,['wrap'],['wrapping']
Integrability,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:221,depend,dependency,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010,1,['depend'],['dependency']
Integrability,"> For the record, I did try this yesterday with FlatExtrapolationOpenBCs and it also blew-up. Ok great. How about the same problem (including CG pressure solver) but no immersed boundaries?. Something to keep an eye on is the number of iterations the CG solver does. It'd be good to report what is going on with those during / prior to breakup. You can call `iteration(model.pressure_solver)` to diagnose it (where it will correspond to the previous solve). > interestingly, when I run your exact example things take a little longer to blow up. This is important; the dependence on time step should be diagnosed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2408115770:568,depend,dependence,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2408115770,1,['depend'],['dependence']
Integrability,"> Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different; target arch. Right --- we can use a wrapper that redefines `getindex` (and potentially also is associated with a certain loop ordering). Looks like there's a julia type that does this:. https://github.com/JuliaLang/julia/blob/master/base/permuteddimsarray.jl. I doubt it would be very hard to figure out how to abstract away loop ordering so it can be flexibly changed for a target architecture. One question still remains: which is the most intuitive convention for `getindex` calls? I personally like `i, j, k` for `x, y, z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865:188,wrap,wrapper,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865,1,['wrap'],['wrapper']
Integrability,"> Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. It's a very breaking change!. > Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though. This PR doesn't remove `StateChecker`, it just stops exporting it. > I use it in almost every script I write haha, but that's because I wrote it to my liking. Touche, but none of the examples use it so it isn't very visible. I'm not even quite sure what the application is, which might be part of the issue? Anyways the point is not to remove this functionality but just not stop exporting it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194:107,interface,interface,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194,1,['interface'],['interface']
Integrability,"> Gregg, Ali, can we get variable delz in at the same time? John. I'm happy to start working on that in October. I think we should reverse the k-index first, because I think at least part of the variable delz algorithm will depend on the direction of `k`. @ali-ramadhan on `buoyancy` versus `buoyancy_perturbation` --- since this is an internal issue (not part of the API), I'm fine to stick with `buoyancy_perturbation` for now and continue to discuss what the best nomenclature is after this PR is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533099629:224,depend,depend,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533099629,1,['depend'],['depend']
Integrability,"> Having said that, you could setup CI to run a few time steps and compare the output with blessed output - this is what MITgcm does for its CI tests. Indeed --- the test of the [Golden Master](https://en.wikipedia.org/wiki/Characterization_test)! That sounds like an excellent idea for `Oceananigans.jl`. No master is more golden than MITgcm. > This might work, but you'll need to decide how closely it should match. You definitely won't get machine precision matches - we can't even do that with different MITgcm runs. The output from MITgcm depends on the machine, the compiler, and the optimisation level. Touche. I was naive.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467624611:544,depend,depends,544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467624611,1,['depend'],['depends']
Integrability,"> Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package? There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it). Hi @simone-silvestri, `cg` is not too hard to implement, so I don't think we will see a significant performance improvement on CPU. ; However, for other methods like `gmres`, `Krylov.jl` easily outperforms `IterativeSolvers.jl`.; On GPU, though, we might see a difference because I try to dispatch to the BLAS/LAPACK routines of the GPU vendors as much as possible, whereas `IterativeSolvers.jl` relies on some broadcast. Also, to the best of my knowledge, only `cg` works on (NVIDIA) GPUs for `IterativeSolvers.jl`, while all solvers in `Krylov.jl` work on the GPUs of any vendor. I'll try to run some benchmarks before the end of the week.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041:584,rout,routines,584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041,1,['rout'],['routines']
Integrability,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:485,interface,interface,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413,3,['interface'],['interface']
Integrability,"> Hi, is there a reason why this isn't in the official examples?. Is it ready? This comment suggests it's not:. > This PR in a work-in-progress and depends on #1091. I still need to make it Literate. Perhaps @ali-ramadhan wouldn't mind some help though. It's probably stale right now and would need a merge master and update.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915:148,depend,depends,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915,1,['depend'],['depends']
Integrability,"> Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose.; > ; > I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with... I definitely see your point. But if that's true, then I think there's a deeper problem here which is that neither the validation scripts nor the benchmarks are kept up to date. (The benchmarks on the docs right now are done with v0.34.0!). I actually tried discussing this in https://github.com/CliMA/Oceananigans.jl/issues/1634, and even proposed a solution that should work. I think we have three options:. - We adopt the opinion that even though it's not ideal because it's out-of-date, we keep the validation experiments since they are cool set-ups that show that our code worked in the past (and supposedly should still be working now, although without proof); - We adopt the opinion that if it's not up-to-date, it's not desired. So we nuke the benchmarks and the validation experiments altogether; - We try to fix this issue and keep the validation experiments and benchmarks up-to-date. You [seem to agree](https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832203095) that creating a separate repo for validation and relying on `CompatHelper` to automatically create PRs would work. I'd be happy to help implementing that, but I don't have access to a server with GPUs that I set-up the CI for (or enough knowledge of the CI tbh). Any one of those 3 options would work for me, but I think it would be good to make an explicit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477:64,depend,depend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477,1,['depend'],['depend']
Integrability,"> Hmmm, I don't know if many log levels will be that helpful. I'm not entirely sure either. It's worth considering whether the standard `Info` and `Debug` levels might be enough for some of your uses, but there's also nothing wrong with trying out some custom levels and removing them if they don't end up making sense. For general logging I've often wondered whether it would be helpful to have a `Notice` level with severity between `Info` and `Warn` to allow informational messages to be stratified into two groups, though we would need clear guidelines for how to use it. Likewise, to have a `Debug2` or `VerboseDebug` level for ""really verbose"" debugging messages (possibly compiled out by default, though that would need a minor tweak in Base to make it possible). > but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. This is basically what the standard `Info` level printing does in `Logging.ConsoleLogger` - it just ignores the line and file info captured by the fontend to simplify the pretty printing of the message. Btw, the pretty printing of log events can be separate from the storage format if desired. For example we could serialize log records to a binary file (including all file,line information etc) but have a tool to pretty print them with extra filtering, replay the messages from a simulation in faster than real time etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159:476,message,messages,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159,5,['message'],"['message', 'messages']"
Integrability,"> Hmmm, yeah I guess model.parameters may be useful in boundary conditions (possibly elsewhere too). To make `model.parameters` fully obsolete, we would need wrappers / interfaces for boundary conditions; eg. ```julia; bc = SimpleBoundaryCondition(Flux, (x, y, t, parameters) -> something, parameters=parameters); ```. Not suggesting we do it now, but something to think about for the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-540062839:158,wrap,wrappers,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-540062839,2,"['interface', 'wrap']","['interfaces', 'wrappers']"
Integrability,"> Honestly I think this is already pretty handy and enforces the idea that in order to compute something it needs to be a field. Hmm, I think the key concept here is that in order to _store_ the result of a computation, we need to allocate memory. That's what invoking `Field` does. It's worth mentioning for posterity the subtlety that calling `compute!` does have an affect on abstract operation, because it triggers the computation of all the leaves. So if an AbstractOperation depends on a field that needs to be computed, calling `compute!` on the abstract operation will cause that child field to get computed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718:481,depend,depends,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718,1,['depend'],['depends']
Integrability,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200:620,message,message,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200,1,['message'],['message']
Integrability,"> How is this possible with a periodic solution?. Maybe I'm missing something, but I can't imagine how that would _not_ happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257:194,message,message,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257,1,['message'],['message']
Integrability,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:110,interface,interface,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980,3,['interface'],"['interface', 'interfaces']"
Integrability,"> I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction.; > ; > ; > ; > ```; > ; > Immersed Fluid; > ; > ----------- ...........; > ; > | ∘ | ∘; > ; > f c f c; > ; > k-1 k-1 k k; > ; > ```; > ; > My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The question is where bottom_height lies in these diagrams. GridFittedBottom is not a limiting case of PartialCellBottom in the way we have coded it, because GridFittedBottom uses the cell center to determine whether the cell is immersed or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605:558,interface,interface,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605,1,['interface'],['interface']
Integrability,"> I am not sure about the purpose of this PR. What is the reason we do not want to calculate the periphery in the nonhydrostatic model tendencies?; > ; > If there is a specific reason, does this solution also apply to immersed boundaries with active cell map? It seems like nothing changed for that case. Because some open boundary conditions integrate an alternative PDE on the boundaries (eg for radiation conditions). In other words the algorithm we are using is only valid for simple open boundary conditions (we designed it for impenetrable condition). More generally, the algorithm is wrong. There are two other benefits. First, we do not use the tendencies on the periphery. So this increases the clarity of the code. Previously, it might not be obvious that even though we compute tendencies on the boundary, we overwrite the field values in `fill_halo_regions!`. It saves a little bit of computation as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988:343,integrat,integrate,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988,1,['integrat'],['integrate']
Integrability,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:535,depend,dependent,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['depend'],['dependent']
Integrability,"> I am thinking about the ease of use in bc, for example; > ; > ```julia; > @inline time_interpolated_bc(i, j, grid, clock, fields, p) = p.time_array[i, j, 1, clock]; > ```; > ; > vs; > ; > ```julia; > @inline function time_interpolated_bc(i, j, grid, clock, fields, p) ; > time = Time(clock); > return p.time_array[i, j, 1, time]; > end; > ```; > ; > I find the first implementation a bit more straightforward, but we can also have both. I propose we prioritize the user interface rather than the source code implementation, which basically has to be written once then left alone",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206:472,interface,interface,472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206,1,['interface'],['interface']
Integrability,"> I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. . Ok, after changing from `IterationInterval` to `TimeInterval` in the 1D diffusion example ([source](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl)), I am able to reproduce the same problem now. . Here is the progress message after picking up the checkpoint:; <img width=""580"" alt=""image"" src=""https://github.com/user-attachments/assets/9ef385f4-b53d-4954-97f9-54656420c232"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596:423,message,message,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596,1,['message'],['message']
Integrability,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142:959,depend,depends,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142,1,['depend'],['depends']
Integrability,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:906,depend,depend,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685,2,['depend'],['depend']
Integrability,"> I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up. I'm actually not sure. All that `NonTraditionalFPlane` does is to tilt the rotation axis of an f-plane based on latitude. So it just projects some component of `f` onto the `y` direction. `GeneralFPlane` (or whatever we end up calling it) can tilt the rotation axis in any arbitrary direction, so it can already do what `NonTraditionalFPlane` does (and more). So really (imho) I don't see much use for `NonTraditionalFPlane` after this gets implemented, except maybe as a convenience function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285:113,depend,depends,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285,1,['depend'],['depends']
Integrability,"> I can prob code this myself, but from this issue it seemed like people were interested... I think this would be a great feature to have in Oceananigans!. I'd be happy to pair program with you @Mikejmnez to help you get started if you like. Feel free to message me on the julia slack (Oceananigans channel is at https://julialang.slack.com/archives/C01D24C0CAH).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768618886:255,message,message,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768618886,1,['message'],['message']
Integrability,"> I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:; >; > Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. I agree that far from the wall there is a clear trend. But I'm not sure that's a fair way to look at it. > But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps. That said, good point that the coefficient doesn't necessarily translate into the eddy viscosity. I'll check the eddy viscosity later and see what comes up as I am now curious :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803:209,depend,dependence,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803,1,['depend'],['dependence']
Integrability,"> I don't have very much to offer, but I believe that compiler behavior / execution can differ on different machines due to difference in underlying packages and compiler dependencies, even when the julia packages are identical. Yeah, I thought so too, but even using the pre-compiled binaries doesn't seem to fix this so idk anymore... > It'll be nice if upgrading to 1.6 (#1514) solves this. I have high hopes that it will!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828451928:171,depend,dependencies,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828451928,1,['depend'],['dependencies']
Integrability,"> I don't think it matters that the full cubed sphere is Periodic. I think the topology is somewhat undefined especially since the i or ""x""-direction doesn't point in any particular dimension. Right, I guess I am thinking of a domain consisting of two connected grids in which the whole domain is bounded. It seems that if `Connected` behaved exactly as `Periodic` then we would have no need for a new type. (I think you understand this and imply it in your text, but I just want to be clear that the only reason `const Connected = Periodic` works is because we are considering a case in which the grids ""wrap around"", and thus having every grid behave like `Periodic` is valid).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371:605,wrap,wrap,605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371,1,['wrap'],['wrap']
Integrability,"> I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`. Ah, I didn't realize this was specifically a Mac M1 issue. I think we'll continue to get issues and questions about this error if we don't do something about it (and its very inconvenient for this important subset of users). What's the best way to solve this problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418:41,depend,dependency,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418,1,['depend'],['dependency']
Integrability,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:111,rout,routines,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038,3,['rout'],['routines']
Integrability,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:106,depend,depend,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027,1,['depend'],['depend']
Integrability,"> I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?. Yeah I don't have much experience with scaling MPI but I'm guessing single-node scaling depends on your software while multi-node scaling depends more on the cluster/hardware?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413:313,depend,depends,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413,2,['depend'],['depends']
Integrability,"> I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it.; > ; > Does this make sense to everyone? I also can't see an obvious way to get Δt to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. To clarify, the statement ""when U_b is negative"" means more generally ""when U_b implies inflow into the domain"". It makes sense to me that inflow is prescribed, whereas outflow is a little tricker, requiring us to smoothly advect information out of the domain. Having the boundary condition depend on the previous time-step does seem to break assumptions we have made about how information flows. For example, we call `update_state!` during model construction. How does the first time-step / initialization work with this kind of outflow model? It might help to consider that. Practically speaking it would not be hard to pass the time-step to update state. But it might be nice to understand the implications before committing, because a different design / redesign could make sense. For example I supposed we would need to have a default ""time step"" that is 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289:1167,depend,depend,1167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289,1,['depend'],['depend']
Integrability,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:370,depend,depends,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980,1,['depend'],['depends']
Integrability,"> I haven't gone through everything but I get the feeling that there is a lot of leftover docstrings/docs that are related to the previous default T, S option. Am I right? We should have T, S where is needed for the demonstration, not just have it everywhere because it's a leftover from before.; > ; > I don't. @navidcy Thanks for the review! I think your message got a little cut in the end. But I totally agree. I have modified these instances where I identified them (for example in model_setup/tracers.md), but a busy schedule kept me from doing a more thorough search for occasions where these happen. I'll fix the ones you found and look for some more!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993:357,message,message,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993,1,['message'],['message']
Integrability,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:232,depend,dependent,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103,1,['depend'],['dependent']
Integrability,"> I like it! I changed the NonhydrostaticModel to be the same.; > ; > A way to facilitate users is that we leave the option to specify a global `advection` (so that we keep the keyword) or two separate `momentum_advection` and `tracer_advection`. I would rather just change it to be consistent with the HydrostaticFreeSurfaceModel directly.; > ; > what do you guys think?. I think we should do that in a different PR because it's a major, major breaking change to the most popular model!. As for the syntax I'd prefer --- I would prefer one keyword argument `advection`. We need that for the changes proposed in #2454 --- because the schemes for different components can depend on one another. So it's easier to put it in one object. I also feel it's better to just specify `grid` once to the `advection` constructor. But that would be harder to implement now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720:671,depend,depend,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720,1,['depend'],['depend']
Integrability,"> I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. By the way, this is available in stdlib `Logging.ConsoleLogger`, but it's hidden behind the `right_justify` keyword and I'm not sure anyone uses it! I had a long debate about this when putting this code into Base, which I lost ;-) (TBH I'm happy with the outcome because having people copy and paste log messages which are right-justified to a particular terminal width would have led to rather a mess.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544768913:112,message,messages,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544768913,2,['message'],['messages']
Integrability,"> I propose handling this by initializing output files within `run!` rather than during instantiation of the output writer. This is separate from the interface discussion here though. Ok, I see. I agree that that discussion can be left to the other PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391887025:150,interface,interface,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391887025,1,['interface'],['interface']
Integrability,"> I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth. Ok, that makes sense, so `d = depth(i, j, k)` is 3D. What about `column_depth(i, j)`? Just want to have a discussion about it rather than simply deciding. Any other ideas besides ""column"", ""domain"", and ""total""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844:80,interface,interface,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844,1,['interface'],['interface']
Integrability,"> I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. NetCDFOutputWriter, JLD2OutputWriter. If you are referring to #3793 my intent is just to introduce an additional wrapper on top of the existing writers. It's merely an alternative to adding output writers manually to `simulation.output_writers`, which I find inelegant. > I believe it will be simple to change by only executting the initialize_nc_file! and initialize_jld2_file! once the model is running, instead of two times, once the writers are initialised and in run time (write_output!). I agree that it's simple to design. > Despite the implementation of this, I still see value in having a flag overwrite_existing, likely set up to false as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. Why would it result in (unintended) data loss? Because its common to mistakenly re-run a simulation? . > Regarding my changes in this PR, the function is_output_splitted! may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function. Okay, I'll take a look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954:98,wrap,wrapper,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954,3,"['depend', 'wrap']","['depending', 'wrapper']"
Integrability,"> I see, I think having an open boundary does necessarily have grid level implications because every tracer needs to have some open boundary specified if the grid has an open boundary right?. What are those implications?. For example, `Periodic` implies that there is one fewer interface for `Face` fields in that direction. As a result, `Periodic` direction changes the way that a grid needs to be constructed. This is what I mean by ""grid-level implication"". What's the difference between `Open` and `Bounded` in terms of data layout? It seems to me that `Open` is a boundary condition rather than dictating a different data layout. For example, would the different topology change the way that we construct the grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1967469013:278,interface,interface,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1967469013,1,['interface'],['interface']
Integrability,"> I see. My aversion to putting something like this in the condition is that we would have to make a lot of changes to allow users to specify the external state, because if we just have the condition like all of the other boundary types then we don't have todo anything for the user to be able to put in anything as the external state.; > ; > We could change `Open` to be:; > ; > ```julia; > @kwdef struct Open{MS} <: AbstractBoundaryConditionClassification; > matching_scheme :: MS = nothing; > end; > ```; > ; > then by default this behaves exactly as it does now, but we could add `_fill_halo_...` methods for different matching schemes. For example if a user want to specify an external state: `OpenBoundaryCondition(1)`, or if they want to use a matching scheme `BoundaryCondition(Open(SomeMatchingScheme()), 1)` or we could make a utility like `SomeMatchingSchemeBoundaryCondition(val)` which returns `BoundaryCondition(Open{SomeMatchingScheme}, val)`. I like the examples you provide, but need to clarify that this discussion has no effect at all on existing code. Adding a new `condition` that is specific to `Open` does not stop us from also using `OpenBoundaryCondition(1)`. To emphasize --- we are talking about how information is organized under the hood. We are not talking about the user interface. For the user interface, I suggest the following syntax:. ```julia; OpenBoundaryCondition(nothing) # impenetrable; OpenBoundaryCondition(1) # external state = 1, no matching scheme; OpenBoundaryCondition(external_state, matching_scheme) # explicit matching scheme; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986426328:1302,interface,interface,1302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986426328,2,['interface'],['interface']
Integrability,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:489,depend,dependent,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,2,['depend'],['dependent']
Integrability,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:175,message,message,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255,1,['message'],['message']
Integrability,"> I suggest we wait on this for the time being. We are in discussions to start a formal collaboration to develop the ocean biogeochemistry component of the CliMA model. We need to plan our strategy with the new collaborators who will join us. It will happen soon and we can then have a discussion with all people involved on what is the best strategy moving forward. I agree, this issue is for planning purposes, but there's no timeline for setting up a new package. I think the package itself is easy, but designing the interface that allows different ""biogeochemical models"" to plug in to Oceananigans will require a bit more care. On the Oceananigans side, it seems like some necessary features of a `biogeochemistry` interface are. * User-specified `biogeochemistry` model ""automatically"" adds the tracers it needs in the model constructor (does not require user to explicitly specify tracers): `model_tracers = add_biogeochemical_tracers(biogeochemistry, user_tracers)`.; * There's a ""biogeochemical tendency"" term in the tracer equations that's controlled by `model.biogeochemistry` type.; * There's an interface in `update_state!(model)` like `update_biogeochemical_state!(model.biogeochemistry, model)` so that biogeochemistry models can precompute a state (eg cumulative integrals to determine light penetration) when needed. Perhaps further consultation will produce additional requirements. One big one that I see is for chemistry models that require subcycling or special numerical methods for time-stepping (ie stiff carbonate chemistry systems as in [Smith et al 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001486)). Supporting those cases will be more challenging. I think our Lagrangian particles already (or are intended to) support dynamics-on-particles so there may not be much to do there on the Oceananigans side.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691:521,interface,interface,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691,3,['interface'],['interface']
Integrability,"> I think it is good to use it in hydrostatic simulations where the aspect ratio is very high (for example drag on the sides should not be equal to drag on the bottom). Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703:242,depend,depend,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703,1,['depend'],['depend']
Integrability,> I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit. To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU? That's why I didn't originally go down the route of making the velocity explicitly part of the boundary condition.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869,2,"['interface', 'rout']","['interface', 'route']"
Integrability,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:889,integrat,integration,889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887,4,"['depend', 'integrat']","['depends', 'integration']"
Integrability,"> I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. It's definitely possible, but I think this isn't the example to do that. Since it's a tilted boundary layer, there's some extra complexity in the TKE budget. It's not a technical obstacle of anything, but it would require more explanation. I think the ocean convection example would be a much better option for a TKE budget.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752:262,integrat,integrated,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752,1,['integrat'],['integrated']
Integrability,"> I think its a fine idea to merge, though it is interesting that the code will still be called Oceananigans :-D. > Agree we need another name, perhaps a variant of shenanigans. True. The window of opportunity to change names is closing though. It might not be good to change package name after the JOSS paper comes out. I'm open to a name change if we can all agree on a new name. > I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. Right. But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. But in JULES.jl, if you want to add a potential temperature perturbation and modify θ you need to modify both the density ρ and the ρθ field. [Example:](https://github.com/thabbott/JULES.jl/blob/beec6727eef83343dd1adac8834f1545994098e2/verification/dry_rising_thermal_bubble/dry_rising_thermal_bubble.jl#L91-L95). ```julia; θ = Θ[i, 1, k] / ρ[i, 1, k] + θ′(xC[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:546,depend,depend,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['depend'],['depend']
Integrability,"> I think overwrite_existing = false could be the default. Seems to me that users could easily add the overwrite_existing = true in their script if they know they are experimenting with something and don't wanna be deleting the output every time. So, `overwrite_existing=false` is the current default. I don't dispute that it's ""easy"" to add `overwrite_existing=true`, but I don't think we should design the interface only up to the point where ""easy"" changes close the gap between the default and what users want to do, most of the time. I think the default should legitimately be useful. I think that `overwrite_existing=false` is rarely desirable -- users only want this when they run big, expensive simulations. I would say that it's almost impossible to set up a big, expensive simulation without going through some prototyping phase first. Moreover, prototyping consumes much more human time than big, expensive simulations. Therefore `overwrite_existing=true` is the correct default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433125490:408,interface,interface,408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433125490,1,['interface'],['interface']
Integrability,"> I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!; > ; > ```julia; > julia> using Oceananigans, Test; > Precompiling Oceananigans; > 1 dependency successfully precompiled in 11 seconds. 129 already precompiled.; > ; > julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); > 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; > ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; > └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5; > ; > julia> closure = ""not a closure""; > ""not a closure""; > ; > julia> NonhydrostaticModel(; grid, closure); > ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String); > ; > Closest candidates are:; > with_tracers(::Any, ::Nothing, Any...; kwargs...); > @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; > with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; > with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; > ...; > ; > Stacktrace:; > [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266:80,message,message,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:85,depend,depends,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978,3,['depend'],"['dependencies', 'depends']"
Integrability,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502:848,depend,depends,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502,1,['depend'],['depends']
Integrability,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:46,interface,interface,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891,3,"['integrat', 'interface']","['integrated', 'interface']"
Integrability,"> I think we need an required_biogeochemical_auxiliary_fields like required_biogeochemical_tracers because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field). Should the user specify this, or should the biogeochemical model add it its struct (taking in `grid` for this purpose) and evaluate it during `update_biogeochemical_state`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310889513:298,depend,dependence,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310889513,2,"['depend', 'integrat']","['dependence', 'integrating']"
Integrability,"> I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code. I will try (feel free to edit):. The use cases we want to add support for is advection of user specified values into the domain (in a ""soft"" way, i.e. not directly specifying incase the interior solution has diverged from the boundary specified solution), we also want to be able to advect information out of the interior domain. . We want to be able todo this with both user specified bulk velocities as well as velocities that depend on the wall normal velocity and possibly wall normal acceleration (some also consider oblique waves but from what I have read it doesn't help that much). The calculated bulk velocities might be the different at every point (i.e. computed within the fill kernel), but may also (often) be the same at every point on the boundary so should be computed before the fill kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760:562,depend,depend,562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760,1,['depend'],['depend']
Integrability,"> I think we should find a general solution to adding citations in docs, rather than attempting to avoid it. Can we define a macro that transforms a citation into a footnote? Then we can include this macro at the top of a documentation file that needs citations. I think that raising an issue with Documenter is a good idea for this. In general we should be comfortable with driving improvements to packages that we depend on rather than hacking inelegant solutions (a last resort). I think @charleskawczynski is also interested in this problem, we can try discussing on Slack. It might not be too hard if we can reuse some existing pieces:. There was an attempt back in 2017 to add a `bibtex` option to `makedocs` that allowed citations with `[<label>](@ref)`: https://github.com/JuliaDocs/Documenter.jl/issues/379#issuecomment-292157714. But it had to use the Python package `pybtex` to parse bibtex files. But since then there's been a native Julia version: https://github.com/JuliaTeX/BibTeX.jl. So maybe if we can get that `bibtex` option to work with BibTeX.jl then we can pretty easily have citations in Documenter?. I'll open an issue on Documenter.jl to see if it's possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474#issuecomment-543170619:416,depend,depend,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474#issuecomment-543170619,1,['depend'],['depend']
Integrability,"> I think wrapping `Base.Broadcast.materialize!` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24; > ; > around `@apply_regionally` for multi region fields might do the job. Or we can extend `materialize!(dest::MultiRegionField, ...)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485:10,wrap,wrapping,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485,1,['wrap'],['wrapping']
Integrability,"> I think you can define in `ImmerdsedBoundaries`; > ; > ```; > return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); > ```; > ; > and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings) ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment). Good point!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847:225,depend,depend,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847,1,['depend'],['depend']
Integrability,"> I wanted to flag for @glwagner and @ali-ramadhan the issue that the above changes to the pressure solver would impact issue #1036, which relies on the decomposition of pressure into hydrostatic and non-hydrostatic components. I'm not sure how big an issue this would be, but good to be aware. As far as I can tell there is no impact of tilting on the pressure solver. For example, one clean algorithm would introduce three buoyancy contributions `x_dot_g_b`, `y_dot_g_b` and `z_dot_g_b` in the three momentum equations, and then solve for non-hydrostatic pressure (which is independent of the direction of gravity). In the current algorithm, we treat buoyancy as special and, rather than adding its contribution to the ""vertical"" momentum equation, we integrate it in ""z"" and then add the _horizontal_ derivatives of that quantity to the _horizontal_ momentum equations. But if we don't make the hydrostatic approximation specifically, then there's nothing special about ""z"" and we could do the same procedure for any of the terms on the RHS of the momentum equation... ?. So, if we tilt the domain, I think we can keep the current pressure decomposition, provided that we correctly project the buoyant acceleration into the tilted coordinate system. A valid criticism is that the algorithm is unnecessary convoluted, of course, which I agree with... > If you rotate gravity, you likely also want to allow the planetary rotation vector to also be rotated. We currently support this: https://clima.github.io/OceananigansDocumentation/latest/model_setup/coriolis/#Non-traditional-f-plane. But it's a good point that we may want a cleaner abstraction. The problem here is really just terminology (or if one wants to tilt their domain in x rather than y). Long ago I argued that we shouldn't use the word `FPlane` et al, but rather just implement a general abstraction for ""background rotation"" of the reference frame of the solution. It might make sense to have this now...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-737375395:754,integrat,integrate,754,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-737375395,1,['integrat'],['integrate']
Integrability,"> I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799:124,depend,depending,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799,1,['depend'],['depending']
Integrability,"> I wonder if it's better to define abstract types like Uniform or Regular for dimensions with uniform grid spacing and Stretched or NonUniform for non-uniform grid spacing. What information do you need for a stretched grid? Is this just a matter of `Δx` becoming a `Function / Array` rather than a number?. In that case we just have `CartesianGrid`, and dispatch occurs on the type of `Δx` for each dimension individually. Edit: may be best to save this change until we have a stretched grid. We haven't really discussed how we'd construct stretched grids, but our design may depend on that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541322605:577,depend,depend,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541322605,1,['depend'],['depend']
Integrability,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:1608,message,message,1608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144,1,['message'],['message']
Integrability,"> I'm not really sure how to fix this one... Not sure if I completely understand what's happening since I am not super familiar with the `NetCDFOutputWriter`, but it looks to me like an implementation of `define_output_variable` has been provided for `WindowedSpatialAverage`, but not for the case when `WindowedSpatialAverage` is wrapped inside a `WindowedTimeAverage` (in which case the type of the output is `::WindowedTimeAverage{<:WindowedSpatialAverage}` as written in the error message above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525:331,wrap,wrapped,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525,2,"['message', 'wrap']","['message', 'wrapped']"
Integrability,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:243,depend,dependency,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,6,"['depend', 'synchroniz']","['dependency', 'synchronization', 'synchronizations', 'synchronize', 'synchronizing']"
Integrability,"> I'm not sure that the corner points are used in the prognostic calculations right?. It depends on the physics. You should check for coriolis, VectorInvariant advection, and biharmonic viscosities. I suspect the corners come into play for those. > Do you mind pointing me in the right direction?. Check out `Oceananigans.Utils.KernelParameters` and use this when launching the kernel that fills the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2439771342:89,depend,depends,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2439771342,1,['depend'],['depends']
Integrability,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:920,integrat,integrate,920,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['integrat'],['integrate']
Integrability,"> I'm wondering if it might be a bit much to put docstrings on every single AbstractGridMetric for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like IntegratedField down the line). Fair point. But internal docstrings also help I think. It's way easier for me to contribute, for example, when the internal functions are well-documented. I think the more we add these, the more likely we are to get contributions from people outside of the regular group, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043:232,Integrat,IntegratedField,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043,1,['Integrat'],['IntegratedField']
Integrability,"> I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm. https://github.com/CliMA/slurm-buildkite is what is being used IIUC. . Oceananigans doesn't use this afaik, but instead just uses runners on a private compute node.; Looks like me, @glwagner or @charleskawczynski have the right priviliges to create an agent token.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736:108,integrat,integrate,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736,1,['integrat'],['integrate']
Integrability,"> I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > ; > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum. Thought more about this and I think it might be quite complicated to change to this so I will leave for now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739:198,depend,dependant,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739,1,['depend'],['dependant']
Integrability,"> I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C.; > ; > Does anyone working on Oceananigans have experience doing that sort of thing?. Could be worth asking on julia slack! You'll have to ship an independent wrapper package (eg `VkFFT.jl`) and figure out how to precompile the binaries, right (so we can install everything from the REPL)?. Could be good for this PR to focus on getting explicit free surface to work, then build up the rest of the features after that. Doing this for real will also require figuring testing out I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503:32,wrap,wrap,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503,2,['wrap'],"['wrap', 'wrapper']"
Integrability,"> I've used xarray to analyze and plot Oceananigans NetCDF files quite a lot in the past with little difficulty (still really like xarray). Being on a regular Cartesian grid helps a lot obviously. You can use `xarray` on Oceananigans data blindly and be happy with it (I do it for the most part!), but their routines for interpolation and especially integration and differentiation don't match up with Oceananigans' finite volume scheme. So if you need to be precise with your calculations, you definitely shouldn't use the `xarray` default routines. And yes, this definitely overlaps with `AbstractOperations`, but I think that's okay, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045:308,rout,routines,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045,3,"['integrat', 'rout']","['integration', 'routines']"
Integrability,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962:136,message,message,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962,2,"['message', 'wrap']","['message', 'wrapper']"
Integrability,"> If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up?. The user has to define `update_biogeochemical_state!` for the particular `BasicBiogeochemistry` they would like to use; if they want to compute light attenuation, they'll have to write that. However, I can envision child packages to Oceananigans providing more structured functionality for users. I think we just want to keep the Oceananigans interface as simple and general as possible since we expected it to be used by many different types of chemistry and biology models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999:481,interface,interface,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999,1,['interface'],['interface']
Integrability,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293:231,interface,interface,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293,1,['interface'],['interface']
Integrability,"> In dealing with a stretched grid, don't we need these to depenend on the horizontal grid?. Not in general; without bathymetry we would only need this for three-dimensional curvilinearity. If we have only horizontal curvilinearity (as arises in a thin approximation to the spherical shell), then vertical spacing are independent of horizontal location. But as noted in this issue, vertical spacing *do* depend on horizontal location with an immersed boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864:404,depend,depend,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864,1,['depend'],['depend']
Integrability,"> Indeed, the boundary conditions for `U` and `V` should be the integral of boundaries for `u` and `v`. I am unsure about the boundaries for `η`; I think `η` is typically prescribed outside the domain in regional simulations, but we probably need to find a reference for that. For reference, I think ROMS currently uses the algorithm described [here](https://www.sciencedirect.com/science/article/abs/pii/S146350031000082X?via%3Dihub). I haven't read it carefully, but it seems to project both `U` and `η` to a common point outside of the domain, calculate a variable that depends on both quantities (Eq. (2)), and specify the BCs for both based on that. (Likewise for `V`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930:573,depend,depends,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930,1,['depend'],['depends']
Integrability,"> Interesting that it modifies `field` in place. I think perhaps a starting point could be an implementation that puts the result in a new field, perhaps?. Yes, in my case, I created a copy of the field I wanted to integrate and then applied the function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098913682:215,integrat,integrate,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098913682,1,['integrat'],['integrate']
Integrability,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:363,depend,dependencies,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800,1,['depend'],['dependencies']
Integrability,> Is it worth using Python here though? I feel like we'd need to have a whole conda environment set-up just for that. Julia can handle the dependencies if we want to use it. See `PyPlot.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482:139,depend,dependencies,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482,1,['depend'],['dependencies']
Integrability,> Is that message going to display _every_ time a model is created?. No. Only when a model is created with `gravity_unit_vector != NegativeZDirection()`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460733936:10,message,message,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460733936,1,['message'],['message']
Integrability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. I would wait for KA to merge (we do not want to depend on a branch). . On the other hand, I would prefer not to wait for KA to have this PR ready to merge so we can merge the two PRs in rapid succession and not take time to refactor/review this one later (it would be better to merge this by July 15th and I think it has some major changes we want to discuss before). In the end the KA PR just handles how offsets are used in indexing kernels. I don't think that API will change even when changing the internals, and even if it does, it is just a matter of changing one function (`launch!` in `src/Utils/kernel_launching!`) to reflect the API changes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191:210,depend,depend,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191,1,['depend'],['depend']
Integrability,"> Is the solution outside the body perfectly symmetric?. > @wenegrat and @whitleyv sounds good - is the angle dependence maybe due to time dependence of flow, does it move around as the flow changes?. @christophernhill This should be a _roughly_ steady state solution for Re = 40 by the end of the simulation. Changes in velocity at that point are O(10^-5). Here is the velocity contours for the above case @weymouth. Angle-wise, 0 degrees was taken due east but the flow is not in that direction, so it should have been symmetric from [-90,90] and [90,270]. As @wenegrat mentioned, the normal velocity may be uneven due to the interpolation and derivative calculations so near the boundary. ![velocity_Re40_dx04_small](https://user-images.githubusercontent.com/67593861/101181102-7ed6fb80-361a-11eb-92f1-041f0daa398e.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738849541:110,depend,dependence,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738849541,2,['depend'],['dependence']
Integrability,"> Is there a forcing function that computes the ""immersed boundary normal"" direction with associated logic?. Not exactly, but if you're determining a grid fitted normal direction then these boolean functions determine if the location is an interface with fluid on the left and solid on the right or vice versa for all the options. They are only true on a boundary face, not if its a solid-solid or fluid-fluid wall. https://github.com/CliMA/Oceananigans.jl/blob/8b988b34abcfbfd2e0453aedec5916c22b8c35c7/src/ImmersedBoundaries/conditional_fluxes.jl#L48. I don't think it would be hard to use these to set a directional sign for the normal direction, depending on which way you're doing that. If you want the normal direction to be based on the true IB rather than grid fitted, then I don't have anything recent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496:240,interface,interface,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,> Is there a way for me to cancel tests so they don't have to run every commit?. You can include `[skip ci]` in the commit message: https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165:123,message,message,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165,1,['message'],['message']
Integrability,"> Is there a way to test x_f_cross_U et al?. Yes: construct a model with the given feature and then perform a time-step. I guess ideally we would form a giant matrix representing all possible model configurations and time-step them all once. This would be expensive. Maybe we should just loop over each physics specification individually and cross our fingers that there's no bad interactions (I can already tell this would be naive, for example, when a turbulence closure depends on buoyancy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090:473,depend,depends,473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090,1,['depend'],['depends']
Integrability,"> Is there any other reason why it should be positional?. I guess I'm just arguing that it's not consistent with most of the API, eg we write `CenterField(grid)`. I find the position representation of required arguments to be a natural and concise interface but perhaps I shouldn't die on that hill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107:248,interface,interface,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107,1,['interface'],['interface']
Integrability,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,2,['interface'],['interface']
Integrability,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:536,interface,interfaces,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['interface'],['interfaces']
Integrability,"> It may be that several other dependencies need to be updated. Yep, a few others updated when I ran . ```julia; (Oceananigans) pkg> update SeawaterPolynomials; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1488008980:31,depend,dependencies,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1488008980,1,['depend'],['dependencies']
Integrability,"> It may become common if users do realistic GCM stuff, because there will be many turbulence closures, but only *one* of them would require explicit boundary-diffusivity modeling to control field gradients and diffusivities along boundaries (for example, prescribing some interesting lateral diffusivity parameterization on top of a vertical mixing parameterization). Ah interesting I didn't think of such cases. I believe we can set up arbitrarily complicated boundary conditions so anything is possible. It's just hard and probably unfeasible/undesirable to extend the user interface to handle all these cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589850223:577,interface,interface,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589850223,1,['interface'],['interface']
Integrability,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224:40,interface,interface,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224,1,['interface'],['interface']
Integrability,"> It will allow us embed a little more multi process in the code. Can you explain this point?. To me it looks like the main difference / improvement of (3) is the _user interface_ rather than functionality, because every grid has an `architecture`. Thus in source code it's the difference between `grid.architecture.partition` or `grid.partition`. With a `process_partition(grid)` interface (which we should have...) even that distinction is lost. The primary tradeoff against the user interface change is an increase in code complexity. New developers have to wrestle with and users have to puzzle over `grid.partition`, even though it's relevant only in a minority of cases (particularly because we are GPU-focused, and are providing features for multi-GPU). For example with `MultiRegionGrid` we'd have `grid.partition` and `grid.region_grids[1].partition`. But maybe I am missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110:381,interface,interface,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110,2,['interface'],['interface']
Integrability,"> It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. Good point, I've been meaning to set up a script for benchmarking the different pressure solvers. We should use performance benchmarking results to make decisions. > Also, I'd encourage writing this code into as self-contained a submodule as possible. I think there are other codes in the julia ecosystem (not least FourierFlows.jl!) that would benefit from fast and multi-architecture Poisson solvers. We don't have to break this into a separate package just yet, but we do want to ensure this is easy to do in the future. Another good point. As you pointed out some of these solvers depend on the `grid` but if we take that out (which would be trivial) then I think the solvers in PR #589 would be pretty reusable by other packages. Although right now they're pretty specific to staggered grids (except for `BatchedTridiagonalSolver`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204:889,depend,depend,889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204,1,['depend'],['depend']
Integrability,"> It's added under `[extras]` beneath `Plots`... where should I put it instead?. But it's not used by the package nor by the tests, right?. I though we added test dependencies under `[extra]` which included Plots.jl but now that examples are not run as part of the tests (only as part of building the docs) then shouldn't both Plots.jl and Measures.jl be in `docs/Project.toml` and not the main `Project.toml`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-724235003:163,depend,dependencies,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-724235003,1,['depend'],['dependencies']
Integrability,"> It's because the two fields use the same data:; > ; > ```julia; > u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); > v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); > ```; > ; > therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array. That makes sense, especially because if I don't specify the scratch data it goes away. But any guesses as to why it only pops up when using IBMs?. https://github.com/CliMA/Oceananigans.jl/pull/2582 seems to suggest that it's because the Average is only computed at fluid nodes and therefore is applied conditionally. Is that it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131:285,depend,dependent,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131,1,['depend'],['dependent']
Integrability,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:46,interface,interface,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203,3,['interface'],['interface']
Integrability,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:193,depend,depending,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"> Just added BitInformation to the Project.toml, due to dependency on `StatsBase` and `Distributions` this also adds; > ; > ```; > Updating `~/git/Oceananigans.jl/Project.toml`; > [de688a37] + BitInformation v0.6.1; > Updating `~/git/Oceananigans.jl/Manifest.toml`; > [66dad0bd] + AliasTables v1.1.2; > [de688a37] + BitInformation v0.6.1; > [49dc2e85] + Calculus v0.5.1; > [31c24e10] + Distributions v0.25.108; > [fa6b7ba4] + DualNumbers v0.6.8; > [1a297f60] + FillArrays v1.11.0; > [34004b35] + HypergeometricFunctions v0.3.23; > [77ba4419] + NaNMath v1.0.2; > [90014a1f] + PDMats v0.11.31; > [1fd47b50] + QuadGK v2.9.4; > [79098fc4] + Rmath v0.7.1; > [2913bbd2] + StatsBase v0.34.3; > [4c63d2b9] + StatsFuns v1.3.1; > [f50d1b31] + Rmath_jll v0.4.0+0; > ```; > ; > also why is the Manifest.toml committed?. Through past experience we found that we needed the Manifest committed to make sense of the errors we encounter during CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793:56,depend,dependency,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793,1,['depend'],['dependency']
Integrability,"> Just curious if DataAPI, Formatting, SortingAlgorithms, StatsBase, and UnicodePlots are required for this PR? They got added to Manifest.toml but no new dependencies were added to Project.toml. No. I have no idea why that happened. What can we do to remove them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545710527:155,depend,dependencies,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545710527,1,['depend'],['dependencies']
Integrability,"> Just ran into this and wanted to mention [NCTiles.jl](https://github.com/gaelforget/NCTiles.jl) which we, https://github.com/lmilechin and myself, recently released.; > ; > Not sure if `NCTiles.jl` is readily applicable to your package output but maybe it would be interesting to discuss some sort of integration. What do you think?. Hi @gaelforget , . Thank you for bringing this to our notice! From what I understand, NCTiles provides convenient functions to either use NCDatasets.jl or NetCDF.jl and integrates with MeshArrays.jl, which has representations for tri-polar grids and such. I haven't had the time to read your 2015 paper so please correct me if I did not grasp the full extent of NCTiles' capabilities. So far Oceananigans does not have support for anything other than regular cartesian grids so NCTiles might be an overkill. But we can definitely consider it in the future when Oceananigans gains new capabilities. . By the way, did you notice any differences in performance between NCDatasets.jl and Netcdf.jl?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-537189439:303,integrat,integration,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-537189439,2,['integrat'],"['integrates', 'integration']"
Integrability,"> Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget.; > ; > Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. I see. Did you try `Oceananigans.Fields.ConstantField`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766:218,integrat,integrate,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766,1,['integrat'],['integrate']
Integrability,"> Lagrangian-averaged should be slightly less diffusive right?. Hmm, I'm not aware of that. afaik it's about the same in a doubly periodic domain. Looking at Bou-Zeid's Figure 1 I also don't see any obvious trend that way. What is generally true is that scale-dependent formulations (not implemented here) tend to be less diffusive then scale-invariant ones (which is the one implemented here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448410206:260,depend,dependent,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448410206,1,['depend'],['dependent']
Integrability,"> Looks like a good interface to me.; > ; > But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?; > ; > @liuchihl will test it in our configurations. Well yes, it's substantial effort to support background fields. So we implemented it in the nonhydrostatic model first. Nobody has requested having background fields for the hydrostatic model. It's not impossible but might require some thinking if it's going to work with the more complicated turbulence closures (like CATKE or k-epsilon) that sometimes get used for hydrostatic applications. Since the nonhydrostatic model is fast (at least on one GPU) the hydrostatic model is mostly important for simulations on the sphere (although this statement needs to be evaluated more carefully for complex domains when we have a proper nonhydrostatic solver).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460:20,interface,interface,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460,1,['interface'],['interface']
Integrability,"> Looks like this is a bad idea, so I'm closing. I'm not sure it's a bad idea. I've been having some issues with spurious waves in rotated domains and I'm thinking this might be the cause. (Since we're modifying the direction gravity is acting on, but we're still integrating the pressure in the model's z direction.). I still haven't been able to test my rotated domain on this branch, so I'm not sure. But if indeed this is the culprit, it might be a good idea to have a flag that turns the hydrostatic separation off for rotated domains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672:264,integrat,integrating,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672,1,['integrat'],['integrating']
Integrability,"> Maybe I'm missing something, but I can't imagine how that would not happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed. I think the problem is that we cannot impose a `b` that has a non-zero domain average. This is consistent with its definition (eg it is proportional to the density _perturbation_; we subtract out a reference density in Boussinesq). Consider the x-momentum equation:. ```; du/dt + ... = b sin(theta); ```. if `b` has no net average, then the average of this equation is just. ```; d <u> / dt = 0; ```. right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035:144,message,message,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035,1,['message'],['message']
Integrability,"> Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364:216,interface,interface,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364,2,['interface'],['interface']
Integrability,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:190,depend,dependencies,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767,1,['depend'],['dependencies']
Integrability,"> More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be 1027 and in the other its 1024. Sorry that was a typo. Just fixed it. > But otherwise I don't see why it wouldn't work and I am a bit stumped. Yes, I've dedicated several hours to investigating this issue also and got nothing. The issue also is that I'm actually depending on that result for research, and it's pretty expensive to calculate that offline. Do you have any suggested workarounds?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625:424,depend,depending,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625,1,['depend'],['depending']
Integrability,"> My primitive logic: for a flux boundary condition, bc.calc() ""calculates"" the flux at the given grid point and time-step. For a ""value"" boundary condition, bc.calc() ""calculates"" the value of the boundary condition at the given grid point and time-step. But I agree it is a weird name. What is a better name?. It may not stand up to mathematical rigor but I still like `bc.impose()`. In your two examples, I feel like a flux is being _imposed_ and a value is being _imposed_. If `bc.calc()` calculates a number then it should be used as; ```julia; something = bc.calc(args...); ```; while `bc.impose` should be used like; ```julia; bc.impose!(args...); ```. But now we're just arguing semantics instead of what's important. > There are two issues: the backend, and the user interface. Maybe the title of this PR is confusing, because I think it's primarily about the backend. I think so too. API suggests more front-end. I also think discussing these dense and complicated issues (e.g. this PR and #120) among multiple busy people is difficult on GitHub. Little far ahead but maybe the Monday CliMA meetings are a good place to get high-level feedback?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439:776,interface,interface,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439,1,['interface'],['interface']
Integrability,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:333,integrat,integrated,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928,1,['integrat'],['integrated']
Integrability,"> No we should fix this for sure. I'm asking because you would save a lot of memory if you avoid writing `Field(w*c)`. Ah, I see. That's a good point, I'll investigate that. I'm wrapping things in `Field()` calls because I use the `data` option in all of them to reuse scratch space and save memory. But indeed when averages are involved that might not be the best way to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870:178,wrap,wrapping,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870,1,['wrap'],['wrapping']
Integrability,"> Nono in the code it should stay the same, because pressure due to `h` and `hB` should have opposite signs. Also for the `VectorInvariantFormulation` I directly calculate `g ∂xᵢ(h - hB)`. That depends on whether `b` is positive or negative. Before, `b <0`, and therefore the total height was `h = \eta -b`, where `\eta` is the free-surface. However, if `b > 0`, then `h = \eta + b`. . This becomes important when we evaluate the pressure graident. . In the first case we have, which is not what we had; ```; -∇η = -∇(h + b) = - ∇h - ∇b; ```; In the second case, we should have ; ```; -∇η = -∇(h - b) = - ∇h + ∇b; ```; which is what we have. Actually, now it seems that with changing the sign of `b`, the code is consistant with the equations we are now solving. Does that make sense?. But if you compute it directly, then do we need to extra `bathymetry` terms that I pointed to above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793:194,depend,depends,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793,1,['depend'],['depends']
Integrability,"> Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there. Hm ok got it, it depends on the status of what's returned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544:169,depend,depends,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544,1,['depend'],['depends']
Integrability,"> Not sure if this is useful but it seems like the `worksize` tuple and some `args` tuple aren't being inferred correctly but `worksize` is just used to launch the kernel so maybe `args` is the problem. I'll have a deeper look when I have more time. You're looking at CPU code here; you rather want to prefix your application with `@device_code_warntype interactive=true` (which will spawn a Cthulhu UI for every kernel), or use `descend_code_warntype` directly passing the kernel's function and argument typle type. It _should_ be possible to reconstruct the tuple type from the error message:. ```; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; ```. But seeing how it's fairly complex you might be better off using `@device_code_warntype interactive=true` (after having imported Cthulhu).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673514740:586,message,message,586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673514740,1,['message'],['message']
Integrability,"> Note that tests will fail on dev/nightly builds (Julia 1.2) because something changed which broke Cassette (which GPUifyLoops depends on). Pushed a fix for that this morning, and also tagged GPUifyLoops v0.2.1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479513151:128,depend,depends,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479513151,1,['depend'],['depends']
Integrability,> Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples. Yes yes yes!. Can we have alias?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417:40,interface,interface,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417,1,['interface'],['interface']
Integrability,"> OK, I'll close this for now then and leave the issue open to remind us to heal the duplicate `R_Earth` that appear in Oceananigans...; > ; > I like the approach that users should set their constants depending on whatever choices they like. E.g., simulating an ocean in Europe or a fish tank on the top of Everest. Can you just get rid of the constant called ""R_Earth""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632295:201,depend,depending,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632295,1,['depend'],['depending']
Integrability,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:740,inject,injects,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['inject'],['injects']
Integrability,"> Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`. `nameof` is a cool idea. Is there a similar julia function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999:205,wrap,wrapper,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999,1,['wrap'],['wrapper']
Integrability,"> Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). The two changes are:. 1. A cell `is_immersed` if the _interface above the cell center_ is below the bottom (or nearly so). Actually the precise condition requires using `minimum_fractional_Δz` as noted above; I think we should have something like. ```julia; function is_immersed(i, j, k, ibg); ϵ = Δzᶜᶜᶜ(i, j, k, ibg) * ibg.immersed_boundary.minimum_fractional_Δz; z_above = znode(c, c, f, i, j, k+1, ibg.grid); return z_above - ϵ < get_bottom_height(i, j, k, ibg.grid, ibg.immersed_boundary.bottom_height); end. function get_bottom_height(i, j, k, grid, bottom_height); x, y, z = nodes(c, c, c, i, j, k, grid); return bottom_height(x, y); end. get_bottom_height(i, j, k, grid, bottom_height::AbstractMatrix) = @inbounds bottom_height[i, j]; ```. Should be inspected closely, might be an error... 2. The vertical grid spacings `Δzᶜᶜᶜ` are modified for the cells that are _just above the bottom_ (ie, `is_immersed(k)` is false, but `is_immersed(k-1)` is true). Note that the interface spacings `Δzᶠᶜᶜ` have to take the minimum between the `Δzᶜᶜᶜ` in adjacent cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195:1192,interface,interface,1192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195,1,['interface'],['interface']
Integrability,"> On a different note, if a `BackgroundField` is time dependent then evaluating it at every time step makes sense. But if it's time independent, as in this case, then it's working a lot more than it should. Agreed!. > If we have an array, say b_array, then can we can turn it into a field using b_field = ComputedField(b_array)?. Just `b_field .= b_array`. > Would it be of interest to have an option for it to not compute it at every time?. There are two ways to achieve this. The underlying data for a concrete `BackgroundField` can be updated via the `progress` callback every time step. A better method that's currently only possible currently with `HydrostaticFreeSurfaceModel` is to add it to the model's list of `auxiliary_fields`. In this case `compute!(field)` is called on every member of that list, so if the `BackgroundField` has a `compute!` method (eg if it's a `ComputedField`, or some other custom `Field` with a `compute!` method) then it will be updated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875586940:54,depend,dependent,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875586940,1,['depend'],['dependent']
Integrability,"> On a side note, since you asked, I am going through some difficulties running the same example with a GPU. My inexperience with GPUs is keeping me from figuring this one out. What GPU are you running on? You'll need an Nvidia GPU and the CUDA library installed. Installing Oceananigans through the Julia package manager should install all the required Julia package dependencies (but won't install CUDA itself). Are you getting any errors?. Hmmm, so there is a small caveat that `Nx` and `Ny` need to be multiples of 16 on the GPU right now, although you'd get an error about this. > Should I create another issue?. Hmmm yeah that might be a good idea just to keep each issue self-contained. > (I'm not sure how much you guys want to be involved in these debugging processes...). We're very interested in being involved with the debugging process! We're still in early development so I'd expect things to break quite often, and we still haven't ironed out all the bugs and usability issues. We've also mostly been using the model ourselves (hard to improve usability if you know all the internals haha), so if you're willing to report issues it would be a huge help with development!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740:368,depend,dependencies,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740,1,['depend'],['dependencies']
Integrability,"> On codecov --- the recent for the poor marks is because we basically will not test `Computation`. This makes sense as we are having trouble with CI and we also want to nuke these features. However, the NetCDFOutput writer still has some functionality that uses `Average` (which in turn has an interface to `Computation`) so I'm not sure we can get rid of them just yet. Sounds good to me to skip those tests. We should just be careful not to tag a new release until things have settled.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-691045772:295,interface,interface,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-691045772,1,['interface'],['interface']
Integrability,"> On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. Hypothesis: dissipation by WENO is beautiful but may impose time-step restrictions. Or put another way, for whatever reason the _amount_ of dissipation introduced by WENO may have limits. And, WENO dissipation is, by design, dependent on grid-scale gradients. Thus if there are dynamics that synoptically produce tiny scales WENO may be ""too weak"" to dissipate over a given ""longish"" time-step. A bit vague but that's one guess at what might be happening. Hyperviscosity is more robust of a filter perhaps (the problem is that we always have to guess the coefficient). Does ""vorticity smoothing"" (vs velocity smoothing) WENO also blow up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996:348,depend,dependent,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996,1,['depend'],['dependent']
Integrability,"> Once the simulation is chugging along, it seems like the Poisson problem is not as difficult. It does seem like the solution becomes more accurate in time (but unfortunately, the CG solver does not start to converge more quickly...). The issue is interestingly related to this comment in MITgcm (which may be wrong by the way, but nevertheless reflects some observation about the CG solver): . https://github.com/MITgcm/MITgcm/blob/c7a06a2c29b2186c216f05f729b330d10e23c8be/model/src/cg3d.F#L86C1-L88C81. For this MWE, the RHS is 0 with `OpenBoundaryCondition(0.01)` on both sides, but not with `FlatExtrapolationOpenBoundaryCondition()`. @jm-c remarked that the RHS is also not zero for the Poisson equation beneath a free surface (which, in a z-coordinate, also essentially has an open boundary since $w(z=0) \ne 0$). > I'll close this issue since the original MWE works now. It's just a matter of setting maxiter. I think this comment is true in a practical sense. Possibly we do need another issue about the non-convergence of the CG solver. I think there is scope for someone to put in some effort to document this (eg come up with tools to evaluate convergence) and present a few nice MWEs (I think in addition to the present one with `FlatExtrapolationOpenBoundaryCondition()`, it would be nice to have a demonstration with impenetrable boundary conditions as well). . The way that the Poisson solver and open boundary conditions are intertwined is also a good reason to implement new open boundary condition matching schemes directly in Oceananigans @jagoosw . Note that we are also thinking about how to develop an interface to `Krylov.jl` in #3803 which may open up additional avenues for progress on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2422592019:1625,interface,interface,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2422592019,1,['interface'],['interface']
Integrability,"> One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Good to know. Thanks for explaining. > Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Agreed! Often unexpected things happen, which keeps us on our toes. > We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. I don't pretend to understand the details of this and don't know the potential pay off so not sure whether I think this will bear fruit or not. > I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. . Good. > _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ah, I don't think I'm getting into that now but it's something to be aware of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988:838,interface,interface,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988,1,['interface'],['interface']
Integrability,"> One thing that I noticed is that advection seemed to be commented out for tracers. Did I read that right?. Yes --- because we are still finalizing the user interface that controls the advection term + advection scheme for momentum and tracers. I think ideally we want to preserve the ability to use high-order advection schemes for momentum when we are on a `RegularCartesianGrid`. However, we also have to use a ""vector-invariant form"" of the advection term when running on curvilinear grids. So we need a way to specify both continuous and numerical aspects of the advection term implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674:158,interface,interface,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674,1,['interface'],['interface']
Integrability,"> Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?. Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid. I agree that we should have a test for that and maybe something in the docs, sometime?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890:152,message,message,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890,1,['message'],['message']
Integrability,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:48,integrat,integrate,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764,3,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"> Out of curiosity @simone-silvestri could you check; > ; > ```julia; > fts2[1, 2, 3, 4] == fts2[1, 2, 3, 4.0]; > ```; > ; > in your example with the `.jld2` file above?. the outcome depends on whether `fts.times = [1, 2, 3, 4]` or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759:183,depend,depends,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759,1,['depend'],['depends']
Integrability,"> Output needs to be arbitrary. We may need to perform on-line analysis and output the result (example: turbulent dissipation rate, time-averages, slices of fields, point values, etc).; > ; > We should design an additional interface for Fields. The type of the field indicates the coordinates on which the field is defined, so we should design an interface that uses that information.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/pull/93#issuecomment-468290310_. Just adding your comment here as I think there are two new questions raised:; 1. How to integrate diagnostics with the output writing framework?; 2. Right now each NetCDF output file shows a single snapshot. Maybe it makes more sense to keep appending to an existing NetCDF file. This might also make addressing (1) easier especially if the diagnostics have a different output frequency that other fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468304803:223,interface,interface,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468304803,3,"['integrat', 'interface']","['integrate', 'interface']"
Integrability,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:359,integrat,integrate,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827,1,['integrat'],['integrate']
Integrability,"> Perhaps this usage should be demonstrated in the `Forcing` docs or something... Yes, I think that would be really helpful. I just checked and, across all of the examples, callbacks are only used for the timestep wizard and progress messages. Probably for this reason a lot of others users also don't realize they are more generally useful!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098848659:234,message,messages,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098848659,1,['message'],['messages']
Integrability,"> Please add a small description of this PR in the top comment. Done. > Question: is Oceananigans the right place for the extension to be or an extension for Oceananigans in Enzyme?; > ; > (I'm not arguing for one or the other; I'm just wondering.). So I think here is the right place, since code has a dependency on Oceananigans itself and EnzymeCore (which is dependency free). It also is how other packages (like NNlib, LinearSolve, SciMLSensitivity, etc) work with Enzyme and other AD tools.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051:303,depend,dependency,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051,2,['depend'],['dependency']
Integrability,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:882,mediat,mediated,882,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,1,['mediat'],['mediated']
Integrability,"> Quick general question: with this interface IBM immediately goes to drag BC, right?. That's correct. There's no way to run IBM without a drag BC with this implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244:36,interface,interface,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244,1,['interface'],['interface']
Integrability,"> Requires [JuliaGPU/KernelAbstractions.jl#399](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399) # On hold at the moment. At the top comment it says this PR depends on another KA PR that isn't merged. However, this PR is merged (and tagged). Does this not depend on https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399 anymore?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729619719:168,depend,depends,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729619719,2,['depend'],"['depend', 'depends']"
Integrability,"> Should AMD use z_dot_g_b now?. The implementation of a ""buoyancy-aware"" AMD is not correct... But yes, if we wanted to have a working version of this feature, it would have to know the direction of gravity. We'd have to add terms that depend on the horizontal directions for it to be correct I think, which probably warrants re-deriving it for generalized gravity from scratch. Since it doesn't even work for vertical gravity we should probably just nuke it and address later. Simplest would be to implement a working version for vertical gravity and throw an error if gravity is tilted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788:237,depend,depend,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788,1,['depend'],['depend']
Integrability,"> Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. I think my suggestion is being misinterpreted --- I was referring only to changes to software and data structures; not changes to the partial differential equations being solved. . If we do not ""add"" the constant background viscosity component to `model.diffusivities.νₑ`, we would instead add the contribution of the constant background viscosity to the total diffusive flux divergence separately from the contribution associated with the nonlinear eddy viscosity (similar to how the diffusive flux divergence for constant background viscosity is currently calculated without the auxiliary field `model.diffusivities.νₑ`). Thus my suggestion only changes the content of `model.diffusivities.νₑ` and otherwise preserves both the user interface and the default behavior for `Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation`. We could also completely remove ""constant background"" parameter from `AnisotropicMinimumDissipation` and preserve existing behavior, since users can use multiple turbulence closures to achieve the same effect, as in. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicViscosity(ν=1.05e-6)); ```. for example. This might be a better user interface than what we have now. As a side note, since there's no constant background viscosity that's appropriate for all scenarios, it should probably be zero by default if we continue to allow users to set it as a parameter in `AnisotropicMinimumDissipation` (eg #1278).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051:982,interface,interface,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051,2,['interface'],['interface']
Integrability,"> Since this is a breaking change (?) do you want to bump to version 0.27.0 in this PR?. Ah, it isn't a breaking change btw (it just adds a wrapper around existing functionality) --- but it does add a new feature, so 0.27.0 could still be warranted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599508063:140,wrap,wrapper,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599508063,1,['wrap'],['wrapper']
Integrability,"> So if support for `pressure = nothing` (or `pressure_solver = nothing`) is added, would `BackgroundField` effectively work as a prescribed unchanging velocity?. Yes, something like this is an alternative design. But do we think that setting `pressure=nothing` might be too roundabout of a way to avoid launching kernels that calculate the velocity tendencies and to avoid allocating memory for the velocity fields?. The design I'm suggesting would have users write `velocities = PrescribedVelocities(...)` in the constructor for `IncompressibleModel` as the interface; so there's just a single keyword arg to set. We don't want `advection=nothing` since this turns off all advection, including advection by `BackgroundField`s. So out of the box @ali-ramadhan's suggestion doesn't work, but its possible that something _like_ it might be designable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768491247:560,interface,interface,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768491247,1,['interface'],['interface']
Integrability,"> So it seems that execution does not have to hit the @warn for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. Precisely. > And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. Perhaps a positional argument to `lambertw`, either boolean or perhaps even better a type (to use multiple dispatch) to control behavior, things like. * `WarnFailures()` (throw warning for failures); * `MarkFailures(value=NaN)` (mark failures with a specific value, do not throw warning); * `IgnoreFailures()` ?; * `WithSolverInfo()` (return a type that contains the root, boolean `converged`, and possibly also number of iterations). > It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. It is interesting to consider auto-sanitization of GPU code...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451,2,['interface'],['interface']
Integrability,"> So seems that all is good? So the problem comes when I continue the integration longer?. It appears that the issue does get worse the longer you run, yes. The original MWE I posted runs for 18 time steps and it looks like this:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Running it for 2 time steps it looks like this:. ![image](https://user-images.githubusercontent.com/13205162/220152519-7dab5501-6636-4c57-851d-5a944ab1d524.png). The results are still different from different tracers, but not visibly so. (The order of magnitude of the differences is around 1e-5 in this case)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437234615:70,integrat,integration,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437234615,1,['integrat'],['integration']
Integrability,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:570,wrap,wrapper,570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['wrap'],['wrapper']
Integrability,"> So the problem comes when I continue the integration longer?. This could be worth trying, note that. ```julia; julia> using Oceananigans.Units. julia> 0.15hours / 30; 18.0; ```. So you can run for 18 steps instead of 4. (@tomchor why 18?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436104605:43,integrat,integration,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436104605,1,['integrat'],['integration']
Integrability,"> So we want to look at model.clock.time and sch.previous_interval_stop_time + sch.interval. It does seem probable the issue is roundoff error. It does seem like a roundoff error, below is the progress message. At iter:64, for example, `model.clock.time` is slightly larger than `sch.previous_interval_stop_time + sch.interval` （which I think they should've been equal):. ```julia; [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds, model clock time:0.0, previous_interval_stop_time + interval:0.1, u-avg: 0.0, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.0, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.0, collecting: true; [ Info: ... simulation initialization complete (231.038 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (546.837 ms).; [ Info: Iter: 11, time: 100 ms, model clock time:0.1, previous_interval_stop_time + interval:0.2, u-avg: 0.1202985845671951, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.1, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.1, collecting: false; [ Info: Iter: 22, time: 200 ms, model clock time:0.2, previous_interval_stop_time + interval:0.30000000000000004, u-avg: 0.8057920910530502, window_start_time: 0.11, window_start_iteration: 12, previous_collection_time:0.2, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.2, collecting: false; [ Info: Iter: 32, time: 300.000 ms, model clock time:0.30000000000000004, previous_interval_stop_time + interval:0.4, u-avg: 2.0225593735128355, window_start_time: 0.21, window_start_iteration: 23, previous_collection_time:0.30000000000000004, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.30000000000000004, collecting: false; [ Info: Iter: 42, time: 400 ms, model clock time:0.4, previous_interval_stop_time + interval:0.5, u-avg: 3.664512241688186, window_start_time: 0.3100000000000001, window_start_iteration: 33,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302:202,message,message,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302,1,['message'],['message']
Integrability,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:704,interface,interface,704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['interface'],['interface']
Integrability,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:1136,depend,depends,1136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577,3,"['depend', 'integrat']","['depend', 'depends', 'integrated']"
Integrability,"> Some good news is that more tests seem to be passing compared to the prevoius PR.; > ; > One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why.; > ; > ```; > Testing Oceananigans; > # Received cancellation signal, interrupting; > ```. I don't know what you saw.; But what I see here: . https://buildkite.com/clima/oceananigans/builds/14750. is that almost all tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988349960:102,message,messages,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988349960,1,['message'],['messages']
Integrability,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:327,wrap,wrap,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443,1,['wrap'],['wrap']
Integrability,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994:122,message,message,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994,1,['message'],['message']
Integrability,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:444,message,message,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161,3,['message'],"['message', 'messages']"
Integrability,"> Sorry @glwagner Maybe I didn't express very well. I don't see any problem in split files and understand the importance in having that. What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI. I was responding to @simone-silvestri !. In terms of user scripts, I certainly do think it's better to access the `rank_id` from the architecture. I think it's easier to read too, and it allows user scripts to depend on one fewer package. However, I think that the output writers should automatically change the filename when the simulation is distributed. This should be pretty easy and just involves adding the suffix `_rank$(rank_id)` to the filename for distributed architectures. We should also have an API for callbacks that are intended to only run on one rank (for example for printing stuff); eg a property `on_rank=0` which is used when `arch isa Distributed`. There's probably other useful things. `FieldTimeSeries` will have to be modified so that it can combine distributed files, for example. Probably, distributed output should also save some kind of ""meta"" file that contains information about the processor layout, to be used by `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329:501,depend,depend,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329,1,['depend'],['depend']
Integrability,"> Thanks @glwagner . I started but have a few questions.; > ; > * Why didn't the hydrostatic model need a `with_halo` function?; > * I started to write a `new_halo` function in `ImmersedBoundaries.jl` but don't think this is the right spot. Where should it go?; > * Most of the function is pretty easy except for when we define the new_grid. What I have [here](https://github.com/CliMA/Oceananigans.jl/blob/5ea7b9168a40619a17d2c9ab42b65b622a7c9ac1/src/ImmersedBoundaries/ImmersedBoundaries.jl#L86) is wrong but can you help me modify it? It seems like we know infomration about the bump but that is not currently passed in new_halo. Maybe we need to pass more information?. I guess the hydrostatic model doesn't call `with_halo`:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl. I think you need `with_halo` rather than `new_halo`, if I read the error message correctly. In that case I think the needed function is a one-liner:. ```julia; with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. But maybe I am missing something? I don't quite understand what you mean about `new_grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667:932,message,message,932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667,1,['message'],['message']
Integrability,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938:816,depend,depend,816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938,1,['depend'],['depend']
Integrability,"> Thanks @jagoosw and @glwagner for your thoughts on this. @glwagner, the approach to nesting is going to be highly dependent on the particular case. The nesting strategy for a simulation with mesoscale eddies passing across the boundary will be very different from the strategy to nest an LES inside a low resolution simulation. I think that this PR should provide different types of boundary conditions (the 'ingredients') and the user will need to decide how to use them for their particular case (the 'recipe' which will rely on different combinations of the 'ingredients'). Does that make sense?. Yes, that makes sense! I do think we need to have a way to test the different methods... ideally, the tests are non-trivial enough to illustrate that the numerics ""works"" for each ingredient that we implement (either independently or when combined with other ingredients to make a recipe). But the tests don't have to be exhaustive; I imagine it will take some time to develop our best practices.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040113530:116,depend,dependent,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040113530,1,['depend'],['dependent']
Integrability,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:342,depend,dependence,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148,1,['depend'],['dependence']
Integrability,"> That makes sense. I didn't realize the difference between a ""golden master"" and a ""regression"" test. I wouldn't call the output we produce right now to be ""golden master"" level. That's just how I'm defining it. > The two regression tests may be failing for different reasons. Since this test will help you determine that, I guess I feel it will be useful for your work. But if you think there is some intrinsic problem with the test added in this PR then ok. I need this test to integrate the turbulence closures into the code, so I will be using it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496241755:481,integrat,integrate,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496241755,1,['integrat'],['integrate']
Integrability,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:761,depend,depending,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685,1,['depend'],['depending']
Integrability,"> That's not my intention at all. I have plans to try to implement a dynamic option with or without the above flexibility I proposed. I do think there are legitimate reasons to allow for a user-defined coefficient. Like manually decreasing the coefficient in regions where it's overly diffusive, or when running wall-resolved LES. Basically, since the necessary change is a couple lines of code, I tend to think that flexibility is worth it. That said, the `Array`-based method you proposed can also cover these cases. Ok, but you proposed an interface that would include the velocity field. What are the use cases for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187205089:543,interface,interface,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187205089,1,['interface'],['interface']
Integrability,"> The boundary condition implementation should dispatch on the type of the boundary conditions. I agree that's a good approach. To do this, we'd have to merge PR #288. Do you have some time to look at it?. > We probably need a kernel to fill the halo regions. We do have a couple but they need to be rewritten. I ended up switching to broadcasts but I think kernels would be more readable, especially as the halo filling will be different for velocities (u, w) and tracers (T, S) with v being a special case as the walls are in the y-dimension. I plan to switch back to kernels before merging this. > I don't understand @jm-c's comment about ""having to fill the halo regions very frequently"". A few more details on this point would be helpful to facilitate a discussion about it. I think it may have been specifically in reference to how the 3rd order positivity-preserving DST (+ flux limiter) advection scheme is implemented (prototyped in PR #183). Not sure if other advection schemes pose a similar issue, but I figure we cross that bridge when we get there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-504984087:1037,bridg,bridge,1037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-504984087,1,['bridg'],['bridge']
Integrability,"> The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before. Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783:606,depend,dependent,606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783,1,['depend'],['dependent']
Integrability,"> The changes look good to me but I admit that I am a bit confuses as to when we have superscripts a vs c or f. The superscript `a` refers to ""Any"" location. For example, the difference operator `δxᶜᵃᵃ` is _independent_ of the `y` and `z` directions:. https://github.com/CliMA/Oceananigans.jl/blob/6bfc1551c57403268138b85620d88dba8114a4c0/src/Operators/difference_operators.jl#L7. Thus this operator is valid if `y` and `z` are respectively `Center` or `Face`. When this is not true (for example, on a horizontally-curvilinear grid, the grid spacing in the x-direction depends on both `x` and `y` location), we need to explicitly specify the location of the operator / object.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548:569,depend,depends,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548,1,['depend'],['depends']
Integrability,"> The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to JLD2OutputWriter and NetCDFOutputWriter in a WindowedTimeAverage. Yeah, sorry, `windowed_time_average.jl` is what I meant to link to. I guess somewhere these accumulation of the denominator of the mean should be reset to zero when the proper time interval has passed, but I'm not sure where. And thanks for the line-by-line explanation. I understand that part but I really don't see how to fix the issue right now. > Can you explain why isn't this captured in our tests?. I don't know for now. I don't fully understand the `WindowedTimeAveraged` tests to be honest. I think I'd need to run those manually on the REPL but I don't quite have a lot of time on my hands right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141:154,wrap,wrapping,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141,1,['wrap'],['wrapping']
Integrability,"> The dependency on OrthogonalSphericalShellGrids here is blocking the progress (the `SplitExplicitAuxiliaryFields` type has changed in this PR). How do we deal with this? We could remove the dependency in the tests of Oceananigans and move those tests over at OrthogonalSphericalShellGrids. Shall we do this? In case we want to do it I have prepared https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/pull/47.; If yes, we can merge that one then this one, then update OrthogonalSphericalShellGrids with the new interface",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2437244222:6,depend,dependency,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2437244222,3,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"> The error message we are gettig now does not seem to involve this PR at all.; > ; > If that is the case do we need to reset it?. Yeah, this is an annoying error we get sometimes for reasons unbeknownst to me. I'll restart the build.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164:12,message,message,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164,1,['message'],['message']
Integrability,"> The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect. I'm aware of that. My point was more that I don't quite remember how the issue was manifested in the dynamics (the recognition of which was what prompted us to abandon https://github.com/CliMA/Oceananigans.jl/pull/1910). > @tomchor I updated the PR description. Feel free to edit it further. Thanks, that's a great detailed description. I only added one item to the advantages: simpler code and user interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197:648,interface,interface,648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197,1,['interface'],['interface']
Integrability,"> The main advantage of having DiskTimeSeries in Oceananigans would be to use it in examples without depending on another package. I'm not sure what `DiskTimeSeries` specifically is, I guess I missed that discussion, so take my comments with a grain of salt. But I don't think Oceananigans examples depending on other packages is necessarily a bad thing. In fact I see it as a good thing. . Right now there is at least one package, possibly two (LESbrary.jl and Oceanostics.jl) that can make the user's life easier when running Oceananigans. At the moment, there is no way for the user to find out that these packages exist, unless they joined the slack or stumbled upon them in an Oceananigans issue (unless I missed something in the docs). I also bet there are many other useful Julia packages that could make one's life easier in Oeananigans that I and many users have never used or heard of. I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908:101,depend,depending,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908,2,['depend'],['depending']
Integrability,"> The main downside I think is that the validation repo goes stale by design. Wouldn't JuliaRegistrator keep this from happening? ; If we list Oceananigans as a dependence, it'll create a new PR with the an updated version of Oceananigans everytime we update Oceananigans.jl, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423:161,depend,dependence,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423,1,['depend'],['dependence']
Integrability,"> The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > ; > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:. First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this. You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface. As I said though, I agree it's a good idea to make this kind of thing easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620:458,interface,interface,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620,2,['interface'],['interface']
Integrability,"> The purpose of this PR was to save mutliple scalars using `NetCDFOutputWriter` and there seemed to be some problems, i.e. some checks fail.; > ; > @glwagner mentioned that maybe `using Statistics: norm` might work without any additional work. Is this the case? If yes then I am happy to close this PR and give it a try on the shallow water Bickley jet example. Ah... the change is fairly innocuous, there's just a few things that make me nervous. 1) It _shouldn't_ fix the problem that it's intended to fix. Unless there's something I am missing... if it fixes the problem that was raised, it's due to some unintended side effect that we don't understand? (Providing some detail and the error message that was received could help, or it could be raised in an issue). A more grave concern is 2) it will slow down the code and cause memory allocation. This is almost always completely negligible since other parts of the code matter more, but it could affect small models, our CI pipeline, etc. It's hard to intentionally throw away type stability :-/ So in a way it's creating technical debt and possibly creating work for us in the future...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415:695,message,message,695,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415,1,['message'],['message']
Integrability,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816:58,integrat,integrated,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816,2,['integrat'],['integrated']
Integrability,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:342,rout,routine,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,1,['rout'],['routine']
Integrability,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:247,wrap,wrapped,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103,1,['wrap'],['wrapped']
Integrability,"> This function only works if you have a diagnostic though. I prefer to simply output the horizontal averages directly to file. How would I do that with the code in this PR?. If you don't want to use a diagnostic, you'd have to pre-allocate a 1D CuArray of size `1*1*Nz` for `Rxy` and a 2D CuArray of size `1*Ny*Nz` for `Rx`, then call `gpu_accumulate_xy!(Rxy, Rx, data, nothing, +)`, then save `Rxy` to disk. Seems like that would be less efficient as you'd have to pre-allocate memory every time you want to calculate a horizontal average. Which is why having a `VerticalProfile` diagnostic that takes care of this stuff is nice. We could write a wrapper function that allocates the arrays, and returns only the horizontal average.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786:649,wrap,wrapper,649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786,1,['wrap'],['wrapper']
Integrability,"> This is good after changes.; > ; > My only question is whether another implementation might be something like; > ; > ```julia; > function Base.:(==)(grid1::AbstractGrid, grid2::AbstractGrid); > !isa(grid2, typeof(grid1).name.wrapper) && return false; > topology(grid1) == topology(grid2) && return false; > ; > x1, y1, z1 = nodes((Face, Face, Face), grid1); > x2, y2, z2 = nodes((Face, Face, Face), grid2); > ; > return x1 == x2 && y1 == y2 && z1 == z2; > end; > ```; > ; > This has different behavior than what's implemented here. In particular, two grids will be identified as equal even if one has ""number spacing"" (eg a constant) whereas the other has array-spacing with all the values equal to that number. In other words, while; > ; > ```julia; > julia> 1.0 == ones(2); > false; > ```; > ; > we may want to identify this case with numeric equality for a grid.; > ; > The key here is that two grids are ""equal"" if they have the same nodes. The other properties (like spacings) are really implied by the placement of the nodes. OK, perhaps then your suggestion is better.; What about when two grids are otherwise the same but one lives on GPU and one on CPU. Will the above render them equal? I guess no since, e.g., `z1 == z2` will return false if one is an Array and other a CuArray.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368:227,wrap,wrapper,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368,1,['wrap'],['wrapper']
Integrability,"> This is great! Have you started a PR already to support Sparse in AMDGPU proper?. @vchuravy yes here's the PR: https://github.com/JuliaGPU/AMDGPU.jl/pull/298. We're stuck for some time since we're getting some timing issues on a couple of tests; We get incorrect results depending on the timing of the operations. Even after adding synchronization after each operation, the error still persists. Other than that they seem to work fine. @jpsamaroo can update you on that. > So this PR is to merge something on an Oceananigans.jl branch, `amdgpu`. It modifies 482 files?!; > The `amdgpu` branch is waaay outdated so as a first step perhaps we need to bring that branch up to date? I'm wondering if the seemingly proposed changes to 482 files would be much reduced if we bring `amdgpu` up to date with `main`?. @navidcy @simone-silvestri I don't have write access to this branch so you can update the branch first before reviewing the PR. This work is not yet ready to be merged yet to the main branch so we decided in the past that this might be the place for it while we test it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562:273,depend,depending,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562,2,"['depend', 'synchroniz']","['depending', 'synchronization']"
Integrability,"> This is great, though I'm wondering what it's role in the Oceananigans code base is. Is the intention to remove these bits once WENO is actually implemented in the code?. Yeah so the point of this PR was to test the WENO operators independently of Oceananigans.jl (also to play around with how advection schemes interact with different time steppers). The WENO operators were coded so that we can readily integrate them with the existing operators in `tracer_advection_operators`. So when an advection scheme abstraction is implemented and `weno.jl` is integrated into the main code, `verification/tracer_advection_1d/tracer_advection_1d.jl` can be converted into an Oceananigans.jl verification experiment. Right now it's just a WENO-5 verification experiment. > Why not?. Ah sorry I wasn't clear. I just didn't think running with CFL=4 would be possible in 3D. > I think the first course of action may be to do something similar to what we did for the nonlinear equation of state: implement a simple new advection scheme (even as simple as first order upwind?) for the purpose of designing an `Advection` abstraction. Agreed. First-order upwind is actually included in this PR; ```julia; @inline ∂x_advective_flux(i, Δx, u, ϕ, ::FirstOrderUpwind) =; max(u[i], 0) * (ϕ[i] - ϕ[i-1])/Δx + min(u[i], 0) * (ϕ[i+1] - ϕ[i])/Δx; ```; but it's so diffusive I don't know if we want to include it as an option (although it's up to the users, they may have a good reason to use first-order upwind).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751:407,integrat,integrate,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751,2,['integrat'],"['integrate', 'integrated']"
Integrability,"> This looks super cool: I'll be happy to meet for coffee and chat in person (assuming you're both at MIT) but I am not very familiar with tools in climatology* and think @meggart @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:394,interface,interface,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['interface'],['interface']
Integrability,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:694,interface,interface,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563,1,['interface'],['interface']
Integrability,"> Those animations look great @tomchor, thanks for working so hard to put this together.; > ; > One observation is that the first plot, the velocity, shows that the initial structures are very small scale in both the horizontal and the vertical. I wonder if increasing \nu would produce an aniamtion that is better resolved?. Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example. . This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. > ; > As for what to do with this, you are the creator, but I would sugget creating a doc. This is a great opportunity to show the nice results and help teach people how to use different features. By creating a doc, do you mean docs example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873:688,depend,depends,688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873,1,['depend'],['depends']
Integrability,"> To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on TimeInterval which should, in theory, work perfectly. Wouldn't the MWE I posted above work? Or do you mean a MWE that generates round-off errors at _predictable_ times? (I cannot predict when the errors will occur in the MWE above.). > Hmm and there is one more point. Round-off error is the reason we get tiny time-steps, and we should fix that. However, that would still leave open the underlying problem, which is that the pressure correction fails for machine epsilon time-steps. So I'm wondering if in fact we should fix both issues. I agree with this point, but I feel like I'm also missing something here. Let's say we change the pressure correction so that it works for machine epsilon. Won't the pressure gradient force still depend on `Δt`? That is, won't it be larger for small `Δt`s and vice-versa? If so, this implies the pressure gradient doesn't converge with `Δt` and if so, how do we close a budget where the pressure term is important? (Maybe that's a question for another place also... I don't want to derail the discussion from the specific issue at hand.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427:861,depend,depend,861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427,1,['depend'],['depend']
Integrability,"> True.; > ; > @tomchor would you be keen to add drag in the internal tide example? If you just add the code I can deal w the rest. I can, but I don't really see drag there adding value to the example. @navidcy, do you think it would be relevant to the physics? Or do we just want drag to be there as an example of using the interface?. Also, I'm not very familiar with these larger-scale, hydrostatic simulations. What's the physically-preferred way to add drag there? Does something like. ```math; \vec\tau = -C^D \vec u \sqrt{u^2+v^2}; ```; (applied to `bottom`, `west` and `east`, with $C^D \approx$ 1e-3) look reasonable?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789:325,interface,interface,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789,1,['interface'],['interface']
Integrability,"> Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`. Actually, even putting `@show ""hi""` **just before** `calculate_pressure_correction!` also does the job.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090:138,synchroniz,synchronization,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090,1,['synchroniz'],['synchronization']
Integrability,"> Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > ; > ; > ; > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > ; > ; > ; > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up. . Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though. We can calculate more metrics for sure. I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?. Here are some docs:. https://numba.pydata.org/numba-doc/latest/user/parallel.html",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990:257,depend,dependent,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990,1,['depend'],['dependent']
Integrability,"> Was it some random one-off stochastic error?. Turns out this happens on a Quadro GP100 GPU, but not on a Tesla V100. I'm using Julia 1.8.3 on NCAR's Casper server using the (current as of this message) main branch. Not sure what to do about this. Does it have to do with the Compute Capability? @navidcy which GPUs does tartarus have again?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705:195,message,message,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705,1,['message'],['message']
Integrability,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483:279,interface,interfaces,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483,1,['interface'],['interfaces']
Integrability,"> We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag.; > ; > What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at. I don't follow. You have all of that information if you simply store the `HaloFillEvents` in a vector. Maybe you can't use the ""length"" but surely you can compute the number needed, which is currently stored as a ""counter"". You can also store the pointer to the field itself rather than an ""id"" / number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287:516,rout,routine,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287,1,['rout'],['routine']
Integrability,"> We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type.; > ; > Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector). Okay, so a longer term plan. For the moment we need that `HydrostaticModel` uses traditional f- or beta-plane, or something that does the same thing. It is `NonhydrostaticModel` that will allow for more types of coriolis terms. Understood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586:118,depend,depends,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586,1,['depend'],['depends']
Integrability,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:225,depend,depends,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568,1,['depend'],['depends']
Integrability,"> We could write a wrapper function that allocates the arrays, and returns only the horizontal average. I think what would be most useful is a function that takes in a pre-allocated array, (potentially scratch space if that is needed), and an array to be averaged, and stores the result of the average in the preallocated array.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520580976:19,wrap,wrapper,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520580976,1,['wrap'],['wrapper']
Integrability,"> We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).; > ; > _Originally posted by @glwagner in [#2050 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805)_. Wouldn't it be better to have something like `Δx = grid_spacing(model.velocities.v, 1)`? Because I'm assuming the `Δx` has to change depending if they want to use it on a quantity that lies on a `Face` or `Center` node in that direction. Maybe just `Δx = grid_spacing(Face, grid, 1)`, or something akin to the already-existing `nodes` function, that returns all 3 at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357:396,depend,depending,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357,1,['depend'],['depending']
Integrability,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:941,interface,interface,941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281,1,['interface'],['interface']
Integrability,"> Well, I don't know what is long or short (but I agree, O(10mins) seems bit long). But most importantly, in my benches I find that v0.90.1 is **faster** than 0.89.3, contrary to what you claim. Do you see a difference if you wrap `ζ` in `Field`? I guess that is my major claim.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622:226,wrap,wrap,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622,1,['wrap'],['wrap']
