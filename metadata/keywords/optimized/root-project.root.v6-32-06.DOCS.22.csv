quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"FLAT_SCRATCH_LO is in units of 256 bytes, the offset must be right; shifted by 8 before moving into FLAT_SCRATCH_HI. FLAT_SCRATCH_HI corresponds to SGPRn-4 on GFX7, and SGPRn-6 on GFX8 (where; SGPRn is the highest numbered SGPR allocated to the wavefront).; FLAT_SCRATCH_HI is multiplied by 256 (as it is in units of 256 bytes) and; added to ``SH_HIDDEN_PRIVATE_BASE_VIMID`` to calculate the per wavefront; FLAT SCRATCH BASE in flat memory instructions that access the scratch; aperture.; 2. The second word of Flat Scratch Init is 32-bit byte size of a single; work-items scratch memory usage. CP obtains this from the runtime, and it is always a multiple of DWORD. CP; checks that the value in the kernel dispatch packet Private Segment Byte; Size is not larger and requests the runtime to increase the queue's scratch; size if necessary. CP directly loads from the kernel dispatch packet Private Segment Byte Size; field and rounds up to a multiple of DWORD. Having CP load it once avoids; loading it at the beginning of every wavefront. The kernel prolog code must move it to FLAT_SCRATCH_LO which is SGPRn-3 on; GFX7 and SGPRn-5 on GFX8. FLAT_SCRATCH_LO is used as the FLAT SCRATCH SIZE; in flat memory instructions. * If the *Target Properties* column of :ref:`amdgpu-processor-table`; specifies *Absolute flat scratch*:. If the kernel or any function it calls may use flat operations to access; scratch memory, the prolog code must set up the FLAT_SCRATCH register pair; (FLAT_SCRATCH_LO/FLAT_SCRATCH_HI which are in SGPRn-4/SGPRn-3). Initialization; uses Flat Scratch Init and Scratch Wavefront Offset SGPR registers (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`):. The Flat Scratch Init is the 64-bit address of the base of scratch backing; memory being managed by SPI for the queue executing the kernel dispatch. CP obtains this from the runtime. The kernel prolog must add the value of the wave's Scratch Wavefront Offset; and move the result as a 64-bit value to the FLAT_SCRAT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:196180,avoid,avoids,196180,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoids']
Safety,"FrameInfo() const {return &FrameInfo; }; virtual const TargetSubtarget *getSubtargetImpl() const{return &Subtarget; }; virtual const TargetRegisterInfo *getRegisterInfo() const {; return &InstrInfo.getRegisterInfo();; }; virtual const DataLayout *getDataLayout() const { return &DataLayout; }. // Pass Pipeline Configuration; virtual bool addInstSelector(PassManagerBase &PM, bool Fast);; virtual bool addPreEmitPass(PassManagerBase &PM, bool Fast);; };. } // end namespace llvm. * ``getInstrInfo()``; * ``getRegisterInfo()``; * ``getFrameInfo()``; * ``getDataLayout()``; * ``getSubtargetImpl()``. For some targets, you also need to support the following methods:. * ``getTargetLowering()``; * ``getJITInfo()``. Some architectures, such as GPUs, do not support jumping to an arbitrary; program location and implement branching using masked execution and loop using; special instructions around the loop body. In order to avoid CFG modifications; that introduce irreducible control flow not handled by such hardware, a target; must call `setRequiresStructuredCFG(true)` when being initialized. In addition, the ``XXXTargetMachine`` constructor should specify a; ``TargetDescription`` string that determines the data layout for the target; machine, including characteristics such as pointer size, alignment, and; endianness. For example, the constructor for ``SparcTargetMachine`` contains; the following:. .. code-block:: c++. SparcTargetMachine::SparcTargetMachine(const Module &M, const std::string &FS); : DataLayout(""E-p:32:32-f128:128:128""),; Subtarget(M, FS), InstrInfo(Subtarget),; FrameInfo(TargetFrameInfo::StackGrowsDown, 8, 0) {; }. Hyphens separate portions of the ``TargetDescription`` string. * An upper-case ""``E``"" in the string indicates a big-endian target data model.; A lower-case ""``e``"" indicates little-endian. * ""``p:``"" is followed by pointer information: size, ABI alignment, and; preferred alignment. If only two figures follow ""``p:``"", then the first; value is pointer siz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:10926,avoid,avoid,10926,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['avoid'],['avoid']
Safety,"FunctionProtos if; it doesn't find one. In ``CallExprAST::codegen()`` we just need to replace the; call to ``TheModule->getFunction()``. In ``FunctionAST::codegen()`` we need to; update the FunctionProtos map first, then call ``getFunction()``. With this; done, we can always obtain a function declaration in the current module for any; previously declared function. We also need to update HandleDefinition and HandleExtern:. .. code-block:: c++. static void HandleDefinition() {; if (auto FnAST = ParseDefinition()) {; if (auto *FnIR = FnAST->codegen()) {; fprintf(stderr, ""Read function definition:"");; FnIR->print(errs());; fprintf(stderr, ""\n"");; ExitOnErr(TheJIT->addModule(; ThreadSafeModule(std::move(TheModule), std::move(TheContext))));; InitializeModuleAndPassManager();; }; } else {; // Skip token for error recovery.; getNextToken();; }; }. static void HandleExtern() {; if (auto ProtoAST = ParseExtern()) {; if (auto *FnIR = ProtoAST->codegen()) {; fprintf(stderr, ""Read extern: "");; FnIR->print(errs());; fprintf(stderr, ""\n"");; FunctionProtos[ProtoAST->getName()] = std::move(ProtoAST);; }; } else {; // Skip token for error recovery.; getNextToken();; }; }. In HandleDefinition, we add two lines to transfer the newly defined function to; the JIT and open a new module. In HandleExtern, we just need to add one line to; add the prototype to FunctionProtos. .. warning::; Duplication of symbols in separate modules is not allowed since LLVM-9. That means you can not redefine function in your Kaleidoscope as its shown below. Just skip this part. The reason is that the newer OrcV2 JIT APIs are trying to stay very close to the static and dynamic linker rules, including rejecting duplicate symbols. Requiring symbol names to be unique allows us to support concurrent compilation for symbols using the (unique) symbol names as keys for tracking. With these changes made, let's try our REPL again (I removed the dump of the; anonymous functions this time, you should get the idea by now ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:20668,recover,recovery,20668,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['recover'],['recovery']
Safety,"GC intrinsic lowering; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. As a part of lowering to the explicit model of relocations; RewriteStatepointsForGC performs GC specific lowering for the following; intrinsics:. * ``gc.get.pointer.base``; * ``gc.get.pointer.offset``; * ``llvm.memcpy.element.unordered.atomic.*``; * ``llvm.memmove.element.unordered.atomic.*``. There are two possible lowerings for the memcpy and memmove operations:; GC leaf lowering and GC parseable lowering. If a call is explicitly marked with; ""gc-leaf-function"" attribute the call is lowered to a GC leaf call to; '``__llvm_memcpy_element_unordered_atomic_*``' or; '``__llvm_memmove_element_unordered_atomic_*``' symbol. Such a call can not; take a safepoint. Otherwise, the call is made GC parseable by wrapping the; call into a statepoint. This makes it possible to take a safepoint during; copy operation. Note that a GC parseable copy operation is not required to; take a safepoint. For example, a short copy operation may be performed without; taking a safepoint. GC parseable calls to '``llvm.memcpy.element.unordered.atomic.*``',; '``llvm.memmove.element.unordered.atomic.*``' intrinsics are lowered to calls; to '``__llvm_memcpy_element_unordered_atomic_safepoint_*``',; '``__llvm_memmove_element_unordered_atomic_safepoint_*``' symbols respectively.; This way the runtime can provide implementations of copy operations with and; without safepoints. GC parseable lowering also involves adjusting the arguments for the call.; Memcpy and memmove intrinsics take derived pointers as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in the copy operation. In order to make the base; pointers available RewriteStatepointsForGC replaces derived pointers with base; pointer and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:30317,safe,safepoint,30317,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"I complicates interoperability with external code that has; not adopted the same programming model. ``-fbounds-safety`` harmonizes the wide pointer and the bounds annotation; approaches to reduce the adoption burden while maintaining the ABI. In this; model, local variables of pointer type are implicitly treated as wide pointers,; allowing them to carry bounds information without requiring explicit bounds; annotations. Please note that this approach doesn't apply to function parameters; which are considered ABI-visible. As local variables are typically hidden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can operate without modifications within this; programming model, reducing the adoption burden. The rest of the section will discuss individual bounds annotations and the; programming model in more detail. Bounds annotations; ------------------. Annotation for pointers to a single object; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The C language allows pointer arithmetic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is ei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:6697,safe,safety,6697,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"IRgen optimization opportunities. //===---------------------------------------------------------------------===//. The common pattern of; --; short x; // or char, etc; (x == 10); --; generates an zext/sext of x which can easily be avoided. //===---------------------------------------------------------------------===//. Bitfields accesses can be shifted to simplify masking and sign; extension. For example, if the bitfield width is 8 and it is; appropriately aligned then is is a lot shorter to just load the char; directly. //===---------------------------------------------------------------------===//. It may be worth avoiding creation of alloca's for formal arguments; for the common situation where the argument is never written to or has; its address taken. The idea would be to begin generating code by using; the argument directly and if its address is taken or it is stored to; then generate the alloca and patch up the existing code. In theory, the same optimization could be a win for block local; variables as long as the declaration dominates all statements in the; block. NOTE: The main case we care about this for is for -O0 -g compile time; performance, and in that scenario we will need to emit the alloca; anyway currently to emit proper debug info. So this is blocked by; being able to emit debug information which refers to an LLVM; temporary, not an alloca. //===---------------------------------------------------------------------===//. We should try and avoid generating basic blocks which only contain; jumps. At -O0, this penalizes us all the way from IRgen (malloc &; instruction overhead), all the way down through code generation and; assembly time. On 176.gcc:expr.ll, it looks like over 12% of basic blocks are just; direct branches!. //===---------------------------------------------------------------------===//; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt:231,avoid,avoided,231,interpreter/llvm-project/clang/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt,3,['avoid'],"['avoid', 'avoided', 'avoiding']"
Safety,"IT license.; Works out of the box while civetweb version fully corresponds to; previously used version of mongoose.; - Introduce TBufferJSON class to store arbitrary ROOT object; into JSON format. It is not one-to-one storage (like XML), but; rather JS-like structures. For instance, all TCollections converted; into JavaScript Array. Produced JS object is similar to JSRootIO.; - Process get.json request, which returns object in JSON form.; It can be used directly is script without special I/O of Bertrand.; - Use get.json on browser side to simplify logic. No need for extra; requests for streamer infos.; - Process get.xml request, provide full object streaming via TBufferXML.; It is complete object data, but with many custom-streamer data.; - Significant redesign of I/O part of JSRootIO code. Main change -; introduce JSROOTIO.TBuffer class which has similar functionality as; original TBufferFile class. Eliminate many places with duplicated code; - In JSRootIO avoid objects cloning when object referenced several times; - Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes should be implemented once.; - Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; - More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; - Eliminate usage of gFile pointer in the I/O part.; - Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are: basic data types,; arrays of basic data types, TString, TArray classes. Also any object; as data member can be streamed.; - TRootSniffer do not creates sublevels for base classes; - When streaming data member, TBufferJSON produces array with all dimensions; only when fCompact==0. By default, THtt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:2996,avoid,avoid,2996,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['avoid'],['avoid']
Safety,"If ``--enable-var-scope`` is in effect, all local variables are cleared at the; beginning of the block. For example,. .. code-block:: llvm. define %struct.C* @C_ctor_base(%struct.C* %this, i32 %x) {; entry:; ; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; failures to be detected in a single invocation. There is no requirement that ``CHECK-LABEL:`` directives contain strings that; correspond to actual syntactic labels in a source or output language: they must; simply uniquely match a single line in the file being verified. ``CHECK-LABEL:`` directives cannot contain variable definitions or uses. Directive modifiers; ~~~~~~~~~~~~~~~~~~~. A directive modifier can be append to a directive by following the directive; with ``{<modifier>}`` where the only supported value for ``<modifier>`` is; ``LITERAL``. The ``LITERAL`` directive modifier can be used to perform a literal match. The; modifier results in the directive not recognizing any syntax to perform regex; matching, variable capture or any substitutions. This is useful when the text; to match would require excessive escaping otherwise. For example, the; following will perform literal matches rather than considering these as; regular express",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:23307,recover,recover,23307,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,2,"['detect', 'recover']","['detected', 'recover']"
Safety,"Inst``; ^^^^^^^^^^^^^^^^^^. Invoke instruction may have branch weight metadata with one or two weights.; The second weight is optional and corresponds to the unwind branch.; If only one weight is set then it contains the execution count of the call; and used in SamplePGO mode only as described for the call instruction. If both; weights are specified then the second weight contains count of unwind branch; taken and the first weights contains the execution count of the call minus; the count of unwind branch taken. Both weights specified are used to calculate; BranchProbability as for BranchInst and for SamplePGO the sum of both weights; is used. .. code-block:: none. !0 = !{; !""branch_weights"",; i32 <INVOKE_NORMAL_WEIGHT>; [ , i32 <INVOKE_UNWIND_WEIGHT> ]; }. Other; ^^^^^. Other terminator instructions are not allowed to contain Branch Weight Metadata. .. _\__builtin_expect:. Built-in ``expect`` Instructions; ================================. ``__builtin_expect(long exp, long c)`` instruction provides branch prediction; information. The return value is the value of ``exp``. It is especially useful in conditional statements. Currently Clang supports two; conditional statements:. ``if`` statement; ^^^^^^^^^^^^^^^^. The ``exp`` parameter is the condition. The ``c`` parameter is the expected; comparison value. If it is equal to 1 (true), the condition is likely to be; true, in other case condition is likely to be false. For example:. .. code-block:: c++. if (__builtin_expect(x > 0, 1)) {; // This block is likely to be taken.; }. ``switch`` statement; ^^^^^^^^^^^^^^^^^^^^. The ``exp`` parameter is the value. The ``c`` parameter is the expected; value. If the expected value doesn't show on the cases list, the ``default``; case is assumed to be likely taken. .. code-block:: c++. switch (__builtin_expect(x, 5)) {; default: break;; case 0: // ...; case 3: // ...; case 5: // This case is likely to be taken.; }. .. _\__builtin_expect_with_probability:. Built-in ``expect.with.pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst:2891,predict,prediction,2891,interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,1,['predict'],['prediction']
Safety,"LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifying references in global locations (e.g. global; variables). #. If you collector requires them, an LLVM IR implementation of your collectors; load and store barriers. Note that since many collectors don't require; barriers at all, LLVM defaults to lowering such barriers to normal loads; and stores unless you arrange otherwise. Implementing a collector plugin; -------------------------------. User code specifies which GC code generation to use with the ``gc`` function; attribute or, equivalently, with the ``setGC`` method of ``Function``. To implement a GC plugin, it is necessary to subclass ``llvm::GCStrategy``,; which can be accomplished in a few lines of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:22667,safe,safepoint,22667,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safepoint']
Safety,"LL_GWP_ASAN_STUBS; gwp_asan::GuardedPoolAllocator GWPASanAllocator;; #endif. void* YourAllocator::malloc(..) {; #ifdef INSTALL_GWP_ASAN_STUBS; if (GWPASanAllocator.shouldSample(..)); return GWPASanAllocator.allocate(..);; #endif. // ... the rest of your allocator code here.; }. Then, all the supporting allocator needs to do is compile with; ``-DINSTALL_GWP_ASAN_STUBS`` and link against the GWP-ASan library! For; performance reasons, we strongly recommend static linkage of the GWP-ASan; library. Guarded Allocation Pool; -----------------------. The core of GWP-ASan is the guarded allocation pool. Each sampled allocation is; backed using its own *guarded* slot, which may consist of one or more accessible; pages. Each guarded slot is surrounded by two *guard* pages, which are mapped as; inaccessible. The collection of all guarded slots makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transien",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:3642,detect,detection,3642,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"LUE %4, $noreg, !3, !4; %7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags; DBG_VALUE %7, $noreg, !5, !6; %1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1); DBG_VALUE %1, $noreg, !1, !2. Here, to avoid presenting a state in which the first assignment to ``!1``; disappears, the DBG_VALUE at the top of the block assigns the variable the; undefined location, until its value is available at the end of the block where; an additional DBG_VALUE is added. Were any other DBG_VALUE for ``!1`` to occur; in the instructions that the MOV32rm was sunk past, the DBG_VALUE for ``%1``; would be dropped and the debugger would never observe it in the variable. This; accurately reflects that the value is not available during the corresponding; portion of the original program. Variable locations during Register Allocation; ---------------------------------------------. To avoid debug instructions interfering with the register allocator, the; LiveDebugVariables pass extracts variable locations from a MIR function and; deletes the corresponding DBG_VALUE instructions. Some localized copy; propagation is performed within blocks. After register allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations. To avoid encoding incorrect variable locations, in this; pass any DBG_VALUE of a virtual register that is not live, is replaced by; the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs; because of virtual register rewriting. These will be subsequently removed by; the RemoveRedundantDebugValues pass. LiveDebugValues expansion of variable locations; -----------------------------------------------. After all optimizations have run and shortly before emission, the; LiveDebugValues pass runs to achieve two aims:. * To propagate the location of variables through copies and register spills,; * For every block, to r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:35653,avoid,avoid,35653,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"M+14.0.5+Release%22+no%3Aproject+. Replace 14.0.5 in this query with the version from the Release Milestone being; targeted. Add these bugs to the ""Release Status"" project. #. Navigate to the `Release Status project <https://github.com/orgs/llvm/projects/3>`_; to see the list of bugs that are being considered for the release. #. Review each bug and first check if it has been fixed in main. If it has, update; its status to ""Needs Pull Request"", and create a pull request for the fix; using the /cherry-pick or /branch comments if this has not been done already. #. If a bug has been fixed and has a pull request created for backporting it,; then update its status to ""Needs Review"" and notify a knowledgeable reviewer.; Usually you will want to notify the person who approved the patch in Phabricator,; but you may use your best judgement on who a good reviewer would be. Once; you have identified the reviewer(s), assign the issue to them and mention; them (i.e @username) in a comment and ask them if the patch is safe to backport.; You should also review the bug yourself to ensure that it meets the requirements; for committing to the release branch. #. Once a bug has been reviewed, add the release:reviewed label and update the; issue's status to ""Needs Merge"". Check the pull request associated with the; issue. If all the tests pass, then the pull request can be merged. If not,; then add a comment on the issue asking someone to take a look at the failures. #. Once the pull request has been merged push it to the official release branch; with the script ``llvm/utils/git/sync-release-repo.sh``. Then add a comment to the issue stating that the fix has been merged along with; the git hashes from the release branch. Add the release:merged label to the issue; and close it. Release Patch Rules; -------------------. Below are the rules regarding patching the release branch:. #. Patches applied to the release branch may only be applied by the release; manager, the official release teste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:11677,safe,safe,11677,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['safe'],['safe']
Safety,"Make sure the line width used to draw `#sqrt` is always >= 1. When a global text alignment was set the `TLatex`characters `#minus`, `#plus`,; `#mp`, `#hbar`, and `#backslash` were mis-aligned. The following macro demonstrate; the problem:. ``` {.cpp}; {; gStyle->SetTextAlign(22);; TLatex t(.5,.5,""#minus100 #mp100 #plus100 #hbar #backslash"");; t.Draw();; }; ```. The angle of a `TLatex` object was set to 0 if the `GetYsize` method was called. ### TColor. New palette `kViridis`. It was presented at SciPy2015 by Stéfan van der Walt and; Nathaniel Smith. It is now matplotlib's current default color map. ![Viridis](palette_112.png). ### TMultiGraph. Ignore empty graphs when computing the multi-graph range at painting time. ### TASImage. A left click on a image produced a one pixel zoom. ### TCreatePrimitives. The ending of a polyline creation is based on the closeness of the two last; entered points. The previous algorithm was based on user coordinates. It is now; based on pixel to avoid the problem reported; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20343). ### TCanvas. When the first canvas created by ROOT was in batch mode, it was note possible to; come back in interactive mode for the next canvases. this problem was reported; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20354). ### Cocoa Backend. Sometimes the mouse cursor did not change back to the window manager arrow when; exiting a `TCanvas`. ### `freetype` library. Updates `builtin_freetype` to 2.6.1 (current upstream version), which can detect; `PPC64LE` machine. This was compiled and tested on `SLC6 + ICC + x86_64`,; `F21 + GCC + ppc64le`, `MacOSX 10.11.1 + Xcode 7.1` and `Windows (ROOT 5.34)`.; `$ROOTSYS/graf2d/freetype/src/README` was removed, because no issues were noticed; with `ICC` compiler and `-Wall -pedantic -ansi` flags.; Additionally `--with-png=no --with-bzip2=no` flags are passed to freetype; configuration script. Default values for these options are auto.; `freetype` finds `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:17066,avoid,avoid,17066,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['avoid'],['avoid']
Safety,"Math Libraries. ## RooFit Libraries. - A fix has been added in the component selection, which is used for plotting simultaneous models. See [PR #2033](https://github.com/root-project/root/pull/2033). ## TMVA Library. #### New Deep Learning Module. - TMVA contains a new set of Deep Learning classes ( `MethodDL` ), with support, in addition to dense layer, also convolutional and recurrent layer. . #### Other New TMVA Features. - Support for Parallelization of BDT using Multi-Threads; - Several improvements in Cross Validation including support for Multi-Process cross-validation running. . ## 2D Graphics Libraries; - `TMultiGraph::GetHistogram` now works even if the multigraph is not drawn. Make sure; it never returns a null pointer.; - X11 line `width = 0` doesn't work on OpenSuSE Thumbleweed for non solid lines. Now fixed.; - TCanvas::SetWindowsSize has been changed to get the same window size in interactive mode…and batch mode.; - Change the `TGraph` default fill color to white to avoid black box in legend; when `gPad->BuildLegend()` is called.; - Auto-coloring for TF1 (drawing options PFC, PLC and PMC) is implemented.; - Auto-coloring for TH1::DrawCopy (drawing options PFC, PLC and PMC) is implemented.; - Improve the option management in `TF1::Draw` to allow to combine the option; `SAME` with other drawing options.; - `TGraph::Draw(""AB"")` was malfunctioning when using `TAxis::SetRangeUser`.; It was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-9144).; - The errors end-caps size in `TLegend` follows the value set by `gStyle->SetEndErrorSize()`.; For instance setting it to 0 allows to remove the end-caps both on the graph and the legend.; It was requested [here](https://sft.its.cern.ch/jira/browse/ROOT-9184); - New color palette ""cividis"" implemented by Sven Augustin.; This colormap aims to solve problems that people with color vision deficiency have; with the common colormaps. For more details see:; Nuñez J, Anderton C, and Renslow R. Optimizing colormaps ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:12301,avoid,avoid,12301,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoid']
Safety,"N and ``op1``; is less than or equal to ``op2``.; #. ``one``: yields ``true`` if both operands are not a QNAN and ``op1``; is not equal to ``op2``.; #. ``ord``: yields ``true`` if both operands are not a QNAN.; #. ``ueq``: yields ``true`` if either operand is a QNAN or ``op1`` is; equal to ``op2``.; #. ``ugt``: yields ``true`` if either operand is a QNAN or ``op1`` is; greater than ``op2``.; #. ``uge``: yields ``true`` if either operand is a QNAN or ``op1`` is; greater than or equal to ``op2``.; #. ``ult``: yields ``true`` if either operand is a QNAN or ``op1`` is; less than ``op2``.; #. ``ule``: yields ``true`` if either operand is a QNAN or ``op1`` is; less than or equal to ``op2``.; #. ``une``: yields ``true`` if either operand is a QNAN or ``op1`` is; not equal to ``op2``.; #. ``uno``: yields ``true`` if either operand is a QNAN.; #. ``true``: always yields ``true``, regardless of operands. The ``fcmp`` instruction can also optionally take any number of; :ref:`fast-math flags <fastmath>`, which are optimization hints to enable; otherwise unsafe floating-point optimizations. Any set of fast-math flags are legal on an ``fcmp`` instruction, but the; only flags that have any effect on its semantics are those that allow; assumptions to be made about the values of input arguments; namely; ``nnan``, ``ninf``, and ``reassoc``. See :ref:`fastmath` for more information. Example:; """""""""""""""". .. code-block:: text. <result> = fcmp oeq float 4.0, 5.0 ; yields: result=false; <result> = fcmp one float 4.0, 5.0 ; yields: result=true; <result> = fcmp olt float 4.0, 5.0 ; yields: result=true; <result> = fcmp ueq double 1.0, 2.0 ; yields: result=false. .. _i_phi:. '``phi``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = phi [fast-math-flags] <ty> [ <val0>, <label0>], ... Overview:; """""""""""""""""". The '``phi``' instruction is used to implement the φ node in the SSA; graph representing the function. Arguments:; """""""""""""""""""". The type of the incoming values is specified ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:466285,unsafe,unsafe,466285,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"OL), C string pointer; and some C structures (via NSValue) are supported:. .. code-block:: objc. // numbers.; NSNumber *smallestInt = @(-INT_MAX - 1); // [NSNumber numberWithInt:(-INT_MAX - 1)]; NSNumber *piOverTwo = @(M_PI / 2); // [NSNumber numberWithDouble:(M_PI / 2)]. // enumerated types.; typedef enum { Red, Green, Blue } Color;; NSNumber *favoriteColor = @(Green); // [NSNumber numberWithInt:((int)Green)]. // strings.; NSString *path = @(getenv(""PATH"")); // [NSString stringWithUTF8String:(getenv(""PATH""))]; NSArray *pathComponents = [path componentsSeparatedByString:@"":""];. // structs.; NSValue *center = @(view.center); // Point p = view.center;; // [NSValue valueWithBytes:&p objCType:@encode(Point)];; NSValue *frame = @(view.frame); // Rect r = view.frame;; // [NSValue valueWithBytes:&r objCType:@encode(Rect)];. Boxed Enums; -----------. Cocoa frameworks frequently define constant values using *enums.*; Although enum values are integral, they may not be used directly as; boxed literals (this avoids conflicts with future ``'@'``-prefixed; Objective-C keywords). Instead, an enum value must be placed inside a; boxed expression. The following example demonstrates configuring an; ``AVAudioRecorder`` using a dictionary that contains a boxed enumeration; value:. .. code-block:: objc. enum {; AVAudioQualityMin = 0,; AVAudioQualityLow = 0x20,; AVAudioQualityMedium = 0x40,; AVAudioQualityHigh = 0x60,; AVAudioQualityMax = 0x7F; };. - (AVAudioRecorder *)recordToFile:(NSURL *)fileURL {; NSDictionary *settings = @{ AVEncoderAudioQualityKey : @(AVAudioQualityMax) };; return [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:NULL];; }. The expression ``@(AVAudioQualityMax)`` converts ``AVAudioQualityMax``; to an integer type, and boxes the value accordingly. If the enum has a; :ref:`fixed underlying type <objc-fixed-enum>` as in:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; NSNumber *red = @(Red), *green = @(Green), *blue =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:5380,avoid,avoids,5380,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['avoid'],['avoids']
Safety,"O`_; * `PARAMATTR_BLOCK`_; * `PARAMATTR_GROUP_BLOCK`_; * `TYPE_BLOCK`_; * `VALUE_SYMTAB_BLOCK`_; * `CONSTANTS_BLOCK`_; * `FUNCTION_BLOCK`_; * `METADATA_BLOCK`_. .. _MODULE_CODE_VERSION:. MODULE_CODE_VERSION Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[VERSION, version#]``. The ``VERSION`` record (code 1) contains a single value indicating the format; version. Versions 0, 1 and 2 are supported at this time. The difference between; version 0 and 1 is in the encoding of instruction operands in; each `FUNCTION_BLOCK`_. In version 0, each value defined by an instruction is assigned an ID; unique to the function. Function-level value IDs are assigned starting from; ``NumModuleValues`` since they share the same namespace as module-level; values. The value enumerator resets after each function. When a value is; an operand of an instruction, the value ID is used to represent the operand.; For large functions or large modules, these operand values can be large. The encoding in version 1 attempts to avoid large operand values; in common cases. Instead of using the value ID directly, operands are; encoded as relative to the current instruction. Thus, if an operand; is the value defined by the previous instruction, the operand; will be encoded as 1. For example, instead of. .. code-block:: none. #n = load #n-1; #n+1 = icmp eq #n, #const0; br #n+1, label #(bb1), label #(bb2). version 1 will encode the instructions as. .. code-block:: none. #n = load #1; #n+1 = icmp eq #1, (#n+1)-#const0; br #1, label #(bb1), label #(bb2). Note in the example that operands which are constants also use; the relative encoding, while operands like basic block labels; do not use the relative encoding. Forward references will result in a negative value.; This can be inefficient, as operands are normally encoded; as unsigned VBRs. However, forward references are rare, except in the; case of phi instructions. For phi instructions, operands are encoded as; `Signed VBRs`_ to deal with forward references. In versi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:23911,avoid,avoid,23911,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['avoid'],['avoid']
Safety,"Object V3 Kernel Descriptor; ++++++++++++++++++++++++++++++++. CP microcode requires the Kernel descriptor to be allocated on 64-byte; alignment. The fields used by CP for code objects before V3 also match those specified in; :ref:`amdgpu-amdhsa-kernel-descriptor-v3-table`. .. table:: Code Object V3 Kernel Descriptor; :name: amdgpu-amdhsa-kernel-descriptor-v3-table. ======= ======= =============================== ============================; Bits Size Field Name Description; ======= ======= =============================== ============================; 31:0 4 bytes GROUP_SEGMENT_FIXED_SIZE The amount of fixed local; address space memory; required for a work-group; in bytes. This does not; include any dynamically; allocated local address; space memory that may be; added when the kernel is; dispatched.; 63:32 4 bytes PRIVATE_SEGMENT_FIXED_SIZE The amount of fixed; private address space; memory required for a; work-item in bytes. When; this cannot be predicted,; code object v4 and older; sets this value to be; higher than the minimum; requirement.; 95:64 4 bytes KERNARG_SIZE The size of the kernarg; memory pointed to by the; AQL dispatch packet. The; kernarg memory is used to; pass arguments to the; kernel. * If the kernarg pointer in; the dispatch packet is NULL; then there are no kernel; arguments.; * If the kernarg pointer in; the dispatch packet is; not NULL and this value; is 0 then the kernarg; memory size is; unspecified.; * If the kernarg pointer in; the dispatch packet is; not NULL and this value; is not 0 then the value; specifies the kernarg; memory size in bytes. It; is recommended to provide; a value as it may be used; by CP to optimize making; the kernarg memory; visible to the kernel; code. 127:96 4 bytes Reserved, must be 0.; 191:128 8 bytes KERNEL_CODE_ENTRY_BYTE_OFFSET Byte offset (possibly; negative) from base; address of kernel; descriptor to kernel's; entry point instruction; which must be 256 byte; aligned.; 351:272 20 Reserved, must be 0.; bytes;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:159127,predict,predicted,159127,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['predict'],['predicted']
Safety,"OfFile:options:error:] will fail if the file; doesn't exist, but there's no way to check for that in advance. This means; you're really in (2).); If you're in (5), document it, then figure out if you're now in (2), (3), or; (4). :-); Q: How do I tell the analyzer that I am intentionally violating nullability?; In some cases, it may make sense for methods to intentionally violate; nullability. For example, your method may — for reasons of backward; compatibility — chose to return nil and log an error message in a method; with a non-null return type when the client violated a documented precondition; rather than check the precondition with NSAssert(). In these cases, you; can suppress the analyzer warning with a cast:. return (id _Nonnull)nil;. Note that this cast does not affect code generation. Q: The analyzer assumes that a loop body is never entered. How can I tell it that the loop body will be entered at least once?. In the contrived example above, the analyzer has detected that the body of; the loop is never entered for the case where length <= 0. In this; particular example, you may know that the loop will always be entered because; the input parameter length will be greater than zero in all calls to this; function. You can teach the analyzer facts about your code as well as document; it by using assertions. By adding assert(length > 0) in the beginning; of the function, you tell the analyzer that your code is never expecting a zero; or a negative value, so it won't need to test the correctness of those paths. int foo(int length) {; int x = 0;; assert(length > 0);; for (int i = 0; i < length; i++); x += 1;; return length/x;; }. Q: How can I suppress a specific analyzer warning?; When you encounter an analyzer bug/false positive, check if it's one of the; issues discussed above or if the analyzer; annotations can; resolve the issue by helping the static analyzer understand the code better.; Second, please report it to help us improve; user experience.; Sometimes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:7362,detect,detected,7362,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['detect'],['detected']
Safety,"On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-party source; code imported into the tree. Generally, our preference is for standards; conforming, modern, and portable C++ code as the implementation language of; choice. For automation, build-systems and utility scripts Python is preferred and; is widely used in the LLVM repository already. C++ Standard Versions; ---------------------. Unless otherwise documented, LLVM subprojects are written using standard C++17; code and avoid unnecessary vendor-specific extensions. Nevertheless, we restrict ourselves to features which are available in the; major toolchains supported as host compilers (see :doc:`GettingStarted` page,; section `Software`). Each toolchain provides a good reference for what it accepts:. * Clang: https://clang.llvm.org/cxx_status.html. * libc++: https://libcxx.llvm.org/Status/Cxx17.html. * GCC: https://gcc.gnu.org/projects/cxx-status.html#cxx17. * libstdc++: https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2017. * MSVC: https://msdn.microsoft.com/en-us/library/hh567368.aspx. C++ Standard Library; --------------------. Instead of implementing custom data structures, we encourage the use of C++; standard library facilities or LLVM support libraries whenever they are; available for a particular task. LLVM and related projects emphasize and rely; on the standard library facilities and the LLVM support libraries as much as; possible. LLVM support libr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:2430,avoid,avoid,2430,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html>. - ROOT Reference Guide. - <http://root.cern.ch/root/Reference.html>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:15171,timeout,timeout,15171,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['timeout'],['timeout']
Safety,"Patches applied to the release branch may only be applied by the release; manager, the official release testers or the code owners with approval from; the release manager. #. Release managers are encouraged, but not required, to get approval from code; owners before approving patches. If there is no code owner or the code owner; is unreachable then release managers can ask approval from patch reviewers or; other developers active in that area. #. *Before RC1* Patches should be limited to bug fixes, important optimization; improvements, or completion of features that were started before the branch; was created. As with all phases, release managers and code owners can reject; patches that are deemed too invasive. #. *Before RC2* Patches should be limited to bug fixes or backend specific; improvements that are determined to be very safe. #. *Before RC3/Final Major Release* Patches should be limited to critical; bugs or regressions. #. *Bug fix releases* Patches should be limited to bug fixes or very safe; and critical performance improvements. Patches must maintain both API and; ABI compatibility with the previous major release. Release Final Tasks; -------------------. The final stages of the release process involves tagging the ""final"" release; branch, updating documentation that refers to the release, and updating the; demo page. Update Documentation; ^^^^^^^^^^^^^^^^^^^^. Review the documentation in the release branch and ensure that it is up; to date. The ""Release Notes"" must be updated to reflect new features, bug; fixes, new known issues, and changes in the list of supported platforms.; The ""Getting Started Guide"" should be updated to reflect the new release; version number tag available from Subversion and changes in basic system; requirements. .. _tag:. Tag the LLVM Final Release; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Tag the final release sources:. ::. $ git tag -sa llvmorg-X.Y.Z; $ git push https://github.com/llvm/llvm-project.git llvmorg-X.Y.Z. Update the LLVM Website",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:13561,safe,safe,13561,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['safe'],['safe']
Safety,"Ptr;; entry->BindValue(ptToken, ptVoidSharedPtr);. // Option 3: type unsafe, application owns the object; void *ptVoidPtr;; entry->BindRawPtr(ptToken, ptVoidPtr);. // Option 4: switch back from application-provided object to RNTuple-created object; entry->EmplaceNewValue(ptToken);. // For all options: use an explicit entry; reader->LoadEntry(0, *entry);; ```. Walkthrough: Writing Data; -------------------------. ```c++; auto model = RNTupleModel::Create();; // Add a field to the model and return the shared pointer for that field in the model's default entry.; auto ptrPt = model->MakeField<float>(""pt"");. auto file = std::make_unique<TFile>(""data.root"", ""APPEND"");; // The writer creates a page sink and connects the model's fields to it; auto writer = RNTupleWriter::Append(std::move(model), ""ntpl"", *file);; *ptrPt = 1.0;; // Append the model's default entry; writer->Fill();; // Commit the dataset by destructing the writer; writer.reset();; ```. The points on object type-safety and ownership apply in the same way as for reading data. Creation of the RNTuple model can use runtime type information:. ```c++; auto model = RNTupleModel::Create();; model->AddField(RFieldBase::Create(""pt"", ""float"").Unwrap());; ```. Main Classes; ------------. ### RNTuple; The RNTuple class contains the information of the RNTuple anchor in a ROOT file (see specification).; It has a dictionary and is streamed through the standard ROOT I/O.; An RNTuple object represents an RNTuple dataset but it is not the dataset itself.; It can be used like a token to open the actual RNTuple dataset with, e.g., RDF or an RNTupleReader,; and it provides the `Merge(...)` interface for the `TFileMerger`. ### RPageSource / Sink; The page source and sink can read and write pages and clusters from and to a storage backend.; There are concrete class implementations for an RNTuple stored in a ROOT file (local or remote), and for an RNTuple stored in a DAOS object store.; There is a virtual page sink for buffered writes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:5009,safe,safety,5009,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['safe'],['safety']
Safety,"RNTuple Introduction; ====================. RNTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:251,safe,safe,251,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['safe'],['safe']
Safety,"ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ; Fix a problem in the assignment operator of the ROOT::Math::PxPyPzM4D class. Avoid having nan when converting for example from PxPyPzME4D to PxPyPzM4D when the mass is negative. ; Throw always exception in the non-supported setters (i.e. SetPt on a PxPyPzEVector) methods, which are generated only for the CINT dictionary. These methods flag a compiled-error when running in C++ mode. SMatrix. Change implementation of the SMatrix::Invert and SMatrix::Inverse methods. Now the optimized method based on the Cramer rule is used only for matrix up to sizes 2x2. The standard methods based on LU (for ordinary squar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:4183,avoid,avoids,4183,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['avoid'],['avoids']
Safety,"Range = NSMakeRange(0, [s1 length]);; return [s1 compare:s2 options:comparisonOptions; range:string1Range locale:currentLocale];; }];; NSLog(@""sorted: %@"", sorted);. This code relies on an implicit conversion from the type of the lambda; expression (an unnamed, local class type called the *closure type*) to the; corresponding block pointer type. The conversion itself is expressed by a; conversion operator in that closure type that produces a block pointer with the; same signature as the lambda itself, e.g.,. .. code-block:: objc. operator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscriptin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:76638,avoid,avoids,76638,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoids']
Safety,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7086,safe,safe,7086,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,['safe'],['safe']
Safety,"SSA; graph representing the function. Arguments:; """""""""""""""""""". The type of the incoming values is specified with the first type field.; After this, the '``phi``' instruction takes a list of pairs as; arguments, with one pair for each predecessor basic block of the current; block. Only values of :ref:`first class <t_firstclass>` type may be used as; the value arguments to the PHI node. Only labels may be used as the; label arguments. There must be no non-phi instructions between the start of a basic block; and the PHI instructions: i.e. PHI instructions must be first in a basic; block. For the purposes of the SSA form, the use of each incoming value is; deemed to occur on the edge from the corresponding predecessor block to; the current block (but after any definition of an '``invoke``'; instruction's return value on the same edge). The optional ``fast-math-flags`` marker indicates that the phi has one; or more :ref:`fast-math-flags <fastmath>`. These are optimization hints; to enable otherwise unsafe floating-point optimizations. Fast-math-flags; are only valid for phis that return a floating-point scalar or vector; type, or an array (nested to any depth) of floating-point scalar or vector; types. Semantics:; """""""""""""""""""". At runtime, the '``phi``' instruction logically takes on the value; specified by the pair corresponding to the predecessor basic block that; executed just prior to the current block. Example:; """""""""""""""". .. code-block:: llvm. Loop: ; Infinite loop that counts from 0 on up...; %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]; %nextindvar = add i32 %indvar, 1; br label %Loop. .. _i_select:. '``select``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = select [fast-math flags] selty <cond>, <ty> <val1>, <ty> <val2> ; yields ty. selty is either i1 or {<N x i1>}. Overview:; """""""""""""""""". The '``select``' instruction is used to choose one value based on a; condition, without IR-level branching. Arguments:; """""""""""""""""""". The '``s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:468129,unsafe,unsafe,468129,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"SUnit) to simulate the speculative; execution of loads and stores. Each load (or store) consumes an entry in the load (or store) queue. Users can; specify flags ``-lqueue`` and ``-squeue`` to limit the number of entries in the; load and store queues respectively. The queues are unbounded by default. The LSUnit implements a relaxed consistency model for memory loads and stores.; The rules are:. 1. A younger load is allowed to pass an older load only if there are no; intervening stores or barriers between the two loads.; 2. A younger load is allowed to pass an older store provided that the load does; not alias with the store.; 3. A younger store is not allowed to pass an older store.; 4. A younger store is not allowed to pass an older load. By default, the LSUnit optimistically assumes that loads do not alias; (`-noalias=true`) store operations. Under this assumption, younger loads are; always allowed to pass older stores. Essentially, the LSUnit does not attempt; to run any alias analysis to predict when loads and stores do not alias with; each other. Note that, in the case of write-combining memory, rule 3 could be relaxed to; allow reordering of non-aliasing store operations. That being said, at the; moment, there is no way to further relax the memory model (``-noalias`` is the; only option). Essentially, there is no option to specify a different memory; type (e.g., write-back, write-combining, write-through; etc.) and consequently; to weaken, or strengthen, the memory model. Other limitations are:. * The LSUnit does not know when store-to-load forwarding may occur.; * The LSUnit does not know anything about cache hierarchy and memory types.; * The LSUnit does not know how to identify serializing operations and memory; fences. The LSUnit does not attempt to predict if a load or store hits or misses the L1; cache. It only knows if an instruction ""MayLoad"" and/or ""MayStore."" For; loads, the scheduling model provides an ""optimistic"" load-to-use latency (which; usually",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:40403,predict,predict,40403,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['predict'],['predict']
Safety,"SVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""); set(LIT_COMMAND ""${LLVM_LIT}"" CACHE STRING ""Path to the LLVM LIT.""). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(); endif(). set(LLVM_INCLUDE_DIRS ${LLVM_MAIN_INCLUDE_DIR}; CACHE STRING ""System LLVM include directories.""; ). # We checked above that LLVM_VERSION is what we require in ROOT_LLVM_VERSION_REQUIRED_MAJOR.; # To simplify code, just forward that requirement to the rest of ROOT, for example to; # construct the resource directory in core/clingutils.; set(LLVM_VERSION_MAJOR ${ROOT_LLVM_VERSION_REQUIRED_MAJOR} PARENT_SCOPE). # We are in the case of NOT builtin_llvm; if (builtin_clang); # remove clang-cpp from CLANG_LINKS_TO_CREATE to avoid clashes with; # install-clang-cpp target defined by LLVM's cmake module; set(CLANG_LINKS_TO_CREATE clang++ clang-cl). # Disable linking against shared LLVM; set(LLVM_LINK_LLVM_DYLIB OFF). add_subdirectory(llvm-project/clang EXCLUDE_FROM_ALL); endif(builtin_clang). set( CLANG_BUILT_STANDALONE 1 ); set(BACKEND_PACKAGE_STRING ""LLVM ${LLVM_PACKAGE_VERSION}""); endif(builtin_llvm). if (builtin_clang); if (builtin_llvm); # For builtin LLVM this is set in interpreter/llvm-project/llvm/CMakeLists.txt; set(Clang_DIR ""${LLVM_BINARY_DIR}/tools/clang/""); else(); set(Clang_DIR ""${CMAKE_BINARY_DIR}/interpreter/llvm-project/clang/""); set(Clang_Config_ExtraPathHints ""${Clang_DIR}cmake/modules/CMakeFiles""); endif(); set(CLANG_INCLUDE_DIRS; ${CMAKE_SOURCE_DIR}/interpreter/llvm-project/clang/include; ${Clang_DIR}/include; CACHE STRING ""Clang include directories.""); else(); set(Clang_DIR ""${LLVM_BINARY_DIR}/lib/cmake/clang/""); endif(). # Reset the compiler flags after compiling LLVM and Clang; set(CMAKE_CX",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:19407,avoid,avoid,19407,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['avoid'],['avoid']
Safety,"T6 releases, forward-compatibility breaks will only be allowed if a non-default feature is enabled via the ``ROOT::Experimental`` namespace; it is expected ROOT7 will enable forward-compatibility breaks by default. - When a file using an unsupported file format feature is encountered, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fIOBits (00000000000000000000000001111110) contains unknown flags (supported flags are 00000000000000000000000000000001), indicating this was written with a newer version of ROOT utilizing critical IO features this version of ROOT does not support. Refusing to deserialize.; ```; - When an older version of ROOT, without this logic, encounters the file, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fNevBufSize is incorrect (-72) ; trying to recover by setting it to zero; ```. - Added an experimental feature that allows the IO libraries to skip writing out redundant information for some split classes, resulting in disk space savings. This is disabled by default and may be enabled by setting:. ```; ROOT::TIOFeatures features;; features.Set(ROOT::Experimental::EIOFeatures::kGenerateOffsetMap);; ttree_ref.SetIOFeatures(features);; ```; - Added `GetAutoSave()` and `SetAutoSave()` methods to `TBufferMerger`, to allow; it to accumulate several buffers in memory before merging, to reduce the; amount of compression work done due to `TTree` metadata. - Added a non-blocking callback mechanism to `TBufferMerger` to allow users to; control the rate at which data is pushed into the merging queue. The callback; mechanism can be used, for example, to launch tasks asynchronously whenever a; buffer is done processing. ## TTree Libraries. - Resolved O(N^2) scaling problem in ```TTree::Draw()``` observed when a branch that contains a; large TClonesArray where each element contains another small vector container.; - `TTree::TTree()` now takes the `TDirect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:8731,redund,redundant,8731,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['redund'],['redundant']
Safety,"TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55920,avoid,avoided,55920,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['avoid'],['avoided']
Safety,"Target Independent Opportunities:. //===---------------------------------------------------------------------===//. We should recognized various ""overflow detection"" idioms and translate them into; llvm.uadd.with.overflow and similar intrinsics. Here is a multiply idiom:. unsigned int mul(unsigned int a,unsigned int b) {; if ((unsigned long long)a*b>0xffffffff); exit(0);; return a*b;; }. The legalization code for mul-with-overflow needs to be made more robust before; this can be implemented though. //===---------------------------------------------------------------------===//. Get the C front-end to expand hypot(x,y) -> llvm.sqrt(x*x+y*y) when errno and; precision don't matter (ffastmath). Misc/mandel will like this. :) This isn't; safe in general, even on darwin. See the libm implementation of hypot for; examples (which special case when x/y are exactly zero to get signed zeros etc; right). //===---------------------------------------------------------------------===//. On targets with expensive 64-bit multiply, we could LSR this:. for (i = ...; ++i) {; x = 1ULL << i;. into:; long long tmp = 1;; for (i = ...; ++i, tmp+=tmp); x = tmp;. This would be a win on ppc32, but not x86 or ppc64. //===---------------------------------------------------------------------===//. Shrink: (setlt (loadi32 P), 0) -> (setlt (loadi8 Phi), 0). //===---------------------------------------------------------------------===//. Reassociate should turn things like:. int factorial(int X) {; return X*X*X*X*X*X*X*X;; }. into llvm.powi calls, allowing the code generator to produce balanced; multiplication trees. First, the intrinsic needs to be extended to support integers, and second the; code generator needs to be enhanced to lower these to multiplication trees. //===---------------------------------------------------------------------===//. Interesting? testcase for add/shift/mul reassoc:. int bar(int x, int y) {; return x*x*x+y+x*x*x*x*x*y*y*y*y;; }; int foo(int z, int n) {; return bar(z, n)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:155,detect,detection,155,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,"['detect', 'safe']","['detection', 'safe']"
Safety,"ThreadSanitizer; ===============. Introduction; ------------. ThreadSanitizer is a tool that detects data races. It consists of a compiler; instrumentation module and a run-time library. Typical slowdown introduced by; ThreadSanitizer is about **5x-15x**. Typical memory overhead introduced by; ThreadSanitizer is about **5x-10x**. How to build; ------------. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:93,detect,detects,93,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,1,['detect'],['detects']
Safety,"Thu Jun 26 14:43:04 CDT 2003. Information about BinInterface; ------------------------------. Take in a set of instructions with some particular register; allocation. It allows you to add, modify, or delete some instructions,; in SSA form (kind of like LLVM's MachineInstrs.) Then re-allocate; registers. It assumes that the transformations you are doing are safe.; It does not update the mapping information or the LLVM representation; for the modified trace (so it would not, for instance, support; multiple optimization passes; passes have to be aware of and update; manually the mapping information.). The way you use it is you take the original code and provide it to; BinInterface; then you do optimizations to it, then you put it in the; trace cache. The BinInterface tries to find live-outs for traces so that it can do; register allocation on just the trace, and stitch the trace back into; the original code. It has to preserve the live-ins and live-outs when; it does its register allocation. (On exits from the trace we have; epilogues that copy live-outs back into the right registers, but; live-ins have to be in the right registers.). Limitations of BinInterface; ---------------------------. It does copy insertions for PHIs, which it infers from the machine; code. The mapping info inserted by LLC is not sufficient to determine; the PHIs. It does not handle integer or floating-point condition codes and it; does not handle floating-point register allocation. It is not aggressively able to use lots of registers. There is a problem with alloca: we cannot find our spill space for; spilling registers, normally allocated on the stack, if the trace; follows an alloca(). What might be an acceptable solution would be to; disable trace generation on functions that have variable-sized; alloca()s. Variable-sized allocas in the trace would also probably; screw things up. Because of the FP and alloca limitations, the BinInterface is; completely disabled right now. Demo; ----. This is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-26-Reoptimizer2.txt:359,safe,safe,359,interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-26-Reoptimizer2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-26-Reoptimizer2.txt,1,['safe'],['safe']
Safety,"Time; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10395,avoid,avoid,10395,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['avoid'],['avoid']
Safety,"UARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15852,safe,safety-attributes,15852,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,2,['safe'],"['safety', 'safety-attributes']"
Safety,"UI tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use the ROOT GUI. \defgroup tutorial_histfactory HistFactory Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the usage of the histfactory. \defgroup tutorial_http HTTP tutorials; \ingroup Tutorials; \brief Examples showing the HTTP interface. \defgroup tutorial_image Image tutorials; \ingroup Tutorials; \brief Examples showing the TImage class usage. \defgroup tutorial_io IO tutorials; \ingroup Tutorials; \brief These tutorials illustrate some of the capabilities of the ROOT IO subsystem. \defgroup tutorial_math Math tutorials; \ingroup Tutorials; \brief Examples showing the Math classes. \defgroup tutorial_matrix Matrix tutorials; \ingroup Tutorials; \brief Examples showing how to use TMatrix. \defgroup tutorial_mc Monte Carlo tutorials; \ingroup Tutorials; \brief Monte Carlo examples. \defgroup tutorial_multicore Multicore tutorials; \ingroup Tutorials; \brief These examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing. \defgroup tutorial_net Net tutorials; \ingroup Tutorials; \brief Examples showing the net classes. \defgroup tutorial_physics Physics tutorials; \ingroup Tutorials; \brief Physics examples. \defgroup tutorial_pyroot PyRoot tutorials; \ingroup Tutorials; \brief Selected examples illustrating how to use ROOT's Python interface: PyROOT. \defgroup tutorial_pythia Pythia tutorials; \ingroup Tutorials; \brief Examples showing the pythia usage. \defgroup tutorial_quadp Quadratic programming package.; \ingroup Tutorials; \brief Example showing the usage of the quadratic programming package quadp. \defgroup tutorial_r R tutorials; \ingroup Tutorials; \brief Examples showing the R interface. \defgroup tutorial_roostats RooStats Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main features of RooStats. \defgroup tutorial_spectrum Spectrum tutorials; \ingroup Tutorials; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:4252,safe,safety,4252,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['safe'],['safety']
Safety,"ULL_CORPUS_DIR. You may use the same flag to add more interesting items to an existing corpus.; Only the inputs that trigger new coverage will be added to the first corpus. .. code-block:: console. ./my_fuzzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR. Running; -------. To run the fuzzer, first create a Corpus_ directory that holds the; initial ""seed"" sample inputs:. .. code-block:: console. mkdir CORPUS_DIR; cp /some/input/samples/* CORPUS_DIR. Then run the fuzzer on the corpus directory:. .. code-block:: console. ./my_fuzzer CORPUS_DIR # -max_len=1000 -jobs=20 ... As the fuzzer discovers new interesting test cases (i.e. test cases that; trigger coverage of new paths through the code under test), those test cases; will be added to the corpus directory. By default, the fuzzing process will continue indefinitely – at least until; a bug is found. Any crashes or sanitizer failures will be reported as usual,; stopping the fuzzing process, and the particular input that triggered the bug; will be written to disk (typically as ``crash-<sha1>``, ``leak-<sha1>``,; or ``timeout-<sha1>``). Parallel Fuzzing; ----------------. Each libFuzzer process is single-threaded, unless the library under test starts; its own threads. However, it is possible to run multiple libFuzzer processes in; parallel with a shared corpus directory; this has the advantage that any new; inputs found by one fuzzer process will be available to the other fuzzer; processes (unless you disable this with the ``-reload=0`` option). This is primarily controlled by the ``-jobs=N`` option, which indicates that; that `N` fuzzing jobs should be run to completion (i.e. until a bug is found or; time/iteration limits are reached). These jobs will be run across a set of; worker processes, by default using half of the available CPU cores; the count of; worker processes can be overridden by the ``-workers=N`` option. For example,; running with ``-jobs=30`` on a 12-core machine would run 6 workers ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:6389,timeout,timeout,6389,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeout']
Safety,Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unk,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:77815,safe,safety,77815,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['safe'],['safety']
Safety,"Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15985,safe,safety-precise,15985,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety-precise']
Safety,"Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal interface of a function, and should; always go in the header, where they are visible to anything that includes; the header. Attributes in the .cpp file are not visible outside of the; immediate translation unit, which leads to false negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:19240,safe,safety,19240,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #define PT_GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x)). #define ACQUIRED_BEFORE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_before(__VA_ARGS__)). #define ACQUIRED_AFTER(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_after(__VA_ARGS__)). #define REQUIRES(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_capability(__VA_ARGS__)). #define REQUIRES_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_shared_capability(__VA_ARGS__)). #define ACQUIRE(...) \; THREAD_ANNOTATION_ATTRIBUT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:25179,safe,safety,25179,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled, by setting; ``-DGWP_ASAN_DEFAULT_OPTIONS`` to the options string you want set by default.; If you're building GWP-ASan as part of a compiler-rt/LLVM build, add it during; cmake configure time (e.g. ``cmake ... -DGWP_ASAN_DEFAULT_OPTIONS=""...""``). If; you're building GWP-ASan outside of compiler-rt, simply ens",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4591,detect,detection,4591,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"While it is possible to engineer more and more complex solutions to; problems like this, it cannot be solved in full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requires a combination of language design, runtime; support, and often operating system support. It is certainly possible to implement a safe language in LLVM, but LLVM; IR does not itself guarantee safety. The LLVM IR allows unsafe pointer; casts, use after free bugs, buffer over-runs, and a variety of other; problems. Safety needs to be implemented as a layer on top of LLVM and,; conveniently, several groups have investigated this. Ask on the `LLVM; forums <https://discourse.llvm.org>`_ if you are interested in more details. Language-Specific Optimizations; -------------------------------. One thing about LLVM that turns off many people is that it does not; solve all the world's problems in one system. One specific; complaint is that people perceive LLVM as being incapable of performing; high-level language-specific optimization: LLVM ""loses too much; information"". Here are a few observations about this:. First, you're right that LLVM does lose information. For example, as of; this writing, there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:8250,safe,safe,8250,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,2,['safe'],"['safe', 'safety']"
Safety,"[*mangled names...*]. DESCRIPTION; -----------. :program:`llvm-cxxfilt` is a symbol demangler that can be used as a replacement; for the GNU :program:`c++filt` tool. It takes a series of symbol names and; prints their demangled form on the standard output stream. If a name cannot be; demangled, it is simply printed as is. If no names are specified on the command-line, names are read interactively from; the standard input stream. When reading names from standard input, each input; line is split on characters that are not part of valid Itanium name manglings,; i.e. characters that are not alphanumeric, '.', '$', or '_'. Separators between; names are copied to the output as is. EXAMPLE; -------. .. code-block:: console. $ llvm-cxxfilt _Z3foov _Z3bari not_mangled; foo(); bar(int); not_mangled; $ cat input.txt; | _Z3foov *** _Z3bari *** not_mangled |; $ llvm-cxxfilt < input.txt; | foo() *** bar(int) *** not_mangled |. OPTIONS; -------. .. option:: --format=<value>, -s. Mangling scheme to assume. Valid values are ``auto`` (default, auto-detect the; style) and ``gnu`` (assume GNU/Itanium style). .. option:: --help, -h. Print a summary of command line options. .. option:: --no-params, -p. Do not demangle function parameters or return types. .. option:: --no-strip-underscore, -n. Do not strip a leading underscore. This is the default for all platforms; except Mach-O based hosts. .. option:: --strip-underscore, -_. Strip a single leading underscore, if present, from each input name before; demangling. On by default on Mach-O based platforms. .. option:: --types, -t. Attempt to demangle names as type names as well as function names. .. option:: --version. Display the version of the :program:`llvm-cxxfilt` executable. .. option:: @<FILE>. Read command-line options from response file `<FILE>`. EXIT STATUS; -----------. :program:`llvm-cxxfilt` returns 0 unless it encounters a usage error, in which; case a non-zero exit code is returned. SEE ALSO; --------. :manpage:`llvm-nm(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst:1216,detect,detect,1216,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cxxfilt.rst,1,['detect'],['detect']
Safety,"[0-9]+).*$"" ""\\1"" ZLIB_VERSION_MINOR ""${ZLIB_H}""); string(REGEX REPLACE ""^.*ZLIB_VERSION \""[0-9]+\\.[0-9]+\\.([0-9]+).*$"" ""\\1"" ZLIB_VERSION_PATCH ""${ZLIB_H}""); set(ZLIB_VERSION_STRING ""${ZLIB_VERSION_MAJOR}.${ZLIB_VERSION_MINOR}.${ZLIB_VERSION_PATCH}""). set(ZLIB_VERSION_TWEAK """"); if(""${ZLIB_H}"" MATCHES ""ZLIB_VERSION \""[0-9]+\\.[0-9]+\\.[0-9]+\\.([0-9]+)""); set(ZLIB_VERSION_TWEAK ""${CMAKE_MATCH_1}""); string(APPEND ZLIB_VERSION_STRING "".${ZLIB_VERSION_TWEAK}""); endif(). set(ZLIB_VERSION ${ZLIB_VERSION_STRING} CACHE INTERNAL """"); set(ZLIB_VERSION_STRING ${ZLIB_VERSION_STRING} CACHE INTERNAL """"). set(ZLIB_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR} CACHE INTERNAL """"); set(ZLIB_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR} CACHE INTERNAL """"). if((CMAKE_SYSTEM_PROCESSOR MATCHES ""amd64|x86_64|AMD64|X86_64|aarch64"") AND (CMAKE_SYSTEM_NAME MATCHES ""Linux"")); # Calling helper to avoid using old unsupported binutils (e.g. with SL6); # macro is returning extra ${ROOT_DEFINITIONS} used after in ZLIB-CF; root_check_assembler(); # Calling helper to avoid using old unsupported binutils (e.g. with Centos7; # and native gcc compiler 4.8.5); # Macros are returning bools SSE_SUPPORT & AVX2_SUPPORT; root_check_sse41(); root_check_avx2(); if(SSE_SUPPORT OR AVX2_SUPPORT); set(ZLIB_CF TRUE CACHE INTERNAL """"); endif(); endif(). if(ZLIB_CF); add_library(ZLIB STATIC ${ZLIB_PUBLIC_HEADERS} ${ZLIBCF_PRIVATE_HEADERS} ${ZLIBCF_SOURCES}); else(); add_library(ZLIB STATIC ${ZLIB_PUBLIC_HEADERS} ${ZLIB_PRIVATE_HEADERS} ${ZLIB_SOURCES}); endif(). set_target_properties(ZLIB PROPERTIES C_VISIBILITY_PRESET hidden POSITION_INDEPENDENT_CODE ON); target_include_directories(ZLIB INTERFACE $<BUILD_INTERFACE:${ZLIB_INCLUDE_DIR}>). if((CMAKE_SYSTEM_PROCESSOR MATCHES ""amd64|x86_64|AMD64|X86_64"") AND (CMAKE_SYSTEM_NAME MATCHES ""Linux"")); target_compile_options(ZLIB PRIVATE -Wno-unused-function -O3 -mpclmul -Wno-attribute-alias ${ROOT_DEFINITIONS}); else(); if(NOT MSVC); target_compile_options(ZLIB PRIVATE -O3); endif();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/CMakeLists.txt:2235,avoid,avoid,2235,builtins/zlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/CMakeLists.txt,1,['avoid'],['avoid']
Safety,"[digit]``"" sequences to specify where and how; arguments to the diagnostic are formatted. Arguments to the diagnostic are numbered according to how they are specified by; the C++ code that :ref:`produces them <internals-producing-diag>`, and are; referenced by ``%0`` .. ``%9``. If you have more than 10 arguments to your; diagnostic, you are doing something wrong :). Unlike ``printf``, there is no; requirement that arguments to the diagnostic end up in the output in the same; order as they are specified, you could have a format string with ""``%1 %0``""; that swaps them, for example. The text in between the percent and digit are; formatting instructions. If there are no instructions, the argument is just; turned into a string and substituted in. Here are some ""best practices"" for writing the English format string:. * Keep the string short. It should ideally fit in the 80 column limit of the; ``DiagnosticKinds.td`` file. This avoids the diagnostic wrapping when; printed, and forces you to think about the important point you are conveying; with the diagnostic.; * Take advantage of location information. The user will be able to see the; line and location of the caret, so you don't need to tell them that the; problem is with the 4th argument to the function: just point to it.; * Do not capitalize the diagnostic string, and do not end it with a period.; * If you need to quote something in the diagnostic string, use single quotes. Diagnostics should never take random English strings as arguments: you; shouldn't use ""``you have a problem with %0``"" and pass in things like ""``your; argument``"" or ""``your return value``"" as arguments. Doing this prevents; :ref:`translating <internals-diag-translation>` the Clang diagnostics to other; languages (because they'll get random English words in their otherwise; localized diagnostic). The exceptions to this are C/C++ language keywords; (e.g., ``auto``, ``const``, ``mutable``, etc) and C/C++ operators (``/=``).; Note that things like ""po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:8167,avoid,avoids,8167,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoids']
Safety,"[i + R3]. Suppose there is high register pressure, R1, R2, R3, can be spilled. We need; to implement proper re-materialization to handle this:. R1 = X + 4; R2 = X + 7; R3 = X + 15. loop:; R1 = X + 4 @ re-materialized; load [i + R1]; ...; R2 = X + 7 @ re-materialized; load [i + R2]; ...; R3 = X + 15 @ re-materialized; load [i + R3]. Furthermore, with re-association, we can enable sharing:. R1 = X + 4; R2 = X + 7; R3 = X + 15. loop:; T = i + X; load [T + 4]; ...; load [T + 7]; ...; load [T + 15]; //===---------------------------------------------------------------------===//. It's not always a good idea to choose rematerialization over spilling. If all; the load / store instructions would be folded then spilling is cheaper because; it won't require new live intervals / registers. See 2003-05-31-LongShifts for; an example. //===---------------------------------------------------------------------===//. With a copying garbage collector, derived pointers must not be retained across; collector safe points; the collector could move the objects and invalidate the; derived pointer. This is bad enough in the first place, but safe points can; crop up unpredictably. Consider:. %array = load { i32, [0 x %obj] }** %array_addr; %nth_el = getelementptr { i32, [0 x %obj] }* %array, i32 0, i32 %n; %old = load %obj** %nth_el; %z = div i64 %x, %y; store %obj* %new, %obj** %nth_el. If the i64 division is lowered to a libcall, then a safe point will (must); appear for the call site. If a collection occurs, %array and %nth_el no longer; point into the correct object. The fix for this is to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:2796,safe,safe,2796,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['safe'],['safe']
Safety,"\defgroup Geometry The Geometry Package. The %ROOT geometry package is a tool for building, browsing,; navigating and visualizing detector geometries. The code works; standalone with respect to any tracking Monte-Carlo engine; therefore,; it does not contain any constraints related to physics. However, the; navigation features provided by the package are designed to optimize; particle transport through complex geometries, working in correlation; with simulation packages such as GEANT3, GEANT4 and FLUKA. - [Quick Start: Creating the world](\ref GP00); - [Example 1: Creating the World](\ref GP00a); - [Example 2: A Geometrical Hierarchy Look and Feel](\ref GP00b); - [Selecting the System of Units in ROOT](\ref GPUNITS); - [Geometry Creation](\ref GP01); - [The Volume Hierarchy](\ref GP01a); - [Creating and Positioning Volumes](\ref GP01b); - [Making Volumes](\ref GP01ba); - [Example of Volume Creation](\ref GP01bb); - [Positioned Volumes (Nodes)](\ref GP01bc); - [Virtual Containers and Assemblies of Volumes](\ref GP01bd); - [Examples of Volume Positioning](\ref GP01be); - [Overlapping Volumes](\ref GP01bf); - [Replicating Volumes](\ref GP01bg); - [Volume Families](\ref GP01bh); - [Dividing Volumes](\ref GP01bi); - [Volume Assemblies](\ref GP01bj); - [Geometrical Transformations](\ref GP01c); - [Matrix Creation Example](\ref GP01ca); - [Rule for Creation of Transformations](\ref GP01cb); - [Available Geometrical Transformations](\ref GP01cc); - [Ownership of Geometry Objects](\ref GP01d); - [Navigation and Tracking](\ref GP02); - [TGeoNavigator Class](\ref GP02a); - [Initializing the Starting Point](\ref GP02b); - [Initializing the Direction](\ref GP02c); - [Initializing the State](\ref GP02d); - [Checking the Current State](\ref GP02e); - [Saving and Restoring the Current State](\ref GP02f); - [Navigation Queries](\ref GP02g); - [Finding If Current State Is Changed For a New Point](\ref GP02ga); - [Finding the Distance to the Next Boundary](\ref GP02gb); - [Computing th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:130,detect,detector,130,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,"\defgroup Shapes_classes Shapes; \ingroup Geometry; \brief Shapes are geometrical objects that provide the basic modeling functionality. - [Primitive Shapes](\ref SHAPES01); - [Navigation Methods Performed By Shapes](\ref SHAPES02); - [Creating Shapes](\ref SHAPES03); - [Dividing Shapes](\ref SHAPES04); - [Parametric Shapes](\ref SHAPES05). The ""shapes"" provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined in their local frame is contained or; not by the shape;; - Computing the distance to enter/exit the shape from a local point,; given a known direction;; - Computing the maximum distance in any direction from a local point; that does NOT result in a boundary crossing of the shape (safe; distance);; - Computing the cosines of the normal vector to the crossed shape; surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also; to implement additional specific abstract methods:. - Computation of the minimal box bounding the shape, given that this; box have to be aligned with the local coordinates;; - Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape topologies and combinations. You can; have a look and run the tutorial: geodemo.C. \image html geom_primitive_shapes.png Primitive Shapes - the general inheritance scheme. Shapes are named objects and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:886,safe,safe,886,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['safe'],['safe']
Safety,\defgroup Unfold TUnfold classes; \ingroup Hist. An algorithm to unfold distributions from detector to truth level. \author Stefan Schmitt DESY. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/doc/index.md:91,detect,detector,91,hist/unfold/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/doc/index.md,1,['detect'],['detector']
Safety,"] : allow IOCtors to have as argument a ref to a type called __void__. We added a dictionary for map<string,string> as part of the default STL dictionary. We added support for template parameter packs in class name involved in the I/O. ### Thread safety and thread awareness. We added the function `TMethodCall::GetCallFunc` to allow direct access to the function wrapper. We reduced thread serialization in `TClass::GetCheckSum`, `TClass::GetBaseClassOffset` and `TClass::Property`. `TObjArray::Delete` was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock). We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: `ROOT::EnableThreadSafety()` which is the successor of the existing `TThread::Initialize`. This call must take place if ROOT needs to be used in a thread safe manner. The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TContext` which record the current directory; and will restore it at destruction time and does not change the current directory. The constructor for `TDirectory::TContext` that takes a single TDirectory pointer as; an argument was changed to set `gDirectory` to zero when being passed a null pointer;; previously it was interpreting a null pointer as a request to *not* change the current; directory - this behavior is now implement by the default constructor. ### Collections. In THashList and THashTable, GetListForObject now returns a pointer to const as modifying the returned list (in particular adding to it) can break invariant of THashTable so we need to clearly mark the list as not being allowed to be modified. In TSeqCollection::Merge, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:2830,safe,safe,2830,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['safe'],['safe']
Safety,"^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310942,avoid,avoids,310942,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoids']
Safety,"^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.select.v16i32 (<16 x i1> <condition>, <16 x i32> <on_true>, <16 x i32> <on_false>, i32 <evl>); declare <vscale x 4 x i64> @llvm.vp.select.nxv4i64 (<vscale x 4 x i1> <condition>, <vscale x 4 x i64> <on_true>, <vscale x 4 x i64> <on_false>, i32 <evl>). Overview:; """""""""""""""""". The '``llvm.vp.select``' intrinsic is used to choose one value based on a; condition vector, without IR-level branching. Arguments:; """""""""""""""""""". The first operand is a vector of ``i1`` and indicates the condition. The; second operand is the value that is selected where the condition vector is; true. The third operand is the value that is selected where the condition; vector is false. The vectors must be of the same size. The fourth operand is; the explicit vector length. #. The optional ``fast-math flags`` marker indicates that the select has one or; more :ref:`fast-math flags <fastmath>`. These are optimization hints to; enable otherwise unsafe floating-point optimizations. Fast-math flags are; only valid for selects that return a floating-point scalar or vector type,; or an array (nested to any depth) of floating-point scalar or vector types. Semantics:; """""""""""""""""""". The intrinsic selects lanes from the second and third operand depending on a; condition vector. All result lanes at positions greater or equal than ``%evl`` are undefined.; For all lanes below ``%evl`` where the condition vector is true the lane is; taken from the second operand. Otherwise, the lane is taken from the third; operand. Example:; """""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.select.v4i32(<4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false, i32 %evl). ;;; Expansion.; ;; Any result is legal on lanes at and above %evl.; %also.r = select <4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false. .. _int_vp_merge:. '``llvm.vp.merge.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:694192,unsafe,unsafe,694192,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59103,avoid,avoid,59103,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoid']
Safety,"^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any; integer bit width, or any vector whose elements are integers. Not all; targets support all bit widths or vector types, however. ::. declare i8 @llvm.ctlz.i8 (i8 <src>, i1 <is_zero_poison>); declare <2 x i37> @llvm.ctlz.v2i37(<2 x i37> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.ctlz``' family of intrinsic functions counts the number of; leading zeros in a variable. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.ctlz``' intrinsic counts the leading (most significant); zeros in a variable, or within each element of the vector. If; ``src == 0`` then the result is the size in bits of the type of ``src``; if ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.ctlz(i32 2) = 30``. .. _int_cttz:. '``llvm.cttz.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.cttz`` on any; integer bit width, or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i42 @llvm.cttz.i42 (i42 <src>, i1 <is_zero_poison>); declare <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.cttz``' family of intrinsic functions counts the number of; trailing zeros. Arguments:; """""""""""""""""""". The first argument is the value to be co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:594521,avoid,avoiding,594521,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoiding']
Safety,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which loop attributes the remainder loop after; partial/runtime unrolling will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll_and_jam``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata is treated very similarly to the ``llvm.loop.unroll`` metadata; above, but affect the unroll and jam pass. In addition any loop with; ``llvm.loop.unroll`` metadata but no ``llvm.loop.unroll_and_jam`` metadata will; disable unroll and jam (so ``llvm.loop.unroll`` metadata will be left to the; unroller, plus ``llvm.loop.unroll.disable`` metadata will disable unroll and jam; too.). The metadata for unroll and jam otherwise is the same as for ``unroll``.; ``llvm.loop.unroll_and_jam.enable``, ``llvm.loop.unroll_and_jam.disable`` and; ``llvm.loop.unroll_and_jam.count`` do the same as for unroll.; ``llvm.loop.unroll_and_jam.full`` is not supported. Again these are only hints; and the normal safety checks will still be performed. '``llvm.loop.unroll_and_jam.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll and jam factor to use, similarly to; ``llvm.loop.unroll.count``. The first operand is the string; ``llvm.loop.unroll_and_jam.count`` and the second operand is a positive integer; specifying the unroll factor. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll_and_jam.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unroll and jammed. '``llvm.loop.unroll_and_jam.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unroll and jamming. The metadata has a single; operand which is the string ``llvm.loop.unroll_and_jam.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll_and_jam.disable""}. '``llvm.loop.unroll_and_jam.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:304153,safe,safety,304153,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"_8_08_4.html>`__) class; template represents a reference to a callable object, templated over the type; of the callable. This is a good choice for passing a callback to a function,; if you don't need to hold onto the callback after the function returns. In this; way, ``function_ref`` is to ``std::function`` as ``StringRef`` is to; ``std::string``. ``function_ref<Ret(Param1, Param2, ...)>`` can be implicitly constructed from; any callable object that can be called with arguments of type ``Param1``,; ``Param2``, ..., and returns a value that can be converted to type ``Ret``.; For example:. .. code-block:: c++. void visitBasicBlocks(Function *F, function_ref<bool (BasicBlock*)> Callback) {; for (BasicBlock &BB : *F); if (Callback(&BB)); return;; }. can be called using:. .. code-block:: c++. visitBasicBlocks(F, [&](BasicBlock *BB) {; if (process(BB)); return isEmpty(BB);; return false;; });. Note that a ``function_ref`` object contains pointers to external memory, so it; is not generally safe to store an instance of the class (unless you know that; the external storage will not be freed). If you need this ability, consider; using ``std::function``. ``function_ref`` is small enough that it should always; be passed by value. .. _DEBUG:. The ``LLVM_DEBUG()`` macro and ``-debug`` option; ------------------------------------------------. Often when working on your pass you will put a bunch of debugging printouts and; other code into your pass. After you get it working, you want to remove it, but; you may need it again in the future (to work out new bugs that you run across). Naturally, because of this, you don't want to delete the debug printouts, but; you don't want them to always be noisy. A standard compromise is to comment; them out, allowing you to enable them if you need them in the future. The ``llvm/Support/Debug.h`` (`doxygen; <https://llvm.org/doxygen/Debug_8h_source.html>`__) file provides a macro named; ``LLVM_DEBUG()`` that is a much nicer solution to this proble",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:41746,safe,safe,41746,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; voi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:11129,unsafe,unsafe,11129,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"_IGN, we terminate the |; | | | process after dumping the error report. |; +----------------------------+---------+--------------------------------------------------------------------------------+. Example; -------. The below code has a use-after-free bug, where the ``string_view`` is created as; a reference to the temporary result of the ``string+`` operator. The; use-after-free occurs when ``sv`` is dereferenced on line 8. .. code:: cpp. 1: #include <iostream>; 2: #include <string>; 3: #include <string_view>; 4:; 5: int main() {; 6: std::string s = ""Hellooooooooooooooo "";; 7: std::string_view sv = s + ""World\n"";; 8: std::cout << sv;; 9: }. Compiling this code with Scudo+GWP-ASan will probabilistically catch this bug; and provide us a detailed error report:. .. code:: console. $ clang++ -fsanitize=scudo -g buggy_code.cpp; $ for i in `seq 1 500`; do; SCUDO_OPTIONS=""GWP_ASAN_SampleRate=100"" ./a.out > /dev/null;; done; |; | *** GWP-ASan detected a memory error ***; | Use after free at 0x7feccab26000 (0 bytes into a 41-byte allocation at 0x7feccab26000) by thread 31027 here:; | ...; | #9 ./a.out(_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St17basic_string_viewIS3_S4_E+0x45) [0x55585c0afa55]; | #10 ./a.out(main+0x9f) [0x55585c0af7cf]; | #11 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xeb) [0x7fecc966952b]; | #12 ./a.out(_start+0x2a) [0x55585c0867ba]; |; | 0x7feccab26000 was deallocated by thread 31027 here:; | ...; | #7 ./a.out(main+0x83) [0x55585c0af7b3]; | #8 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xeb) [0x7fecc966952b]; | #9 ./a.out(_start+0x2a) [0x55585c0867ba]; |; | 0x7feccab26000 was allocated by thread 31027 here:; | ...; | #12 ./a.out(main+0x57) [0x55585c0af787]; | #13 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xeb) [0x7fecc966952b]; | #14 ./a.out(_start+0x2a) [0x55585c0867ba]; |; | *** End GWP-ASan report ***; | Segmentation fault. To symbolize these stack traces, some care has to be taken. Scudo currently uses; GNU's ``back",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:9844,detect,detected,9844,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detected']
Safety,"_USE_RELATIVE_PATHS_IN_FILES**:BOOL; Rewrite absolute source paths in sources and debug info to relative ones. The; source prefix can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_RELATIVE_PATHS_IN_DEBUG_INFO**:BOOL; Rewrite absolute source paths in debug info to relative ones. The source prefix; can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_SANITIZER**:STRING; Define the sanitizer used to build LLVM binaries and tests. Possible values; are ``Address``, ``Memory``, ``MemoryWithOrigins``, ``Undefined``, ``Thread``,; ``DataFlow``, and ``Address;Undefined``. Defaults to empty string. **LLVM_USE_SPLIT_DWARF**:BOOL; If enabled CMake will pass ``-gsplit-dwarf`` to the compiler. This option; reduces link-time memory usage by reducing the amount of debug information that; the linker needs to resolve. It is recommended for platforms using the ELF object; format, like Linux systems when linker memory usage is too high. **SPHINX_EXECUTABLE**:STRING; The path to the ``sphinx-build`` executable detected by CMake.; For installation instructions, see; https://www.sphinx-doc.org/en/master/usage/installation.html. **SPHINX_OUTPUT_HTML**:BOOL; If enabled (and ``LLVM_ENABLE_SPHINX`` is enabled) then the targets for; building the documentation as html are added (but not built by default unless; ``LLVM_BUILD_DOCS`` is enabled). There is a target for each project in the; source tree that uses sphinx (e.g. ``docs-llvm-html``, ``docs-clang-html``; and ``docs-lld-html``). Defaults to ON. **SPHINX_OUTPUT_MAN**:BOOL; If enabled (and ``LLVM_ENABLE_SPHINX`` is enabled) the targets for building; the man pages are added (but not built by default unless ``LLVM_BUILD_DOCS``; is enabled). Currently the only target added is ``docs-llvm-man``. Defaults; to ON. **SPHINX_WARNINGS_AS_ERRORS**:BOOL; If enabled then sphinx documentation warnings will be treated as; errors. Defaults to ON. Advanced variables; ~~~~~~~~~~~~~~~~~~. These are niche, and changing them from their de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:36906,detect,detected,36906,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['detect'],['detected']
Safety,"__counted_by; count--; // may violate the invariant of __counted_by if count was 0.; count = g; // may violate the invariant of __counted_by; // depending on the value of `g`.; }. The requirement to annotate all pointers with explicit bounds information could; present a significant adoption burden. To tackle this issue, the model; incorporates the concept of a ""wide pointer"" (a.k.a. fat pointer) – a larger; pointer that carries bounds information alongside the pointer value. Utilizing; wide pointers can potentially reduce the adoption burden, as it contains bounds; information internally and eliminates the need for explicit bounds annotations.; However, wide pointers differ from standard C pointers in their data layout,; which may result in incompatibilities with the application binary interface; (ABI). Breaking the ABI complicates interoperability with external code that has; not adopted the same programming model. ``-fbounds-safety`` harmonizes the wide pointer and the bounds annotation; approaches to reduce the adoption burden while maintaining the ABI. In this; model, local variables of pointer type are implicitly treated as wide pointers,; allowing them to carry bounds information without requiring explicit bounds; annotations. Please note that this approach doesn't apply to function parameters; which are considered ABI-visible. As local variables are typically hidden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:5761,safe,safety,5761,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:32292,redund,redundant,32292,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['redund'],['redundant']
Safety,"__terminated_by(T)`` can cast to ``__unsafe_indexable``. * Any type without ``__terminated_by(T)`` cannot cast to ``__terminated_by(T)``; without explicitly using an intrinsic function to allow it. + ``__unsafe_terminated_by_from_indexable(T, PTR [, PTR_TO_TERM])`` casts any; safe pointer PTR to a ``__terminated_by(T)`` pointer. ``PTR_TO_TERM`` is an; optional argument where the programmer can provide the exact location of the; terminator. With this argument, the function can skip reading the entire; array in order to locate the end of the pointer (or the upper bound).; Providing an incorrect ``PTR_TO_TERM`` causes a run-time trap. + ``__unsafe_forge_terminated_by(T, P, E)`` creates ``T __terminated_by(E)``; pointer given any pointer ``P``. Tmust be a pointer type. Portability with toolchains that do not support the extension; -------------------------------------------------------------. The language model is designed so that it doesn't alter the semantics of the; original C program, other than introducing deterministic traps where otherwise; the behavior is undefined and/or unsafe. Clang provides a toolchain header; (``ptrcheck.h``) that macro-defines the annotations as type attributes when; ``-fbounds-safety`` is enabled and defines them to empty when the extension is; disabled. Thus, the code adopting ``-fbounds-safety`` can compile with; toolchains that do not support this extension, by including the header or adding; macros to define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:45408,unsafe,unsafe,45408,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicitly be ``FILE; *__unsafe_indexable`` and thus it cannot be directly assigned to ``FILE *fp``; in the bounds-safe source. To allow this operation, ``__unsafe_forge_single``; is used to create a ``__single`` from the return value of ``fopen``. * Similar to ``__unsafe_indexable``, any non-pointer type (including ``int``,; ``intptr_t``, ``uintptr_t``, etc.) cannot be converted to any safe pointer; type because these don't have bounds information. ``__unsafe_forge_single`` or; ``__unsafe_forge_bidi_indexable`` must be used to force the conversion. * Any safe pointer types can cast to ``__unsafe_indexable`` because it doesn't; have any invariant to maintain. * ``__single`` casts to ``__bidi_indexable`` if the pointee type has a known; size. After the conversion, the resulting ``__bidi_indexable`` has the size of; a single object of the pointee type of ``__single``. ``__single`` cannot cast; to ``__bidi_indexable`` if the pointee type is incomplete or sizeless. For; example, ``void *__single`` cannot convert to ``void *__bidi_indexable``; because void is an incomplete type and thus the compiler cannot correctly; determine the upper bound of a single void pointer. * Similarly, ``__single`` can cast to ``__indexable`` if the pointee type has a; known size. The resulting ``__indexable`` has the size of a single object of; the pointee type. * ``__single`` casts to ``__counted_by(E)`` only",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:41841,safe,safe,41841,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safe']
Safety,"_memmove_element_unordered_atomic_safepoint_*``' symbols respectively.; This way the runtime can provide implementations of copy operations with and; without safepoints. GC parseable lowering also involves adjusting the arguments for the call.; Memcpy and memmove intrinsics take derived pointers as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in the copy operation. In order to make the base; pointers available RewriteStatepointsForGC replaces derived pointers with base; pointer and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:31514,safe,safepoint,31514,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,2,['safe'],['safepoint']
Safety,"_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:32396,redund,redundant,32396,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['redund'],['redundant']
Safety,"` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:84426,safe,safe,84426,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"`-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can use the following suppression mechanism; to unblock yourself and continue on with the testing. This suppression; mechanism should only be used for suppressing issues in external code; it; does not work on code recompiled with AddressSanitizer. To suppress errors; in external libraries, set the ``ASAN_OPTIONS`` environment variable to point; to a suppression file. You can either specify the full path to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:6797,detect,detection,6797,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detection']
Safety,"`; ------------------. nvcc does not officially support ``std::complex``. It's an error to use; ``std::complex`` in ``__device__`` code, but it often works in ``__host__; __device__`` code due to nvcc's interpretation of the ""wrong-side rule"" (see; below). However, we have heard from implementers that it's possible to get; into situations where nvcc will omit a call to an ``std::complex`` function,; especially when compiling without optimizations. As of 2016-11-16, clang supports ``std::complex`` without these caveats. It is; tested with libstdc++ 4.8.5 and newer, but is known to work only with libc++; newer than 2016-11-16. ``<algorithm>``; ---------------. In C++14, many useful functions from ``<algorithm>`` (notably, ``std::min`` and; ``std::max``) become constexpr. You can therefore use these in device code,; when compiling with clang. Detecting clang vs NVCC from code; =================================. Although clang's CUDA implementation is largely compatible with NVCC's, you may; still want to detect when you're compiling CUDA code specifically with clang. This is tricky, because NVCC may invoke clang as part of its own compilation; process! For example, NVCC uses the host compiler's preprocessor when; compiling for device code, and that host compiler may in fact be clang. When clang is actually compiling CUDA code -- rather than being used as a; subtool of NVCC's -- it defines the ``__CUDA__`` macro. ``__CUDA_ARCH__`` is; defined only in device mode (but will be defined if NVCC is using clang as a; preprocessor). So you can use the following incantations to detect clang CUDA; compilation, in host and device modes:. .. code-block:: c++. #if defined(__clang__) && defined(__CUDA__) && !defined(__CUDA_ARCH__); // clang compiling CUDA code, host mode.; #endif. #if defined(__clang__) && defined(__CUDA__) && defined(__CUDA_ARCH__); // clang compiling CUDA code, device mode.; #endif. Both clang and nvcc define ``__CUDACC__`` during CUDA compilation. You can; detect ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:7659,detect,detect,7659,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['detect'],['detect']
Safety,"`RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a RooCmdArg to various RooFit functions, such as [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5).; If this happens, please consult the documentation of [fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) to check which of the [free functions in the `RooFit` namespace](https://root.cern/doc/v626/group__CmdArgs.html) you need to use to achieve the desired configuration. **Example** of an error that is now caught at compile time: confusing the [RooAbsPdf::fitTo()]() function signature with the one of [TH1::Fit()](https://root.cern/doc/v626/classTH1.html#a63eb028df86bc86c8e20c989eb23fb2a) and passing the fit range name as a string literal:. ```C++; pdf.fitTo(*data, ""r""); // ERROR!; // Will not compile anymore, as `""r""` is not a recognized command",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:31287,avoid,avoid,31287,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['avoid'],['avoid']
Safety,"`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:131913,avoid,avoid,131913,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"`` relocation sequence. Don't forget to create a root for each intermediate value that is generated when; evaluating an expression. In ``h(f(), g())``, the result of ``f()`` could; easily be collected if evaluating ``g()`` triggers a collection. Finally, you need to link your runtime library with the generated program; executable (for a static compiler) or ensure the appropriate symbols are; available for the runtime linker (for a JIT compiler). Introduction; ============. What is Garbage Collection?; ---------------------------. Garbage collection is a widely used technique that frees the programmer from; having to know the lifetimes of heap objects, making software easier to produce; and maintain. Many programming languages rely on garbage collection for; automatic memory management. There are two primary forms of garbage collection:; conservative and accurate. Conservative garbage collection often does not require any special support from; either the language or the compiler: it can handle non-type-safe programming; languages (such as C/C++) and does not require any special information from the; compiler. The `Boehm collector; <https://hboehm.info/gc/>`__ is an example of a; state-of-the-art conservative collector. Accurate garbage collection requires the ability to identify all pointers in the; program at run-time (which requires that the source-language be type-safe in; most cases). Identifying pointers at run-time requires compiler support to; locate all places that hold live pointer variables at run-time, including the; :ref:`processor stack and registers <gcroot>`. Conservative garbage collection is attractive because it does not require any; special compiler support, but it does have problems. In particular, because the; conservative garbage collector cannot *know* that a particular word in the; machine is a pointer, it cannot move live objects in the heap (preventing the; use of compacting and generational GC algorithms) and it can occasionally suffer; fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:3243,safe,safe,3243,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10950,avoid,avoid,10950,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76837,detect,detected,76837,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52967,risk,risk,52967,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['risk'],['risk']
Safety,"``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (and; common practice) to initialize guarded members without acquiring any locks.; The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the; object being initialized or destroyed, while still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:22252,safe,safe,22252,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safe']
Safety,"``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3215,safe,safety,3215,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, adding and producing a diagnostic is pretty straightforward.; The hard part is deciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:18182,recover,recover,18182,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recover']
Safety,"`bugpoint`` should tell you what passes crash, give you a; bitcode file, and give you instructions on how to reproduce the failure with; ``opt`` or ``llc``. .. _code generator debugger:. Code generator debugger; -----------------------. The code generator debugger attempts to narrow down the amount of code that is; being miscompiled by the selected code generator. To do this, it takes the test; program and partitions it into two pieces: one piece which it compiles with the; ""safe"" backend (into a shared object), and one piece which it runs with either; the JIT or the static LLC compiler. It uses several techniques to reduce the; amount of code pushed through the LLVM code generator, to reduce the potential; scope of the problem. After it is finished, it emits two bitcode files (called; ""test"" [to be compiled with the code generator] and ""safe"" [to be compiled with; the ""safe"" backend], respectively), and instructions for reproducing the; problem. The code generator debugger assumes that the ""safe"" backend produces; good code. .. _miscompilation debugger:. Miscompilation debugger; -----------------------. The miscompilation debugger works similarly to the code generator debugger. It; works by splitting the test program into two pieces, running the optimizations; specified on one piece, linking the two pieces back together, and then executing; the result. It attempts to narrow down the list of passes to the one (or few); which are causing the miscompilation, then reduce the portion of the test; program which is being miscompiled. The miscompilation debugger assumes that; the selected code generator is working properly. Advice for using bugpoint; =========================. ``bugpoint`` can be a remarkably useful tool, but it sometimes works in; non-obvious ways. Here are some hints and tips:. * In the code generator and miscompilation debuggers, ``bugpoint`` only works; with programs that have deterministic output. Thus, if the program outputs; ``argv[0]``, the date, ti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:4932,safe,safe,4932,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['safe'],['safe']
Safety,"`index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side of LLVM transformations. Because this is a ""how-to"" section, you should also read about the main classes; that you will be working with. The :ref:`Core LLVM Class Hierarchy Reference; <coreclasses>` contains details and descriptions of the main classes that you; should know about. .. _inspection:. Basic Inspection and Traversal Routines; ---------------------------------------. The LLVM compiler infrastructure have many different data structures that may be; traversed. Following the example of the C++ standard template library, the; techniques used to traverse these various data structures are all basically the; same. For an enumerable sequence of values, the ``XXXbegin()`` function (or; method) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:103443,avoid,avoid,103443,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoid']
Safety,"`null``; upon entry to the function. Support for this mode in code generation is; largely a legacy detail to keep old collector implementations working. Custom lowering of intrinsics; ------------------------------. For GCs which use barriers or unusual treatment of stack roots, the; implementor is responsibly for providing a custom pass to lower the; intrinsics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such a pass is the ShadowStackGC and it's; ShadowStackGCLowering pass. There is currently no way to register such a custom lowering pass; without building a custom copy of LLVM. .. _safe-points:. Generating safe points; -----------------------. LLVM provides support for associating stackmaps with the return address of; a call. Any loop or return safepoints required by a given collector design; can be modeled via calls to runtime routines, or potentially patchable call; sequences. Using gcroot, all call instructions are inferred to be possible; safepoints and will thus have an associated stackmap. .. _assembly:. Emitting assembly code: ``GCMetadataPrinter``; ---------------------------------------------. LLVM allows a plugin to print arbitrary assembly code before and after the rest; of a module's assembly code. At the end of the module, the GC can compile the; LLVM stack map into assembly code. (At the beginning, this information is not; yet computed.). Since AsmWriter and CodeGen are separate components of LLVM, a separate abstract; base class and registry is provided for printing assembly code, the; ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``. The AsmWriter will look; for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:. .. code-block:: c++. MyGC::MyGC() {; UsesMetadata = true;; }. This separation allows JIT-only clients to be smaller. Note that LLVM does not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:34830,safe,safepoints,34830,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safepoints']
Safety,"a flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; print(c->name); // Unsafe read; } else {; kGlobalCustomer = c; // Pointer escape; }; // Unsafe read, Pointer escape; }; ```. ## Example: finding dead stores. Let's say we want to find redundant stores, because they indicate potential; bugs. ```c++; x = GetX();; x = GetY();; ```. The first store to `x` is never read, probably there is a bug. The implementation of dead store analysis is very similar to output parameter; analysis: we need to track stores and loads, and find stores that were never; read. [Liveness analysis](https://en.wikipedia.org/wiki/Live_variable_analysis) is a; generalization of this idea, which is often used to answer many related; questions, for example:. * finding dead stores,; * finding uninitialized variables,; * finding a good point to deallocate memory,; * finding out if it would be safe to move an object. ## Example: definitive initialization. Definitive initialization proves that variables are known to be initialized when; read. If we find a variable which is read when not initialized then we generate; a warning. ```c++; void Init() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; } else {; x = 20; // x is initialized; }; print(x); // x is initialized; }; ```. ```c++; void Uninit() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; }; print(x); // x is maybe uninitialized, x is being read, report a bug.; }; ```. For this purpose we can use lattice in a form of a mapping from variable; declarations to initialization states; each initialization state is represented; by the following lattice:. ![Lattice for definitive initialization analysis](DataFlowAnalysisIntroImages/DefinitiveInitializationLattice.svg). A lattice element could also capture the source lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:20319,safe,safe,20319,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['safe'],['safe']
Safety,"a set of ""internal"" bounds annotations to turn pointers; into wide pointers. These are ``__bidi_indexable`` and ``__indexable``. When a; pointer has either of these annotations, the compiler changes the pointer to the; corresponding wide pointer. This means these annotations will break the ABI and; will not be compatible with plain C, and thus they should generally not be used; in ABI surfaces. * ``__bidi_indexable`` : A pointer with this annotation becomes a wide pointer; to carry the upper bound and the lower bound, the layout of which is; equivalent to ``struct { T *ptr; T *upper_bound; T *lower_bound; };``. As the; name indicates, pointers with this annotation are ""bidirectionally indexable"",; meaning that they can be indexed with either a negative or a positive offset; and the pointers can be incremented or decremented using pointer arithmetic. A; ``__bidi_indexable`` pointer is allowed to hold an out-of-bounds pointer; value. While creating an OOB pointer is undefined behavior in C,; ``-fbounds-safety`` makes it well-defined behavior. That is, pointer; arithmetic overflow with ``__bidi_indexable`` is defined as equivalent of; two's complement integer computation, and at the LLVM IR level this means; ``getelementptr`` won't get ``inbounds`` keyword. Accessing memory using the; OOB pointer is prevented via a run-time bounds check. * ``__indexable`` : A pointer with this annotation becomes a wide pointer; carrying the upper bound (but no explicit lower bound), the layout of which is; equivalent to ``struct { T *ptr; T *upper_bound; };``. Since ``__indexable``; pointers do not have a separate lower bound, the pointer value itself acts as; the lower bound. An ``__indexable`` pointer can only be incremented or indexed; in the positive direction. Indexing it in the negative direction will trigger; a compile-time error. Otherwise, the compiler inserts a run-time; check to ensure pointer arithmetic doesn't make the pointer smaller than the; original ``__indexable`` poin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:14850,safe,safety,14850,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"a, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize incremental scans in generational collectors. * Emission of read barriers when loading object references. These are useful; for interoperating with concurrent collectors. There are additional areas that LLVM does not directly address:. * Registration of global roots with the runtime. * Registration of stack map entries with the runtime. * The functions used by the program to allocate memory, trigger a collection,; etc. * Computation or compilation of type maps, or registration of them with the; runtime. These are used to crawl the heap for object references. In general, LLVM's support for GC does not include features which can be; adequately addressed with other",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:6547,safe,safepoints,6547,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,2,['safe'],"['safely', 'safepoints']"
Safety,"a; <range-metadata>` and LLVM can do the sext to zext conversion for you. Zext GEP indices to machine register width; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Internally, LLVM often promotes the width of GEP indices to machine register; width. When it does so, it will default to using sign extension (sext); operations for safety. If your source language provides information about; the range of the index, you may wish to manually extend indices to machine; register width using a zext instruction. When to specify alignment; ^^^^^^^^^^^^^^^^^^^^^^^^^^; LLVM will always generate correct code if you don’t specify alignment, but may; generate inefficient code. For example, if you are targeting MIPS (or older; ARM ISAs) then the hardware does not handle unaligned loads and stores, and; so you will enter a trap-and-emulate path if you do a load or store with; lower-than-natural alignment. To avoid this, LLVM will emit a slower; sequence of loads, shifts and masks (or load-right + load-left on MIPS) for; all cases where the load / store does not have a sufficiently high alignment; in the IR. The alignment is used to guarantee the alignment on allocas and globals,; though in most cases this is unnecessary (most targets have a sufficiently; high default alignment that they’ll be fine). It is also used to provide a; contract to the back end saying ‘either this load/store has this alignment, or; it is undefined behavior’. This means that the back end is free to emit; instructions that rely on that alignment (and mid-level optimizers are free to; perform transforms that require that alignment). For x86, it doesn’t make; much difference, as almost all instructions are alignment-independent. For; MIPS, it can make a big difference. Note that if your loads and stores are atomic, the backend will be unable to; lower an under aligned access into a sequence of natively aligned accesses.; As a result, alignment is mandatory for atomic loads and stores. Other Things to Consider; ^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:4907,avoid,avoid,4907,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['avoid'],['avoid']
Safety,"a; SREM or UREM operation. The `legalize types`_ and `legalize operations`_ phases; are responsible for turning an illegal DAG into a legal DAG. .. _SelectionDAG-Process:. SelectionDAG Instruction Selection Process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SelectionDAG-based instruction selection consists of the following steps:. #. `Build initial DAG`_ --- This stage performs a simple translation from the; input LLVM code to an illegal SelectionDAG. #. `Optimize SelectionDAG`_ --- This stage performs simple optimizations on the; SelectionDAG to simplify it, and recognize meta instructions (like rotates; and ``div``/``rem`` pairs) for targets that support these meta operations.; This makes the resultant code more efficient and the `select instructions; from DAG`_ phase (below) simpler. #. `Legalize SelectionDAG Types`_ --- This stage transforms SelectionDAG nodes; to eliminate any types that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to clean up; redundancies exposed by type legalization. #. `Legalize SelectionDAG Ops`_ --- This stage transforms SelectionDAG nodes to; eliminate any operations that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to eliminate; inefficiencies introduced by operation legalization. #. `Select instructions from DAG`_ --- Finally, the target instruction selector; matches the DAG operations to target instructions. This process translates; the target-independent input DAG into another DAG of target instructions. #. `SelectionDAG Scheduling and Formation`_ --- The last phase assigns a linear; order to the instructions in the target-instruction DAG and emits them into; the MachineFunction being compiled. This step uses traditional prepass; scheduling techniques. After all of these steps are complete, the SelectionDAG is destroyed and the; rest of the code generation passes are run. One of the most common ways to debug these steps is using `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:37618,redund,redundancies,37618,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['redund'],['redundancies']
Safety,"a[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:11012,safe,safety,11012,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"ability and; maintainability of the code. We consider that readability is harmed when omitting the brace in the presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or none of its; members, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``if``; would help to avoid running into a ""dangling else"" situation. .. code-block:: c++. // Omit the braces since the body is simple and clearly associated with the; // `if`.; if (isa<FunctionDecl>(D)); handleFunctionDecl(D);; else if (isa<VarDecl>(D)); handleVarDecl(D);. // Here we document the condition itself and not the body.; if (isa<VarDecl>(D)) {; // It is necessary that we explain the situation with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (shouldProcessAttr(A)); handleAttr(A);; }. // Use braces for the `if` block to keep it uniform with the `else` block.; if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D);; } else {; // In this `else` case, it i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:62830,avoid,avoid,62830,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"able`` can cast to ``__single``. The; compiler may insert run-time checks to ensure the pointer has at least a; single element or is a null pointer. * ``__bidi_indexable`` casts to ``__indexable`` if the pointer does not have an; underflow. The compiler may insert run-time checks to ensure the pointer is; not below the lower bound. * ``__indexable`` casts to ``__bidi_indexable``. The resulting; ``__bidi_indexable`` gets the lower bound same as the pointer value. * A type conversion may involve both a bitcast and a bounds annotation cast. For; example, casting from ``int *__bidi_indexable`` to ``char *__single`` involve; a bitcast (``int *`` to ``char *``) and a bounds annotation cast; (``__bidi_indexable`` to ``__single``). In this case, the compiler performs; the bitcast and then converts the bounds annotation. This means, ``int; *__bidi_indexable`` will be converted to ``char *__bidi_indexable`` and then; to ``char *__single``. * ``__terminated_by(T)`` cannot cast to any safe pointer type without the same; ``__terminated_by(T)`` attribute. To perform the cast, programmers can use an; intrinsic function such as ``__unsafe_terminated_by_to_indexable(P)`` to force; the conversion. * ``__terminated_by(T)`` can cast to ``__unsafe_indexable``. * Any type without ``__terminated_by(T)`` cannot cast to ``__terminated_by(T)``; without explicitly using an intrinsic function to allow it. + ``__unsafe_terminated_by_from_indexable(T, PTR [, PTR_TO_TERM])`` casts any; safe pointer PTR to a ``__terminated_by(T)`` pointer. ``PTR_TO_TERM`` is an; optional argument where the programmer can provide the exact location of the; terminator. With this argument, the function can skip reading the entire; array in order to locate the end of the pointer (or the upper bound).; Providing an incorrect ``PTR_TO_TERM`` causes a run-time trap. + ``__unsafe_forge_terminated_by(T, P, E)`` creates ``T __terminated_by(E)``; pointer given any pointer ``P``. Tmust be a pointer type. Portability with tool",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:44100,safe,safe,44100,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safe']
Safety,"about CodeView and PDBs is ongoing. * RTTI: :good:`Complete`. Generation of RTTI data structures has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4436,safe,safe,4436,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['safe'],['safe']
Safety,"ace. ###### The flag registers again make everything hard. Unfortunately, the technique of using `orq`-instructions has a serious flaw on; x86. The very thing that makes it easy to accumulate state, the flag registers; containing predicates, causes serious problems here because they may be alive; and used by the loading instruction or subsequent instructions. On x86, the; `orq` instruction **sets** the flags and will override anything already there.; This makes inserting them into the instruction stream very hazardous.; Unfortunately, unlike when hardening the loaded value, we have no fallback here; and so we must have a fully general approach available. The first thing we must do when generating these sequences is try to analyze; the surrounding code to prove that the flags are not in fact alive or being; used. Typically, it has been set by some other instruction which just happens; to set the flags register (much like ours!) with no actual dependency. In those; cases, it is safe to directly insert these instructions. Alternatively we may; be able to move them earlier to avoid clobbering the used value. However, this may ultimately be impossible. In that case, we need to preserve; the flags around these instructions:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; pushfq; orq %rax, %rcx # Mask the pointer if misspeculating.; orq %rax, %rdx # Mask the index if misspeculating.; popfq; movl (%rcx,%rdx), %edi; ```. Using the `pushf` and `popf` instructions saves the flags register around our; inserted code, but comes at a high cost. First, we must store the flags to the; stack and reload them. Second, this causes the stack pointer to be adjusted; dynamically, requiring a frame pointer be used for referring to temporaries; spilled to the stack, etc. On newer x86 processors we can use the `lahf` and `sahf` instructions to save; all of the flags besides the overflow flag in a register rather than on the; stack. We can then use `seto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:32153,safe,safe,32153,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['safe'],['safe']
Safety,"ach; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:69455,detect,detection,69455,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['detect'],['detection']
Safety,"ack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7069,safe,safe,7069,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['safe'],['safe']
Safety,"add32carry:; 	leal	(%rsi,%rdi), %eax; 	cmpl	%esi, %eax; 	adcl	$0, %eax; 	ret. //===---------------------------------------------------------------------===//. The hot loop of 256.bzip2 contains code that looks a bit like this:. int foo(char *P, char *Q, int x, int y) {; if (P[0] != Q[0]); return P[0] < Q[0];; if (P[1] != Q[1]); return P[1] < Q[1];; if (P[2] != Q[2]); return P[2] < Q[2];; return P[3] < Q[3];; }. In the real code, we get a lot more wrong than this. However, even in this; code we generate:. _foo: ## @foo; ## %bb.0: ## %entry; 	movb	(%rsi), %al; 	movb	(%rdi), %cl; 	cmpb	%al, %cl; 	je	LBB0_2; LBB0_1: ## %if.then; 	cmpb	%al, %cl; 	jmp	LBB0_5; LBB0_2: ## %if.end; 	movb	1(%rsi), %al; 	movb	1(%rdi), %cl; 	cmpb	%al, %cl; 	jne	LBB0_1; ## %bb.3: ## %if.end38; 	movb	2(%rsi), %al; 	movb	2(%rdi), %cl; 	cmpb	%al, %cl; 	jne	LBB0_1; ## %bb.4: ## %if.end60; 	movb	3(%rdi), %al; 	cmpb	3(%rsi), %al; LBB0_5: ## %if.end60; 	setl	%al; 	movzbl	%al, %eax; 	ret. Note that we generate jumps to LBB0_1 which does a redundant compare. The; redundant compare also forces the register values to be live, which prevents; folding one of the loads into the compare. In contrast, GCC 4.2 produces:. _foo:; 	movzbl	(%rsi), %eax; 	cmpb	%al, (%rdi); 	jne	L10; L12:; 	movzbl	1(%rsi), %eax; 	cmpb	%al, 1(%rdi); 	jne	L10; 	movzbl	2(%rsi), %eax; 	cmpb	%al, 2(%rdi); 	jne	L10; 	movzbl	3(%rdi), %eax; 	cmpb	3(%rsi), %al; L10:; 	setl	%al; 	movzbl	%al, %eax; 	ret. which is ""perfect"". //===---------------------------------------------------------------------===//. For the branch in the following code:; int a();; int b(int x, int y) {; if (x & (1<<(y&7))); return a();; return y;; }. We currently generate:; 	movb	%sil, %al; 	andb	$7, %al; 	movzbl	%al, %eax; 	btl	%eax, %edi; 	jae	.LBB0_2. movl+andl would be shorter than the movb+andb+movzbl sequence. //===---------------------------------------------------------------------===//. For the following:; struct u1 {; float x, y;; };; float foo(struct u1 u) {; retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:40575,redund,redundant,40575,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['redund'],['redundant']
Safety,"additional; :ref:`optimization rules <arc.optimization>` which permit the removal or; optimization of operations based on local knowledge of data flow. The; semantics describe the high-level behaviors that the compiler implements, not; an exact sequence of operations that a program will be compiled into. .. _arc.objects.operands:. Retainable object pointers as operands and arguments; ----------------------------------------------------. In general, ARC does not perform retain or release operations when simply using; a retainable object pointer as an operand within an expression. This includes:. * loading a retainable pointer from an object with non-weak :ref:`ownership; <arc.ownership>`,; * passing a retainable pointer as an argument to a function or method, and; * receiving a retainable pointer as the result of a function or method call. .. admonition:: Rationale. While this might seem uncontroversial, it is actually unsafe when multiple; expressions are evaluated in ""parallel"", as with binary operators and calls,; because (for example) one expression might load from an object while another; writes to it. However, C and C++ already call this undefined behavior; because the evaluations are unsequenced, and ARC simply exploits that here to; avoid needing to retain arguments across a large number of calls. The remainder of this section describes exceptions to these rules, how those; exceptions are detected, and what those exceptions imply semantically. .. _arc.objects.operands.consumed:. Consumed parameters; ^^^^^^^^^^^^^^^^^^^. A function or method parameter of retainable object pointer type may be marked; as :arc-term:`consumed`, signifying that the callee expects to take ownership; of a +1 retain count. This is done by adding the ``ns_consumed`` attribute to; the parameter declaration, like so:. .. code-block:: objc. void foo(__attribute((ns_consumed)) id x);; - (void) foo: (id) __attribute((ns_consumed)) x;. This attribute is part of the type of the function or me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:15980,unsafe,unsafe,15980,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['unsafe'],['unsafe']
Safety,"age adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (see the next section about CLHEP compatibility). #### Compatibility with CLHEP Vector Classes. - For backward compatibility with CLHEP the vector classes can be; constructed from a CLHEP `HepVector` or **`HepLorentzVector`**, by; using a template constructor, which requires only that the classes; implement the accessors` x()`, `y()`, and `z()` (and `t()` for the; 4D). - We provide vector member function with the same naming convention as; CLHEP for the most used functions like `x()`, `y()` and `z()`. #### Connection to Linear Algebra Package. In some use cases, like in track reconstruction, it is needed to use the; content of the vector and rotation classes in conjunction with linear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:76596,avoid,avoid,76596,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"age we have is that the attacker also cannot modify; `%base`. If we use the fast instruction sequence above, but only apply it to; the index, we will always access `%rip + (scale * -1) + offset`. If the; attacker can find a load which with this address happens to point to secret; data, then they can reach it. However, the loader and base libraries can also; simply refuse to map the heap, data segments, or stack within 2gb of any of the; text in the program, much like it can reserve the low 2gb of address space. ###### The flag registers again make everything hard. Unfortunately, the technique of using `orq`-instructions has a serious flaw on; x86. The very thing that makes it easy to accumulate state, the flag registers; containing predicates, causes serious problems here because they may be alive; and used by the loading instruction or subsequent instructions. On x86, the; `orq` instruction **sets** the flags and will override anything already there.; This makes inserting them into the instruction stream very hazardous.; Unfortunately, unlike when hardening the loaded value, we have no fallback here; and so we must have a fully general approach available. The first thing we must do when generating these sequences is try to analyze; the surrounding code to prove that the flags are not in fact alive or being; used. Typically, it has been set by some other instruction which just happens; to set the flags register (much like ours!) with no actual dependency. In those; cases, it is safe to directly insert these instructions. Alternatively we may; be able to move them earlier to avoid clobbering the used value. However, this may ultimately be impossible. In that case, we need to preserve; the flags around these instructions:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; pushfq; orq %rax, %rcx # Mask the pointer if misspeculating.; orq %rax, %rdx # Mask the index if misspeculating.; popfq; movl (%rcx,%rdx), %edi; ```. Using the `p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:31676,hazard,hazardous,31676,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['hazard'],['hazardous']
Safety,"ail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These operations are required to be atomic in the sense that if you use; unordered loads and unordered stores, a load cannot see a value which was; never stored. A normal load or store instruction is usually sufficient, but; note that an unordered load or store cannot be split into multiple; instructions (or an instruction which does multiple memory operations, like; ``LDRD`` on ARM without LPAE, or not naturally-aligned ``LDRD`` on LPAE ARM). Monotonic; ---------. Monotonic is the weakest level of atomicity that can be used in synchronization; primitives, although it does not provide any general synchronization. It; essentially guarantees that if you take all the operations affecting a specific; address, a consistent ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:9246,unsafe,unsafe,9246,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['unsafe'],['unsafe']
Safety,"ailure. Defaults to false. **--args** *program args*. Pass all arguments specified after **--args** to the test program whenever it runs.; Note that if any of the *program args* start with a ""``-``"", you should use:. .. code-block:: bash. bugpoint [bugpoint args] --args -- [program args]. The ""``--``"" right after the **--args** option tells **bugpoint** to consider; any options starting with ""``-``"" to be part of the **--args** option, not as; options to **bugpoint** itself. **--tool-args** *tool args*. Pass all arguments specified after **--tool-args** to the LLVM tool under test; (**llc**, **lli**, etc.) whenever it runs. You should use this option in the; following way:. .. code-block:: bash. bugpoint [bugpoint args] --tool-args -- [tool args]. The ""``--``"" right after the **--tool-args** option tells **bugpoint** to; consider any options starting with ""``-``"" to be part of the **--tool-args**; option, not as options to **bugpoint** itself. (See **--args**, above.). **--safe-tool-args** *tool args*. Pass all arguments specified after **--safe-tool-args** to the ""safe"" execution; tool. **--gcc-tool-args** *gcc tool args*. Pass all arguments specified after **--gcc-tool-args** to the invocation of; **gcc**. **--opt-args** *opt args*. Pass all arguments specified after **--opt-args** to the invocation of **opt**. **--disable-{dce,simplifycfg}**. Do not run the specified passes to clean up and reduce the size of the test; program. By default, **bugpoint** uses these passes internally when attempting to; reduce test programs. If you're trying to find a bug in one of these passes,; **bugpoint** may crash. **--enable-valgrind**. Use valgrind to find faults in the optimization phase. This will allow; bugpoint to find otherwise asymptomatic problems caused by memory; mis-management. **-find-bugs**. Continually randomize the specified passes and run them on the test program; until a bug is found or the user kills **bugpoint**. **-help**. Print a summary of command line opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:2138,safe,safe-tool-args,2138,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['safe'],['safe-tool-args']
Safety,"al destination which contains an unreachable; instruction. This form conveys to the optimizer that the call returns; abnormally. For an invoke which neither returns normally or requires unwind; code in the current function, you can use a noreturn call instruction if; desired. This is generally not required because the optimizer will convert; an invoke with an unreachable unwind destination to a call instruction. #. Use profile metadata to indicate statically known cold paths, even if; dynamic profiling information is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:7559,safe,safe,7559,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['safe'],['safe']
Safety,"alf by refactoring the code reading and writing the TBasket data;; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch. Updated TBranchElement::Unroll to no longer split a base class; that can not be split (i.e. respect the information returned; by TStreamerElement::CannotSplit (and thus TClass::CanSplit). This disabling is currently _not_ done automatically for backward compatibility reasons and because; ; Without TClass::SetCanSplit there was no way to; force the splitting (short of setting the split level lower); Some classes still requires a custom streamer solely to; read older data files (for example for file written before; the advent of StreamerInfo) and are such not necessary to; be used when writting (and schema evolution rules can not; yet be used in this case). Allowed removing branches when cloning a TNtuple. Added an option value (""cachedbranches"") to the Print() function of TTreeCache to be able to print the list of cached branches. Made the ownership of the TBranch by fBranch clearer (and thus allow the 'reuse' of TTree object without memory leak). Introduced GetLeaf(branchname,leafname) used in TTreeFormula to avoid ambiguity in the syntax introduced by too many slashes. Improved performance of TTree::GetEntry. With this changes the 'overhead'; compare to protobuf goes from 48% to 24%. (This does not include the; cost of the file opening which can be comparatively large for small; files. For the example used in the comparison the cost TFile::Open is 8% of the cost; of 100000 calls to TTree::GetEntry). Prevented the use of non-existent memory when reading in an object that is part of an STL collection and which used; to contains an embedded object (and this data member has been removed). Now properly recognize a TClonesArray data member even if the requested type was a typedef (to TClonesArray) that is in a namespace (for example edm::Event::ContaierType). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html:3574,avoid,avoid,3574,tree/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html,1,['avoid'],['avoid']
Safety,"alized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``__has_feature(memory_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and therefore should be used with care, and only if absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; consid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:2498,avoid,avoid,2498,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['avoid'],['avoid']
Safety,"all optimization,; and omission of register saves and restores in some cases; it is not; checked or enforced when generating the callee. The parameter and the; function return type must be valid operands for the; :ref:`bitcast instruction <i_bitcast>`. This is not a valid attribute for; return values and can only be applied to one parameter. ``nonnull``; This indicates that the parameter or return pointer is not null. This; attribute may only be applied to pointer typed parameters. This is not; checked or enforced by LLVM; if the parameter or return pointer is null,; :ref:`poison value <poisonvalues>` is returned or passed instead.; The ``nonnull`` attribute should be combined with the ``noundef`` attribute; to ensure a pointer is not null or otherwise the behavior is undefined. ``dereferenceable(<n>)``; This indicates that the parameter or return pointer is dereferenceable. This; attribute may only be applied to pointer typed parameters. A pointer that; is dereferenceable can be loaded from speculatively without a risk of; trapping. The number of bytes known to be dereferenceable must be provided; in parentheses. It is legal for the number of bytes to be less than the; size of the pointee type. The ``nonnull`` attribute does not imply; dereferenceability (consider a pointer to one element past the end of an; array), however ``dereferenceable(<n>)`` does imply ``nonnull`` in; ``addrspace(0)`` (which is the default address space), except if the; ``null_pointer_is_valid`` function attribute is present.; ``n`` should be a positive number. The pointer should be well defined,; otherwise it is undefined behavior. This means ``dereferenceable(<n>)``; implies ``noundef``. ``dereferenceable_or_null(<n>)``; This indicates that the parameter or return value isn't both; non-null and non-dereferenceable (up to ``<n>`` bytes) at the same; time. All non-null pointers tagged with; ``dereferenceable_or_null(<n>)`` are ``dereferenceable(<n>)``.; For address space 0 ``dereferenceable_o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:61344,risk,risk,61344,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['risk'],['risk']
Safety,"all. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17447,redund,redundant,17447,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['redund'],['redundant']
Safety,"ally; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_object_size`` (which Clang also supports), but; ``__builtin_dynamic_object_size`` can evaluate the object's size at runtime.; ``__builtin_dynamic_object_size`` is meant to be used as a drop-in replacement; for ``__builtin_object_size`` in libraries that support it. For instance, here is a program that ``__builtin_dynamic_object_size`` will make; safer:. .. code-block:: c. void copy_into_buffer(size_t size) {; char* buffer = malloc(size);; strlcpy(buffer, ""some string"", strlen(""some string""));; // Previous line preprocesses to:; // __builtin___strlcpy_chk(buffer, ""some string"", strlen(""some string""), __builtin_object_size(buffer, 0)); }. Since the size of ``buffer`` can't be known at compile time, Clang will fold; ``__builtin_object_size(buffer, 0)`` into ``-1``. However, if this was written; as ``__builtin_dynamic_object_size(buffer, 0)``, Clang will fold it into; ``size``, providing some extra runtime safety. Deprecating Macros; ==================. Clang supports the pragma ``#pragma clang deprecated``, which can be used to; provide deprecation warnings for macro uses. For example:. .. code-block:: c. #define MIN(x, y) x < y ? x : y; #pragma clang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#pragma clang deprecated`` should be preferred for this purpose over; ``#pragma GCC warning`` because the warning can be controlled with; ``-Wdeprecated``. Restricted Expansion Macros; ===========================. Clang supports the pragma ``#pragma clang restrict_expansion``, which can be; used restrict macro expansion in headers. This can be valuable when providing; headers with ABI stability requirements. Any expansion of the annotated macro; processed by the preprocessor after the ``#pragma`` annotation will log a; warning. Redef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:189365,safe,safety,189365,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['safe'],['safety']
Safety,"already visited.; Methods of CallExpr/FunctionDecl/CallEvent that; return arguments crash when the argument is out-of-bounds. If you checked the function name,; it doesn't mean that the function has the expected number of arguments!; Which is why you should use CallDescription.; Nullability of different entities within different kinds of symbols and regions is usually; documented via assertions in their constructors.; NamedDecl::getName will fail if the name of the declaration is not a single token,; e.g. for destructors. You could use NamedDecl::getNameAsString for those cases.; Note that this method is much slower and should be used sparringly, e.g. only when generating reports; but not during analysis.; Is -analyzer-checker=core included in all test RUN: lines? It was never supported; to run the analyzer with the core checks disabled. It might cause unexpected behavior and; crashes. You should do all your testing with the core checks enabled. Patterns that you should most likely avoid even if they're not technically wrong:. BugReporterVisitor should most likely not match the AST of the current program point; to decide when to emit a note. It is much easier to determine that by observing changes in; the program state.; In State->getSVal(Region), if Region is not known to be a TypedValueRegion; and the optional type argument is not specified, the checker may accidentally try to dereference a; void pointer.; Checker logic should not depend on whether a certain value is a Loc or NonLoc.; It should be immediately obvious whether the SVal is a Loc or a; NonLoc depending on the AST that is being checked. Checking whether a value; is Loc or Unknown/Undefined or whether the value is; NonLoc or Unknown/Undefined is totally fine.; New symbols should not be constructed in the checker via direct calls to SymbolManager,; unless they are of SymbolMetadata class tagged by the checker,; or they represent newly created values such as the return value in evalCall.; For modeling arit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:26014,avoid,avoid,26014,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['avoid'],['avoid']
Safety,"alue is then passed by-address. For; output-only parameters, the temporary is uninitialized when passed (if the; parameter is not explicitly initialized inside the function an undefined value; is stored back to the argument expression). For parameters that are both input; and output, the temporary is initialized from the lvalue argument expression; through implicit or explicit casting from the lvalue argument type to the; parameter type. On return of the function, the values of any parameter temporaries are written; back to the argument expression through an inverted conversion sequence (if an; ``out`` parameter was not initialized in the function, the uninitialized value; may be written back). Parameters of constant-sized array type are also passed with value semantics.; This requires input parameters of arrays to construct temporaries and the; temporaries go through array-to-pointer decay when initializing parameters. Implementations are allowed to avoid unnecessary temporaries, and HLSL's strict; no-alias rules can enable some trivial optimizations. Array Temporaries; -----------------. Given the following example:. .. code-block:: c++. void fn(float a[4]) {; a[0] = a[1] + a[2] + a[3];; }. float4 main() : SV_Target {; float arr[4] = {1, 1, 1, 1};; fn(arr);; return float4(arr[0], arr[1], arr[2], arr[3]);; }. In C or C++, the array parameter decays to a pointer, so after the call to; ``fn``, the value of ``arr[0]`` is ``3``. In HLSL, the array is passed by value,; so modifications inside ``fn`` do not propagate out. .. note::. DXC may pass unsized arrays directly as decayed pointers, which is an; unfortunate behavior divergence. Out Parameter Temporaries; -------------------------. .. code-block:: c++. void Init(inout int X, inout int Y) {; Y = 2;; X = 1;; }. void main() {; int V;; Init(V, V); // MSVC (or clang-cl) V == 2, Clang V == 1; }. In the above example the ``Init`` function's behavior depends on the C++; implementation. C++ does not define the order in which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:2286,avoid,avoid,2286,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,1,['avoid'],['avoid']
Safety,"alue. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23430,safe,safety,23430,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safety']
Safety,"always_inline)); #else; #define ALWAYS_INLINE; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__always_inline__`` can be used instead of ``always_inline``. ``__has_declspec_attribute``; ----------------------------. This function-like macro takes a single identifier argument that is the name of; an attribute implemented as a Microsoft-style ``__declspec`` attribute. It; evaluates to 1 if the attribute is supported by the current compilation target,; or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_declspec_attribute // Optional of course.; #define __has_declspec_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_declspec_attribute(dllexport); #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__dllexport__`` can be used instead of ``dllexport``. ``__is_identifier``; -------------------. This function-like macro takes a single identifier argument that might be either; a reserved word or a regular identifier. It evaluates to 1 if the argument is just; a regular identifier and not a reserved word, in the sense that it can then be; used as the name of a user-defined function or variable. Otherwise it evaluates; to 0. It can be used like this:. .. code-block:: c++. ...; #ifdef __is_identifier // Compatibility with non-clang compilers.; #if __is_identifier(__wchar_t); typedef wchar_t __wchar_t;; #endif; #endif. __wchar_t WideCharacter;; ... Include File Checking Macros; ============================. Not all developments systems have the same include files. The; :ref:`langext-__has_include` and :ref:`langext-__has_include_next` macros allow; you to check for the existence of an include f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:9016,avoid,avoid,9016,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"am:. .. code-block:: shell. clang++ -c --offload-arch=gfx906 sample.hip -o sample.o. To link a HIP program, use this command:. .. code-block:: shell. clang++ --hip-link --offload-arch=gfx906 sample.o -o sample. In the above command, the ``--hip-link`` flag instructs Clang to link the HIP runtime library. However,; the use of this flag is unnecessary if a HIP input file is already present in your program. For convenience, Clang also supports compiling and linking in a single step:. .. code-block:: shell. clang++ --offload-arch=gfx906 -xhip sample.cpp -o sample. In the above commands, ``gfx906`` is the GPU architecture that the code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:3447,detect,detect,3447,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['detect'],['detect']
Safety,"ameter; which causes ${\displaystyle F'}$ to increase by the amount; FCNBase::up(), where ${\displaystyle F'}$ is the minimum of; $\mbox{FCN}$ with respect to all *other* free parameters, and; FCNBase::up() is the return value of the error definition specified by; the user (default = 1.). The algorithm for finding the positive and negative $\mbox{MINOS}$; errors for parameter $\mbox{n}$ consists of varying parameter; $\mbox{n}$, each time minimizing $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 1}$ variable parameters, to find; numerically the two values of parameter $\mbox{n}$ for which the; minimum of $\mbox{FCN}$ takes on the values; $\displaystyle F_{\mathrm{min}} + \mbox{up}$, where; $\displaystyle F_{\mathrm{min}}$ is the minimum of $\mbox{FCN}$ with; respect to all $\mbox{npar}$ parameters. In order to make the; procedure as fast as possible, $\mbox{MINOS}$ uses the error matrix; to predict the values of all parameters at the various sub-minima which; it will have to find in the course of the calculation, and in the limit; that the problem is nearly linear, the predictions of $\mbox{MINOS}$; will be nearly exact, requiring very few iterations. On the other hand,; when the problem is very non-linear (i.e., $\mbox{FCN}$ is far from; a quadratic function of its parameters), is precisely the situation when; $\mbox{MINOS}$ is needed in order to indicate the correct parameter; errors. ### $\mbox{CONTOURS}$ plotting ###. M offers a procedure for finding $\mbox{FCN}$ $\mbox{CONTOURS}$; (provided via the class MnContours, see [api:contours]). The contour calculated by MnContours::operator() is dynamic, in the; sense that it represents the minimum of $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 2}$ parameters (if any). In statistical; terms, this means that MnContours takes account of the correlations; between the two parameters being plotted, and all the other variable; parameters, using a procedure analogous to that of $\mbox{MINOS}$.; (If th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:19143,predict,predict,19143,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,['predict'],"['predict', 'predictions']"
Safety,"an be nested).; * The ``Lexer`` keeps track of an :ref:`MultipleIncludeOpt; <MultipleIncludeOpt>` object, which is used to detect whether the buffer uses; the standard ""``#ifndef XX`` / ``#define XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56414,detect,detect,56414,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['detect'],['detect']
Safety,"an be; retrieved after the call:. ``` {.cpp}; Double_t TGeoManager::GetStep(); ```. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning *""step approved""*. The default value for `stepmax` is; `TGeoShape::Big `with the meaning that boundaries are looked for; without limitation. ![Finding the distance to the next crossed boundary](pictures/080001E8.png). According the values of the input parameters the method will perform; additional optional tasks:. **`|stepmax| < `** ***`TGeoShape::Big()`*** **` `**. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. **`stepmax < 0`**. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:160208,safe,safe,160208,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"an promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking is: should I bother with this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for indu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9713,avoid,avoid,9713,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['avoid'],['avoid']
Safety,"an.; This is useful to improve optimization and eliminates certain warnings. For; example, without the ``__builtin_unreachable`` in the example below, the; compiler assumes that the inline asm can fall through and prints a ""function; declared '``noreturn``' should not return"" warning. **Syntax**:. .. code-block:: c++. __builtin_unreachable(). **Example of use**:. .. code-block:: c++. void myabort(void) __attribute__((noreturn));; void myabort(void) {; asm(""int3"");; __builtin_unreachable();; }. **Description**:. The ``__builtin_unreachable()`` builtin has completely undefined behavior.; Since it has undefined behavior, it is a statement that it is never reached and; the optimizer can take advantage of this to produce better code. This builtin; takes no arguments and produces a void result. Query for this feature with ``__has_builtin(__builtin_unreachable)``. ``__builtin_unpredictable``; ---------------------------. ``__builtin_unpredictable`` is used to indicate that a branch condition is; unpredictable by hardware mechanisms such as branch prediction logic. **Syntax**:. .. code-block:: c++. __builtin_unpredictable(long long). **Example of use**:. .. code-block:: c++. if (__builtin_unpredictable(x > 0)) {; foo();; }. **Description**:. The ``__builtin_unpredictable()`` builtin is expected to be used with control; flow conditions such as in ``if`` and ``switch`` statements. Query for this feature with ``__has_builtin(__builtin_unpredictable)``. ``__builtin_expect``; --------------------. ``__builtin_expect`` is used to indicate that the value of an expression is; anticipated to be the same as a statically known result. **Syntax**:. .. code-block:: c++. long __builtin_expect(long expr, long val). **Example of use**:. .. code-block:: c++. if (__builtin_expect(x, 0)) {; bar();; }. **Description**:. The ``__builtin_expect()`` builtin is typically used with control flow; conditions such as in ``if`` and ``switch`` statements to help branch; prediction. It means that its fir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:113434,predict,prediction,113434,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['predict'],['prediction']
Safety,"anager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51186,safe,safe,51186,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"anager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ~~~ {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ~~~. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ~~~ {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ~~~. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ~~~ {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ~~~. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ~~~ {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ~~~. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:4902,safe,safe,4902,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['safe'],['safe']
Safety,"anagerFile have been renamed; TDataSetManager; and TDataSetManagerFile. New; functionality. Add support for session; queuing in the scheduler. This; allows to control the number of sessions allowed to process queries; concurrently. The feature is enabled by a new parameter 'queue:fifo' in; the 'xpd.schedparam'; directive. In case of static worker assignment; (default, random,; round-robin) the max number of running sessions can be limited by; another new parameter 'mxrun';; for; example;            ;     xpd.schedparam default; mxrun:3 queue:fifo; will run concurrently only 3 sessions. Additional requests are queued; and run as soon as one of the running; sessions goes idle. The current policy is FIFO, so that there is a; rotation among queued; sessions. In the case of load-based worker assignment, the max number; of running; queries is determined dynamically.; Add support for repeat functionality in the xrd.worker; directive. To avoid repeating the same line N times; one can just add; 'repeat=N'; in the line; for; example;            ;     xpd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:1018,avoid,avoid,1018,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['avoid'],['avoid']
Safety,"analysis, and visualization. RooFit provides; a set of tools/classes to define and evaluate probability density functions; (PDFs), perform maximum likelihood fits, perform statistical tests, etc. ## Proof of Concept: Speeding up RooFit using Automatic Differentiation (AD). RooFit is used to reduce statistical models (functions) to find a set of; parameters that minimize the value of the function. This minimization happens; via one of several methods relying heavily on the computation of derivatives; of the function with respect to its free parameters. Currently, the; computation of Numerical Derivatives is the most time-consuming component of; RooFit [^1]. On the other hand, derivatives computed using the Automatic; Differentiation tool [Clad] have been shown to be far more efficient [^2]. \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. Main Advantage of using AD with RooFit: efficient and more precise; derivatives. It computes derivatives with high precision, avoiding the errors; that may arise from approximating derivatives using finite differences. \htmlonly; </div>; \endhtmlonly. ### AD Support essentially requires Code Generation. As we'll discuss in upcoming sections, *AD support* can be added using *C++; Code generation*.; These two terms may be used interchangeably in this document, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current Status of Code Generation in RooFit. RooFit is an extensive toolkit.; The initiative to add AD support/ Code Generation has been started, but has; not yet achieved full coverage for the models defined/maintained in RooFit. ## How Clad enables AD support using Source Code Transformation. [Clad] is a C++ plugin for Clang. It implements a technique called Source Code; Transformation to enable AD support. Source Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:1546,avoid,avoiding,1546,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['avoid'],['avoiding']
Safety,"and parses `Foo.h`. The recursive parsing happens at two places; making this code path error prone.; ```cpp; // ROOT prompt; root [] namespace foo { };struct S;; root [] foo::bar/*store parsing state*/; gSystem->Load(""Foo"");; // More scaffolding.; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; /*restore parsing state*/ baz1 /*store parsing state*/; #include <Foo.h>/*restore parsing state*/;; ```. To recap, unfortunately, ROOT PCH is not extendable; ROOTMAP requires a lot of; maintenance and goes on a very untested codepath, while RDICT has a very limited; scope. The three features require a lot of mechanisms to work together and the; corner cases are very many. The interaction between some of the features often; break design and introduce layering violations. ## From C++ Modules to Dictionaries. C++ Modules have native capabilities to avoid reparsing. It combines all; home-grown solutions to avoid the costly operation at industry quality. Currently, when ROOT is built with `-Druntime_cxxmodules=On` it gives priority to; C++ Module files (real *pcm* files). If such a file is present it reads all; necessary information from it. If no such file is present ROOT falls back to the; standard information flow. ### Observable differences from 'standard' ROOT. As always, ROOT is (mostly) API and ABI compatible. C++ Modules-aware ROOT is no; different. There are several differences which can be noticed:; * \*modulemap files in $ROOTSYS/include -- those files are used by rootcling to; put a set of header files in a single pcm file. For example, all related; headers of *libGeom* are persisted in *Geom.pcm*. There are a few notable; examples, which are specific to the way we build ROOT. In certain cases we; want some header files to be compiled within C context or with RTTI on/off.; That's mostly for bootstrapping ROO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:11255,avoid,avoid,11255,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 15,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106282,safe,safety,106282,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['safe'],['safety']
Safety,"ang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#pragma clang deprecated`` should be preferred for this purpose over; ``#pragma GCC warning`` because the warning can be controlled with; ``-Wdeprecated``. Restricted Expansion Macros; ===========================. Clang supports the pragma ``#pragma clang restrict_expansion``, which can be; used restrict macro expansion in headers. This can be valuable when providing; headers with ABI stability requirements. Any expansion of the annotated macro; processed by the preprocessor after the ``#pragma`` annotation will log a; warning. Redefining the macro or undefining the macro will not be diagnosed, nor; will expansion of the macro within the main source file. For example:. .. code-block:: c. #define TARGET_ARM 1; #pragma clang restrict_expansion(TARGET_ARM, ""<reason>""). /// Foo.h; struct Foo {; #if TARGET_ARM // warning: TARGET_ARM is marked unsafe in headers: <reason>; uint32_t X;; #else; uint64_t X;; #endif; };. /// main.c; #include ""foo.h""; #if TARGET_ARM // No warning in main source file; X_TYPE uint32_t; #else; X_TYPE uint64_t; #endif. This warning is controlled by ``-Wpedantic-macros``. Final Macros; ============. Clang supports the pragma ``#pragma clang final``, which can be used to; mark macros as final, meaning they cannot be undef'd or re-defined. For example:. .. code-block:: c. #define FINAL_MACRO 1; #pragma clang final(FINAL_MACRO). #define FINAL_MACRO // warning: FINAL_MACRO is marked final and should not be redefined; #undef FINAL_MACRO // warning: FINAL_MACRO is marked final and should not be undefined. This is useful for enforcing system-provided macros that should not be altered; in user headers or code. This is controlled by ``-Wpedantic-macros``. Final; macros will always warn on redefinition, including situations with identical; bodies and in system headers. Line Control; ============. Clang supports an e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:190608,unsafe,unsafe,190608,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"ant parts of the failing configuration. In general, we recommend Release build types with Assertions enabled. This; generally provides a good balance between build times and bug detection for; most buildbots. There may be room for including some debug info (e.g. with; `-gmlt`), but in general the balance between debug info quality and build; times is a delicate one. Use Ninja & LLD; Ninja really does help build times over Make, particularly for highly; parallel builds. LLD helps to reduce both link times and memory usage; during linking significantly. With a build machine with sufficient; parallelism, link times tend to dominate critical path of the build, and are; thus worth optimizing. Use CCache and NOT incremental builds; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the; builder less sensitive to which projects are being monitored vs built.; If a change triggers a build request, but doesn't change the build output; (e.g. doc changes, python utility changes, etc..), the build will entirely; hit in cache and the build request will complete in just the testing time. With multiple workers, it is tempting to try to configure a shared cache; between the workers. Experience to date indicates this is difficult to; well, and that having local per-worker caches gets most of the benefit; anyways. We don't currently recommend shared caches. CCache does depend on the builder hardware having sufficient IO to access; the cache with reasonable access times - i.e. a fast disk, or enough memory; for a RAM cache, etc.. For builders without, incremental may be your best; option, but is likely to require higher ongo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:11414,risk,risk,11414,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['risk'],['risk']
Safety,"ant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not yet documented; here. Supported Architectures; =======================. Support for statepoint generation requires some code for each backend.; Today, only Aarch64 and X86_64 are supported. .. _OpenWork:. Limitations and Half Baked Ideas; ================================. Mixing References and Raw Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Support for languages which allow unmanaged pointers to garbage collected; objects (i.e. pass a pointer to an object to a C routine) in the abstract; machine model. At the moment, the best idea on how to approach this; involves an intrinsic or opaque function which hides th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:33450,safe,safepoints,33450,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145606,detect,detector,145606,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"aph2D. - When `GetX(YZ)axis` were called on a `TGraph2D`, the frame limit and; plotting options were changed.; - Modify the `Clear` function in order to be able to reuse a; `TGraph2D` after a `Clear` is performed.; - In `GetHistogram()` the lower and higher axis limits are always; different.; - Protection added to avoid a Seg Fault on `.q` when `SetHistogram()`; is called on a `TGraph2D`. ### TMultiGraph. - In `TMultiGraph::Add(TMultiGraph *multigraph, Option_t *chopt)`; If `chopt` is defined all the graphs in `multigraph` will be added; with the `chopt` option. If `chopt` is undefined each graph will; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement this option `pads`. This option is equivalent to the one in; `THStack`. It allows to draw all the `TGraphs` in separated pads. ### THStack. - By default the background of the histograms is erased before drawing the; histograms. The new option `noclear` avoid this behaviour. This is useful; when drawing a `THStack` on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. ### TH2Poly. - Implement a simple version of ""Scale"". ### TF1. - Change `TF1::Integral(double a, double b, double * params = 0, double eps = 1.E-12)` to; `TF1::Integral(doubnle a, double b, double epsrel=1.E-12)`. One should use `TF1::SetParameters` to; set the function parameters before computing the integral. - Add a new function `TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)`; that returns as last argument the error in the integration. `TF1::Integral` is implemented using `Tf1::IntegralOneDim`. - The one-dim and multi-dim integral functions are now implemented using the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim`; classes. This allows to change the integration algorithm used in `TF1` using the static methods of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:12093,avoid,avoid,12093,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['avoid'],['avoid']
Safety,"appropriate place to implement a garbage collected heap or a; garbage collector itself. That code should exist in the language's runtime; library. The compiler plugin is responsible for generating code which conforms; to the binary interface defined by library, most essentially the :ref:`stack map; <stack-map>`. To subclass ``llvm::GCStrategy`` and register it with the compiler:. .. code-block:: c++. // lib/MyGC/MyGC.cpp - Example LLVM GC plugin. #include ""llvm/CodeGen/GCStrategy.h""; #include ""llvm/CodeGen/GCMetadata.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGC : public GCStrategy {; public:; MyGC() {}; };. GCRegistry::Add<MyGC>; X(""mygc"", ""My bespoke garbage collector."");; }. This boilerplate collector does nothing. More specifically:. * ``llvm.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRARYNAME = MyGC; LOADABLE_MODULE = 1. include $(LEVEL)/Makefile.common. Once the plugin is compiled, code using it may be compiled using ``llc; -load=MyGC.so`` (though MyGC.so may have some other platform-specific; extension):. ::. $ cat sample.ll; define void @f() gc ""mygc"" {; entry:; ret void; }; $ llvm-as < sample.ll | llc -load=MyGC.so. It is also possible to statically link the collector plugin into tools, such as; a language-specific compiler front-end. .. _collector-algos:. Overview of available features; ------------------------------. ``GCStrategy`` provides a range of features through which a plugin may do useful; work. Some of these are callbacks, some are algorithms that can be enabled,; disabled, or customized. This matrix summarizes the supported (a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:25021,safe,safe,25021,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ar to do stupid things or miss obvious simplifications. ``bugpoint`` is; also designed to trade off programmer time for computer time in the; compiler-debugging process; consequently, it may take a long period of; (unattended) time to reduce a test case, but we feel it is still worth it. Note; that ``bugpoint`` is generally very quick unless debugging a miscompilation; where each test of the program (which requires executing it) takes a long time. Automatic Debugger Selection; ----------------------------. ``bugpoint`` reads each ``.bc`` or ``.ll`` file specified on the command line; and links them together into a single module, called the test program. If any; LLVM passes are specified on the command line, it runs these passes on the test; program. If any of the passes crash, or if they produce malformed output (which; causes the verifier to abort), ``bugpoint`` starts the `crash debugger`_. Otherwise, if the ``-output`` option was not specified, ``bugpoint`` runs the; test program with the ""safe"" backend (which is assumed to generate good code) to; generate a reference output. Once ``bugpoint`` has a reference output for the; test program, it tries executing it with the selected code generator. If the; selected code generator crashes, ``bugpoint`` starts the `crash debugger`_ on; the code generator. Otherwise, if the resulting output differs from the; reference output, it assumes the difference resulted from a code generator; failure, and starts the `code generator debugger`_. Finally, if the output of the selected code generator matches the reference; output, ``bugpoint`` runs the test program after all of the LLVM passes have; been applied to it. If its output differs from the reference output, it assumes; the difference resulted from a failure in one of the LLVM passes, and enters the; `miscompilation debugger`_. Otherwise, there is no problem ``bugpoint`` can; debug. .. _crash debugger:. Crash debugger; --------------. If an optimizer or code generator crashes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:2114,safe,safe,2114,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['safe'],['safe']
Safety,"are; LLVM variables that are frequently used to control that. The full; description is in `LLVM-related variables`_ below. **LLVM_ENABLE_PROJECTS**:STRING; Control which projects are enabled. For example you may want to work on clang; or lldb by specifying ``-DLLVM_ENABLE_PROJECTS=""clang;lldb""``. **LLVM_ENABLE_RUNTIMES**:STRING; Control which runtimes are enabled. For example you may want to work on; libc++ or libc++abi by specifying ``-DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi""``. **LLVM_LIBDIR_SUFFIX**:STRING; Extra suffix to append to the directory where libraries are to be; installed. On a 64-bit architecture, one could use ``-DLLVM_LIBDIR_SUFFIX=64``; to install libraries to ``/usr/lib64``. **LLVM_PARALLEL_{COMPILE,LINK}_JOBS**:STRING; Building the llvm toolchain can use a lot of resources, particularly; linking. These options, when you use the Ninja generator, allow you; to restrict the parallelism. For example, to avoid OOMs or going; into swap, permit only one link job per 15GB of RAM available on a; 32GB machine, specify ``-G Ninja -DLLVM_PARALLEL_LINK_JOBS=2``. **LLVM_TARGETS_TO_BUILD**:STRING; Control which targets are enabled. For example you may only need to enable; your native target with, for example, ``-DLLVM_TARGETS_TO_BUILD=X86``. .. _llvm_use_linker:. **LLVM_USE_LINKER**:STRING; Override the system's default linker. For instance use ``lld`` with; ``-DLLVM_USE_LINKER=lld``. Rarely-used CMake variables; ---------------------------. Here are some of the CMake variables that are rarely used, along with a brief; explanation and LLVM-related notes. For full documentation, consult the CMake; manual, or execute ``cmake --help-variable VARIABLE_NAME``. **CMAKE_CXX_STANDARD**:STRING; Sets the C++ standard to conform to when building LLVM. Possible values are; 17 and 20. LLVM Requires C++ 17 or higher. This defaults to 17. **CMAKE_INSTALL_BINDIR**:PATH; The path to install executables, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""bin"". **CMAKE_INSTALL_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:9826,avoid,avoid,9826,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['avoid'],['avoid']
Safety,"are; parallelograms in the general case. The Z faces have 2 edges parallel; with the X-axis. ![TGeoPara class](pictures/060001B7.png). The shape has the center in the origin and it is defined by:. - `dX, dY, dZ:` half-lengths of the projections of the edges on X, Y; and Z. The lower Z face is positioned at `-dZ`, while the upper at; `+dZ`.; - `alpha:` angle between the segment defined by the centers of the; X-parallel edges and Y axis `[-90,90]` in degrees; - `theta:` theta angle of the segment defined by the centers of the Z; faces;; - `phi:` phi angle of the same segment. ``` {.cpp}; TGeoPara(dX,dY,dZ,alpha,theta,phi);; ```. A box is a particular parallelepiped having the parameters:; `(dX,dY,dZ,0.,0.,0.)`. #### Trapezoids. In general, we will call trapezoidal shapes having 8 vertices and up to; 6 trapezoid faces. Besides that, two of the opposite faces are parallel; to XY plane and are positioned at ` dZ`. Since general trapezoids are; seldom used in detector geometry descriptions, there are several; primitives implemented in the modeller for particular cases. `Trd1` is a trapezoid with only X varying with Z. It is defined by the; half-length in Z, the half-length in X at the lowest and highest Z; planes and the half-length in Y:. ``` {.cpp}; TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);; ```. ![TGeoTrd1 class](pictures/060001B8.png). `Trd2` is a trapezoid with both X and Y varying with Z. It is defined by; the half-length in Z, the half-length in X at the lowest and highest Z; planes and the half-length in Y at these planes:. ``` {.cpp}; TGeoTrd2(Double_t dx1,Double_t dx2,Double_t dy1,Double_t dy2, Double_t dz);; ```. ![TGeoTrd2 class](pictures/060001B9.png). #### General Trapezoid - TGeoTrap Class. A general trapezoid is one for which the faces perpendicular to z are; trapezes but their centers are not necessary at the same x, y; coordinates. ![TGeoTrap Class](pictures/image443.jpg). It has eleven parameters: the half length in z, the polar angles",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:28230,detect,detector,28230,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"aren't valid on ``store`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:421341,safe,safe,421341,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"ares disk space, memory usage, and I/O times of C++; pointers and **`TRef`**`s`. In general, a **`TRef`** is faster than C++; but the advantage of a C++ pointer is that it is already C++. ### Streaming C++ Pointers. When ROOT encounters a pointer data member it calls the `Streamer` of; the object and labels it with a unique object identifier. The object; identifier is unique for one I/O operation. If there is another pointer; to the object in the same I/O operation, the first object is referenced; i.e. it is not saved again. When reading the file, the object is rebuilt; and the references recalculated. ![Streaming object pointers](pictures/020000EC.jpg). In this way, the network of pointers and their objects is rebuilt and; ready to use the same way it was used before it was persistent. If the; pointer hold the address of an object which in embedded in another; object (as opposed to being pointed to by a pointer), the object will be; duplicate at read time. To avoid this, make the pointer a transient data; member. ### Motivation for the TRef Class. If the object is split into several files or into several branches of; one or more `TTrees`, standard C++ pointers cannot be used because each; I/O operation will write the referenced objects, and multiple copies; will exist. In addition, if the pointer is read before the referenced; object, it is null and may cause a run time system error. To address; these limitations, ROOT offers the **`TRef`** class. **`TRef`** allows referencing an object in a different branch and/or in; a different file. **`TRef`** also supports the complex situation where a; **`TFile`** is updated multiple times on the same machine or a different; machine. When a **`TRef`** is read before its referenced object, it is; null. As soon as the referenced object is read, the **`TRef`** points to; it. In addition, one can specify an action to be taken by **`TRef`** in; the case it is read before its reference object (see""Action on Demand""; below). ### Usi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:56889,avoid,avoid,56889,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['avoid'],['avoid']
Safety,"argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33409,safe,safe,33409,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"argument, N; return value function (where M is the number of values being; relocated + the original call arguments and N is the original return; value + each relocated value), but LLVM does not easily support such a; representation. Instead, the statepoint intrinsic marks the actual site of the; safepoint or statepoint. The statepoint returns a token value (which; exists only at compile time). To get back the original return value; of the call, we use the ``gc.result`` intrinsic. To get the relocation; of each pointer in turn, we use the ``gc.relocate`` intrinsic with the; appropriate index. Note that both the ``gc.relocate`` and ``gc.result`` are; tied to the statepoint. The combination forms a ""statepoint relocation; sequence"" and represents the entirety of a parseable call or 'statepoint'. When lowered, this example would generate the following x86 assembly:. .. code-block:: gas. 	 .globl	test1; 	 .align	16, 0x90; 	 pushq	%rax; 	 callq	foo; .Ltmp1:; 	 movq	(%rsp), %rax # This load is redundant (oops!); 	 popq	%rdx; 	 retq. Each of the potentially relocated values has been spilled to the; stack, and a record of that location has been recorded to the; :ref:`Stack Map section <stackmap-section>`. If the garbage collector; needs to update any of these pointers during the call, it knows; exactly what to change. The relevant parts of the StackMap section for our example are:. .. code-block:: gas. # This describes the call site; # Stack Maps: callsite 2882400000; 	 .quad	2882400000; 	 .long	.Ltmp1-test1; 	 .short	0; # .. 8 entries skipped ..; # This entry describes the spill slot which is directly addressable; # off RSP with offset 0. Given the value was spilled with a pushq,; # that makes sense.; # Stack Maps: Loc 8: Direct RSP [encoding: .byte 2, .byte 8, .short 7, .int 0]; 	 .byte	2; 	 .byte	8; 	 .short	7; 	 .long	0. This example was taken from the tests for the :ref:`RewriteStatepointsForGC`; utility pass. As such, its full StackMap can be easily examined with the; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:10282,redund,redundant,10282,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['redund'],['redundant']
Safety,"ariables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that space. Stack variables; work the same way, except that instead of being declared with global; variable definitions, they are declared with the `LLVM alloca; instruction <../../LangRef.html#alloca-instruction>`_:. .. code-block:: llvm. define i32 @example() {; entry:; %X = alloca i32 ; type of %X is i32*.; ...; %tmp = load i32, i32* %X ; load the stack value %X from the stack.; %tmp2 = add i32 %tmp, 1 ; increment it; store i32 %tmp2, i32* %X ; store it back; ... This code shows an example of how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:5549,avoid,avoid,5549,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['avoid'],['avoid']
Safety,"arked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100148,avoid,avoid,100148,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoid']
Safety,"armVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87318,recover,recovery,87318,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"arr[10]);. This means the array parameters are treated as `__counted_by` pointers within; the function and callers of the function also see them as the corresponding; `__counted_by` pointers. Incomplete arrays on function prototypes will cause a compiler error unless it; has ``__counted_by`` annotation in its bracket. .. code-block:: c. void f1(int n, int arr[]); // error. void f3(int n, int arr[__counted_by(n)]); // ok. void f2(int n, int arr[n]); // ok, decays to int *__counted_by(n). void f4(int n, int *__counted_by(n) arr); // ok. void f5(int n, int *arr); // ok, but decays to int *__single,; // and cannot be used for pointer arithmetic. Array references; ^^^^^^^^^^^^^^^^. In C, similar to arrays on the function prototypes, a reference to array is; automatically promoted (or ""decayed"") to a pointer to its first element (e.g.,; ``&arr[0]``). In `-fbounds-safety`, array references are promoted to ``__bidi_indexable``; pointers which contain the upper and lower bounds of the array, with the; equivalent of ``&arr[0]`` serving as the lower bound and ``&arr[array_size]``; (or one past the last element) serving as the upper bound. This applies to all; types of arrays including constant-length arrays, variable-length arrays (VLAs),; and flexible array members annotated with `__counted_by`. In the following example, reference to ``vla`` promotes to ``int; *__bidi_indexable``, with ``&vla[n]`` as the upper bound and ``&vla[0]`` as the; lower bound. Then, it's copied to ``int *p``, which is implicitly ``int; *__bidi_indexable p``. Please note that value of ``n`` used to create the upper; bound is ``10``, not ``100``, in this case because ``10`` is the actual length; of ``vla``, the value of ``n`` at the time when the array is being allocated. .. code-block:: c. void foo(void) {; int n = 10;; int vla[n];; n = 100;; int *p = vla; // { .ptr: &vla[0], .upper: &vla[10], .lower: &vla[0] }; // it's `&vla[10]` because the value of `n` was 10 at the; // time when the array is actual",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:33786,safe,safety,33786,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184340,detect,detection,184340,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,3,"['detect', 'recover']","['detection', 'recover', 'recovery']"
Safety,"as it contains bounds; information internally and eliminates the need for explicit bounds annotations.; However, wide pointers differ from standard C pointers in their data layout,; which may result in incompatibilities with the application binary interface; (ABI). Breaking the ABI complicates interoperability with external code that has; not adopted the same programming model. ``-fbounds-safety`` harmonizes the wide pointer and the bounds annotation; approaches to reduce the adoption burden while maintaining the ABI. In this; model, local variables of pointer type are implicitly treated as wide pointers,; allowing them to carry bounds information without requiring explicit bounds; annotations. Please note that this approach doesn't apply to function parameters; which are considered ABI-visible. As local variables are typically hidden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can operate without modifications within this; programming model, reducing the adoption burden. The rest of the section will discuss individual bounds annotations and the; programming model in more detail. Bounds annotations; ------------------. Annotation for pointers to a single object; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The C language allows pointer arithmetic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:6299,safe,safety,6299,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"as to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function to the graph, observe that the; pointer is passed. It is more interesting to look at the output on; the screen to see the parameters values and other crucial; information that we will learn to read at the end of this guide. - Line *44*: again draws the clone of the object on the canvas. The; ""Same"" option avoids the cancellation of the already drawn objects,; in our case, the graph. The function *f* will be drawn using the *same* axis; system defined by the previously drawn graph. - Line *47-52*: completes the plot with a legend, represented by a; `TLegend` instance. The constructor takes as parameters the lower; left and upper right corners coordinates with respect to the total; size of the canvas, assumed to be 1, and the legend header string.; You can add to the legend the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified coordinate. The `#splitline{}{}`; construct allows to store multiple lines in the same `TLatex`; object. - Line *63*: save the canvas as image. The format is automatically; inferred from the file ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:5422,avoid,avoids,5422,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['avoid'],['avoids']
Safety,"as,\; Stefan Wunsch, CERN/SFT. ## Deprecation and Removal. ### Ruby bindings. The ruby binding has been unmaintained for several years; it does not build with current ruby versions.; Given that this effectively meant that Ruby was dysfunctional and given that nobody (but package maintainers) has complained, we decided to remove it. ### Removal of previously deprecated or disabled packages. The packages `afs`, `chirp`, `glite`, `sapdb`, `srp` and `ios` have been removed from ROOT.; They were deprecated before, or never ported from configure, make to CMake. ### Remove GLUtesselator forward declaration from TVirtualX.h. It was never used in TVirtualX interfaces. If GLUtesselator forward declaration is required, use TGLUtil.h include instead. ## C++ Modules Technology Preview. ROOT has several features which interact with libraries and require implicit; header inclusion. This can be triggered by reading or writing data on disk,; or user actions at the prompt. Often, the headers are immutable and reparsing is; redundant. C++ Modules are designed to minimize the reparsing of the same; header content by providing an efficient on-disk representation of C++ Code. This is an experimental feature which can be enabled by compiling ROOT with; `-Druntime_cxxmodules=On`. You can read more about the current state of the; feature [here](../../README.CXXMODULES.md). ## Core Libraries. ### New command line flag ""--version"" for root. `root --version` now displays ROOT version and build info and quits:. ```; ROOT Version: 6.15/01; Built for linuxx8664gcc on Sep 20 2018, 11:04:35; From heads/master@v6-13-04-1273-gea3f4333a2; ```. ### Fish support for thisroot script. `. bin/thisroot.fish` sets up the needed ROOT environment variables for one of the ROOT team's favorite shells, the [fish shell](https://fishshell.com/). ### Change of setting the compression algorithm in `rootrc`. The previous setting called `ROOT.ZipMode` is now unused and ignored.; Instead, use `Root.CompressionAlgorithm`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:2171,redund,redundant,2171,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['redund'],['redundant']
Safety,"assignment) for a matrix with the same; representation, or from a different one when possible, for example; from a symmetric to a general matrix. - Constructor (and assignment) from a matrix expression, like; `D=A*B+C`. Due to the expression template technique, no temporary; objects are created in this operation. In the case of an operation; like `A=A*B+C`, a temporary object is needed and it is created; automatically to store the intermediary result in order to preserve; the validity of this operation. - Constructor from a generic STL-like iterator copying the data; referred by the iterator, following its order. It is both possible; to specify the begin and end of the iterator or the begin and the; size. In case of a symmetric matrix, it is required only the; triangular block and the user can specify whether giving a block; representing the lower (default case) or the upper diagonal part. Here are some examples on how to create a matrix. We use typedef's in; the following examples to avoid the full C++ names for the matrix; classes. Notice that for a general matrix the representation has the; default value, **`ROOT::Math::MatRepStd`**, and it is not needed to be; specified. Furthermore, for a general square matrix, the number of; column may be as well omitted. ``` {.cpp}; // typedef definitions used in the following declarations; typedef ROOT::Math::SMatrix<double,3> SMatrix33;; typedef ROOT::Math::SMatrix<double,2> SMatrix22;; typedef ROOT::Math::SMatrix<double,3,3,; ROOT::Math::MatRepSym<double,3>> SMatrixSym3;; typedef ROOT::Math::SVector>double,2> SVector2;; typedef ROOT::Math::SVector>double,3> SVector3;; typedef ROOT::Math::SVector>double,6> SVector6;; SMatrix33 m0; // create a zero 3x3 matrix; // create an 3x3 identity matrix; SMatrix33 i = ROOT::Math::SMatrixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:107438,avoid,avoid,107438,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"assil Vassilev, CERN/SFT \; Wouter Verkerke, NIKHEF/Atlas, RooFit, \; Omar, Zapata, Medellin, Columbia \; Maciej Zimnoch, GSoC, Poland. ## ROOT reference manual. The ROOT reference manual has been moved into Doxygen. Still some work and; polish has to be done but the reference guide in this new format is now online; and can be seen from the [ROOT home page](https://root.cern.ch/doc/master/index.html). ## Core Libraries. ### Dictionary generation. Fixed the dictionary generation in the case of class inside a namespace; marked inlined. Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates. Fix [ROOT-7760] : fully allow the usage of the dylib extension on OSx. Fix [ROOT-7723] : allow IOCtors to have as argument a ref to a type called __void__. We added a dictionary for map<string,string> as part of the default STL dictionary. We added support for template parameter packs in class name involved in the I/O. ### Thread safety and thread awareness. We added the function `TMethodCall::GetCallFunc` to allow direct access to the function wrapper. We reduced thread serialization in `TClass::GetCheckSum`, `TClass::GetBaseClassOffset` and `TClass::Property`. `TObjArray::Delete` was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock). We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: `ROOT::EnableThreadSafety()` which is the successor of the existing `TThread::Initialize`. This call must take place if ROOT needs to be used in a thread safe manner. The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TCo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:2051,safe,safety,2051,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['safe'],['safety']
Safety,"at already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently suppor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:10111,detect,detect,10111,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,1,['detect'],['detect']
Safety,"at we will store our code in. We want to modify this dylib to; contain not only the symbols that we add to it, but also the symbols from our; REPL process as well. We do this by attaching a; ``DynamicLibrarySearchGenerator`` instance using the; ``DynamicLibrarySearchGenerator::GetForCurrentProcess`` method. .. code-block:: c++. static Expected<std::unique_ptr<KaleidoscopeJIT>> Create() {; auto JTMB = JITTargetMachineBuilder::detectHost();. if (!JTMB); return JTMB.takeError();. auto DL = JTMB->getDefaultDataLayoutForTarget();; if (!DL); return DL.takeError();. return std::make_unique<KaleidoscopeJIT>(std::move(*JTMB), std::move(*DL));; }. const DataLayout &getDataLayout() const { return DL; }. LLVMContext &getContext() { return *Ctx.getContext(); }. Next we have a named constructor, ``Create``, which will build a KaleidoscopeJIT; instance that is configured to generate code for our host process. It does this; by first generating a JITTargetMachineBuilder instance using that classes'; detectHost method and then using that instance to generate a datalayout for; the target process. Each of these operations can fail, so each returns its; result wrapped in an Expected value [3]_ that we must check for error before; continuing. If both operations succeed we can unwrap their results (using the; dereference operator) and pass them into KaleidoscopeJIT's constructor on the; last line of the function. Following the named constructor we have the ``getDataLayout()`` and; ``getContext()`` methods. These are used to make data structures created and; managed by the JIT (especially the LLVMContext) available to the REPL code that; will build our IR modules. .. code-block:: c++. void addModule(std::unique_ptr<Module> M) {; cantFail(CompileLayer.add(ES.getMainJITDylib(),; ThreadSafeModule(std::move(M), Ctx)));; }. Expected<ExecutorSymbolDef> lookup(StringRef Name) {; return ES.lookup({&ES.getMainJITDylib()}, Mangle(Name.str()));; }. Now we come to the first of our JIT API methods: addM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:9293,detect,detectHost,9293,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['detect'],['detectHost']
Safety,"ata, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, these edges will need independent protection from; variant #1 style attacks. The analogous approach to that used for conditional; control flow should work:; ```; uintptr_t all_ones_mask = std::numerical_limits<uintptr_t>::max();; uintptr_t all_zeros_mask = 0;; void leak(int d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:8850,predict,predicted,8850,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['predicted']
Safety,"ata. Any; connection between the old ``MDNode`` and the loop is lost. The; ``llvm.loop`` node is also used as LoopID (``Loop::getLoopID()``), i.e.; the loop effectively gets a new identifier. For instance,; ``llvm.mem.parallel_loop_access`` references the LoopID. Therefore, if; the parallel access property is to be preserved after adding/removing; loop attributes, any ``llvm.mem.parallel_loop_access`` reference must be; updated to the new LoopID. Transformation Metadata Structure; =================================. Some attributes describe code transformations (unrolling, vectorizing,; loop distribution, etc.). They can either be a hint to the optimizer; that a transformation might be beneficial, instruction to use a specific; option, , or convey a specific request from the user (such as; ``#pragma clang loop`` or ``#pragma omp simd``). If a transformation is forced but cannot be carried-out for any reason,; an optimization-missed warning must be emitted. Semantic information; such as a transformation being safe (e.g.; ``llvm.mem.parallel_loop_access``) can be unused by the optimizer; without generating a warning. Unless explicitly disabled, any optimization pass may heuristically; determine whether a transformation is beneficial and apply it. If; metadata for another transformation was specified, applying a different; transformation before it might be inadvertent due to being applied on a; different loop or the loop not existing anymore. To avoid having to; explicitly disable an unknown number of passes, the attribute; ``llvm.loop.disable_nonforced`` disables all optional, high-level,; restructuring transformations. The following example avoids the loop being altered before being; vectorized, for instance being unrolled. .. code-block:: llvm. br i1 %exitcond, label %for.exit, label %for.header, !llvm.loop !0; ...; !0 = distinct !{!0, !1, !2}; !1 = !{!""llvm.loop.vectorize.enable"", i1 true}; !2 = !{!""llvm.loop.disable_nonforced""}. After a transformation is applied, f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:2661,safe,safe,2661,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['safe'],['safe']
Safety,"ated; on the stack won't get copied to the heap when the non-block pointer escapes.; A block pointer is implicitly converted to ``id`` when it is passed to a; function as a variadic argument. .. _arc.misc.exceptions:. Exceptions; ----------. By default in Objective C, ARC is not exception-safe for normal releases:. * It does not end the lifetime of ``__strong`` variables when their scopes are; abnormally terminated by an exception.; * It does not perform releases which would occur at the end of a; full-expression if that full-expression throws an exception. A program may be compiled with the option ``-fobjc-arc-exceptions`` in order to; enable these, or with the option ``-fno-objc-arc-exceptions`` to explicitly; disable them, with the last such argument ""winning"". .. admonition:: Rationale. The standard Cocoa convention is that exceptions signal programmer error and; are not intended to be recovered from. Making code exceptions-safe by; default would impose severe runtime and code size penalties on code that; typically does not actually care about exceptions safety. Therefore,; ARC-generated code leaks by default on exceptions, which is just fine if the; process is going to be immediately terminated anyway. Programs which do care; about recovering from exceptions should enable the option. In Objective-C++, ``-fobjc-arc-exceptions`` is enabled by default. .. admonition:: Rationale. C++ already introduces pervasive exceptions-cleanup code of the sort that ARC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to be corruption of the Objective-C runtime, so we want to be safer; here. Of course, potentially massive leaks are about as likely to take dow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:98387,safe,safe,98387,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['safe'],"['safe', 'safety']"
Safety,"ation of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62393,safe,safe,62393,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['safe'],['safe']
Safety,"ation over spilling. If all; the load / store instructions would be folded then spilling is cheaper because; it won't require new live intervals / registers. See 2003-05-31-LongShifts for; an example. //===---------------------------------------------------------------------===//. With a copying garbage collector, derived pointers must not be retained across; collector safe points; the collector could move the objects and invalidate the; derived pointer. This is bad enough in the first place, but safe points can; crop up unpredictably. Consider:. %array = load { i32, [0 x %obj] }** %array_addr; %nth_el = getelementptr { i32, [0 x %obj] }* %array, i32 0, i32 %n; %old = load %obj** %nth_el; %z = div i64 %x, %y; store %obj* %new, %obj** %nth_el. If the i64 division is lowered to a libcall, then a safe point will (must); appear for the call site. If a collection occurs, %array and %nth_el no longer; point into the correct object. The fix for this is to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The ocaml frametable structure supports liveness information. It would be good; to support it. //===---------------------------------------------------------------------===//. The FIXME in ComputeCommonTailLength in BranchFolding.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:3463,safe,safe,3463,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['safe'],['safe']
Safety,"ation, being internal to; the wrapper generation, goes unused.; However, that does mean that a debugger that starts from python will not be; able to step through JITed code into the C++ function that needs debugging,; even when such information is available for that C++ function. To enable debugging information in JITed code, set the ``EXTRA_CLING_ARGS``; envar to ``-g`` (and any further compiler options you need, e.g. add ``-O2``; to debug optimized code). On a crash in C++, the backend will attempt to provide a stack trace.; This works quite well on Linux (through ``gdb``) and decently on MacOS; (through ``unwind``), but is currently unreliable on MS Windows.; To prevent printing of this trace, which can be slow to produce, set the; envar ``CPPYY_CRASH_QUIET`` to '1'. It is even more useful to obtain a traceback through the Python code that led; up to the problem in C++.; Many modern debuggers allow mixed-mode C++/Python debugging (for example; `gdb`_ and `MSVC`_), but cppyy can also turn abortive C++ signals (such as a; segmentation violation) into Python exceptions, yielding a normal traceback.; This is particularly useful when working with cross-inheritance and other; cross-language callbacks. To enable the signals to exceptions conversion, import the lowlevel module; ``cppyy.ll`` and use:. .. code-block:: python. import cppyy.ll; cppyy.ll.set_signals_as_exception(True). Call ``set_signals_as_exception(False)`` to disable the conversion again.; It is recommended to only have the conversion enabled around the problematic; code, as it comes with a performance penalty.; If the problem can be localized to a specific function, you can use its; ``__sig2exc__`` flag to only have the conversion active in that function.; Finally, for convenient scoping, you can also use:. .. code-block:: python. with cppyy.ll.signals_as_exception():; # crashing code goes here. The translation of signals to exceptions is as follows (all of the exceptions; are subclasses of ``cppyy.ll.Fat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst:1265,abort,abortive,1265,bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst,1,['abort'],['abortive']
Safety,"ations working. Custom lowering of intrinsics; ------------------------------. For GCs which use barriers or unusual treatment of stack roots, the; implementor is responsibly for providing a custom pass to lower the; intrinsics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such a pass is the ShadowStackGC and it's; ShadowStackGCLowering pass. There is currently no way to register such a custom lowering pass; without building a custom copy of LLVM. .. _safe-points:. Generating safe points; -----------------------. LLVM provides support for associating stackmaps with the return address of; a call. Any loop or return safepoints required by a given collector design; can be modeled via calls to runtime routines, or potentially patchable call; sequences. Using gcroot, all call instructions are inferred to be possible; safepoints and will thus have an associated stackmap. .. _assembly:. Emitting assembly code: ``GCMetadataPrinter``; ---------------------------------------------. LLVM allows a plugin to print arbitrary assembly code before and after the rest; of a module's assembly code. At the end of the module, the GC can compile the; LLVM stack map into assembly code. (At the beginning, this information is not; yet computed.). Since AsmWriter and CodeGen are separate components of LLVM, a separate abstract; base class and registry is provided for printing assembly code, the; ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``. The AsmWriter will look; for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:. .. code-block:: c++. MyGC::MyGC() {; UsesMetadata = true;; }. This separation allows JIT-only clients to be smaller. Note that LLVM does not currently have analogous APIs to support code generation; in the JIT, nor using the object writers. .. code-block:: c++. // lib/MyGC/MyGCP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:35032,safe,safepoints,35032,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safepoints']
Safety,"atv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16801,abort,abort,16801,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"ault Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; // this is undefined before C++20, but the checker doesn't; // warn because it doesn't know the exact value of b; }; return 1000 << 31; // warn: this overflows the capacity of 'int'; }. **Solution**. Ensure the shift operands are in proper range before shifting. .. _core-CallAndMessage:. core.Ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:1698,predict,predictably,1698,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['predict'],['predictably']
Safety,"ausing several failures in the CMS code when inverting matrices.; ; Add the Cholesky decomposition method for symmetric positive defined matrices (thanks to Manuel Schiller). A class has been introduced,; ROOT::Math::CholeskyDecomp which provaids methods for decomposing or inverting a matrix and also for solving a linear system.; . New methods have also been added in SMatrix: bool SMatrix::InvertChol() and SMatrix & SMatrix::InverseChol(ifail) for the inversion of a symmetric positive defined matrix. New specialized implementation exists up to matrices with sizes 6x6. The speed is comparable to the Cramer method (SMatrix::InvertFast), but with much better accuracy. The new InvertChol method is in any case faster than the general inverter method for all symmetric matrices (SMatrix::Invert), which uses the Bunch-Kaufman decomposition.; Add also a new free function, ROOT::Math::SolveChol for solving a symmetric linear system. For users who need the solution, using this functions avoid for them performing the inversion and then a matrix multiplication. Add support in the SMatrix class for operator m[i][j]; Add in the dictionary the typedefs for some square and symmetrix matrices based on double and floats (up to size 7) defined in the file Math/SMatrixDfwd and Math/SMatrixFfwd; . Minuit. Apply various improvements in the TMInuitMInimizer class thanks to the feedback of Alfio Lazzaro:; ; implement Hess() and CovMatrixStatus();; add new method based on SEEK. The Tolerance() value can be used to specify the volume (in unit of sigma) for searching for the global minimum; fix some of the methods, like NCalls() and GlobalCC(); . Minuit2. Apply some fixes in MnHesse and MnPosDef classes to check correctly variables to not be zero.; (use same checks as in F77Minuit); ; Fix a bug introduced in DavidonErrorCalculator when checking for delgam. Negative values are allowed. This fixes a test problem given privately by A. Suter.; ; Uses also a tighter condition on edm when exiting th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:4680,avoid,avoid,4680,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['avoid'],['avoid']
Safety,"ave locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lock ``mu`` before it can; read or write to ``balance``, thus ensuring that the increment and decrement; operations are atomic. Similarly, ``REQUIRES`` declares that; the calling thread must lock ``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ===============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:2453,safe,safety,2453,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"aw axis labels on both sides when pad.fTick[x/y] > 1; - make drawing of TCanvas with many primitives smoother; - add fOptTitle, fOptLogx/y/z fields in JSROOT.gStyle; * Behavior changes:; - disable automatic frame adjustment, can be enabled with ""&adjframe"" parameter in URL; - when drawing TH2/TH3 scatter plots, always generate same ""random"" pattern; - use barwidth/baroffset parameters in lego plots; * Bug fixes:; - use same number of points to draw lines and markers on the TGraph; - correctly draw filled TArrow endings; - let combine ""L"" or ""C"" TGraph draw option with others; - correct positioning of custom axis labels; - correctly toggle lin/log axes in lego plot; - let correctly change marker attributes interactively ; - monitoring mode in draw.htm page; - zooming in colz palette; - support both 9.x and 10.x jsdom version in Node.js (#149); - draw axis main line with appropriate attributes (#150); - use axis color when drawing grids lines (#150); - when set pad logx/logy, reset existing user ranges in pad; - avoid too deep calling stack when drawing many graphs or histos (#154); - correctly (re)draw tooltips on canvas with many subpads. ## Code Examples. - New graphics tutorial AtlasExample.C illustrating the ATLAS style.; - New TLazyDS tutorial added tdf015_LazyDataSource.C.; - Show how to inspect a `TCutFlowReport` object. ## Class Reference Guide. - Replace low resolution images with bigger ones more suited for modern screens. ## Build System and Configuration. - ROOT can now be built against an externally built llvm and clang (llvm can be used unpatched, clang still require ROOT specific patches). The options are builtin_llvm and builtin_clang both defaulting to ON.; - Update RConfigure.h with R__HAS__VDT if the package is found/builtin; - CMake exported targets now have the `INTERFACE_INCLUDE_DIRECTORIES` property set ([ROOT-8062](https://sft.its.cern.ch/jira/browse/ROOT-8062)).; - The `-fPIC` compile flag is no longer propagated to dependent projects via `CM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:17191,avoid,avoid,17191,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoid']
Safety,"aw cell values, if their screen size is above given limit.; New energy-scales drawn as overlay (in color and size mode). The; legend can be moved around the screen with the mouse.; Fix transition between orthographic and perspective camera in; TEveCaloLego event handler.; Use color-sets in overlays and axis in order to automatically; keep same contrast when changing background color. In TEveTrackPropagator improve overall trajectory extrapolation; through the path-marks. Fix a problem with path-mark / boundary; approach with near-zero magnetic field. Maximum R / Z of extrapolation that can be set in the object; editor can now be changed via static data-members; fgEditorMaxR and fgEditorMaxZ.; Generalization of selection from GL viewers to support internal; multiple selection from the elements.; Add support for selection of individual calorimeter towers in; TEveCalo classes.; Add support for 3D -> 3D projections. This also allows for; scaling (compression/extension) of certain space region as required by; NA62 to show the 200m long detector in a meaningful way. Several generalizations of the projection infrastructure were; required:; TEveProjectable::ProjectedClass() takes an argument:; virtual TClass* ProjectedClass(const TEveProjection* p) const = 0;; thus allowing different projected classes for different projections.; All TEveProjection::ProjectPoint/Vector(...) functions have an; additional ""depth"" argument thus allowing the projected classes to; skip explicit setting of depth after the point has been projected; -- this could damage the 3rd component. Pre-scaling now supports 3 dimensions.; Abstract TEveProjected::SetDepth() has been split into two parts:; ; It has been implemented in the base class where it checks for; the projection type (2d) before calling the local function;; Abstract SetDepthLocal() has been added to provide the same; functionality. This allows for the 2d/3d check to be done in place only.; New projection class has been introduced: TEve3DPro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:1562,detect,detector,1562,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,1,['detect'],['detector']
Safety,"axis. - Update Projection methods of both TH2 and TH3 to not return a null; pointer when an histogram with the same name already existed and it; was not compatible. Now just set the new correct binning on the; previously existing histogram. ### TGraph. - `TGraph::Draw()` needed at least the option `AL` to draw the graph; axis even when there was no active canvas or when the active canvas; did not have any axis defined. This was counter-intuitive. Now if; `TGraph::Draw()` is invoked without parameter and if there is no; axis defined in the current canvas, the option `ALP` is automatically; set.; - Change `SavePrimtive()` to improve speed compilation on generated macros. ### TGraph2D. - When `GetX(YZ)axis` were called on a `TGraph2D`, the frame limit and; plotting options were changed.; - Modify the `Clear` function in order to be able to reuse a; `TGraph2D` after a `Clear` is performed.; - In `GetHistogram()` the lower and higher axis limits are always; different.; - Protection added to avoid a Seg Fault on `.q` when `SetHistogram()`; is called on a `TGraph2D`. ### TMultiGraph. - In `TMultiGraph::Add(TMultiGraph *multigraph, Option_t *chopt)`; If `chopt` is defined all the graphs in `multigraph` will be added; with the `chopt` option. If `chopt` is undefined each graph will; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement this option `pads`. This option is equivalent to the one in; `THStack`. It allows to draw all the `TGraphs` in separated pads. ### THStack. - By default the background of the histograms is erased before drawing the; histograms. The new option `noclear` avoid this behaviour. This is useful; when drawing a `THStack` on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. ### TH2Poly. - Implement a simple version of ""Scale"". ### TF1. - Change `TF1::Integral(double a, double b, dou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:11406,avoid,avoid,11406,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['avoid'],['avoid']
Safety,"bal is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive is supported on all ELF targets.; The second parameter is the library name (without the traditional Unix prefix of; ``lib``). This allows you to provide an implicit link of dependent libraries. Evaluating Object Size Dynamically; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_object_size`` (which Clang also supports), but; ``__builtin_dynamic_object_size`` can evaluate the object's size at runtime.; ``__builtin_dynamic_object_size`` is meant to be used as a drop-in replacement; for ``__builtin_object_size`` in libraries that support it. For instance, here is a program that ``__builtin_dynamic_object_size`` will make; safer:. .. code-block:: c. void copy_into_buffer(size_t size) {; char* buffer = malloc(size);; strlcpy(buffer, ""some string"", strlen(""some string""));; // Previous line preprocesses to:; // __builtin___strlcpy_chk(buffer, ""some string"", strlen(""some string""), __builtin_object_size(buffer, 0)); }. Since the size of ``buffer`` can't be known at compile time, Clang will fold; ``__builtin_object_size(buffer, 0)`` into ``-1``. However, if this was written; as ``__builtin_dynamic_object_size(buffer, 0)``, Clang will fold it into; ``size``, providing some extra runtime safety. Deprecating Macros; ==================. Clang supports the pragma ``#pragma clang deprecated``, which can be used to; provide deprecation warnings for macro uses. For example:. .. code-block:: c. #define MIN(x, y) x < y ? x : y; #pragma clang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:188797,safe,safer,188797,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['safe'],['safer']
Safety,"be specified on; the function as well, so the function is never inlined into any caller.; Only functions with the ``alwaysinline`` attribute are valid; candidates for inlining into the body of this function.; ``optsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function low,; and otherwise do optimizations specifically to reduce code size as; long as they do not significantly impact runtime performance.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``""patchable-function""``; This attribute tells the code generator that the code; generated for this function needs to follow certain conventions that; make it possible for a runtime function to patch over it later.; The exact effect of this attribute depends on its string value,; for which there currently is one legal possibility:. * ``""prologue-short-redirect""`` - This style of patchable; function is intended to support patching a function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; This attribute indicates that the function will trigger a guard region; in the end of the stack. It ensures that accesses to the stack must be; no further ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:97277,safe,safe,97277,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"bedding such; nodes into geometry. Nodes have visualization attributes as the volume; has. When undefined by users, painting a node on a pad will take the; corresponding volume attributes. ### Creating and Positioning Volumes. #### Making Volumes. As mentioned before, volumes are the basic objects used in building the; geometrical hierarchy. They represent objects that are not positioned,; but store all information about the placement of the other volumes they; may contain. Therefore a volume can be replicated several times in the; geometry. As it was explained, in order to create a volume, one has to; put together a shape and a medium, which are already defined. Volumes have to be named by users at creation time. Every different name; may represent a unique volume object, but may also represent more; general a family (class) of volume objects having the same shape type; and medium, but possibly different shape parameters. It is the user's; task to provide different names for different volume families in order; to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two; cases: when a parametric shape is used or when a division operation is; applied. Each volume in the geometry stores a unique ID corresponding to; its family. In order to ease-up their creation, the manager class is; providing an API that allows making a shape and a volume in a single; step. #### Example of Volume Creation. ``` {.cpp}; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);. // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);. // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:64113,avoid,avoid,64113,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['avoid'],['avoid']
Safety,"being collated. If the tree or any of the underlying tree of the chain has an index,; that index and any index in the subsequent underlying TTree objects will be merged. There are currently three 'options'; to control this merging:; ; NoIndex : all the TTreeIndex object are dropped.; DropIndexOnError : if any of the underlying TTree object do no have a TTreeIndex,; they are all dropped.; AsIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; BuildIndexOnError : If any of the underlying TTree object do no have a TTreeIndex,; all TTreeIndex are 'ignored' and the mising piece are rebuilt. Previously the index were kept only if the first files had an index and if there was any missing index,; the resulting index had gaps (the default was similar to AsIsIndexOnError). The new default is BuildIndexOnError ; i.e.; we now attempt by default to build the missing indices. In TBranch CopyAddress (and hence indirectly in the fast cloning); avoid having to read the first entry just to get the address set; and do the address setting directly. In TTree::CopyAddress when copying the addresses of a branch created by a leaflist; and where the memory buffer was allocated automatically (as opposed to set by the user); avoid deleting the memory allocated by the tree each time CopyAddress is called.; (This effectively prevented cloning more than once a TTree with a branch created by a leaflist.). Warning: The TTreeCache is no longer enabled by default in a TChain to align the behavior with a TTree. You need to call; TTree::SetCacheSize to enable the TTreeCache.; Correct and clarify the relationship between AutoFlush and AutoSave:; ; Both the AutoFlush and AutoSave interval can be specified in; terms of bytes (a negative value for fAutoFlush or fAutoSave); or in terms of the number of entries (positive values).; An AutoFlush is always done with an AutoSave.; If the interval specified for AutoSave is less than that for; AutoFlush, the AutoSave inter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:2372,avoid,avoid,2372,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['avoid'],['avoid']
Safety,"bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192849,unsafe,unsafe,192849,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"ble ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFAIL``. This can be helpful when one does not want to modif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:7842,timeout,timeout,7842,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['timeout'],['timeout']
Safety,"ble to; tell what it came from. Second, while LLVM does lose information, LLVM is not a fixed target: we; continue to enhance and improve it in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into a wall, please bring the topic up on; the llvm-dev list. At the very worst, you can always treat LLVM as if it; were a ""dumb code generator"" and implement the high-level optimizations; you desire in your front-end, on the language-specific AST. Tips and Tricks; ===============. There is a variety of useful tips and tricks that you come to know after; working on/with LLVM that aren't obvious at first glance. Instead of; letting everyone rediscover them, this section talks about some of these; issues. Implementing portable offsetof/sizeof; -------------------------------------. One interesting thing that comes up, if you are trying to keep the code; generated by your compiler ""target independent"", is that you often need; to know the size of som",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:10721,safe,safe,10721,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['safe'],['safe']
Safety,"ble_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ``` {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; ```. The method above computes the director cosines of normal to the crossed; shape surface from a given point towards direction. This is filled into; the `norm` array, supplied by the user. The normal vector is always; chosen such that its dot product with the direction is positive defined. ### Creating Shapes. Shape objects embeds only the minimum set of parameters that are fully; describing a valid physical shape.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51827,safe,safe,51827,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"ble_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ~~~. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ~~~ {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ~~~. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ~~~ {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ~~~. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ~~~ {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; ~~~. The method above computes the director cosines of normal to the crossed; shape surface from a given point towards direction. This is filled into; the `norm` array, supplied by the user. The normal vector is always; chosen such that its dot product with the direction is positive defined. \anchor SHAPES03; ### Creating Shapes. Shape objects embeds only the minimum set of parameters that are fully; describing a val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:5543,safe,safe,5543,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['safe'],['safe']
Safety,"bled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:17101,safe,safety,17101,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"blems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17027,safe,safe,17027,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"bles at global or local static scope. The Invoke Operator; ===================. Blocks are :block-term:`invoked` using function call syntax with a; list of expression parameters of types corresponding to the; declaration and returning a result type also according to the; declaration. Given:. .. code-block:: c. int (^x)(char);; void (^z)(void);; int (^(*y))(char) = &x;. the following are all legal Block invocations:. .. code-block:: c. x('a');; (*y)('a');; (true ? x : *y)('a'). The Copy and Release Operations; ===============================. The compiler and runtime provide :block-term:`copy` and; :block-term:`release` operations for Block references that create and,; in matched use, release allocated storage for referenced Blocks. The copy operation ``Block_copy()`` is styled as a function that takes; an arbitrary Block reference and returns a Block reference of the same; type. The release operation, ``Block_release()``, is styled as a; function that takes an arbitrary Block reference and, if dynamically; matched to a Block copy operation, allows recovery of the referenced; allocated memory. The ``__block`` Storage Qualifier; =================================. In addition to the new Block type we also introduce a new storage; qualifier, :block-term:`__block`, for local variables. [testme: a; __block declaration within a block literal] The ``__block`` storage; qualifier is mutually exclusive to the existing local storage; qualifiers auto, register, and static. [testme] Variables qualified by; ``__block`` act as if they were in allocated storage and this storage; is automatically recovered after last use of said variable. An; implementation may choose an optimization where the storage is; initially automatic and only ""moved"" to allocated (heap) storage upon; a Block_copy of a referencing Block. Such variables may be mutated as; normal variables are. In the case where a ``__block`` variable is a Block one must assume; that the ``__block`` variable resides in allocated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:6806,recover,recovery,6806,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['recover'],['recovery']
Safety,"block:: objc. NSArray *array = @[ @""Hello"", NSApp, [NSNumber numberWithInt:42] ];. This creates an ``NSArray`` with 3 elements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[id",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:10256,safe,safer,10256,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['safe'],['safer']
Safety,"bp); 	movw	$0, -98(%ebp). This appears to be bad because the RA is not folding the store to the stack ; slot into the movl. The above instructions could be:; 	movl $32, -80(%ebp); ...; 	movl $32, -84(%ebp); ...; This seems like a cross between remat and spill folding. This has redundant subtractions of %eax from a stack slot. However, %ecx doesn't; change, so we could simply subtract %eax from %ecx first and then use %ecx (or; vice-versa). //===---------------------------------------------------------------------===//. This code:. 	%tmp659 = icmp slt i16 %tmp654, 0		; <i1> [#uses=1]; 	br i1 %tmp659, label %cond_true662, label %cond_next715. produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; compares. GCC produces multiple branches, which is much nicer:. compare:; subl $12, %esp; movl 20(%esp), %edx; movl 16(%esp), %eax; decl %edx; jle .L7; .L5:; addl $12, %esp; ret; .p2align 4,,7; .L7:; jl .L4; cmpl $0, %eax; .p2align 4,,8; ja .L5; .L4:; .p2align 4,,9; call abort. //===---------------------------------------------------------------------===//. Tail call optimization improvements: Tail call optimization currently; pushes all arguments on the top of the stack (their normal place for; non-tail call optimized calls) that source from the callers arguments; or that source from a virtual register (also",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:17267,abort,abort,17267,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['abort'],['abort']
Safety,"bugs.chromium.org/p/llvm/issues/detail?id=11. Both issues were addressed with source changes: #5 in clangd/vscode-clangd, and; #11 in llvm-project. No dedicated LLVM release was made for either. We believe that with the publishing of this first annual transparency report,; the security group now has implemented all necessary processes for the group to; operate as promised. The group's processes can be improved further, and we do; expect further improvements to get implemented in 2022. Many of the potential; improvements end up being discussed on the `monthly public call on LLVM's; security group <https://llvm.org/docs/GettingInvolved.html#online-sync-ups>`_. 2022; ----. In this section we report on the issues the group received in 2022, or on issues; that were received earlier, but were disclosed in 2022. In 2022, the llvm security group received 15 issues that have been disclosed at; the time of writing this transparency report. 5 of these were judged to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=17 reports a miscompile in; LLVM that can result in the frame pointer and return address being; overwritten. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=19 reports a vulnerability; in `std::filesystem::remove_all` in libc++. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=23 reports a new Spectre; gadget variant that Speculative Load Hardening (SLH) does not mitigate. No; extension to SLH was implemented to also mitigate against this variant. * https://bugs.chromium.org/p/llvm/issues/detail?id=30 reports missing memory; safety protection on the (C++) exception handling path. A number of fixes; were implemented. * https://bugs.chromium.org/p/llvm/issues/detail?id=33 reports the RETBLEED; vulnerability. The outcome was clang growing a new security hardening feature; `-mfunction-return=thunk-extern`, see https://reviews.llvm.org/D129572. No dedicated LLVM releases were made for any of the above issues. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst:3032,safe,safety,3032,interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,1,['safe'],['safety']
Safety,"by double braces: ``{{yourregex}}``. FileCheck implements a POSIX; regular expression matcher; it supports Extended POSIX regular expressions; (ERE). Because we want to use fixed string matching for a majority of what we; do, FileCheck has been designed to support mixing and matching fixed string; matching with regular expressions. This allows you to write things like this:. .. code-block:: llvm. ; CHECK: movhpd	{{[0-9]+}}(%esp), {{%xmm[0-7]}}. In this case, any offset from the ESP register will be allowed, and any xmm; register will be allowed. Because regular expressions are enclosed with double braces, they are; visually distinct, and you don't need to use escape characters within the double; braces like you would in C. In the rare case that you want to match double; braces explicitly from the input, you can use something ugly like; ``{{[}][}]}}`` as your pattern. Or if you are using the repetition count; syntax, for example ``[[:xdigit:]]{8}`` to match exactly 8 hex digits, you; would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid; confusion with FileCheck's closing double-brace. FileCheck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:25972,avoid,avoid,25972,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['avoid'],['avoid']
Safety,"byte quantity, even if it occupies only 4 bytes in memory. A data member of a class is marked transient on the line of its declaration by a; comment beginning with ""//!"". Such members are not written to disk, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers reference the object through a unique object identifier. This saves space; and avoids the infinite loop that might otherwise arise if the directed graph of object; instance pointer references contains a cycle. If a data member is a pointer to a simple type, the Streamer presumes it is an array,; with the dimension defined in a comment of the form ""//[<length>]"", where length is; either an integer constant or a variable that is an integer data member of the class.; If a variable is used, it must be defined ahead of its use or in a base class. The above describes the function of the StreamerInfo record in decomposing a; self-identifying object if the user uses the streamer generated by ""rootcint"".; There are two reasons why a user may need to write a specialized streamer for a class.; One reason is that it may be necessary to execute some code before or after data is read; or written, for example, to initialize some non-persistent data members after the; persistent data is read. In this case, the custom streamer can use the StreamerInfo record; to decompose a self-identifying object in the exact same manner as the gen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:8345,avoid,avoids,8345,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['avoid'],['avoids']
Safety,"c generated; };. #pragma OPENCL EXTENSION __cl_clang_bitfields : disable; struct without_bitfield {; unsigned int i : 5; // error - bitfields are not supported; };. ``__cl_clang_function_pointers``; --------------------------------. With this extension it is possible to enable various language features that; are relying on function pointers using regular OpenCL extension pragma; mechanism detailed in `the OpenCL Extension Specification,; section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. In C++ for OpenCL this also enables:. - Use of member function pointers;. - Unrestricted use of references to functions;. - Virtual member functions. Such functionality is not conformant and does not guarantee to compile; correctly in any circumstances. It can be used if:. - the kernel source does not contain call expressions to (member-) function; pointers, or virtual functions. For example this extension can be used in; metaprogramming algorithms to be able to specify/detect types generically. - the generated kernel binary does not contain indirect calls because they; are eliminated using compiler optimizations e.g. devirtualization. - the selected target supports the function pointer like functionality e.g.; most CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; void foo(); {; void (*fp)(); // compiled - no diagnostic generated; }. #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; void bar(); {; void (*fp)(); // error - pointers to function are not allowed; }. ``__cl_clang_variadic_functions``; ---------------------------------. With this extension it is possible to enable variadic arguments in functions; using regular OpenCL extension pragma mechanism detailed in `the OpenCL; Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not conf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:87424,detect,detect,87424,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['detect'],['detect']
Safety,"c:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:63485,risk,risk,63485,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['risk'],['risk']
Safety,"cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101610,detect,detector,101610,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"calar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX90A are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table`. .. table:: AMDHSA Memory Model Code Sequences GFX90A; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table. ============ ===",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:241181,avoid,avoid,241181,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"calar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX940, GFX941, GFX942; are defined in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table`. .. table:: AMDHSA Memory Model Code Sequences GFX940, GFX941, GFX942; :name: amdgpu-amdhsa-memory-model",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:291199,avoid,avoid,291199,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a full barrier. ``__builtin_addressof``; -----------------------. ``__builtin_addressof`` performs the functionality of the built-in ``&``; operator, ignoring any ``operator&`` overload. This is useful in constant; expressions in C++11, where there is no other way to take the address of an; object that overloads ``operator&``. Clang automatically adds; ``[[clang::lifetimebound]]`` to the parameter of ``__builtin_addressof``. **Example of use**:. .. code-block:: c++. template<typename T> constexpr T *addressof(T &value) {; return __builtin_addressof(value);; }. ``__builtin_function_start``; -----------------------------. ``__builtin_function_start`` returns the address of a function body. **Syntax**:. .. code-block:: c++. void *__builtin_function_start(function). **Example of use**:. .. code-block:: c++. void a() {}; void *p = __buil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:117119,avoid,avoiding,117119,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoiding']
Safety,"case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct return pointer to; the middle call. Then we do the same for the middle call, allocating a; frame and passing its address to ``Foo``'s default constructor. By; wrapping the evaluation of the inner ``bar`` with stack save and; restore, we can have multiple overlapping active call frames. Callee-cleanup Calling Conventions; ----------------------------------. Another wrinkle is the existence of callee-cleanup conventions. On; Windows, all methods and many other functions adjust the stack to clear; the memory used to pass their arguments. In some sense, this means that; the allocas are automatically cleared by the call. However, LLVM; instead models this as a write of undef to all of the inalloca values; passed to the call instead of a stack adjustment. Frontends should; still restore the stack pointer to avoid a stack leak. Exceptions; ----------. There is also the possibility of an exception. If argument evaluation; or copy construction throws an exception, the landing pad must do; cleanup, which includes adjusting the stack pointer to avoid a stack; leak. This means the cleanup of the stack memory cannot be tied to the; call itself. There needs to be a separate IR-level instruction that can; perform independent cleanup of arguments. Efficiency; ----------. Eventually, it should be possible to generate efficient code for this; construct. In particular, using inalloca should not require a base; pointer. If the backend can prove that all points in the CFG only have; one possible stack level, then it can address the stack directly from; the stack pointer. While this is not yet implemented, the plan is that; the inalloca attribute should not change much, but the frontend IR; generation recommendations may change.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:5379,avoid,avoid,5379,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,2,['avoid'],['avoid']
Safety,"case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:122102,safe,safety,122102,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,2,['safe'],"['safe', 'safety']"
Safety,"cation(line: 4, column: 1, scope: !6); %4:_(s32) = G_SUB %3, %1, debug-location !DILocation(line: 5, column: 1, scope: !6); DBG_VALUE %4(s32), $noreg, !9, !DIExpression(), debug-location !DILocation(line: 5, column: 1, scope: !6). By default, ``mir-debugify`` inserts ``DBG_VALUE`` instructions **everywhere**; it is legal to do so. In particular, every (non-PHI) machine instruction that; defines a register must be followed by a ``DBG_VALUE`` use of that def. If; an instruction does not define a register, but can be followed by a debug inst,; MIRDebugify inserts a ``DBG_VALUE`` that references a constant. Insertion of; ``DBG_VALUE``'s can be disabled by setting ``-debugify-level=locations``. To run MIRDebugify once, simply insert ``mir-debugify`` into your ``llc``; invocation, like:. .. code-block:: bash. # Before some other pass.; $ llc -run-pass=mir-debugify,other-pass ... # After some other pass.; $ llc -run-pass=other-pass,mir-debugify ... To run MIRDebugify before each pass in a pipeline, use; ``-debugify-and-strip-all-safe``. This can be combined with ``-start-before``; and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-and-strip-all-safe -O1 <other llc args>. If you want to check it after each pass in a pipeline, use; ``-debugify-check-and-strip-all-safe``. This can also be combined with; ``-start-before`` and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-check-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-check-and-strip-all-safe -O1 <other llc args>. To check all debug info from a test, use ``mir-check-debugify``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-check-debugify. To strip out all debug info from a test, use ``mir-strip-debug``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-strip-debug. It can be useful to combine ``mir-debugify``, ``mir-check-debugify`` and/or; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:18039,safe,safe,18039,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['safe'],['safe']
Safety,"cators do; not promise to return memory that is more than 8-byte or 16-byte-aligned. Use; this option to limit the alignment that the compiler can assume for an arbitrary; pointer, which may point onto the heap. This option does not affect the ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typedef. For example:. .. code-block:: console. #include <immintrin.h>; // Make an aligned typedef of the AVX-512 16-int vector type.; typedef __v16si __aligned_v16si __attribute__((aligned(64)));. void initialize_vector(__aligned_v16si *v) {; // The compiler may assume that ‘v’ is 64-byte aligned, regardless of the; // value of -fmax-type-align.; }. .. option:: -faddrsig, -fno-addrsig. Controls whether Clang emits an address-significance table into the object; file. Address-significance tables allow linkers to implement `safe ICF; <https://research.google.com/pubs/archive/36912.pdf>`_ without the false; positives that can result from other implementation techniques such as; relocation scanning. Address-significance tables are enabled by default; on ELF targets when using the integrated assembler. This flag currently; only has an effect on ELF targets. .. option:: -f[no]-unique-internal-linkage-names. Controls whether Clang emits a unique (best-effort) symbol name for internal; linkage symbols. When this option is set, compiler hashes the main source; file path from the command line and appends it to all internal symbols. If a; program contains multiple objects compiled with the same command-line source; file path, the symbols are not guaranteed to be unique. This option is; particularly useful in attributing profile information to the correct; function when multiple functions with the same private linkage name exist; in the binary. It should be noted that this option cannot guarantee uniq",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:86794,safe,safe,86794,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['safe'],['safe']
Safety,"ch alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as; STL iterators. The heavyweight iterators allow a smaller data structure. .. _dss_intervaltree:. llvm/ADT/IntervalTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing operations. The IntervalTree is designed to be set up once, and then queried without any; further additions. .. _dss_map:. <map>; ^^^^^. std::map has similar characteristics to :ref:`std::set <dss_set>`: it uses a; single allocation per pair inserted into the map, it offers log(n) lookup with; an extremely large constant factor, imposes a space penalty of 3 pointers per; pair in the map, etc. std::map is most useful when your keys or values are very large, if you need to; iterate over the collection in sorted",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:92889,avoid,avoid,92889,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoid']
Safety,"chains; # export TOOLCHAINS=org.llvm.3.8.0svn. # `xcrun -find clang` should return the installed clang, and `clang --version`; # should show 3.8.0svn. if(NOT APPLE); return(); endif(). option(LLVM_CREATE_XCODE_TOOLCHAIN ""Create a target to install LLVM into an Xcode toolchain"" Off). if(NOT LLVM_CREATE_XCODE_TOOLCHAIN); return(); endif(). # XCODE_VERSION is set by CMake when using the Xcode generator, otherwise we need; # to detect it manually here.; if(NOT XCODE_VERSION); execute_process(; COMMAND xcodebuild -version; OUTPUT_VARIABLE xcodebuild_version; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""Xcode ([0-9][0-9]?([.][0-9])+)"" version_match ${xcodebuild_version}); if(version_match); message(STATUS ""Identified Xcode Version: ${CMAKE_MATCH_1}""); set(XCODE_VERSION ${CMAKE_MATCH_1}); else(); # If detecting Xcode version failed, set a crazy high version so we default; # to the newest.; set(XCODE_VERSION 99); message(WARNING ""Failed to detect the version of an installed copy of Xcode, falling back to highest supported version. Set XCODE_VERSION to override.""); endif(); endif(). # Xcode 8 requires CompatibilityVersion 2; set(COMPAT_VERSION 2); if(XCODE_VERSION VERSION_LESS 8.0.0); # Xcode 7.3 (the first version supporting external toolchains) requires; # CompatibilityVersion 1; set(COMPAT_VERSION 1); endif(). execute_process(; COMMAND xcrun -find otool; OUTPUT_VARIABLE clang_path; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""(.*/Toolchains)/.*"" toolchains_match ${clang_path}); if(NOT toolchains_match); message(FATAL_ERROR ""Could not identify toolchain dir""); endif(); set(toolchains_dir ${CMAKE_MATCH_1}). set(LLVMToolchainDir ""${CMAKE_INSTALL_PREFIX}/Toolchains/LLVM${PACKAGE_VERSION}.xctoolchain/""). add_custom_command(OUTPUT ${LLVMToolchainDir}; COMMAND ${CMAKE_COMMAND} -E make_directory ${LLVMToolchainDir}). add_custom_command(OUTPUT ${LLVMToolchainDir}/Info.plist; DEPENDS ${LLVMToolchainDir}; COMMAND ${",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:2462,detect,detect,2462,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['detect'],['detect']
Safety,"cident information. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. Guidelines for Reporting Incidents; ==================================. Please email conduct@llvm.org with the following details (if possible):. * Your contact info (so we can get in touch with you). Include email and; optionally a phone number.; * Names or descriptions of anyone who was involved or who witnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3257,safe,safety,3257,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['safe'],['safety']
Safety,"cified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:195925,detect,detected,195925,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"cision to unroll the loop depends on the register pressure and the generated code size. Epilogue Vectorization; ^^^^^^^^^^^^^^^^^^^^^^. When vectorizing a loop, often a scalar remainder (epilogue) loop is necessary; to execute tail iterations of the loop if the loop trip count is unknown or it; does not evenly divide the vectorization and unroll factors. When the; vectorization and unroll factors are large, it's possible for loops with smaller; trip counts to end up spending most of their time in the scalar (rather than; the vector) code. In order to address this issue, the inner loop vectorizer is; enhanced with a feature that allows it to vectorize epilogue loops with a; vectorization and unroll factor combination that makes it more likely for small; trip count loops to still execute in vectorized code. The diagram below shows; the CFG for a typical epilogue vectorized loop with runtime checks. As; illustrated the control flow is structured in a way that avoids duplicating the; runtime pointer checks and optimizes the path length for loops that have very; small trip counts. .. image:: epilogue-vectorization-cfg.png. Performance; -----------. This section shows the execution time of Clang on a simple benchmark:; `gcc-loops <https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/UnitTests/Vectorizer>`_.; This benchmarks is a collection of loops from the GCC autovectorization; `page <http://gcc.gnu.org/projects/tree-ssa/vectorization.html>`_ by Dorit Nuzman. The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without loop vectorization at -O3, tuned for ""corei7-avx"", running on a Sandybridge iMac.; The Y-axis shows the time in msec. Lower is better. The last column shows the geomean of all the kernels. .. image:: gcc-loops.png. And Linpack-pc with the same configuration. Result is Mflops, higher is better. .. image:: linpack-pc.png. Ongoing Development Directions; ------------------------------. .. toctree::; :hidden:. VectorizationPlan. :doc:`Vec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:12093,avoid,avoids,12093,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['avoid'],['avoids']
Safety,"ck pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated; on the stack won't get copied to the heap when the non-block pointer escapes.; A block pointer is implicitly converted to ``id`` when it is passed to a; function as a variadic argument. .. _arc.misc.exceptions:. Exceptions; ----------. By default in Objective C, ARC is not exception-safe for normal releases:. * It does not end the lifetime of ``__strong`` variables when their scopes are; abnormally terminated by an exception.; * It does not perform releases which would occur at the end of a; full-expression if that full-expression throws an exception. A program may be compiled with the option ``-fobjc-arc-exceptions`` in order to; enable these, or with the option ``-fno-objc-arc-exceptions`` to explicitly; disable them, with the last such argument ""winning"". .. admonition:: Rationale. The standard Cocoa convention is that exceptions signal programmer error and; are not intended to be recovered from. Making code exceptions-safe by; default would impose severe runtime and code size penalties on code that; typically does not actually care about exceptions safety. Therefore,; ARC-generated code leaks by default on exceptions, which is just fine if the; process is going to be immediately terminated anyway. Programs which do care; about recovering from exceptions should enable the option. In Objective-C++, ``-fobjc-arc-exceptions`` is enabled by default. .. admonition:: Rationale. C++ already introduces pervasive exceptions-cleanup code of the sort that ARC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:98348,recover,recovered,98348,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['recover'],['recovered']
Safety,"ck();; }. // Acquire all associated mutexes exclusively.; void Lock() ACQUIRE() {; mut->Lock();; locked = true;; }. // Try to acquire all associated mutexes exclusively.; bool TryLock() TRY_ACQUIRE(true) {; return locked = mut->TryLock();; }. // Acquire all associated mutexes in shared mode.; void ReaderLock() ACQUIRE_SHARED() {; mut->ReaderLock();; locked = true;; }. // Try to acquire all associated mutexes in shared mode.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true) {; return locked = mut->ReaderTryLock();; }. // Release all associated mutexes. Warn on double unlock.; void Unlock() RELEASE() {; mut->Unlock();; locked = false;; }. // Release all associated mutexes. Warn on double unlock.; void ReaderUnlock() RELEASE() {; mut->ReaderUnlock();; locked = false;; }; };. #ifdef USE_LOCK_STYLE_THREAD_SAFETY_ATTRIBUTES; // The original version of thread safety analysis the following attribute; // definitions. These use a lock-based terminology. They are still in use; // by existing thread safety code, and will continue to be supported. // Deprecated.; #define PT_GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_var). // Deprecated.; #define GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_var). // Replaced by REQUIRES; #define EXCLUSIVE_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_locks_required(__VA_ARGS__)). // Replaced by REQUIRES_SHARED; #define SHARED_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(shared_locks_required(__VA_ARGS__)). // Replaced by CAPABILITY; #define LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(lockable). // Replaced by SCOPED_CAPABILITY; #define SCOPED_LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). // Replaced by ACQUIRE; #define EXCLUSIVE_LOCK_FUNCTION(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_lock_function(__VA_ARGS__)). // Replaced by ACQUIRE_SHARED; #define SHARED_LOCK_FUNCTION(...) \; THREAD_ANNOTATION_ATTRIBUTE__(shared_lock_function(__VA_ARGS__)). // Replaced by RELEASE and RELEASE_SHARED; #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:31569,safe,safety,31569,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"ck. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2980,safe,safe,2980,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,['safe'],['safe']
Safety,"cket is created on the AQL queue. The HSA compatible; runtime api uses 64-bit atomic operations to reserve space in the AQL queue; for the packet. The packet must be set up, and the final write must use an; atomic store release to set the packet kind to ensure the packet contents are; visible to the kernel agent. AQL defines a doorbell signal mechanism to; notify the kernel agent that the AQL queue has been updated. These rules, and; the layout of the AQL queue and kernel dispatch packet is defined in the *HSA; System Architecture Specification* [HSA]_.; 6. A kernel dispatch packet includes information about the actual dispatch,; such as grid and work-group size, together with information from the code; object about the kernel, such as segment sizes. The HSA compatible runtime; queries on the kernel symbol can be used to obtain the code object values; which are recorded in the :ref:`amdgpu-amdhsa-code-object-metadata`.; 7. CP executes micro-code and is responsible for detecting and setting up the; GPU to execute the wavefronts of a kernel dispatch.; 8. CP ensures that when the a wavefront starts executing the kernel machine; code, the scalar general purpose registers (SGPR) and vector general purpose; registers (VGPR) are set up as required by the machine code. The required; setup is defined in the :ref:`amdgpu-amdhsa-kernel-descriptor`. The initial; register state is defined in; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`.; 9. The prolog of the kernel machine code (see; :ref:`amdgpu-amdhsa-kernel-prolog`) sets up the machine state as necessary; before continuing executing the machine code that corresponds to the kernel.; 10. When the kernel dispatch has completed execution, CP signals the completion; signal specified in the kernel dispatch packet if not 0. .. _amdgpu-amdhsa-memory-spaces:. Memory Spaces; ~~~~~~~~~~~~~. The memory space properties are:. .. table:: AMDHSA Memory Spaces; :name: amdgpu-amdhsa-memory-spaces-table. ================= =========== =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:151980,detect,detecting,151980,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['detect'],['detecting']
Safety,"clang`` (not ``ld``) for the final link step. When linking; shared libraries, the AddressSanitizer run-time is not linked, so; ``-Wl,-z,defs`` may cause link errors (don't use it with AddressSanitizer). To; get a reasonable performance add ``-O1`` or higher. To get nicer stack traces; in error messages add ``-fno-omit-frame-pointer``. To get perfect stack traces; you may need to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat example_UseAfterFree.cc; int main(int argc, char **argv) {; int *array = new int[100];; delete [] array;; return array[argc]; // BOOM; }. # Compile and link; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc. or:. .. code-block:: console. # Compile; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -c example_UseAfterFree.cc; # Link; % clang++ -g -fsanitize=address example_UseAfterFree.o. If a bug is detected, the program will print an error message to stderr and; exit with a non-zero exit code. AddressSanitizer exits on the first detected error.; This is by design:. * This approach allows AddressSanitizer to produce faster and smaller generated code; (both by ~5%).; * Fixing bugs becomes unavoidable. AddressSanitizer does not produce; false alarms. Once a memory corruption occurs, the program is in an inconsistent; state, which could lead to confusing results and potentially misleading; subsequent reports. If your process is sandboxed and you are running on OS X 10.10 or earlier, you; will need to set ``DYLD_INSERT_LIBRARIES`` environment variable and point it to; the ASan library that is packaged with the compiler used to build the; executable. (You can find the library by searching for dynamic libraries with; ``asan`` in their name.) If the environment variable is not set, the process will; try to re-exec. Also keep in mind that when moving the executable to another machine,; the ASan library will also need to be copied",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:2342,detect,detected,2342,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detected']
Safety,"clarations. For example:. .. code-block:: c++. namespace {; class StringSort {; ...; public:; StringSort(...); bool operator<(const char *RHS) const;; };; } // namespace. static void runHelper() {; ...; }. bool StringSort::operator<(const char *RHS) const {; ...; }. Avoid putting declarations other than classes into anonymous namespaces:. .. code-block:: c++. namespace {. // ... many declarations ... void runHelper() {; ...; }. // ... many declarations ... } // namespace. When you are looking at ""``runHelper``"" in the middle of a large C++ file,; you have no immediate way to tell if this function is local to the file. In; contrast, when the function is marked static, you don't need to cross-reference; faraway places in the file to tell that the function is local. Don't Use Braces on Simple Single-Statement Bodies of if/else/loop Statements; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When writing the body of an ``if``, ``else``, or for/while loop statement, we; prefer to omit the braces to avoid unnecessary line noise. However, braces; should be used in cases where the omission of braces harm the readability and; maintainability of the code. We consider that readability is harmed when omitting the brace in the presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or none of its; members, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is har",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:61719,avoid,avoid,61719,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"clared directly within an identifier list are incorrectly scoped; to the prototype rather than to the function body.; . 36; NAD; May floating-point constants be represented with more precision than implied by its type?; Yes. 37; NAD; Questions about multibyte characters and Unicode; Yes. 38; NAD; Questions about argument substitution during macro expansion; Yes. 39; NAD; Questions about the ""C"" locale; Yes. 40; NAD; 9 unrelated questions about C89. Partial; Question 6 has full support, the rest of the questions are currently unknown.; . 41; NAD; Do characters defined in 5.2.1 impact 7.3.1?; N/A. 42; NAD; On the behavior of library functions and overlapping objects; N/A. 43; C89; On the definition of the NULL macro; Yes. 44; NAD; On the result of the offsetof macro; Yes. 45; NAD; Is the behavior of freopen defined when the file is invalid?; N/A. 46; NAD; Use of typedef names in parameter declarations; Yes. 47; NAD; Questions about declaration conformance; Yes. 48; NAD; Clarifications on the abort() function; N/A. 49; C89; Can strxfrm() output more characters than were input?; N/A. 50; NAD; Do wide string literals implicitly include <stddef.h>?; Yes. 51; NAD; Question on pointer arithmetic; Yes. 52; C89; Editorial corrections; Yes. 53; C89; Accessing a pointer to a function with a prototype through a pointer to pointer to function without a prototype; Yes. 54; C89; Can the string handling functions have a length of 0?; N/A. 55; C89; Signal handler macros should have distinct values; N/A. 56; NAD; Floating-point representation precision requirements; Yes. 57; NAD; Is there an integral type for every pointer?; Yes. 58; NAD; Is there a limit on the number of digits processed by scanf and strtdo?; N/A. 59; NAD; Do types have to be completed?; Yes. 60; C89; Array initialization from a string literal; Yes. 61; NAD; Whitespace in scanf format string; N/A. 62; NAD; Can the rename function be defined to fail?; N/A. 63; Dup; Floating-point representation precision requirements;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:4289,abort,abort,4289,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['abort'],['abort']
Safety,"clares LLVM's RTTI templates. That; way your clients don't even have to think about it. .. code-block:: c++. #include ""llvm/Support/Casting.h"". #. In the base class, introduce an enum which discriminates all of the; different concrete classes in the hierarchy, and stash the enum value; somewhere in the base class. Here is the code after introducing this change:. .. code-block:: c++. class Shape {; public:; + /// Discriminator for LLVM-style RTTI (dyn_cast<> et al.); + enum ShapeKind {; + SK_Square,; + SK_Circle; + };; +private:; + const ShapeKind Kind;; +public:; + ShapeKind getKind() const { return Kind; }; +; Shape() {}; virtual double computeArea() = 0;; };. You will usually want to keep the ``Kind`` member encapsulated and; private, but let the enum ``ShapeKind`` be public along with providing a; ``getKind()`` method. This is convenient for clients so that they can do; a ``switch`` over the enum. A common naming convention is that these enums are ""kind""s, to avoid; ambiguity with the words ""type"" or ""class"" which have overloaded meanings; in many contexts within LLVM. Sometimes there will be a natural name for; it, like ""opcode"". Don't bikeshed over this; when in doubt use ``Kind``. You might wonder why the ``Kind`` enum doesn't have an entry for; ``Shape``. The reason for this is that since ``Shape`` is abstract; (``computeArea() = 0;``), you will never actually have non-derived; instances of exactly that class (only subclasses). See `Concrete Bases; and Deeper Hierarchies`_ for information on how to deal with; non-abstract bases. It's worth mentioning here that unlike; ``dynamic_cast<>``, LLVM-style RTTI can be used (and is often used) for; classes that don't have v-tables. #. Next, you need to make sure that the ``Kind`` gets initialized to the; value corresponding to the dynamic type of the class. Typically, you will; want to have it be an argument to the constructor of the base class, and; then pass in the respective ``XXXKind`` from subclass constructors. H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:2592,avoid,avoid,2592,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['avoid'],['avoid']
Safety,"class presents a very convenient frame which; surrounds visually a group of logically connected widgets: radio; buttons, related check boxes, two or more functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/020002",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33575,avoid,avoid,33575,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['avoid'],['avoid']
Safety,"clusterIter()) < tree-<GetEntries()) {; printf(""The cluster starts at %lld and ends at %lld\n"",clusterStart,clusterIter.GetNextEntry()-1);; }; See TTreeCache::FillBuffer for a concrete usage example. Significant improvement of the performance of SetBranchAddress/SetAddress (by a factor 3 to 10 depending on the length/complexity of the classname).; Prevent the unlimited growth of the TBasket's buffer even if the basket is reused.; When the basket is Reset (this happens when it is written and will be reused),; if the TBuffer size is greater than. - twice the data in the current basket; and - twice the average data in each basket (of this branch); and - twice the requeste basket size (TBranch::GetBasketSize).; the size of the buffer is reduced to the max of; 'the data in the current basket' and 'the average' and the requested; buffer size and aligned to next highest multiple of 512.; In TBranchRef distinguish between the entry we need (now called RequestedEntry) and the; entry we have read (fReadEntry) so that we can avoid re-reading the same entry too many; times when executing TRef::GetObject.; Reduce by 40% the time taken GetEntry for a branch created using a leaflist (exclusive of the decompression time).; Introduce TVirtualPerfStats::FileUnzipEvent to be able to keep track of the cost of unzipping and use this in TTreePerfStats and TBasket ... This give a good picture of where the time in unzip or in unstreaming; Add more clusters to the TTreeCache buffer until fBufferMinSize is hit to avoid severely underfilled buffer when; a low number of branches is selected/used.; When reading backwards, make sure to load a full (new) cluster and several other fixes to TTreeCache.; Reduce the memory used by a TTree in half. Refactor the code reading and writing the TBasket data.; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch.; In TTree::Fill, call FlushBasket before calling Opti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html:1398,avoid,avoid,1398,tree/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html,1,['avoid'],['avoid']
Safety,"code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not ye",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:32750,avoid,avoid,32750,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,2,"['avoid', 'safe']","['avoid', 'safepoint']"
Safety,"codings (byte sequences in; hex). The third section is the *Resource pressure view*. This view reports; the average number of resource cycles consumed every iteration by instructions; for every processor resource unit available on the target. Information is; structured in two tables. The first table reports the number of resource cycles; spent on average every iteration. The second table correlates the resource; cycles to the machine instruction in the sequence. For example, every iteration; of the instruction vmulps always executes on resource unit [6]; (JFPU1 - floating point pipeline #1), consuming an average of 1 resource cycle; per iteration. Note that on AMD Jaguar, vector floating-point multiply can; only be issued to pipeline JFPU1, while horizontal floating-point additions can; only be issued to pipeline JFPU0. The resource pressure view helps with identifying bottlenecks caused by high; usage of specific hardware resources. Situations with resource pressure mainly; concentrated on a few resources should, in general, be avoided. Ideally,; pressure should be uniformly distributed between multiple resources. Timeline View; ^^^^^^^^^^^^^; The timeline view produces a detailed report of each instruction's state; transitions through an instruction pipeline. This view is enabled by the; command line option ``-timeline``. As instructions transition through the; various stages of the pipeline, their states are depicted in the view report.; These states are represented by the following characters:. * D : Instruction dispatched.; * e : Instruction executing.; * E : Instruction executed.; * R : Instruction retired.; * = : Instruction already dispatched, waiting to be executed.; * \- : Instruction executed, waiting to be retired. Below is the timeline view for a subset of the dot-product example located in; ``test/tools/llvm-mca/X86/BtVer2/dot-product.s`` and processed by; :program:`llvm-mca` using the following command:. .. code-block:: bash. $ llvm-mca -mtriple=x86_6",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:20936,avoid,avoided,20936,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['avoid'],['avoided']
Safety,"column names in the RDataFrame object is now also; usable from a node of a distributed computation graph. This makes the generation of said computation graph slightly; less lazy than before. Notably, it used to be the case that a distributed computation graph could be defined with; code that was not yet available on the user's local application, but that would only become available in the; distributed worker. Now a call such as `df.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `ROOT::Minuit2::FCNGradientBase` were changed to accept `std::span<const double>` arguments instead of `std::vector<double> const&`.; This should have minimal impact on users, since one should usual use Minuit 2 via the `ROOT::Math::Minimizer` interface, which is unchanged. ## RooFit Libraries. ### Miscellaneous. * Setting `useHashMapForFind(true)` is not supported for RooArgLists anymore, since hash-assisted finding by name hash can be ambiguous: a RooArgList is allowed to have different elements with the same name. If you want to do fast lookups by name, convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is now switched on by default, and the associated getter and setter functions are deprecated. They will be removed in ROOT 6.36. If you want to fit the model as well instead of just ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:4264,avoid,avoid,4264,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['avoid'],['avoid']
Safety,"complicated bugs that span function boundaries. It may have problems, performance issues, etc. We'd like to hear about them. checker-261; built: February 22, 2012; highlights:. Contains a new experimental malloc/free checker.; Better support for projects using ARC.; Warns about null pointers passed as arguments to C string functions.; Warns about common anti-patterns in 'strncat' size argument, which can lead to buffer overflows.; set-xcode-analyzer now supports self-contained Xcode.app (Xcode 4.3 and later).; Contains a newer version of the analyzer than Xcode 4.3.; Misc. bug fixes and performance work. checker-260; built: January 25, 2012; highlights:; This is essentially the same as checker-259, but enables the following experimental checkers (please provide feedback):. Warns about unsafe uses of CFArrayCreate, CFSetCreate, and CFDictionaryCreate; Warns about unsafe uses of getpw, gets, which are sources of buffer overflows; Warns about unsafe uses of mktemp and mktemps, which can lead to insecure temporary files; Warns about unsafe uses of vfork, which is insecure to use; Warns about not checking the return values of setuid, setgid, seteuid, setegid, setreuid, setregid (another security issue). checker-259; built: January 25, 2012; highlights:. Contains a newer version of the analyzer than the one shipped in Xcode 4.2.; Significant performance optimizations to reduce memory usage of the analyzer.; Tweaks to scan-build to have it work more easily with Xcode projects using Clang.; Numerous bug fixes to better support code using ARC. checker-258; built: October 13, 2011; highlights:. Contains a newer version of the analyzer than the one shipped in Xcode 4.2.; Adds a new security checker for looking at correct uses of the Mac OS KeyChain API.; Supports ARC (please file bugs where you see issues); Major under-the-cover changes. This should result in more precise results in some cases, but this is laying the groundwork for major improvements. Please file bugs where yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:9447,unsafe,unsafe,9447,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,4,['unsafe'],['unsafe']
Safety,"corresponding to the predecessor basic block that; executed just prior to the current block. Example:; """""""""""""""". .. code-block:: llvm. Loop: ; Infinite loop that counts from 0 on up...; %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]; %nextindvar = add i32 %indvar, 1; br label %Loop. .. _i_select:. '``select``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = select [fast-math flags] selty <cond>, <ty> <val1>, <ty> <val2> ; yields ty. selty is either i1 or {<N x i1>}. Overview:; """""""""""""""""". The '``select``' instruction is used to choose one value based on a; condition, without IR-level branching. Arguments:; """""""""""""""""""". The '``select``' instruction requires an 'i1' value or a vector of 'i1'; values indicating the condition, and two values of the same :ref:`first; class <t_firstclass>` type. #. The optional ``fast-math flags`` marker indicates that the select has one or more; :ref:`fast-math flags <fastmath>`. These are optimization hints to enable; otherwise unsafe floating-point optimizations. Fast-math flags are only valid; for selects that return a floating-point scalar or vector type, or an array; (nested to any depth) of floating-point scalar or vector types. Semantics:; """""""""""""""""""". If the condition is an i1 and it evaluates to 1, the instruction returns; the first value argument; otherwise, it returns the second value; argument. If the condition is a vector of i1, then the value arguments must be; vectors of the same size, and the selection is done element by element. If the condition is an i1 and the value arguments are vectors of the; same size, then an entire vector is selected. Example:; """""""""""""""". .. code-block:: llvm. %X = select i1 true, i8 17, i8 42 ; yields i8:17. .. _i_freeze:. '``freeze``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = freeze ty <val> ; yields ty:result. Overview:; """""""""""""""""". The '``freeze``' instruction is used to stop propagation of; :ref:`undef <undefvalues>` and :ref:`poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:469459,unsafe,unsafe,469459,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"corresponds; to the level 0 in the stored array, while the last node will correspond; to level `n`. For each level, the node, volume and global matrix can be; retrieved using corresponding getters:. ``` {.cpp}; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; ```. By default the object at level n is retrieved (the align-able object). Once created, a physical node can be misaligned, meaning that its; positioning matrix or even the shape.:. ``` {.cpp}; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); ```. The convention used is that newmat represents the new local matrix of; the last node in the branch with respect to its mother volume. The; `Align()` method will actually duplicate the corresponding branch within; the logical hierarchy, creating new volumes and nodes. This is mandatory; in order to avoid problems due to replicated volumes and can create; exhaustive memory consumption if used abusively. Once aligned, a physical node is ready to be tracked. The operation can; be done only after the geometry was closed. Important NOTE: Calling the `Align()` method for a physical node changes; the node pointers for the stored node branch in the active geometry, Due; to this the other defined physical nodes containing elements of this; path will be invalid. Example:. ``` {.cpp}; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; ```. The call to `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nodes:. ``` {.cpp}; void RefreshPhysicalNodes(Bool_t lock = kTRUE); ```. The method above will optionally lock the possibility of doing any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:148991,avoid,avoid,148991,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['avoid'],['avoid']
Safety,"count for each object and frees an object; when its count falls to zero. Mark-Sweep; When the heap is exhausted, the collector marks reachable objects starting; from the roots, then deallocates unreachable objects in a sweep phase. Copying; As reachability analysis proceeds, the collector copies objects from one heap; area to another, compacting them in the process. Copying collectors enable; highly efficient ""bump pointer"" allocation and can improve locality of; reference. Incremental; (Including generational collectors.) Incremental collectors generally have all; the properties of a copying collector (regardless of whether the mature heap; is compacting), but bring the added complexity of requiring write barriers. Threaded; Denotes a multithreaded mutator; the collector must still stop the mutator; (""stop the world"") before beginning reachability analysis. Stopping a; multithreaded mutator is a complicated problem. It generally requires highly; platform-specific code in the runtime, and the production of carefully; designed machine code at safe points. Concurrent; In this technique, the mutator and the collector run concurrently, with the; goal of eliminating pause times. In a *cooperative* collector, the mutator; further aids with collection should a pause occur, allowing collection to take; advantage of multiprocessor hosts. The ""stop the world"" problem of threaded; collectors is generally still present to a limited extent. Sophisticated; marking algorithms are necessary. Read barriers may be necessary. As the matrix indicates, LLVM's garbage collection infrastructure is already; suitable for a wide variety of collectors, but does not currently extend to; multithreaded programs. This will be added in the future as there is; interest. .. _stack-map:. Computing stack maps; --------------------. LLVM automatically computes a stack map. One of the most important features; of a ``GCStrategy`` is to compile this information into the executable in; the binary represent",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:31246,safe,safe,31246,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ==================================================. The bounds annotations provided by the ``-fbounds-safety`` programming model; have potential use cases beyond the language extension itself. For example,; static and dynamic analysis tools could use the bounds information to improve; diagnostics for out-of-bounds accesses, even if ``-fbounds-safety`` is not used.; The bounds annotations could be used to improve C interoperability with; bounds-safe languages, providing a better mapping to bounds-safe types in the; safe language interface. The bounds annotations can also serve as documentation; specifying the relationship between declarations. Limitations; ===========. ``-fbounds-safety`` aims to bring the bounds safety guarantee to the C language,; and it does not guarantee other types of memory safety properties. Consequently,; it may not prevent some of the secondary bounds safety violations caused by; other types of safety violations such as type confusion. For instance,; ``-fbounds-safety`` does not perform type-safety checks on conversions between; `__single`` pointers of different pointee types (e.g., ``char *__single`` →; ``void *__single`` → ``int *__single``) beyond what the foundation languages; (C/C++) already offer. ``-fbounds-safety`` heavily relies on run-time checks to keep the bounds safety; and the soundness of the type system. This may incur significant code size; overhead in unoptimized builds and leaving some of the adoption mistakes to be; caught only at run time. This is not a fundamental limitation, however, because; incrementally adding necessary static analysis will allow us to catch issues; early on and remove unnecessary bounds checks in unoptimized builds.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:47180,safe,safety,47180,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,9,['safe'],['safety']
Safety,"cquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:17555,detect,detecting,17555,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['detect'],['detecting']
Safety,"crossing can be; retrieved after the call:. ~~~{.cpp}; Double_t TGeoManager::GetStep(); ~~~. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning ""step approved"". The default value for `stepmax` is; TGeoShape::Big with the meaning that boundaries are looked for; without limitation. \image html geometry017.png ""Finding the distance to the next crossed boundary"" width=600px. According the values of the input parameters the method will perform; additional optional tasks:. `|stepmax| < TGeoShape::Big()`. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:120779,safe,safe,120779,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"ct that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physicall",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161364,safe,safety,161364,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"cter array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; instance, which can be used directly or converted to an ``std::string`` using; the ``str`` member function. See ``llvm/ADT/StringRef.h`` (`doxygen; <https://llvm.org/doxygen/StringRef_8h_source.html>`__) for more; information. You should rarely use the ``StringRef`` class directly, because it contains; pointers to external memory it is not generally safe to store an instance of the; class (unless you know that the external storage will not be freed).; ``StringRef`` is small and pervasive enough in LLVM that it should always be; passed by value. The ``Twine`` class; ^^^^^^^^^^^^^^^^^^^. The ``Twine`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Twine.html>`__); class is an efficient way for APIs to accept concatenated strings. For example,; a common LLVM paradigm is to name one instruction based on the name of another; instruction with a suffix, for example:. .. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:9524,safe,safe,9524,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"ction as much as possible. Finally, ``bugpoint``; deletes any individual LLVM instructions whose absence does not eliminate the; failure. At the end, ``bugpoint`` should tell you what passes crash, give you a; bitcode file, and give you instructions on how to reproduce the failure with; ``opt`` or ``llc``. .. _code generator debugger:. Code generator debugger; -----------------------. The code generator debugger attempts to narrow down the amount of code that is; being miscompiled by the selected code generator. To do this, it takes the test; program and partitions it into two pieces: one piece which it compiles with the; ""safe"" backend (into a shared object), and one piece which it runs with either; the JIT or the static LLC compiler. It uses several techniques to reduce the; amount of code pushed through the LLVM code generator, to reduce the potential; scope of the problem. After it is finished, it emits two bitcode files (called; ""test"" [to be compiled with the code generator] and ""safe"" [to be compiled with; the ""safe"" backend], respectively), and instructions for reproducing the; problem. The code generator debugger assumes that the ""safe"" backend produces; good code. .. _miscompilation debugger:. Miscompilation debugger; -----------------------. The miscompilation debugger works similarly to the code generator debugger. It; works by splitting the test program into two pieces, running the optimizations; specified on one piece, linking the two pieces back together, and then executing; the result. It attempts to narrow down the list of passes to the one (or few); which are causing the miscompilation, then reduce the portion of the test; program which is being miscompiled. The miscompilation debugger assumes that; the selected code generator is working properly. Advice for using bugpoint; =========================. ``bugpoint`` can be a remarkably useful tool, but it sometimes works in; non-obvious ways. Here are some hints and tips:. * In the code generator and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:4775,safe,safe,4775,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,2,['safe'],['safe']
Safety,"ction has the ``""stack-probe-size""`` attribute; of the callee.; ``""no-stack-arg-probe""``; This attribute disables ABI-required stack probes, if any.; ``returns_twice``; This attribute indicates that this function can return twice. The C; ``setjmp`` is an example of such a function. The compiler disables; some optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:100563,detect,detection,100563,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detection']
Safety,"ction should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26657,recover,recovery,26657,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['recover'],['recovery']
Safety,"ction; taking a memory operand. Different constraints allow for different addressing; modes used by the target.; - Immediate value constraint. This kind of constraint is for an integer or other; immediate value which can be rendered directly into an instruction. The; various target-specific constraints allow the selection of a value in the; proper range for the instruction you wish to use it with. Output constraints; """""""""""""""""""""""""""""""""""". Output constraints are specified by an ""``=``"" prefix (e.g. ""``=r``""). This; indicates that the assembly will write to this operand, and the operand will; then be made available as a return value of the ``asm`` expression. Output; constraints do not consume an argument from the call instruction. (Except, see; below about indirect outputs). Normally, it is expected that no output locations are written to by the assembly; expression until *all* of the inputs have been read. As such, LLVM may assign; the same register to an output and an input. If this is not safe (e.g. if the; assembly contains two instructions, where the first writes to one output, and; the second reads an input and writes to a second output), then the ""``&``""; modifier must be used (e.g. ""``=&r``"") to specify that the output is an; ""early-clobber"" output. Marking an output as ""early-clobber"" ensures that LLVM; will not use the same register for any inputs (other than an input tied to this; output). Input constraints; """""""""""""""""""""""""""""""""". Input constraints do not have a prefix -- just the constraint codes. Each input; constraint will consume one argument from the call instruction. It is not; permitted for the asm to write to any input register or memory location (unless; that input is tied to an output). Note also that multiple inputs may all be; assigned to the same register, if LLVM can determine that they necessarily all; contain the same value. Instead of providing a Constraint Code, input constraints may also ""tie""; themselves to an output constraint, by providing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:212378,safe,safe,212378,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"ctivated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Cance",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10005,safe,safe,10005,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"ctorization [2]_. 4. Support multiple candidates efficiently. In particular, similar candidates; related to a range of possible VF's and UF's must be represented efficiently.; Potential versioning needs to be supported efficiently. 5. Support vectorizing idioms, such as interleaved groups of strided loads or; stores. This is achieved by modeling a sequence of output instructions using; a ""Recipe"", which is responsible for computing its cost and generating its; code. 6. Encapsulate Single-Entry Single-Exit regions (SESE). During vectorization; such regions may need to be, for example, predicated and linearized, or; replicated VF*UF times to handle scalarized and predicated instructions.; Innerloops are also modelled as SESE regions. 7. Support instruction-level analysis and transformation, as part of Planning; Step 2.b: During vectorization instructions may need to be traversed, moved,; replaced by other instructions or be created. For example, vector idiom; detection and formation involves searching for and optimizing instruction; patterns. Definitions; ===========; The low-level design of VPlan comprises of the following classes. :LoopVectorizationPlanner:; A LoopVectorizationPlanner is designed to handle the vectorization of a loop; or a loop nest. It can construct, optimize and discard one or more VPlans,; each VPlan modelling a distinct way to vectorize the loop or the loop nest.; Once the best VPlan is determined, including the best VF and UF, this VPlan; drives the generation of output IR. :VPlan:; A model of a vectorized candidate for a given input IR loop or loop nest. This; candidate is represented using a Hierarchical CFG. VPlan supports estimating; the cost and driving the generation of the output IR code it represents. :Hierarchical CFG:; A control-flow graph whose nodes are basic-blocks or Hierarchical CFG's. The; Hierarchical CFG data structure is similar to the Tile Tree [5]_, where; cross-Tile edges are lifted to connect Tiles instead of the original",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst:3868,detect,detection,3868,interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,1,['detect'],['detection']
Safety,"cts on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a hi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75366,safe,safe,75366,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"d a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on how to use the static analyzer. OPTIONS; -------. Stage Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -E. Run the preprocessor stage. .. option:: -fsyntax-only. Run the preprocessor, parser and semantic analysis stages. .. option:: -S. Run the previous stages a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:2036,avoid,avoids,2036,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['avoid'],['avoids']
Safety,"d along with; the git hashes from the release branch. Add the release:merged label to the issue; and close it. Release Patch Rules; -------------------. Below are the rules regarding patching the release branch:. #. Patches applied to the release branch may only be applied by the release; manager, the official release testers or the code owners with approval from; the release manager. #. Release managers are encouraged, but not required, to get approval from code; owners before approving patches. If there is no code owner or the code owner; is unreachable then release managers can ask approval from patch reviewers or; other developers active in that area. #. *Before RC1* Patches should be limited to bug fixes, important optimization; improvements, or completion of features that were started before the branch; was created. As with all phases, release managers and code owners can reject; patches that are deemed too invasive. #. *Before RC2* Patches should be limited to bug fixes or backend specific; improvements that are determined to be very safe. #. *Before RC3/Final Major Release* Patches should be limited to critical; bugs or regressions. #. *Bug fix releases* Patches should be limited to bug fixes or very safe; and critical performance improvements. Patches must maintain both API and; ABI compatibility with the previous major release. Release Final Tasks; -------------------. The final stages of the release process involves tagging the ""final"" release; branch, updating documentation that refers to the release, and updating the; demo page. Update Documentation; ^^^^^^^^^^^^^^^^^^^^. Review the documentation in the release branch and ensure that it is up; to date. The ""Release Notes"" must be updated to reflect new features, bug; fixes, new known issues, and changes in the list of supported platforms.; The ""Getting Started Guide"" should be updated to reflect the new release; version number tag available from Subversion and changes in basic system; requirements. .. _t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:13390,safe,safe,13390,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['safe'],['safe']
Safety,"d as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:195344,detect,detection,195344,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detection']
Safety,"d code,; most garbage collectors are organized in terms of three abstractions:; load barriers, store barriers, and safepoints. #. A load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3441,safe,safepoint,3441,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"d from the target triple or; autodetected to the current architecture. .. option:: -mcpu=cpuname. Specify a specific chip in the current architecture to generate code for.; By default this is inferred from the target triple and autodetected to; the current architecture. For a list of available CPUs, use:; **llvm-as < /dev/null | llc -march=xyz -mcpu=help**. .. option:: -mattr=a1,+a2,-a3,... Override or control specific attributes of the target, such as whether SIMD; operations are enabled or not. The default set of attributes is set by the; current CPU. For a list of available attributes, use:; **llvm-as < /dev/null | llc -march=xyz -mattr=help**. FLOATING POINT OPTIONS; ----------------------. .. option:: -disable-excess-fp-precision. Disable optimizations that may increase floating point precision. .. option:: -enable-no-infs-fp-math. Enable optimizations that assume no Inf values. .. option:: -enable-no-nans-fp-math. Enable optimizations that assume no NAN values. .. option:: -enable-unsafe-fp-math. Causes :program:`lli` to enable optimizations that may decrease floating point; precision. .. option:: -soft-float. Causes :program:`lli` to generate software floating point library calls instead of; equivalent hardware instructions. CODE GENERATION OPTIONS; -----------------------. .. option:: -code-model=model. Choose the code model from:. .. code-block:: text. default: Target default code model; tiny: Tiny code model; small: Small code model; kernel: Kernel code model; medium: Medium code model; large: Large code model. .. option:: -disable-post-RA-scheduler. Disable scheduling after register allocation. .. option:: -disable-spill-fusing. Disable fusing of spill code into instructions. .. option:: -jit-enable-eh. Exception handling should be enabled in the just-in-time compiler. .. option:: -join-liveintervals. Coalesce copies (default=true). .. option:: -nozero-initialized-in-bss. Don't place zero-initialized symbols into the BSS section. .. option:: -pre-RA-sched=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst:3257,unsafe,unsafe-fp-math,3257,interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lli.rst,1,['unsafe'],['unsafe-fp-math']
Safety,"d object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_commands.json and put it at; the top of the build directory. Clang tools are pointed to the top of; the build directory to detect the file and use the compilation database; to parse C++ code in the source tree. Alternatives; ============; For simple projects, Clang tools also recognize a ``compile_flags.txt`` file.; This should contain one argument per line. The same flags will be used to; compile any file. Example:. ::. -xc++; -I; libwidget/include/. Here ``-I libwidget/include`` is two arguments, and so becomes two lines.; Paths are relative to the directory containing ``compile_flags.txt``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:4608,detect,detect,4608,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['detect'],['detect']
Safety,"d on the control flow graph of programs. However, traditional; instruction sets do not implement PHI instructions. Thus, in order to generate; executable code, compilers must replace PHI instructions with other instructions; that preserve their semantics. There are many ways in which PHI instructions can safely be removed from the; target code. The most traditional PHI deconstruction algorithm replaces PHI; instructions with copy instructions. That is the strategy adopted by LLVM. The; SSA deconstruction algorithm is implemented in; ``lib/CodeGen/PHIElimination.cpp``. In order to invoke this pass, the identifier; ``PHIEliminationID`` must be marked as required in the code of the register; allocator. Instruction folding; ^^^^^^^^^^^^^^^^^^^. *Instruction folding* is an optimization performed during register allocation; that removes unnecessary copy instructions. For instance, a sequence of; instructions such as:. ::. %EBX = LOAD %mem_address; %EAX = COPY %EBX. can be safely substituted by the single instruction:. ::. %EAX = LOAD %mem_address. Instructions can be folded with the; ``TargetRegisterInfo::foldMemoryOperand(...)`` method. Care must be taken when; folding instructions; a folded instruction can be quite different from the; original instruction. See ``LiveIntervals::addIntervalsForSpills`` in; ``lib/CodeGen/LiveIntervalAnalysis.cpp`` for an example of its use. Built in register allocators; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The LLVM infrastructure provides the application developer with three different; register allocators:. * *Fast* --- This register allocator is the default for debug builds. It; allocates registers on a basic block level, attempting to keep values in; registers and reusing registers as appropriate. * *Basic* --- This is an incremental approach to register allocation. Live; ranges are assigned to registers one at a time in an order that is driven by; heuristics. Since code can be rewritten on-the-fly during allocation, this; framework allows inte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:68844,safe,safely,68844,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['safe'],['safely']
Safety,"d set EXTERNAL_TOOLCHAINS_DIR to the; # path specified by $CMAKE_INSTALL_PREFIX/Toolchains. # This file generates a custom install-xcode-toolchain target which constructs; # and installs a toolchain with the identifier in the pattern:; # org.llvm.${PACKAGE_VERSION}. This toolchain can then be used to override the; # system compiler by setting TOOLCHAINS=org.llvm.${PACKAGE_VERSION} in the; # in the environment. # Example usage:; # cmake -G Ninja -DLLVM_CREATE_XCODE_TOOLCHAIN=On; # -DCMAKE_INSTALL_PREFIX=$PWD/install; # ninja install-xcode-toolchain; # export EXTERNAL_TOOLCHAINS_DIR=$PWD/install/Toolchains; # export TOOLCHAINS=org.llvm.3.8.0svn. # `xcrun -find clang` should return the installed clang, and `clang --version`; # should show 3.8.0svn. if(NOT APPLE); return(); endif(). option(LLVM_CREATE_XCODE_TOOLCHAIN ""Create a target to install LLVM into an Xcode toolchain"" Off). if(NOT LLVM_CREATE_XCODE_TOOLCHAIN); return(); endif(). # XCODE_VERSION is set by CMake when using the Xcode generator, otherwise we need; # to detect it manually here.; if(NOT XCODE_VERSION); execute_process(; COMMAND xcodebuild -version; OUTPUT_VARIABLE xcodebuild_version; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""Xcode ([0-9][0-9]?([.][0-9])+)"" version_match ${xcodebuild_version}); if(version_match); message(STATUS ""Identified Xcode Version: ${CMAKE_MATCH_1}""); set(XCODE_VERSION ${CMAKE_MATCH_1}); else(); # If detecting Xcode version failed, set a crazy high version so we default; # to the newest.; set(XCODE_VERSION 99); message(WARNING ""Failed to detect the version of an installed copy of Xcode, falling back to highest supported version. Set XCODE_VERSION to override.""); endif(); endif(). # Xcode 8 requires CompatibilityVersion 2; set(COMPAT_VERSION 2); if(XCODE_VERSION VERSION_LESS 8.0.0); # Xcode 7.3 (the first version supporting external toolchains) requires; # CompatibilityVersion 1; set(COMPAT_VERSION 1); endif(). execute_process(; COMMAND xcrun -fin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:1910,detect,detect,1910,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['detect'],['detect']
Safety,"d support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ""Run; in background"" has been added; to the dialog box. The behaviour of Ctrl-C has also been modified: the; user is prompted for a choice among continuing asynchronously, stopping; (terminating) or aborting the query.; Add the possibility to define the dataset information; sources via the directive 'xpd.datasetsrc'.; In this way the permissions; should be set correctly and the related problems disappear.; Record the logs from the ROOT version validation tests; (proofserv forked in test mode). In case of failure - or if the debug; flag is on - the log files are kept under; <xproof_adminpath>/rootsysvalidation/root.<tag>.log; (the <tag> has all the '/' replaced by '-'). This should; facilitate understanding the problems when in case of validation; failures.; Add support for automatic; running of PROOF sessions in valgrind. The second; argument of TProof::Open is used to trigger the relevant; settings. To valgrind the master session start PROOF; with TProof::Open(""<master>"",""valgrind=master"");; to valgrind two workers sessions use; TProof::Open(""<master>"",""valgrind=workers""); to valgrind; master and 2 workers, use; TProof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:3085,abort,aborting,3085,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['abort'],['aborting']
Safety,"d the preservation of otherwise identical metadata nodes. Since; the loop-metadata node can be attached to multiple nodes, the 'distinct'; keyword has become unnecessary. Prior to the property nodes, one or two ``DILocation`` (debug location); nodes can be present in the list. The first, if present, identifies the; source-code location where the loop begins. The second, if present,; identifies the source-code location where the loop ends. Loop metadata nodes cannot be used as unique identifiers. They are; neither persistent for the same loop through transformations nor; necessarily unique to just one loop. '``llvm.loop.disable_nonforced``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables all optional loop transformations unless; explicitly instructed using other transformation metadata such as; ``llvm.loop.unroll.enable``. That is, no heuristic will try to determine; whether a transformation is profitable. The purpose is to avoid that the; loop is transformed to a different loop before an explicitly requested; (forced) transformation is applied. For instance, loop fusion can make; other transformations impossible. Mandatory loop canonicalizations such; as loop rotation are still applied. It is recommended to use this metadata in addition to any llvm.loop.*; transformation directive. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop iden",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:295336,avoid,avoid,295336,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"d trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke frag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:20479,unsafe,unsafe,20479,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['unsafe'],['unsafe']
Safety,"d vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not chang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:66071,safe,safe,66071,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"d, a more consistent way of identifying; the instruction's value is to refer to the `MachineOperand` where the value is; defined: independently of which register is defined by that `MachineOperand`. In; the code above, the `DBG_INSTR_REF` instruction refers to instruction number; one, operand zero, while the `ADD32rr` has a `debug-instr-number` attribute; attached indicating that it is instruction number one. De-coupling variable locations from registers avoids difficulties involving; register allocation and optimisation, but requires additional instrumentation; when the instructions are optimised instead. Optimisations that replace; instructions with optimised versions that compute the same value must either; preserve the instruction number, or record a substitution from the old; instruction / operand number pair to the new instruction / operand pair -- see; `MachineFunction::substituteDebugValuesForInst`. If debug info maintenance is; not performed, or an instruction is eliminated as dead code, the variable; location is safely dropped and marked ""optimised out"". The exception is; instructions that are mutated rather than replaced, which always need debug info; maintenance. # Register allocator considerations. When the register allocator runs, debugging instructions do not directly refer; to any virtual registers, and thus there is no need for expensive location; maintenance during regalloc (i.e. `LiveDebugVariables`). Debug instructions are; unlinked from the function, then linked back in after register allocation; completes. The exception is `PHI` instructions: these become implicit definitions at; control flow merges once regalloc finishes, and any debug numbers attached to; `PHI` instructions are lost. To circumvent this, debug numbers of `PHI`s are; recorded at the start of register allocation (`phi-node-elimination`), then; `DBG_PHI` instructions are inserted after regalloc finishes. This requires some; maintenance of which register a variable is located in d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:3032,safe,safely,3032,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['safe'],['safely']
Safety,"d, the checker will consider all `DstArgs` arguments tainted after the call.; - `DstArgs` is a list of numbers in the range of ``[-1..int_max]`` that indicates the indexes of arguments in the function call.; The number ``-1`` specifies the return value of the function.; If any `SrcArgs` arguments are tainted, the checker will consider all `DstArgs` arguments tainted after the call.; - `VariadicType` is a string that can be one of ``None``, ``Dst``, ``Src``.; It is used in conjunction with `VariadicIndex` to specify arguments inside a variadic argument.; The value of ``Src`` will treat every call site argument that is part of a variadic argument list as a source concerning propagation rules (as if specified by `SrcArg`).; The value of ``Dst`` will treat every call site argument that is part of a variadic argument list a destination concerning propagation rules.; The value of ``None`` will not consider the arguments that are part of a variadic argument list (this option is redundant but can be used to temporarily switch off handling of a particular variadic argument option without removing the VariadicIndex key).; - `VariadicIndex` is a number in the range of ``[0..int_max]``. It indicates the starting index of the variadic argument in the signature of the function. .. _clangsa-taint-sink-details:. Sink syntax and semantics; #########################. An entry under `Sinks` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function during symbolic execution will emit a taint-related diagnostic if any of the arguments specified with `Args` are tainted at the call site.; - `Args` is a list of numbers in the range of ``[0..int_max]`` that indicates the indexes of arguments in the function call.; The checker reports an error if any of the specified arguments are tainted. The following keys are optional:; - `Scope` is a string that sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:8290,redund,redundant,8290,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['redund'],['redundant']
Safety,"d-just-interpreting-cpp/>`_; - *Vassil Vassilev* 2021 The LLVM Project Blog; - This blog page discusses how Cling enables template Instantiation on demand, language interoperability on demand, interpreter/compiler as a service, plugins extension.; * - `TinySpec-Cling <https://github.com/nwoeanhinnogaehr/tinyspec-cling>`_; - Noah Weninger 2020; - A tiny C++ live-coded overlap-add (re)synthesizer for Linux, which uses Cling to add REPL-like functionality for C++ code.; * - `Interactive C++ for Data Science <https://blog.llvm.org/posts/2020-12-21-interactive-cpp-for-data-science/>`_; - *Vassil Vassilev,* *David Lange,* *Simeon Ehrig,* *Sylvain Corlay* 2020 The LLVM Project Blog; - Cling enables eval-style programming for Data Science applications. Examples of ROOT and Xeus-Cling for data science are shown.; * - `Interactive C++ with Cling <https://blog.llvm.org/posts/2020-11-30-interactive-cpp-with-cling/>`_; - *Vassil Vassilev* 2020 The LLVM Project Blog; - This blog page briefly discusses the concept of interactive C++ by presenting Cling’s main features, such as wrapper functions, entity redefinition, error recovery. ; * - `Using the Cling C++ Interpreter on the Bela Platform <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_; - Jack Armitage 2019; - Cling has been installed on a BeagleBoard to bring live coding to the Bela interactive audio platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:3778,recover,recovery,3778,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['recover'],['recovery']
Safety,"d; br label %return. return: ; preds = %invoke.cont.3, %invoke.cont.2; %retval.0 = phi i32 [ 0, %invoke.cont.2 ], [ %3, %invoke.cont.3 ]; ret i32 %retval.0. lpad.cleanup: ; preds = %invoke.cont.2; %0 = cleanuppad within none []; call void @""??1Cleanup@@QEAA@XZ""(ptr nonnull %obj) nounwind; cleanupret from %0 unwind label %lpad.catch. lpad.catch: ; preds = %lpad.cleanup, %entry; %1 = catchswitch within none [label %catch.body] unwind label %lpad.terminate. catch.body: ; preds = %lpad.catch; %catch = catchpad within %1 [ptr @""??_R0H@8"", i32 0, ptr %e]; invoke void @""?may_throw@@YAXXZ""(); to label %invoke.cont.3 unwind label %lpad.terminate. invoke.cont.3: ; preds = %catch.body; %3 = load i32, ptr %e, align 4; catchret from %catch to label %return. lpad.terminate: ; preds = %catch.body, %lpad.catch; cleanuppad within none []; call void @""?terminate@@YAXXZ""(); unreachable; }. Funclet parent tokens; -----------------------. In order to produce tables for EH personalities that use funclets, it is; necessary to recover the nesting that was present in the source. This funclet; parent relationship is encoded in the IR using tokens produced by the new ""pad""; instructions. The token operand of a ""pad"" or ""ret"" instruction indicates which; funclet it is in, or ""none"" if it is not nested within another funclet. The ``catchpad`` and ``cleanuppad`` instructions establish new funclets, and; their tokens are consumed by other ""pad"" instructions to establish membership.; The ``catchswitch`` instruction does not create a funclet, but it produces a; token that is always consumed by its immediate successor ``catchpad``; instructions. This ensures that every catch handler modelled by a ``catchpad``; belongs to exactly one ``catchswitch``, which models the dispatch point after a; C++ try. Here is an example of what this nesting looks like using some hypothetical; C++ code:. .. code-block:: c. void f() {; try {; throw;; } catch (...) {; try {; throw;; } catch (...) {; }; }; }. .. code-block:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:29386,recover,recover,29386,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['recover'],['recover']
Safety,"d>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". On some platforms, the value returned by this intrinsic remains unchanged; between loads in the same thread. On other platforms, it returns the same; global variable value, if any, e.g. ``@__stack_chk_guard``. Currently some platforms have IR-level customized stack guard loading (e.g.; X86 Linux) that is not handled by ``llvm.stackguard()``, while they should be; in the future. '``llvm.objectsize``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.objectsiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:930696,abort,abort,930696,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['abort'],['abort']
Safety,"date, time, or any other ""random"" data, ``bugpoint`` may; misinterpret differences in these data, when output, as the result of a; miscompilation. Programs should be temporarily modified to disable outputs; that are likely to vary from run to run. * In the `crash debugger`_, ``bugpoint`` does not distinguish different crashes; during reduction. Thus, if new crash or miscompilation happens, ``bugpoint``; will continue with the new crash instead. If you would like to stick to; particular crash, you should write check scripts to validate the error; message, see ``-compile-command`` in :doc:`CommandGuide/bugpoint`. * In the code generator and miscompilation debuggers, debugging will go faster; if you manually modify the program or its inputs to reduce the runtime, but; still exhibit the problem. * ``bugpoint`` is extremely useful when working on a new optimization: it helps; track down regressions quickly. To avoid having to relink ``bugpoint`` every; time you change your optimization however, have ``bugpoint`` dynamically load; your optimization with the ``-load`` option. * ``bugpoint`` can generate a lot of output and run for a long period of time.; It is often useful to capture the output of the program to file. For example,; in the C shell, you can run:. .. code-block:: console. $ bugpoint ... |& tee bugpoint.log. to get a copy of ``bugpoint``'s output in the file ``bugpoint.log``, as well; as on your terminal. * ``bugpoint`` cannot debug problems with the LLVM linker. If ``bugpoint``; crashes before you see its ""All input ok"" message, you might try ``llvm-link; -v`` on the same set of input files. If that also crashes, you may be; experiencing a linker bug. * ``bugpoint`` is useful for proactively finding bugs in LLVM. Invoking; ``bugpoint`` with the ``-find-bugs`` option will cause the list of specified; optimizations to be randomized and applied to the program. This process will; repeat until a bug is found or the user kills ``bugpoint``. * ``bugpoint`` can produ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:6837,avoid,avoid,6837,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['avoid'],['avoid']
Safety,"de checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:32553,safe,safepoint,32553,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"de enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by perform",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2025,safe,safer,2025,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safer']
Safety,"de set can; be a subset of another loop with a different loop header. The loop; hierarchy in a function forms a forest: Each top-level loop is the; root of the tree of the loops nested inside it. .. image:: ./loop-nested.svg; :width: 350 px. * It is not possible that two loops share only a few of their nodes.; Two loops are either disjoint or one is nested inside the other. In; the example below the left and right subsets both violate the; maximality condition. Only the merge of both sets is considered a loop. .. image:: ./loop-nonmaximal.svg; :width: 250 px. * It is also possible that two logical loops share a header, but are; considered a single loop by LLVM:. .. code-block:: C. for (int i = 0; i < 128; ++i); for (int j = 0; j < 128; ++j); body(i,j);. which might be represented in LLVM-IR as follows. Note that there is; only a single header and hence just a single loop. .. image:: ./loop-merge.svg; :width: 400 px. The :ref:`LoopSimplify <loop-terminology-loop-simplify>` pass will; detect the loop and ensure separate headers for the outer and inner loop. .. image:: ./loop-separate.svg; :width: 400 px. * A cycle in the CFG does not imply there is a loop. The example below; shows such a CFG, where there is no header node that dominates all; other nodes in the cycle. This is called **irreducible control-flow**. .. image:: ./loop-irreducible.svg; :width: 150 px. The term reducible results from the ability to collapse the CFG into a; single node by successively replacing one of three base structures with; a single node: A sequential execution of basic blocks, acyclic conditional; branches (or switches), and a basic block looping on itself.; `Wikipedia <https://en.wikipedia.org/wiki/Control-flow_graph#Reducibility>`_; has a more formal definition, which basically says that every cycle has; a dominating header. * Irreducible control-flow can occur at any level of the loop nesting.; That is, a loop that itself does not contain any loops can still have; cyclic control flow ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:4237,detect,detect,4237,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['detect'],['detect']
Safety,"de that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling; -----------------------------. The `OSDI'14 paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ mentions that; on Linux the instrumentation pass finds calls to setjmp or functions that; may throw ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7507,unsafe,unsafe,7507,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"ded intrinsic. You can use ``llvm.nearbyint`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.nearbyint.f32(float %Val); declare double @llvm.nearbyint.f64(double %Val); declare x86_fp80 @llvm.nearbyint.f80(x86_fp80 %Val); declare fp128 @llvm.nearbyint.f128(fp128 %Val); declare ppc_fp128 @llvm.nearbyint.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.nearbyint.*``' intrinsics returns the operand rounded to the; nearest integer. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same; type. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``nearbyint``; functions would, and handles error conditions in the same way. Since LLVM; assumes the :ref:`default floating-point environment <floatenv>`, the rounding; mode is assumed to be set to ""nearest"", so halfway cases are rounded to the even; integer. Use :ref:`Constrained Floating-Point Intrinsics <constrainedfp>` to; avoid that assumption. .. _int_round:. '``llvm.round.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.round`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.round.f32(float %Val); declare double @llvm.round.f64(double %Val); declare x86_fp80 @llvm.round.f80(x86_fp80 %Val); declare fp128 @llvm.round.f128(fp128 %Val); declare ppc_fp128 @llvm.round.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.round.*``' intrinsics returns the operand rounded to the; nearest integer. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same; type. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``round``; functions would, and handles error conditions in the same way. .. _int_roundeven:. '``llvm.roundeven.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:583769,avoid,avoid,583769,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"default, ``mir-debugify`` inserts ``DBG_VALUE`` instructions **everywhere**; it is legal to do so. In particular, every (non-PHI) machine instruction that; defines a register must be followed by a ``DBG_VALUE`` use of that def. If; an instruction does not define a register, but can be followed by a debug inst,; MIRDebugify inserts a ``DBG_VALUE`` that references a constant. Insertion of; ``DBG_VALUE``'s can be disabled by setting ``-debugify-level=locations``. To run MIRDebugify once, simply insert ``mir-debugify`` into your ``llc``; invocation, like:. .. code-block:: bash. # Before some other pass.; $ llc -run-pass=mir-debugify,other-pass ... # After some other pass.; $ llc -run-pass=other-pass,mir-debugify ... To run MIRDebugify before each pass in a pipeline, use; ``-debugify-and-strip-all-safe``. This can be combined with ``-start-before``; and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-and-strip-all-safe -O1 <other llc args>. If you want to check it after each pass in a pipeline, use; ``-debugify-check-and-strip-all-safe``. This can also be combined with; ``-start-before`` and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-check-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-check-and-strip-all-safe -O1 <other llc args>. To check all debug info from a test, use ``mir-check-debugify``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-check-debugify. To strip out all debug info from a test, use ``mir-strip-debug``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-strip-debug. It can be useful to combine ``mir-debugify``, ``mir-check-debugify`` and/or; ``mir-strip-debug`` to identify backend transformations which break in; the presence of debug info. For example, to run the AArch64 backend tests; with all normal passes ""sandwiched"" in between MIRDebugify and; MIRStripDebugify mutatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:18247,safe,safe,18247,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['safe'],['safe']
Safety,"den): | | dso.so (clang++ -fvisibility=hidden): |; | | | |; | +-----------------------------------------------------+ | | struct __attribute__((visibility(""default""))) C { |; | | LTO unit (clang++ -fvisibility=hidden -flto): | | | virtual void f(); |; | | | | | } |; | | struct A { ... }; | | | void C::f() {} |; | | struct [[clang::lto_visibility_public]] B { ... }; | | | struct D { |; | | struct __attribute__((visibility(""default""))) C { | | | virtual void g() = 0; |; | | virtual void f(); | | | }; |; | | }; | | | struct E : D { |; | | struct [[clang::lto_visibility_public]] D { | | | virtual void g() { ... } |; | | virtual void g() = 0; | | | }; |; | | }; | | | __attribute__((visibility(""default""))) D *mkE() { |; | | | | | return new E; |; | +-----------------------------------------------------+ | | } |; | | | |; | struct B { ... }; | +----------------------------------------------------+; | |; +-----------------------------------------------------------+. We will now describe the LTO visibility of each of the classes defined in; these linkage units. Class ``A`` is not defined outside of ``main``'s LTO unit, so it can have; hidden LTO visibility. This is inferred from the object file visibility; specified on the command line. Class ``B`` is defined in ``main``, both inside and outside its LTO unit. The; definition outside the LTO unit has public LTO visibility, so the definition; inside the LTO unit must also have public LTO visibility in order to avoid; an ODR violation. Class ``C`` is defined in both ``main`` and ``dso.so`` and therefore must; have public LTO visibility. This is correctly inferred from the ``visibility``; attribute. Class ``D`` is an abstract base class with a derived class ``E`` defined; in ``dso.so``. This is an example of the COM scenario; the definition of; ``D`` in ``main``'s LTO unit must have public LTO visibility in order to be; compatible with the definition of ``D`` in ``dso.so``, which is observable; by calling the function ``mkE``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:6194,avoid,avoid,6194,interpreter/llvm-project/clang/docs/LTOVisibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst,1,['avoid'],['avoid']
Safety,"description :ref:`here<amdgpu_synid_neg>`. .. _amdgpu_synid_wait_exp:. wait_exp; ~~~~~~~~. Specifies a wait on the EXP counter before issuing the current instruction.; The counter must be less than or equal to this value before the instruction is issued.; If set to 7, no wait is performed. The default value is zero. This is a safe value, but it may be suboptimal. ================ ======================================================; Syntax Description; ================ ======================================================; wait_exp:{0..7} An additional wait on the EXP counter before; issuing this instruction.; ================ ======================================================. .. _amdgpu_synid_wait_vdst:. wait_vdst; ~~~~~~~~~. Specifies a wait on the VA_VDST counter before issuing the current instruction.; The counter must be less than or equal to this value before the instruction is issued.; If set to 15, no wait is performed. The default value is zero. This is a safe value, but it may be suboptimal. ================== ======================================================; Syntax Description; ================== ======================================================; wait_vdst:{0..15} An additional wait on the VA_VDST counter before; issuing this instruction.; ================== ======================================================. DPP8 Modifiers; --------------. .. _amdgpu_synid_dpp8_sel:. dpp8_sel; ~~~~~~~~. Selects which lanes to pull data from, within a group of 8 lanes. This is a mandatory modifier.; There is no default value. The *dpp8_sel* modifier must specify exactly 8 values.; The first value selects which lane to read from to supply data into lane 0.; The second value controls lane 1 and so on. Each value may be specified as either; an :ref:`integer number<amdgpu_synid_integer_number>` or; an :ref:`absolute expression<amdgpu_synid_absolute_expression>`. =============================================================== ===========================;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:36682,safe,safe,36682,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['safe'],['safe']
Safety,"dingStandards>`. To enforce this language version, we check the most; popular host toolchains for specific minimum versions in our build systems:. * Clang 5.0; * Apple Clang 10.0; * GCC 7.4; * Visual Studio 2019 16.7. Anything older than these toolchains *may* work, but will require forcing the; build system with a special option and is not really a supported host platform.; Also note that older versions of these compilers have often crashed or; miscompiled LLVM. For less widely used host toolchains such as ICC or xlC, be aware that a very; recent version may be required to support all of the C++ features used in LLVM. We track certain versions of software that are *known* to fail when used as; part of the host toolchain. These even include linkers at times. **GNU ld 2.16.X**. Some 2.16.X versions of the ld linker will produce very long; warning messages complaining that some ""``.gnu.linkonce.t.*``"" symbol was; defined in a discarded section. You can safely ignore these messages as they are; erroneous and the linkage is correct. These messages disappear using ld 2.17. **GNU binutils 2.17**: Binutils 2.17 contains `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=3111>`__ which causes huge link; times (minutes instead of seconds) when building LLVM. We recommend upgrading; to a newer version (2.17.50.0.4 or later). **GNU Binutils 2.19.1 Gold**: This version of Gold contained `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=9836>`__ which causes; intermittent failures when building LLVM with position independent code. The; symptom is an error about cyclic dependencies. We recommend upgrading to a; newer version of Gold. Getting a Modern Host C++ Toolchain; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This section mostly applies to Linux and older BSDs. On macOS, you should; have a sufficiently modern Xcode, or you will likely need to upgrade until you; do. Windows does not have a ""system compiler"", so you must install either Visual; Studio 2019 (or later), or a r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:14157,safe,safely,14157,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['safe'],['safely']
Safety,"displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more informationIn; TProofOutputFile, support the ""<user>"" and ""<group>""; placeholders in the output file name to automatically re-direct the; output to an area specific to the logged user.; Addition of a new class TProofProgressStatus, which is used to keep; the query progress stauts in all the TProofPlayer objects and in the; TPacketizerAdaptive. It is also send in kPROOF_GETPACKET and; kPROOF_STOPPROCESS messages. ; The class TPacketizerProgressive is removed. . Fixes. Enable; the max number of sessions ('mxsess' parameter in the xpd.schedparam; directive); users are just refused to start a session if this limit is; reached.Make sure to collect consistently input messages when running in asynchronous modeFix; a few problems with TProof::SendFile (used by UploadPackage, Load); appearing when a rapid sequence of these commands was submitted Invalidate the TProofMgr when the physical connection is; closed; avoids; crashing when trying to get the logs after a failure. ; Fix a memory leak in log retrieval (the TProofLog object; was never; deleted); Add protections for the cases the manager cannot be; initialized; Fix a race condition possibly affecting the handling of; workers death; Avoid duplicating worker logs in the master log file; unless; when explicitly needed by the request (Exec(...), Print(...)) or when; an error occuredFix; problem with the determination and transmission of the name of the; object to be processed. The problem appeared when processing files; containing >1 trees in changing order.Fix problem with TProof::Load loading the macro to one worker only per machineFix wrong return code preventing the correct propagation of the full ClearPackage to workersFix a problem causing the whole query to stop even in the case a worker was terminated gently with SIGTERM.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:6382,avoid,avoids,6382,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['avoid'],['avoids']
Safety,"dition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``. .. code-block:: c. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:28584,avoid,avoid,28584,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['avoid'],['avoid']
Safety,"dition to potential cache misses, this can't help decoding as I; imagine there has to be some kind of complicated decoder reset and realignment; to grab the bytes from the next cacheline. 532 532 0x3cfc movb (1809(%esp, %esi), %bl <<<--- spans 2 64 byte lines; 942 942 0x3d03 movl %dh, (1809(%esp, %esi); 937 937 0x3d0a incl %esi; 3 3 0x3d0b cmpb %bl, %dl; 27 27 0x3d0d jnz 0x000062db <main+11707>. //===---------------------------------------------------------------------===//. In c99 mode, the preprocessor doesn't like assembly comments like #TRUNCATE. //===---------------------------------------------------------------------===//. This could be a single 16-bit load. int f(char *p) {; if ((p[0] == 1) & (p[1] == 2)) return 1;; return 0;; }. //===---------------------------------------------------------------------===//. We should inline lrintf and probably other libc functions. //===---------------------------------------------------------------------===//. This code:. void test(int X) {; if (X) abort();; }. is currently compiled to:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne LBB1_1; addl $12, %esp; ret; LBB1_1:; call L_abort$stub. It would be better to produce:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne L_abort$stub; addl $12, %esp; ret. This can be applied to any no-return function call that takes no arguments etc.; Alternatively, the stack save/restore logic could be shrink-wrapped, producing; something like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; subl $12, %esp; call L_abort$stub. Both are useful in different situations. Finally, it could be shrink-wrapped; and tail called, like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; pop %eax # realign stack.; call L_abort$stub. Though this probably isn't worth it. //===---------------------------------------------------------------------===//. Sometimes it is better to codegen subtractions from a constant (e.g. 7-x) with; a neg instead of a sub instruction. Consider:. int test(char ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:11775,abort,abort,11775,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['abort'],['abort']
Safety,"dividual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2714,unsafe,unsafe,2714,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,"['safe', 'unsafe']","['safe-stack', 'unsafe']"
Safety,"do our conclusions about functions; themselves. What could the difference be? For example, on a machine with 64-bit pointers; (let's assume we have only one address space), one function stores a 64-bit; integer, while another one stores a pointer. If the target is the machine; mentioned above, and if functions are identical, except the parameter type (we; could consider it as a part of function type), then we can treat a ``uint64_t``; and a ``void*`` as equal. This is just an example; more possible details are described a bit below. As another example, the reader may imagine two more functions. The first; function performs a multiplication by 2, while the second one performs an; logical left shift by 1. Possible solutions; ^^^^^^^^^^^^^^^^^^; Let's briefly consider possible options about how and what we have to implement; in order to create full-featured functions merging, and also what it would; mean for us. Equal function detection obviously supposes that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:4681,detect,detection,4681,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,2,['detect'],"['detection', 'detector']"
Safety,"dom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable; ValidationFraction; ; Cuts: Corrected inconsistency in MethodCuts:; the signal efficiency written out into the weight file does; not correspond to the center of the bin within which the; background rejection is maximised (as before) but to the; lower left edge of it. This is because the cut optimisation; algorithm determines the best background rejection for all; signal efficiencies belonging into a bin. Since the best; background rejection is in general obtained for the lowest; possible signal efficiency, the reference signal efficiency; is the lowest value in the bin.; ; Cuts: Fixed Cuts (optimisaton) method -> event; with smallest value was not included in search for optimal; cut (thanks to Dimitris Varouchas, LAL-Orsay, for helping; us detecting the problem).; ; Genetic Algorithm: Corrected configurable random; seed in GeneticAlgorithm (thanks to David Gonzalez Maline,; CERN, for pointing this out); ; GUI: Fixes in input-variable and MVA plotting:; under/over-flow numbers given on plots were not properly; normalised; the maximum histogram ranges have been; increased to avoid cut-offs. Thanks to Andreas Wenger,; Zuerich, for pointing these out.; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:5499,detect,detecting,5499,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,2,"['avoid', 'detect']","['avoid', 'detecting']"
Safety,"doper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. There are a few other dbg.value configurations that mean it terminates; dominating location definitions without adding a new location. The complete; list is:. * Any location operand is ``poison`` (or ``undef``).; * Any location operand is an empty metadata tuple (``!{}``) (which cannot; occur in a ``!DIArgList``).; * There are no location operands (empty ``DIArgList``) and the ``DIExpression``; is empty. This class of dbg.value that kills variable locations is called a ""kill; dbg.value"" or ""kill location"", and for legacy reasons the term ""undef; dbg.value"" may be used in existing code. The ``DbgVariableIntrinsic`` methods; ``isKillLocation`` and ``setKillLocation`` should be used where possible rather; than inspecting location operands directly to check or set whether a dbg.value; is a kill location. In general, if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:23634,recover,recovered,23634,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['recover'],['recovered']
Safety,"ds, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C'`; and `C""`, having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation comes from the fact that any container is directly used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D,E,` and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class **`TGeoVolumeAssembly`**, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ‘unnecessary' volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:71506,avoid,avoid,71506,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['avoid'],['avoid']
Safety,"ds-safety`` does not enforce overall type safety and bounds invariants; can still be violated by incorrect casts in some cases. That said,; ``-fbounds-safety`` prevents type conversions that change bounds attributes in a; way to violate the bounds invariant of the destination's pointer annotation.; Type conversions that change bounds attributes may be allowed if it does not; violate the invariant of the destination or that can be verified at run time.; Here are some of the important cast rules. Two pointers that have different bounds annotations on their nested pointer; types are incompatible and cannot implicitly cast to each other. For example,; ``T *__single *__single`` cannot be converted to ``T *__bidi_indexable; *__single``. Such a conversion between incompatible nested bounds annotations; can be allowed using an explicit cast (e.g., C-style cast). Hereafter, the rules; only apply to the top pointer types. ``__unsafe_indexable`` cannot be converted; to any other safe pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, etc) using a cast. The extension provides builtins to force; this conversion, ``__unsafe_forge_bidi_indexable(type, pointer, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""uns",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:39914,safe,safe,39914,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safe']
Safety,"ds..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery at",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15097,recover,recovery,15097,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,"['recover', 'redund']","['recovery', 'redundant']"
Safety,"dy decoded instructions, and dispatched in groups to the; simulated hardware schedulers. The size of a dispatch group depends on the availability of the simulated; hardware resources. The processor dispatch width defaults to the value; of the ``IssueWidth`` in LLVM's scheduling model. An instruction can be dispatched if:. * The size of the dispatch group is smaller than processor's dispatch width.; * There are enough entries in the reorder buffer.; * There are enough physical registers to do register renaming.; * The schedulers are not full. Scheduling models can optionally specify which register files are available on; the processor. :program:`llvm-mca` uses that information to initialize register; file descriptors. Users can limit the number of physical registers that are; globally available for register renaming by using the command option; ``-register-file-size``. A value of zero for this option means *unbounded*. By; knowing how many registers are available for renaming, the tool can predict; dispatch stalls caused by the lack of physical registers. The number of reorder buffer entries consumed by an instruction depends on the; number of micro-opcodes specified for that instruction by the target scheduling; model. The reorder buffer is responsible for tracking the progress of; instructions that are ""in-flight"", and retiring them in program order. The; number of entries in the reorder buffer defaults to the value specified by field; `MicroOpBufferSize` in the target scheduling model. Instructions that are dispatched to the schedulers consume scheduler buffer; entries. :program:`llvm-mca` queries the scheduling model to determine the set; of buffered resources consumed by an instruction. Buffered resources are; treated like scheduler resources. Instruction Issue; """"""""""""""""""""""""""""""""""; Each processor scheduler implements a buffer of instructions. An instruction; has to wait in the scheduler's buffer until input register operands become; available. Only at that point, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:36015,predict,predict,36015,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['predict'],['predict']
Safety,"e (by avoid the fast merge technique). The equivalent in TFileMerger is to call; merger->SetFastMethod(kFALSE); To make sure that the class emulation layer of ROOT does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. The handling of memory by the collection proxy has been improved in the case of a; collection of pointers which can now become owner of its content. The default, for backward compatibility reasons and to avoid double delete (at the expense; of memory leaks), the container of pointers are still not owning their content; unless they are a free standing container (i.e. itself not contained in another; object).; To make a container of pointers become owner of its content do something like:. TClass::AddRule(""ObjectVector<LHCb::MCRichDigitSummary> m_vector options=Owner"");. Added TKey::Reset and TKey::WriteFileKeepBuffer to allow derived classes (TBasket) to be re-use as key rather than always recreated.; TH1::Streamer and TGraph2D::Streamer no longer reset the kCanDelete bit directly so that the user can give; ownership of the object to the canvas they are stored with. However, if they are saved on their own, the mechanism; that associates them to the current directory (DirectoryAutoAdd) will now reset the bit to avoid any possible; ownsership confusion.; Added TFile::SetOffset and TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); to drastically reduce; the number of fseek done on the physical file when using the TTreeCache.; To support future changes in the API of the CollectionProxy, we added the new #define:; ROOT_COLLECTIONPROXY_VERSION and REFLEX_COLLECTIONPROXY_VERSION. Reduce possible confusions and conflicts by always using in TClass and TStreamerInfo the version of template instance names with ULong64_t and Long64_t rather than [unsigned] long long.; new Hadoop TFile plugin. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:12364,avoid,avoid,12364,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['avoid'],['avoid']
Safety,"e MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for each condition in a boolean expression. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). O",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:534047,detect,detect,534047,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detect']
Safety,"e as now; have a real SP for the top of the stack.; - How is ``sret`` passed on the stack? In argument stack area? Can it overlay; arguments?. AMDPAL; ------. This section provides code conventions used when the target triple OS is; ``amdpal`` (see :ref:`amdgpu-target-triples`). .. _amdgpu-amdpal-code-object-metadata-section:. Code Object Metadata; ~~~~~~~~~~~~~~~~~~~~. .. note::. The metadata is currently in development and is subject to major; changes. Only the current version is supported. *When this document; was generated the version was 2.6.*. Code object metadata is specified by the ``NT_AMDGPU_METADATA`` note; record (see :ref:`amdgpu-note-records-v3-onwards`). The metadata is represented as Message Pack formatted binary data (see; [MsgPack]_). The top level is a Message Pack map that includes the keys; defined in table :ref:`amdgpu-amdpal-code-object-metadata-map-table`; and referenced tables. Additional information can be added to the maps. To avoid conflicts, any; key names should be prefixed by ""*vendor-name*."" where ``vendor-name``; can be the name of the vendor and specific vendor tool that generates the; information. The prefix is abbreviated to simply ""."" when it appears; within a map that has been added by the same *vendor-name*. .. table:: AMDPAL Code Object Metadata Map; :name: amdgpu-amdpal-code-object-metadata-map-table. =================== ============== ========= ======================================================================; String Key Value Type Required? Description; =================== ============== ========= ======================================================================; ""amdpal.version"" sequence of Required PAL code object metadata (major, minor) version. The current values; 2 integers are defined by *Util::Abi::PipelineMetadata(Major|Minor)Version*.; ""amdpal.pipelines"" sequence of Required Per-pipeline metadata. See; map :ref:`amdgpu-amdpal-code-object-pipeline-metadata-map-table` for the; definition of the keys included",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:401964,avoid,avoid,401964,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"e attributes of the; original outer loop without the ``llvm.loop.unroll.*`` attributes are; copied and ``llvm.loop.unroll.disable`` added to it. ``llvm.loop.unroll_and_jam.followup_inner`` will set the loop attributes; of the unrolled inner loop. If not specified, the attributes of the; original inner loop are used unchanged. ``llvm.loop.unroll_and_jam.followup_remainder_outer`` sets the loop; attributes of the outer remainder loop. If not specified it will not; have any attributes. The remainder loop might not be present due to; being fully unrolled. ``llvm.loop.unroll_and_jam.followup_remainder_inner`` sets the loop; attributes of the inner remainder loop. If not specified it will have; the attributes of the original inner loop. It the outer remainder loop; is unrolled, the inner remainder loop might be present multiple times. Attributes defined in ``llvm.loop.unroll_and_jam.followup_all`` are; added to all of the aforementioned output loops. To avoid that the unrolled loop is unrolled again, it is; recommended to add ``llvm.loop.unroll.disable`` to; ``llvm.loop.unroll_and_jam.followup_all``. It suppresses unroll-and-jam; as well as an additional inner loop unrolling. If no follow-up; attribute specified for a generated loop, it is added automatically. Loop Distribution; -----------------. The LoopDistribution pass tries to separate vectorizable parts of a loop; from the non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 +",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:10552,avoid,avoid,10552,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoid']
Safety,"e branch in your fork. That will automatically update; the pull request. When updating a pull request, you should push additional ""fix up"" commits to; your branch instead of force pushing. This makes it easier for GitHub to; track the context of previous review comments. Consider using the; `built-in support for fixups <https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupamendrewordltcommitgt>`_; in git. If you do this, you must squash and merge before landing the PR and; you must use the pull request title and description as the commit message.; You can do this manually with an interactive git rebase or with GitHub's; built-in tool. See the section about landing your fix below. When pushing to your branch, make sure you push to the correct fork. Check your; remotes with:. ::. git remote -v. And make sure you push to the remote that's pointing to your fork. Rebasing Pull Requests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When your PR has been accepted you can use the web interface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:4303,avoid,avoid,4303,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['avoid'],['avoid']
Safety,"e compiler) dependencies and; tries to generate the relevant vfs file. ## State of the union. Preloading all modules at start up time turn our motivating example into:. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition. ```. becomes equivalent to. ```cpp; // ROOT prompt; root [] import ROOT.*;; root [] import Foo.*;; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. The implementation avoids recursive actions and relies on a well-defined (by; the C++ standard) behavior. Currently, this comes with a constant performance; overhead which we go in details bellow. ROOT uses the global module index (GMI) to avoid the performance overhead. ROOT; only preloads the set of C++ modules which are not present in the GMI. The; example becomes equivalent to:. ```cpp; // ROOT prompt; root [] import Foo.*; // Preload Foo if it is not in the GMI.; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. Line #4 forces cling to send ROOT a callback that TCanvas in unknown but; the GMI resolves it to module Gpad, loads it and returns the control to cling. ### Performance; This section compares ROOT PCH technology with C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended to the experiments’ software stacks because of its design constraints.; On the contrary, the C++ Modules can be used in third-party code where the PCH; is not available. The comparis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:16666,avoid,avoid,16666,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,"e corresponds; to the level 0 in the stored array, while the last node will correspond; to level `n`. For each level, the node, volume and global matrix can be; retrieved using corresponding getters:. ~~~{.cpp}; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; ~~~. By default the object at level n is retrieved (the align-able object). Once created, a physical node can be misaligned, meaning that its; positioning matrix or even the shape.:. ~~~{.cpp}; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); ~~~. The convention used is that newmat represents the new local matrix of; the last node in the branch with respect to its mother volume. The; `Align()` method will actually duplicate the corresponding branch within; the logical hierarchy, creating new volumes and nodes. This is mandatory; in order to avoid problems due to replicated volumes and can create; exhaustive memory consumption if used abusively. Once aligned, a physical node is ready to be tracked. The operation can; be done only after the geometry was closed. Important NOTE: Calling the `Align()` method for a physical node changes; the node pointers for the stored node branch in the active geometry, Due; to this the other defined physical nodes containing elements of this; path will be invalid. Example:. ~~~{.cpp}; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; ~~~. The call to `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nodes:. ~~~{.cpp}; void RefreshPhysicalNodes(Bool_t lock = kTRUE); ~~~. The method above will optionally lock the possibility of doing any; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:109531,avoid,avoid,109531,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"e enough in LLVM that it should always be; passed by value. The ``Twine`` class; ^^^^^^^^^^^^^^^^^^^. The ``Twine`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Twine.html>`__); class is an efficient way for APIs to accept concatenated strings. For example,; a common LLVM paradigm is to name one instruction based on the name of another; instruction with a suffix, for example:. .. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:10612,avoid,avoids,10612,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoids']
Safety,"e environment. # Example usage:; # cmake -G Ninja -DLLVM_CREATE_XCODE_TOOLCHAIN=On; # -DCMAKE_INSTALL_PREFIX=$PWD/install; # ninja install-xcode-toolchain; # export EXTERNAL_TOOLCHAINS_DIR=$PWD/install/Toolchains; # export TOOLCHAINS=org.llvm.3.8.0svn. # `xcrun -find clang` should return the installed clang, and `clang --version`; # should show 3.8.0svn. if(NOT APPLE); return(); endif(). option(LLVM_CREATE_XCODE_TOOLCHAIN ""Create a target to install LLVM into an Xcode toolchain"" Off). if(NOT LLVM_CREATE_XCODE_TOOLCHAIN); return(); endif(). # XCODE_VERSION is set by CMake when using the Xcode generator, otherwise we need; # to detect it manually here.; if(NOT XCODE_VERSION); execute_process(; COMMAND xcodebuild -version; OUTPUT_VARIABLE xcodebuild_version; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""Xcode ([0-9][0-9]?([.][0-9])+)"" version_match ${xcodebuild_version}); if(version_match); message(STATUS ""Identified Xcode Version: ${CMAKE_MATCH_1}""); set(XCODE_VERSION ${CMAKE_MATCH_1}); else(); # If detecting Xcode version failed, set a crazy high version so we default; # to the newest.; set(XCODE_VERSION 99); message(WARNING ""Failed to detect the version of an installed copy of Xcode, falling back to highest supported version. Set XCODE_VERSION to override.""); endif(); endif(). # Xcode 8 requires CompatibilityVersion 2; set(COMPAT_VERSION 2); if(XCODE_VERSION VERSION_LESS 8.0.0); # Xcode 7.3 (the first version supporting external toolchains) requires; # CompatibilityVersion 1; set(COMPAT_VERSION 1); endif(). execute_process(; COMMAND xcrun -find otool; OUTPUT_VARIABLE clang_path; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""(.*/Toolchains)/.*"" toolchains_match ${clang_path}); if(NOT toolchains_match); message(FATAL_ERROR ""Could not identify toolchain dir""); endif(); set(toolchains_dir ${CMAKE_MATCH_1}). set(LLVMToolchainDir ""${CMAKE_INSTALL_PREFIX}/Toolchains/LLVM${PACKAGE_VERSION}.xctoolchain/""). add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:2322,detect,detecting,2322,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['detect'],['detecting']
Safety,"e file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15928,abort,aborted,15928,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['abort'],['aborted']
Safety,"e frequent than writes. .. _plugin:. .. _builtin-gc-strategies:. Built In GC Strategies; ======================. LLVM includes built in support for several varieties of garbage collectors. The Shadow Stack GC; ----------------------. To use this collector strategy, mark your functions with:. .. code-block:: c++. F.setGC(""shadow-stack"");. Unlike many GC algorithms which rely on a cooperative code generator to compile; stack maps, this algorithm carefully maintains a linked list of stack roots; [:ref:`Henderson2002 <henderson02>`]. This so-called ""shadow stack"" mirrors the; machine stack. Maintaining this data structure is slower than using a stack map; compiled into the executable as constant data, but has a significant portability; advantage because it requires no special support from the target code generator,; and does not require tricky platform-specific code to crawl the machine stack. The tradeoff for this simplicity and portability is:. * High overhead per function call. * Not thread-safe. Still, it's an easy way to get started. After your compiler and runtime are up; and running, writing a :ref:`plugin <plugin>` will allow you to take advantage; of :ref:`more advanced GC features <collector-algos>` of LLVM in order to; improve performance. The shadow stack doesn't imply a memory allocation algorithm. A semispace; collector or building atop ``malloc`` are great places to start, and can be; implemented with very little code. When it comes time to collect, however, your runtime needs to traverse the stack; roots, and for this it needs to integrate with the shadow stack. Luckily, doing; so is very simple. (This code is heavily commented to help you understand the; data structure, but there are only 20 lines of meaningful code.). .. code-block:: c++. /// The map for a single function's stack frame. One of these is; /// compiled as constant data into the executable for each function.; ///; /// Storage of metadata values is elided if the %metadata parameter to; /// @",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:16788,safe,safe,16788,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"e if we know it's ok to clobber the condition register. add r2, sp, #255 * 4; add r2, #132; ldr r2, [r2, #7 * 4]. This is especially bad when dynamic alloca is used. The all fixed size stack; objects are referenced off the frame pointer with negative offsets. See; oggenc for an example. //===---------------------------------------------------------------------===//. Poor codegen test/CodeGen/ARM/select.ll f7:. 	ldr r5, LCPI1_0; LPC0:; 	add r5, pc; 	ldr r6, LCPI1_1; 	ldr r2, LCPI1_2; 	mov r3, r6; 	mov lr, pc; 	bx r5. //===---------------------------------------------------------------------===//. Make register allocator / spiller smarter so we can re-materialize ""mov r, imm"",; etc. Almost all Thumb instructions clobber condition code. //===---------------------------------------------------------------------===//. Thumb load / store address mode offsets are scaled. The values kept in the; instruction operands are pre-scale values. This probably ought to be changed; to avoid extra work when we convert Thumb2 instructions to Thumb1 instructions. //===---------------------------------------------------------------------===//. We need to make (some of the) Thumb1 instructions predicable. That will allow; shrinking of predicated Thumb2 instructions. To allow this, we need to be able; to toggle the 's' bit since they do not set CPSR when they are inside IT blocks. //===---------------------------------------------------------------------===//. Make use of hi register variants of cmp: tCMPhir / tCMPZhir. //===---------------------------------------------------------------------===//. Thumb1 immediate field sometimes keep pre-scaled values. See; ThumbRegisterInfo::eliminateFrameIndex. This is inconsistent from ARM and; Thumb2. //===---------------------------------------------------------------------===//. Rather than having tBR_JTr print a "".align 2"" and constant island pass pad it,; add a target specific ALIGN instruction instead. That way, getInstSizeInBytes; won't have to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt:5354,avoid,avoid,5354,interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README-Thumb.txt,1,['avoid'],['avoid']
Safety,"e interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5821,avoid,avoid,5821,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['avoid'],['avoid']
Safety,"e methods to arrange for it to be run before your pass.; LLVM has many different types of analyses and passes that can be required,; spanning the range from ``DominatorSet`` to ``BreakCriticalEdges``. Requiring; ``BreakCriticalEdges``, for example, guarantees that there will be no critical; edges in the CFG when your pass has been run. Some analyses chain to other analyses to do their job. For example, an; `AliasAnalysis <AliasAnalysis>` implementation is required to :ref:`chain; <aliasanalysis-chaining>` to other alias analysis passes. In cases where; analyses chain, the ``addRequiredTransitive`` method should be used instead of; the ``addRequired`` method. This informs the ``PassManager`` that the; transitively required pass should be alive as long as the requiring pass is. The ``AnalysisUsage::addPreserved<>`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. One of the jobs of the ``PassManager`` is to optimize how and when analyses are; run. In particular, it attempts to avoid recomputing data unless it needs to.; For this reason, passes are allowed to declare that they preserve (i.e., they; don't invalidate) an existing analysis if it's available. For example, a; simple constant folding pass would not modify the CFG, so it can't possibly; affect the results of dominator analysis. By default, all passes are assumed; to invalidate all others. The ``AnalysisUsage`` class provides several methods which are useful in; certain circumstances that are related to ``addPreserved``. In particular, the; ``setPreservesAll`` method can be called to indicate that the pass does not; modify the LLVM program at all (which is true for analyses), and the; ``setPreservesCFG`` method can be used by transformations that change; instructions in the program but do not modify the CFG or terminator; instructions. ``addPreserved`` is particularly useful for transformations like; ``BreakCriticalEdges``. This pass knows how to update a small set of loop and; dominator related analyses i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:31336,avoid,avoid,31336,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['avoid'],['avoid']
Safety,"e not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects. This array is flawed because it is static; and hard-coded, it should be dynamic. However, the important point is; that the template statement indicates that T is a template, or; parameterized class. If we need an `ArrayContainer` for Track objects,; it can be created by:. ``` {.cpp}; ArrayContainer<Track> MyTrackArrayContainer;; ```. C++ takes the parameter list and substitutes Track for T throughout the; definition of the class `ArrayContainer`, then compiles the code so; generated, effectively doing the same we could do by hand, but with a; lot less effort. This produces code that is type safe, but does have different drawbacks:. - Templates make code harder to read. - At the time of writing this documentation, some compilers can be; very slow when dealing with templates. - It does not solve the problem when a container has to hold a; heterogeneous set of objects. - The system can end up generating a great deal of code; each; container/object combination has its own code, a phenomenon that is; sometimes referred to as *code bloat*. - The Standard Template Library (STL) is part on ANSI C++, and; includes a set of template containers. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:19476,safe,safe,19476,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['safe'],['safe']
Safety,"e of major LHC detectors:; * ALICE: [full](https://root.cern/js/latest/?file=https://root.cern/files/alice2.root&item=Geometry;1&opt=macro:https://root.cern/js/files/geomAlice.C); * ATLAS: [full](https://root.cern/js/latest/?file=https://root.cern/files/atlas.root&item=atlas;1&opt=clipxyz), [cryo](https://root.cern/js/latest/?file=https://root.cern/files/atlas.root&item=atlas;1&opt=macro:https://root.cern/files/atlas_cryo.C), [sctt](https://root.cern/js/latest/?file=https://root.cern/files/atlas.root&item=atlas;1&opt=macro:https://root.cern/files/atlas_sctt.C); * CMS: [cmse](https://root.cern/js/latest/?file=https://root.cern/files/cms.root&item=cms;1&opt=macro:https://root.cern/files/cms_cmse.C;clipxyz), [calo](https://root.cern/js/latest/?file=https://root.cern/files/cms.root&item=cms;1&opt=macro:https://root.cern/files/cms_calo.C;clipxyz); * LHCb: [full](https://root.cern/js/latest/?file=https://root.cern/files/lhcbfull.root&item=Geometry;1&opt=all;dflt). Other detectors examples:; * HADES: [full](https://root.cern/js/latest/?file=https://root.cern/files/hades2.root&item=CBMGeom;1&opt=all;dflt), [preselected](https://root.cern/js/latest/?json=../files/geom/hades.json.gz); * BABAR: [full](https://root.cern/js/latest/?file=https://root.cern/files/babar.root&item=babar;1&opt=macro:https://root.cern/files/babar_all.C), [emca](https://root.cern/js/latest/?file=https://root.cern/files/babar.root&item=babar;1&opt=macro:https://root.cern/files/babar_emca.C); * STAR: [full](https://root.cern/js/latest/?file=https://root.cern/files/star.root&item=star;1&opt=macro:https://root.cern/files/star_all.C;clipxyz), [svtt](https://root.cern/js/latest/?file=https://root.cern/files/star.root&item=star;1&opt=macro:https://root.cern/files/star_svtt.C); * D0: [full](https://root.cern/js/latest/?file=https://root.cern/files/d0.root&item=d0;1&opt=clipxyz); * NA47: [full](https://root.cern/js/latest/?file=https://root.cern/files/na47.root&item=na47;1&opt=dflt); * BRAHMS: [full](https://root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:24912,detect,detectors,24912,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['detect'],['detectors']
Safety,"e of the clang tree. One; possible mitigation strategy is to manually diff clang between ``U2``; and ``U3`` and apply those updates to ``local/zip``. Another,; possibly simpler strategy is to freeze local work on downstream; branches and merge all submodules from the latest upstream before; running ``zip-downstream-fork.py``. If downstream merged each project; from upstream in lockstep without any intervening local commits, then; things should be fine without any special action. We anticipate this; to be the common case. The tree for ``Lclang1`` outside of clang will represent the state of; things at ``U3`` since all of the upstream projects not participating; in the umbrella history should be in a state respecting the commit; ``U3``. The trees for llvm and lld should correctly represent commits; ``Lllvm1`` and ``Llld1``, respectively. Commit ``UM3`` changed files not related to submodules and we need; somewhere to put them. It is not safe in general to put them in the; monorepo root directory because they may conflict with files in the; monorepo. Let's assume we want them in a directory ``local`` in the; monorepo. **Example 1: Umbrella looks like the monorepo**. For this example, we'll assume that each subproject appears in its own; top-level directory in the umbrella, just as they do in the monorepo .; Let's also assume that we want the files in directory ``myproj`` to; appear in ``local/myproj``. Given the above run of ``migrate-downstream-fork.py``, a recipe to; create the zipped history is below::. # Import any non-LLVM repositories the umbrella references.; git -C my-monorepo remote add localrepo \; https://my.local.mirror.org/localrepo.git; git fetch localrepo. subprojects=( clang clang-tools-extra compiler-rt debuginfo-tests libclc; libcxx libcxxabi libunwind lld lldb llgo llvm openmp; parallel-libs polly pstl ). # Import histories for upstream split projects (this was probably; # already done for the ``migrate-downstream-fork.py`` run).; for project in ${sub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:27247,safe,safe,27247,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['safe'],['safe']
Safety,"e optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:162639,safe,safe,162639,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['safe'],['safe']
Safety,"e output of `TFile::Map()` are the list of; keys, the list of free segments, and the address where the data ends..; When a file is closed, it writes a linked list of keys at the end of the; file. This is what we see in the third to the last entry. In our; example, the list of keys is stored in 732 bytes beginning at byte\#; 8244. ``` {.cpp}; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; ```. The second to last entry is a list of free segments. In our case, this; starts 8976 and is not very long, only 53 bytes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:14998,recover,recover,14998,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['recover'],['recover']
Safety,"e pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:421509,safe,safely,421509,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"e pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, etc) using a cast. The extension provides builtins to force; this conversion, ``__unsafe_forge_bidi_indexable(type, pointer, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicitly be ``FILE; *__unsafe_indexable`` and thus it cannot be directly assigned to ``FILE *fp``; in the bounds-safe source. To allow this operation, ``__unsafe_forge_single``; is used to create a ``__single`` from the return value of ``fopen``. * Similar to ``__unsafe_indexable``, any non-pointer type (including ``int``,; ``intptr_t``, ``uintptr_t``, etc.) cannot be converted to any safe pointer; type because these don't have bounds information. ``__unsafe_f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:40910,safe,safety,40910,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"e really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still destroyed at the end of the query, but there was no; memory advantage in TH1::Add wrt TH1::Merge.; Make sure that the performance tree is removed from the output; list when saved to the output file. Solves a segv at quit.; Decouple from registered TChains in already TProof::Close(); allows; to avoid possible crash at exit ('.q') occuring after the recent; revision of the socket cleanup policy.; In XrdProofd, fix a few issues with option 'xpd.multiuser'.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:3328,avoid,avoid,3328,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,1,['avoid'],['avoid']
Safety,"e recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You can track memory usage and detect leaks by monitoring the number; of objects that are created and deleted (see **`TObjectTable`**). To; use this facility, edit the file `$ROOTSYS/etc/system.rootrc` or; `.rootrc` if you have this file and add the two following lines:. ```; Root.ObjectStat: 1; ```. In your code or on the command line you can type the line:. ``` {.cpp}; gObjectTable->Print();; ```. This line will print the list of all active classes and the number of; instances for each class. By comparing consecutive print outs, you can; see objects that you forgot to delete. Note that this method cannot; show leaks coming from the allocation of non-objects or classes; unknown to ROOT. ## Converting from PAW to ROOT. The web page at:; <http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE> gives the; ""translation"" table of some commonly used PAW commands into ROOT. If; you move the mouse cursor over the picture at:; <http://root.cern.ch/root/HowtoConvertFromPAW.html#SET>, you will get; the corresponding ROOT commands as tooltips. ### Converting HB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:39494,detect,detect,39494,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['detect'],['detect']
Safety,"e some passes (i.e., TraceValues) insert a lot of; string constants into the program, regardless of whether or not an existing; string is available. .. _passes-dce:. ``dce``: Dead Code Elimination; ------------------------------. Dead code elimination is similar to dead instruction elimination, but it; rechecks instructions that were used by removed instructions to see if they; are newly dead. ``deadargelim``: Dead Argument Elimination; ------------------------------------------. This pass deletes dead arguments from internal functions. Dead argument; elimination removes arguments which are directly dead, as well as arguments; only passed into function calls as dead arguments of other functions. This; pass also deletes dead arguments in a similar way. This pass is often useful as a cleanup pass to run after aggressive; interprocedural passes, which add possibly-dead arguments. ``dse``: Dead Store Elimination; -------------------------------. A trivial dead store elimination that only considers basic-block local; redundant stores. .. _passes-function-attrs:. ``function-attrs``: Deduce function attributes; ----------------------------------------------. A simple interprocedural pass which walks the call-graph, looking for functions; which do not access or only read non-local memory, and marking them; ``readnone``/``readonly``. In addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:15932,redund,redundant,15932,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['redund'],['redundant']
Safety,"e specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ""Run; in background"" has been added; to the dialog box. The behaviour of Ctrl-C has also been modified: the; user is prompted for a choice among continuing asynchronously, stopping; (terminating) or aborting the query.; Add the possibility to define the dataset information; sources via the directive 'xpd.datasetsrc'.; In this way the permissions; should be set correctly and the related problems disappear.; Record the logs from the ROOT version validation tests; (proofserv forked in test mode). In case of failure - or if the debug; flag is on - the log files are kept under; <xproof_adminpath>/rootsysvalidation/root.<tag>.log; (the <tag> has all the '/' replaced by '-'). This should; facilitate understanding the problems when in case of validation; failures.; Add support for automatic; running of PROOF ses",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:2631,avoid,avoid,2631,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['avoid'],['avoid']
Safety,"e the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119063,safe,safe,119063,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"e to be poisoned the; resulting stack pointer will be invalid. ##### Rewrite API of internal functions to directly propagate predicate state. (Not yet implemented.). We have the option with internal functions to directly adjust their API to; accept the predicate as an argument and return it. This is likely to be; marginally cheaper than embedding into `%rsp` for entering functions. ##### Use `lfence` to guard function transitions. An `lfence` instruction can be used to prevent subsequent loads from; speculatively executing until all prior mispredicted predicates have resolved.; We can use this broader barrier to speculative loads executing between; functions. We emit it in the entry block to handle calls, and prior to each; return. This approach also has the advantage of providing the strongest degree; of mitigation when mixed with unmitigated code by halting all misspeculation; entering a function which is mitigated, regardless of what occurred in the; caller. However, such a mixture is inherently more risky. Whether this kind of; mixture is a sufficient mitigation requires careful analysis. Unfortunately, experimental results indicate that the performance overhead of; this approach is very high for certain patterns of code. A classic example is; any form of recursive evaluation engine. The hot, rapid call and return; sequences exhibit dramatic performance loss when mitigated with `lfence`. This; component alone can regress performance by 2x or more, making it an unpleasant; tradeoff even when only used in a mixture of code. ##### Use an internal TLS location to pass predicate state. We can define a special thread-local value to hold the predicate state between; functions. This avoids direct ABI implications by using a side channel between; callers and callees to communicate the predicate state. It also allows implicit; zero-initialization of the state, which allows non-checked code to be the first; code executed. However, this requires a load from TLS in the entry",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:41859,risk,risky,41859,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['risk'],['risky']
Safety,"e tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_attribute``; -------------------. This function-like macro takes a single identifier argument that is the name of; a GNU-style attribute. It evaluates to 1 if the attribute is supported by the; current compilation target, or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_attribute // Optional of course.; #define __has_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_attribute(always_inline); #define ALWAYS_INLINE __attribute__((always_inline)); #else; #define ALWAYS_INLINE; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__always_inline__`` can be used instead of ``always_inline``. ``__has_declspec_attribute``; ----------------------------. This function-like macro takes a single identifier argument that is the name of; an attribute implemented as a Microsoft-style ``__declspec`` attribute. It; evaluates to 1 if the attribute is supported by the current compilation target,; or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_declspec_attribute // Optional of course.; #define __has_declspec_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_declspec_attribute(dllexport); #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__dllexport__`` can be used instead of `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:8151,avoid,avoid,8151,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"e, ``typeof(int*)``; returns ``int *`` without any bounds annotation. A bounds annotation may be; added after the fact depending on the context. In the following example,; ``typeof(int *)`` returns ``int *`` so it's equivalent as the local variable is; declared as ``int *l``, so it eventually becomes implicitly; ``__bidi_indexable``. .. code-block:: c. void foo(void) {; typeof(int *) l; // `int *__bidi_indexable` (same as `int *l`); }. The programmers can still explicitly add a bounds annotation on the types named; inside ``typeof``, e.g., ``typeof(int *__bidi_indexable)``, which evaluates to; ``int *__bidi_indexable``. Default pointer types in ``sizeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``sizeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. This means if a bounds annotation; is not specified, the evaluated pointer type is treated identically to a plain C; pointer type. Therefore, ``sizeof(int*)`` remains the same with or without; ``-fbounds-safety``. That said, programmers can explicitly add attribute to the; types, e.g., ``sizeof(int *__bidi_indexable)``, in which case the sizeof; evaluates to the size of type ``int *__bidi_indexable`` (the value equivalent to; ``3 * sizeof(int*)``). When ``sizeof()`` takes an expression, i.e., ``sizeof(expr``, it behaves as; ``sizeof(typeof(expr))``, except that ``sizeof(expr)`` does not report an error; with ``expr`` that has a type with an external bounds annotation dependent on; another declaration, whereas ``typeof()`` on the same expression would be an; error as described in :ref:`Default pointer types in typeof`.; The following example describes this behavior. .. code-block:: c. void foo(int *__counted_by(size) p, size_t size) {; // sizeof(p) == sizeof(int *__counted_by(size)) == sizeof(int *); // typeof(p): error; };. Default pointer types in ``alignof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``alignof()`` only takes a type name as the argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:28349,safe,safety,28349,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"e-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling; -----------------------------. The `OSDI'14 paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ mentions that; on Linux the instrumentation pass finds calls to setjmp or functions that; may throw an exception, and inserts required instrumentation at their call; sites. Specifically, the instrumentation pass saves the shadow stack pointer; on the safe stack before the call site, and restores it either after the; call to setjmp or after an exception has been caught. This is implemented; in the function ``SafeStack::createStackRestorePoints``. Pub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7874,unsafe,unsafe,7874,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"e. * ``__terminated_by(T)`` : The pointer or array is terminated by ``T`` which is; a constant expression. Accessing or incrementing the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20086,safe,safety,20086,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"e. Mandatory loop canonicalizations such; as loop rotation are still applied. It is recommended to use this metadata in addition to any llvm.loop.*; transformation directive. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an interleave count to the loop interleaver.; The first operand is the string ``llvm.loop.interleave.count`` and the; second operand is an integer specifying the interleave count. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.interleave.count"", i32 4}. Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving; multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to 0; then the interleave count will be determined automatically. '``llvm.loop.vectorize.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables vectorization for the loo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:296586,safe,safe,296586,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"e., have been assigned; responsibility for), with the proviso that such commits must not break the; build. This is a ""trust but verify"" policy, and commits of this nature are; reviewed after they are committed. #. Multiple violations of these policies or a single egregious violation may; cause commit access to be revoked. In any case, your changes are still subject to `code review`_ (either before or; after they are committed, depending on the nature of the change). You are; encouraged to review other peoples' patches as well, but you aren't required; to do so. .. _discuss the change/gather consensus:. Making a Major Change; ---------------------. When a developer begins a major new project with the aim of contributing it back; to LLVM, they should inform the community with a post to the `LLVM Discourse forums`_, to the extent; possible. The reason for this is to:. #. keep the community informed about future changes to LLVM,. #. avoid duplication of effort by preventing multiple parties working on the; same thing and not knowing about it, and. #. ensure that any technical issues around the proposed work are discussed and; resolved before any significant work is done. The design of LLVM is carefully controlled to ensure that all the pieces fit; together well and are as consistent as possible. If you plan to make a major; change to the way LLVM works or want to add a major new extension, it is a good; idea to get consensus with the development community before you start working on; it. Once the design of the new feature is finalized, the work itself should be done; as a series of `incremental changes`_, not as a long-term development branch. .. _incremental changes:. Incremental Development; -----------------------. In the LLVM project, we do all significant changes as a series of incremental; patches. We have a strong dislike for huge changes or long-term development; branches. Long-term development branches have a number of drawbacks:. #. Branches must have mainline ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:26229,avoid,avoid,26229,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['avoid'],['avoid']
Safety,"e; <https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html>`_ for; details. Note that clang `maynot support; <https://bugs.llvm.org/show_bug.cgi?id=26966>`_ the CUDA toolkit as installed by; some Linux package managers. Clang does attempt to deal with specific details of; CUDA installation on a handful of common Linux distributions, but in general the; most reliable way to make it work is to install CUDA in a single directory from; NVIDIA's `.run` package and specify its location via `--cuda-path=...` argument. CUDA compilation is supported on Linux. Compilation on MacOS and Windows may or; may not work and currently have no maintainers. Invoking clang; --------------. Invoking clang for CUDA compilation works similarly to compiling regular C++.; You just need to be aware of a few additional flags. You can use `this <https://gist.github.com/855e277884eb6b388cd2f00d956c2fd4>`_; program as a toy example. Save it as ``axpy.cu``. (Clang detects that you're; compiling CUDA code by noticing that your filename ends with ``.cu``.; Alternatively, you can pass ``-x cuda``.). To build and run, run the following commands, filling in the parts in angle; brackets as described below:. .. code-block:: console. $ clang++ axpy.cu -o axpy --cuda-gpu-arch=<GPU arch> \; -L<CUDA install path>/<lib64 or lib> \; -lcudart_static -ldl -lrt -pthread; $ ./axpy; y[0] = 2; y[1] = 4; y[2] = 6; y[3] = 8. On MacOS, replace `-lcudart_static` with `-lcudart`; otherwise, you may get; ""CUDA driver version is insufficient for CUDA runtime version"" errors when you; run your program. * ``<CUDA install path>`` -- the directory where you installed CUDA SDK.; Typically, ``/usr/local/cuda``. Pass e.g. ``-L/usr/local/cuda/lib64`` if compiling in 64-bit mode; otherwise,; pass e.g. ``-L/usr/local/cuda/lib``. (In CUDA, the device code and host code; always have the same pointer widths, so if you're compiling 64-bit code for; the host, you're also compiling 64-bit code for the device.) Note that as o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:1827,detect,detects,1827,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['detect'],['detects']
Safety,"e@nondot.org>; To: Vikram S. Adve <vadve@cs.uiuc.edu>; Subject: RE: Meeting writeup. > I read it through and it looks great!. Thanks!. > The finally clause in Java may need more thought. The code for this clause; > is like a subroutine because it needs to be entered from many points (end of; > try block and beginning of each catch block), and then needs to *return to; > the place from where the code was entered*. That's why JVM has the; > jsr/jsr_w instruction. Hrm... I guess that is an implementation decision. It can either be; modelled as a subroutine (as java bytecodes do), which is really; gross... or it can be modelled as code duplication (emitted once inline,; then once in the exception path). Because this could, at worst,; slightly less than double the amount of code in a function (it is; bounded) I don't think this is a big deal. One of the really nice things; about the LLVM representation is that it still allows for runtime code; generation for exception paths (exceptions paths are not compiled until; needed). Obviously a static compiler couldn't do this though. :). In this case, only one copy of the code would be compiled... until the; other one is needed on demand. Also this strategy fits with the ""zero; cost"" exception model... the standard case is not burdened with extra; branches or ""call""s. > I suppose you could save the return address in a particular register; > (specific to this finally block), jump to the finally block, and then at the; > end of the finally block, jump back indirectly through this register. It; > will complicate building the CFG but I suppose that can be handled. It is; > also unsafe in terms of checking where control returns (which is I suppose; > why the JVM doesn't use this). I think that a code duplication method would be cleaner, and would avoid; the caveats that you mention. Also, it does not slow down the normal case; with an indirect branch... Like everything, we can probably defer a final decision until later. :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-19-ExceptionResponse.txt:1709,unsafe,unsafe,1709,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-19-ExceptionResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-19-ExceptionResponse.txt,2,"['avoid', 'unsafe']","['avoid', 'unsafe']"
Safety,"e_t Size) {; if (auto *Obj = ParseMe(Data, Size)) {; Obj->DoSomethingInteresting();; return 0; // Accept. The input may be added to the corpus.; }; return -1; // Reject; The input will not be added to the corpus.; }. Leaks; -----. Binaries built with AddressSanitizer_ or LeakSanitizer_ will try to detect; memory leaks at the process shutdown.; For in-process fuzzing this is inconvenient; since the fuzzer needs to report a leak with a reproducer as soon as the leaky; mutation is found. However, running full leak detection after every mutation; is expensive. By default (``-detect_leaks=1``) libFuzzer will count the number of; ``malloc`` and ``free`` calls when executing every mutation.; If the numbers don't match (which by itself doesn't mean there is a leak); libFuzzer will invoke the more expensive LeakSanitizer_; pass and if the actual leak is found, it will be reported with the reproducer; and the process will exit. If your target has massive leaks and the leak detection is disabled; you will eventually run out of RAM (see the ``-rss_limit_mb`` flag). Developing libFuzzer; ====================. LibFuzzer is built as a part of LLVM project by default on macos and Linux.; Users of other operating systems can explicitly request compilation using; ``-DCOMPILER_RT_BUILD_LIBFUZZER=ON`` flag.; Tests are run using ``check-fuzzer`` target from the build directory; which was configured with ``-DCOMPILER_RT_INCLUDE_TESTS=ON`` flag. .. code-block:: console. ninja check-fuzzer. FAQ; =========================. Q. Why doesn't libFuzzer use any of the LLVM support?; -----------------------------------------------------. There are two reasons. First, we want this library to be used outside of the LLVM without users having to; build the rest of LLVM. This may sound unconvincing for many LLVM folks,; but in practice the need for building the whole LLVM frightens many potential; users -- and we want more users to use this code. Second, there is a subtle technical reason not to rely o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:27091,detect,detection,27091,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detection']
Safety,"eabihf``; * ``binutils-arm-linux-gnueabihf``; * ``libgcc1-armhf-cross``; * ``libsfgcc1-armhf-cross``; * ``libstdc++6-armhf-cross``; * ``libstdc++6-4.7-dev-armhf-cross``. Configuring CMake; -----------------. For more information on how to configure CMake for LLVM/Clang,; see :doc:`CMake`. The CMake options you need to add are:. * ``-DCMAKE_SYSTEM_NAME=<target-system>``; * ``-DCMAKE_INSTALL_PREFIX=<install-dir>``; * ``-DLLVM_HOST_TRIPLE=arm-linux-gnueabihf``; * ``-DLLVM_TARGETS_TO_BUILD=ARM``. Note: ``CMAKE_CROSSCOMPILING`` is always set automatically when ``CMAKE_SYSTEM_NAME`` is set. Don't put ``-DCMAKE_CROSSCOMPILING=TRUE`` in your options. Also note that ``LLVM_HOST_TRIPLE`` specifies the triple of the system; that the cross built LLVM is going to run on - the flag is named based; on the autoconf build/host/target nomenclature. (This flag implicitly sets; other defaults, such as ``LLVM_DEFAULT_TARGET_TRIPLE``.). If you're compiling with GCC, you can use architecture options for your target,; and the compiler driver will detect everything that it needs:. * ``-DCMAKE_CXX_FLAGS='-march=armv7-a -mcpu=cortex-a9 -mfloat-abi=hard'``. However, if you're using Clang, the driver might not be up-to-date with your; specific Linux distribution, version or GCC layout, so you'll need to fudge. In addition to the ones above, you'll also need:. * ``--target=arm-linux-gnueabihf`` or whatever is the triple of your cross GCC.; * ``'--sysroot=/usr/arm-linux-gnueabihf'``, ``'--sysroot=/opt/gcc/arm-linux-gnueabihf'``; or whatever is the location of your GCC's sysroot (where /lib, /bin etc are).; * Appropriate use of ``-I`` and ``-L``, depending on how the cross GCC is installed,; and where are the libraries and headers. You may also want to set the ``LLVM_NATIVE_TOOL_DIR`` option - pointing; at a directory with prebuilt LLVM tools (``llvm-tblgen``, ``clang-tblgen``; etc) for the build host, allowing you to them reuse them if available.; E.g. ``-DLLVM_NATIVE_TOOL_DIR=<path-to-native-llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:1989,detect,detect,1989,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['detect'],['detect']
Safety,"easePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(void)wobble:(WobbleAmount *)amount;; @end. @implementation Widget. -(void)wobble:(WobbleAmount",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:92299,safe,safety,92299,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safety']
Safety,"east once; duplicates; are possible.; * The Locations within each record may either be of pointer size or a; multiple of pointer size. In the later case, the record must be; interpreted as describing a sequence of pointers and their corresponding; base pointers. If the Location is of size N x sizeof(pointer), then; there will be N records of one pointer each contained within the Location.; Both Locations in a pair can be assumed to be of the same size. Note that the Locations used in each section may describe the same; physical location. e.g. A stack slot may appear as a deopt location,; a gc base pointer, and a gc derived pointer. The LiveOut section of the StkMapRecord will be empty for a statepoint; record. Safepoint Semantics & Verification; ==================================. The fundamental correctness property for the compiled code's; correctness w.r.t. the garbage collector is a dynamic one. It must be; the case that there is no dynamic trace such that an operation; involving a potentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some other",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:23597,safe,safepoint,23597,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"ecify any custom filter (e.g. *.png) in the filter combo box; Enable the new (flat) button style. This can be enabled/disabled via the GUI.Style entry in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc); Create special icons for symlinks (shortcuts) in the browser (add a small arrow on bottom left corner of the original icon). TGFileDialog. Implemented the wish #78935: Longer ""File of type:"" selector is wanted (make more combo box entries visible); Enable the new (flat) button style. This can be enabled/disabled via the GUI.Style entry in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc). TGFSContainer. The shortcuts are now working on Windows. TGColorDialog, TGFontDialog, TGTextEditDialogs. Several improvements in the layout when increasing the font size. TGTextEditor. Added a ""Close"" menu entry; Properly ask the user to save the currently opened file (if modified) when trying to open a new file; Moved the IsSaved() part of the code in the LoadFile() method, to make sure it works also when the text editor is used as a plugin in the browser; Change the text highlighing color; Cleanup the text when quitting root (avoid potential crash on Linux). TGFrame. Allow to override CTRL+S behavior by using the TGMainFrame::BindKey() function. TVirtualDragManager. Renamed TVirtualDragManager::GetDragType() to TVirtualDragManager::GetEDragType(), to avoid potential clash between two classes (TGFrame and TVirtualDragManager) having both GetDragType method with different return types. And they are both inherited by one class (TGuiBldDragManager) which doesn't define GetDragType. TGSlider. Added mouse wheel handling. TGToolTip. Properly set the text color of the tooltip label, using the value of Gui.TooltipForegroundColor in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc). GUIHtml; TGHtmlBrowser. Only add non-empty strings (urls) in the combo box, to avoid empty entries; Enable the new (flat) button style. This can be enabled/disabled vi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v530/index.html:3437,avoid,avoid,3437,gui/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v530/index.html,1,['avoid'],['avoid']
Safety,"ecise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5463,safe,safe,5463,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['safe'],['safe']
Safety,"eck at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeoManager->PrintOverlaps() prints the list of overlaps. \anchor GP03b; ### Graphical Checking Method",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:94739,avoid,avoid,94739,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"eck the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; author property if it is incorrect. See `Attribution of Changes`_ for more; information including the method we used for attribution before the project; migrated to git. In the rare situation where there are multiple authors, please use the `git; tag 'Co-authored-by:' to list the additional authors; <https://github.blog/2018-01-29-commit-tog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:15251,avoid,avoid,15251,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['avoid'],['avoid']
Safety,"ecks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point types which would overflow the; destination. Because the range of representable values for all; floating-point types supported by Clang is [-inf, +inf], the only; cases detected are conversions from floating point to integer types.; - ``-fsanitize=float-divide-by-zero``: Floating point division by; zero. This is undefined per the C and C++ standards, but is defined; by Clang (and by ISO/IEC/IEEE 60559 / IEEE 754) as producing either an; infinity or NaN value, so is not included in ``-fsanitize=undefined``.; - ``-fsanitize=function``: Indirect call of a function through a; function pointer of the wrong type.; - ``-fsanitize=implicit-unsigned-integer-truncation``,; ``-fsanitize=implicit-signed-integer-truncation``: Implicit conversion from; integer of larger bit width to smaller bit width, if that results in data; loss. That is, if the demoted value, after casting back to the original; width, is not equal to the original value before the downcast.; The ``-fsanitize=implicit-unsigned-integer-truncation`` handles conversions; between two ``unsigned`` types, while; ``-fsanitize=implicit-signed-integer-truncation`` handles the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:4657,detect,detected,4657,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['detect'],['detected']
Safety,"ecomes more likely if the number; of free parameters is very large, or if the parameters are badly; scaled (not all of the same order of magnitude), and correlations; are also large. In any case, whether the non–positive–definiteness; is real or only numerical is largely irrelevant, since in both cases; the error matrix will be unreliable and the minimum suspicious. ## Additional trouble–shooting ##. When M just doesn't work, some of the more common causes are:. - **Precision mismatch.** Make sure your $\mbox{FCN}$ uses; internally the same precision as M . If the problem is only one of precision, and not of word length; mismatch, an appropriate MnMachinePrecision::setPrecision() may fix; it. - **Trivial bugs in $\mbox{FCN}$.** The possibilities for bugs are; numerous. Probably the most common among physicists inexperienced in; is the confusion between double and int types, which you can; sometimes get away with, but not always. [^3] M can spot some; trivial bugs itself, and issues a warning when it detects an unusual; $\mbox{FCN}$ behaviour. Such a warning should be taken; seriously. M also offers some tools (especially $\mbox{SCAN}$) which can; help the user to find trivial bugs. - **An ill–posed problem.** For questions of parameter dependence, see; the discussion above on postive–definiteness. Other mathematical; problems which can arise are: **excessive numerical roundoff** — be; especially careful of exponential and factorial functions which get; big very quickly and lose accuracy; **starting too far from the; solution** — the function may have unphysical local minima,; especially at infinity in some variables; **incorrect; normalization** — in likelihood functions, the probability; distributions must be normalized or at least have an integral which; is independent of the values of the variable parameters. - **A bug in M .** This is unlikely, but it happens. If a bug is; suspected, and all other possible causes can be eliminated, please; try to save a copy of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:74185,detect,detects,74185,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['detect'],['detects']
Safety,"ecs holding kinematic properties of muons; // a filter on muons pseudorapidities is applied considering a range in pseudo rapidity.; filtered_mu_pts_tvec = mu_pts_tvec[abs(mu_etas_tvec) < 2)];; ```; - The `TArrayBranch` class has been removed and replaced by the more powerful `TVec`.; - Columns on disk stored as C arrays should be read as `TVec`s, `std::vector` columns can be read as `TVec`s if requested. Jitted transformations and actions consider `std::vector` columns as well as C array columns `TVec`s.; - In jitted transformations and actions, `std::vector` and C array columns are read as `TVec`s.; - When snapshotting, columns read from trees which are of type `std::vector` or C array and read as TVecs are persistified on disk as a `std::vector` or C arrays respectively - no transformation happens. `TVec` columns, for example coming from `Define`s, are written as `std::vector<T, TAdoptAllocator<T>>`. #### Fixes; - Do not alphabetically order columns before snapshotting to avoid issues when writing C arrays the size of which varies and is stored in a separate branch.; - Validate columns before writing datasets on disk.; - Check the type of the columns via type info in CSV, ROOT and trivial data source.; - Allow to snapshot a dataset read from a `TCsvDS`.; - Snapshot and Cache now properly trigger column definitions.; - Correctly deduce type of Float_t branches when jitting.; - Do not rely on branches' titles for runtime type inference.; - Do not loose an entry when using Range and multiple actions. #### Other changes; - Throw an exception if the type of a branch cannot be deduced. ## Histogram Libraries; - Per object statsoverflow flag has been added. This change is required to prevent non reproducible behaviours in a multithreaded environments. For example, if several threads change the; `TH1::fgStatOverflows` flag and fill histograms, the behaviour will be undefined.; - A fix has been added in resetting the statistics of histograms with label. The bug was causing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:10171,avoid,avoid,10171,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoid']
Safety,"ected to be substantially more expensive even than using; `%rsp` and potentially `lfence` within the function entry block. ##### Define a new ABI and/or calling convention. We could define a new ABI and/or calling convention to explicitly pass the; predicate state in and out of functions. This may be interesting if none of the; alternatives have adequate performance, but it makes deployment and adoption; dramatically more complex, and potentially infeasible. ## High-Level Alternative Mitigation Strategies. There are completely different alternative approaches to mitigating variant 1; attacks. [Most](https://lwn.net/Articles/743265/); [discussion](https://lwn.net/Articles/744287/) so far focuses on mitigating; specific known attackable components in the Linux kernel (or other kernels) by; manually rewriting the code to contain an instruction sequence that is not; vulnerable. For x86 systems this is done by either injecting an `lfence`; instruction along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:44063,safe,safe,44063,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['safe'],['safe']
Safety,"ecutable (for a static compiler) or ensure the appropriate symbols are; available for the runtime linker (for a JIT compiler). Introduction; ============. What is Garbage Collection?; ---------------------------. Garbage collection is a widely used technique that frees the programmer from; having to know the lifetimes of heap objects, making software easier to produce; and maintain. Many programming languages rely on garbage collection for; automatic memory management. There are two primary forms of garbage collection:; conservative and accurate. Conservative garbage collection often does not require any special support from; either the language or the compiler: it can handle non-type-safe programming; languages (such as C/C++) and does not require any special information from the; compiler. The `Boehm collector; <https://hboehm.info/gc/>`__ is an example of a; state-of-the-art conservative collector. Accurate garbage collection requires the ability to identify all pointers in the; program at run-time (which requires that the source-language be type-safe in; most cases). Identifying pointers at run-time requires compiler support to; locate all places that hold live pointer variables at run-time, including the; :ref:`processor stack and registers <gcroot>`. Conservative garbage collection is attractive because it does not require any; special compiler support, but it does have problems. In particular, because the; conservative garbage collector cannot *know* that a particular word in the; machine is a pointer, it cannot move live objects in the heap (preventing the; use of compacting and generational GC algorithms) and it can occasionally suffer; from memory leaks due to integer values that happen to point to objects in the; program. In addition, some aggressive compiler transformations can break; conservative garbage collectors (though these seem rare in practice). Accurate garbage collectors do not suffer from any of these problems, but they; can suffer from degrade",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:3615,safe,safe,3615,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ecuted a lot. Furthermore `preserve_mostcc`; doesn't prevent the inliner from inlining the function call. This calling convention will be used by a future version of the ObjectiveC; runtime and should therefore still be considered experimental at this time.; Although this convention was created to optimize certain runtime calls to; the ObjectiveC runtime, it is not limited to this runtime and might be used; by other runtimes in the future too. The current implementation only; supports X86-64, but the intention is to support more architectures in the; future.; ""``preserve_allcc``"" - The `PreserveAll` calling convention; This calling convention attempts to make the code in the caller even less; intrusive than the `PreserveMost` calling convention. This calling; convention also behaves identical to the `C` calling convention on how; arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. This removes the burden of saving and; recovering a large register set before and after the call in the caller. If; the arguments are passed in callee-saved registers, then they will be; preserved by the callee across the call. This doesn't apply for values; returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11. R11 can be used as a scratch register. Furthermore it also preserves; all floating-point registers (XMMs/YMMs). - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. Furthermore it also preserves lower 128 bits of V8-V31 SIMD -; floating point registers. The idea behind this convention is to support calls to runtime functions; that don't need to call out to any other functions. This calling convention, like the `PreserveMost` calling convention, will be; used by a future version of the ObjectiveC runtime and should be considered; experimental at this time.; ""``cxx_fast_tlscc``"" - The `CXX_FAST_TLS` calling convention for access functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:18941,recover,recovering,18941,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recovering']
Safety,"ed to be treated differently inside an inlined body. For example, consider these conversions from nonnull to nullable in presence of inlining:. .. code-block:: cpp. id obj = getNonnull();; takesNullable(obj);; takesNonnull(obj);. void takesNullable(nullable id obj) {; obj->ivar // we should assume obj is nullable and warn here; }. With no special treatment, when the takesNullable is inlined the analyzer will not warn when the obj symbol is dereferenced. One solution for this is to reanalyze takesNullable as a top level function to get possible violations. The alternative method, deducing nullability information from the arguments after inlining is not robust enough (for example there might be more parameters with different nullability, but in the given path the two parameters might end up being the same symbol or there can be nested functions that take different view of the nullability of the same symbol). So the symbol will remain nonnull to avoid false positives but the functions that takes nullable parameters will be analyzed separately as well without inlining. Annotations on multi level pointers; -----------------------------------. Tracking multiple levels of annotations for pointers pointing to pointers would make the checker more complicated, because this way a vector of nullability qualifiers would be needed to be tracked for each symbol. This is not a big caveat, since once the top level pointer is dereferenced, the symvol for the inner pointer will have the nullability information. The lack of multi level annotation tracking only observable, when multiple levels of pointers are passed to a function which has a parameter with multiple levels of annotations. So for now the checker support the top level nullability qualifiers only.:. .. code-block:: cpp. int * __nonnull * __nullable p;; int ** q = p;; takesStarNullableStarNullable(q);. Implementation notes; --------------------. What to track?. * The checker would track memory regions, and to each relevant r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:4338,avoid,avoid,4338,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,1,['avoid'],['avoid']
Safety,"ed. Each virtual register can only be mapped to physical registers of a; particular class. For instance, in the X86 architecture, some virtuals can only; be allocated to 8 bit registers. A register class is described by; ``TargetRegisterClass`` objects. To discover if a virtual register is; compatible with a given physical, this code can be used:. .. code-block:: c++. bool RegMapping_Fer::compatible_class(MachineFunction &mf,; unsigned v_reg,; unsigned p_reg) {; assert(TargetRegisterInfo::isPhysicalRegister(p_reg) &&; ""Target register must be physical"");; const TargetRegisterClass *trc = mf.getRegInfo().getRegClass(v_reg);; return trc->contains(p_reg);; }. Sometimes, mostly for debugging purposes, it is useful to change the number of; physical registers available in the target architecture. This must be done; statically, inside the ``TargetRegisterInfo.td`` file. Just ``grep`` for; ``RegisterClass``, the last parameter of which is a list of registers. Just; commenting some out is one simple way to avoid them being used. A more polite; way is to explicitly exclude some registers from the *allocation order*. See the; definition of the ``GR8`` register class in; ``lib/Target/X86/X86RegisterInfo.td`` for an example of this. Virtual registers are also denoted by integer numbers. Contrary to physical; registers, different virtual registers never share the same number. Whereas; physical registers are statically defined in a ``TargetRegisterInfo.td`` file; and cannot be created by the application developer, that is not the case with; virtual registers. In order to create new virtual registers, use the method; ``MachineRegisterInfo::createVirtualRegister()``. This method will return a new; virtual register. Use an ``IndexedMap<Foo, VirtReg2IndexFunctor>`` to hold; information per virtual register. If you need to enumerate all virtual; registers, use the function ``TargetRegisterInfo::index2VirtReg()`` to find the; virtual register numbers:. .. code-block:: c++. for (unsigned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:60606,avoid,avoid,60606,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['avoid'],['avoid']
Safety,"eeded and subject to approval of the CoC Committee. .. _Resolutions:. Resolutions; ===========. The committee should agree unanimously on a resolution. In the event that the; committee cannot reach a unanimous resolution, the LLVM Foundation Board of; Directors will help resolve the situation and determine if the resolution can; proceed without a unanimous vote. When deciding on a resolution, the goal is to address the report in an; appropriate way, while also looking to prevent or reduce the risk of continuing; harm in the future. Any action deemed necessary by the committee will be; taken, but below is a list of possible resolutions:. * Taking no further action as the incident was determined not to be a; violation.; * A private verbal warning and/or reprimand from the committee to the; individual(s) involved and request to stop this behavior. This conversation; may happen in person, email, by phone, video chat, or IRC.; * Request that the reportee avoid any interaction with, and physical proximity; to, another person for the remainder of the event.; * Refusal of alcoholic beverage purchases by the reportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediately leave an event and not return.; * Immediately ending any volunteer responsibilities and privileges the reportee; holds.; * An imposed suspension (e.g., asking someone to ""take a week off"" from mailing; lists, bug tracker, IRC, Discord, repositories, or other communication; forms). ; * A permanent or temporary ban from some or all LLVM Project spaces (online or; in person). Once a resolution is agreed upon, but before it is enacted, the committee will; contact the reporter and any other affected parties to explain the proposed; resolution. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:7671,avoid,avoid,7671,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['avoid'],['avoid']
Safety,"eek(; const llvm_blake3_hasher *self,; uint64_t seek,; uint8_t *out,; size_t out_len);; ```. The same as `llvm_blake3_hasher_finalize`, but with an additional `seek`; parameter for the starting byte position in the output stream. To; efficiently stream a large output without allocating memory, call this; function in a loop, incrementing `seek` by the output length each time. ---. ```c; void llvm_blake3_hasher_reset(; llvm_blake3_hasher *self);; ```. Reset the hasher to its initial state, prior to any calls to; `llvm_blake3_hasher_update`. Currently this is no different from calling; `llvm_blake3_hasher_init` or similar again. However, if this implementation gains; multithreading support in the future, and if `llvm_blake3_hasher` holds (optional); threading resources, this function will reuse those resources. # Building. This implementation is just C and assembly files. ## x86. Dynamic dispatch is enabled by default on x86. The implementation will; query the CPU at runtime to detect SIMD support, and it will use the; widest instruction set available. By default, `blake3_dispatch.c`; expects to be linked with code for five different instruction sets:; portable C, SSE2, SSE4.1, AVX2, and AVX-512. For each of the x86 SIMD instruction sets, four versions are available:; three flavors of assembly (Unix, Windows MSVC, and Windows GNU) and one; version using C intrinsics. The assembly versions are generally; preferred. They perform better, they perform more consistently across; different compilers, and they build more quickly. On the other hand, the; assembly versions are x86\_64-only, and you need to select the right; flavor for your target platform. ## ARM NEON. The NEON implementation is enabled by default on AArch64, but not on; other ARM targets, since not all of them support it. To enable it, set; `BLAKE3_USE_NEON=1`. To explicitiy disable using NEON instructions on AArch64, set; `BLAKE3_USE_NEON=0`. ## Other Platforms. The portable implementation should work on most o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:7094,detect,detect,7094,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['detect'],['detect']
Safety,"een 1 and `TG-1` bytes. The size; of a short granule is stored at the location in shadow memory where the; granule's tag is normally stored, while the granule's actual tag is stored; in the last byte of the granule. This means that in order to verify that a; pointer tag matches a memory tag, HWASAN must check for two possibilities:. * the pointer tag is equal to the memory tag in shadow memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:2960,detect,detects,2960,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,1,['detect'],['detects']
Safety,"ef:`cycle<cycle-terminology>` covers both, loops and; irreducible control flow. * The `FixIrreducible <https://llvm.org/doxygen/FixIrreducible_8h.html>`_; pass can transform irreducible control flow into loops by inserting; new loop headers. It is not included in any default optimization pass; pipeline, but is required for some back-end targets. * Exiting edges are not the only way to break out of a loop. Other; possibilities are unreachable terminators, [[noreturn]] functions,; exceptions, signals, and your computer's power button. * A basic block ""inside"" the loop that does not have a path back to the; loop (i.e. to a latch or header) is not considered part of the loop.; This is illustrated by the following code. .. code-block:: C. for (unsigned i = 0; i <= n; ++i) {; if (c1) {; // When reaching this block, we will have exited the loop.; do_something();; break;; }; if (c2) {; // abort(), never returns, so we have exited the loop.; abort();; }; if (c3) {; // The unreachable allows the compiler to assume that this will not rejoin the loop.; do_something();; __builtin_unreachable();; }; if (c4) {; // This statically infinite loop is not nested because control-flow will not continue with the for-loop.; while(true) {; do_something();; }; }; }. * There is no requirement for the control flow to eventually leave the; loop, i.e. a loop can be infinite. A **statically infinite loop** is a; loop that has no exiting edges. A **dynamically infinite loop** has; exiting edges, but it is possible to be never taken. This may happen; only under some circumstances, such as when n == UINT_MAX in the code; below. .. code-block:: C. for (unsigned i = 0; i <= n; ++i); body(i);. It is possible for the optimizer to turn a dynamically infinite loop; into a statically infinite loop, for instance when it can prove that the; exiting condition is always false. Because the exiting edge is never; taken, the optimizer can change the conditional branch into an; unconditional one. If a is loop is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:6398,abort,abort,6398,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['abort'],['abort']
Safety,"eficial, instruction to use a specific; option, , or convey a specific request from the user (such as; ``#pragma clang loop`` or ``#pragma omp simd``). If a transformation is forced but cannot be carried-out for any reason,; an optimization-missed warning must be emitted. Semantic information; such as a transformation being safe (e.g.; ``llvm.mem.parallel_loop_access``) can be unused by the optimizer; without generating a warning. Unless explicitly disabled, any optimization pass may heuristically; determine whether a transformation is beneficial and apply it. If; metadata for another transformation was specified, applying a different; transformation before it might be inadvertent due to being applied on a; different loop or the loop not existing anymore. To avoid having to; explicitly disable an unknown number of passes, the attribute; ``llvm.loop.disable_nonforced`` disables all optional, high-level,; restructuring transformations. The following example avoids the loop being altered before being; vectorized, for instance being unrolled. .. code-block:: llvm. br i1 %exitcond, label %for.exit, label %for.header, !llvm.loop !0; ...; !0 = distinct !{!0, !1, !2}; !1 = !{!""llvm.loop.vectorize.enable"", i1 true}; !2 = !{!""llvm.loop.disable_nonforced""}. After a transformation is applied, follow-up attributes are set on the; transformed and/or new loop(s). This allows additional attributes; including followup-transformations to be specified. Specifying multiple; transformations in the same metadata node is possible for compatibility; reasons, but their execution order is undefined. For instance, when; ``llvm.loop.vectorize.enable`` and ``llvm.loop.unroll.enable`` are; specified at the same time, unrolling may occur either before or after; vectorization. As an example, the following instructs a loop to be vectorized and only; then unrolled. .. code-block:: llvm. !0 = distinct !{!0, !1, !2, !3}; !1 = !{!""llvm.loop.vectorize.enable"", i1 true}; !2 = !{!""llvm.loop.disable_nonforc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:3305,avoid,avoids,3305,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoids']
Safety,"efore drawing - only then; real frame size will be set; 8. Fix problem with GetBBox - it only can be used for visible elements in mozilla.; 9. Support drawing of fit parameters in stat box, use (as far as possible) stat and; fit format for statistic display; 10. Implement 'g' formatting kind for stat box output - one need to checks; significant digits when producing output.; 11. Support new draw options for TGraph: 'C', 'B1', '0', '2', '3', '4', '[]'; 12. Primary support for STL containers in IO part. Allows to read ROOT6 TF1.; 13. Full support of TGraphBentErrors; 14. Support objects drawing from JSON files in default user interface, including; monitoring. One could open file from link like: https://root.cern.ch/js/dev/?json=demo/canvas_tf1.json; 15. Introduce JSROOT.FFormat function to convert numeric values into string according; format like 6.4g or 5.7e. Used for statistic display. ## Changes in 3.5; 1. Fix error in vertical text alignment; 2. Many improvements in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one should clear drawings); 11. Several improvements in THttpServer user interface - repair hierarchy reload,; hide unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:65499,avoid,avoid,65499,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['avoid'],['avoid']
Safety,"eir own algorithms for boundary; crossing). ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ~~~. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the computation of safety can always be forced:. ~~~{.cpp}; Double_t safety = gGeoManager->Safety();; ~~~. \anchor GP02gd; #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ~~~{.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ~~~. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:80031,safe,safe,80031,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"elease pool's scope is left. .. _arc.ownership.restrictions.conversion.indirect:. Conversion of pointers to ownership-qualified types; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if an expression of type ``T*`` is converted,; explicitly or implicitly, to the type ``U*``, where ``T`` and ``U`` have; different ownership qualification, unless:. * ``T`` is qualified with ``__strong``, ``__autoreleasing``, or; ``__unsafe_unretained``, and ``U`` is qualified with both ``const`` and; ``__unsafe_unretained``; or; * either ``T`` or ``U`` is ``cv void``, where ``cv`` is an optional sequence; of non-ownership qualifiers; or; * the conversion is requested with a ``reinterpret_cast`` in Objective-C++; or; * the conversion is a well-formed :ref:`pass-by-writeback; <arc.ownership.restrictions.pass_by_writeback>`. The analogous rule applies to ``T&`` and ``U&`` in Objective-C++. .. admonition:: Rationale. These rules provide a reasonable level of type-safety for indirect pointers,; as long as the underlying memory is not deallocated. The conversion to; ``const __unsafe_unretained`` is permitted because the semantics of reads are; equivalent across all these ownership semantics, and that's a very useful and; common pattern. The interconversion with ``void*`` is useful for allocating; memory or otherwise escaping the type system, but use it carefully.; ``reinterpret_cast`` is considered to be an obvious enough sign of taking; responsibility for any problems. It is undefined behavior to access an ownership-qualified object through an; lvalue of a differently-qualified type, except that any non-``__weak`` object; may be read through an ``__unsafe_unretained`` lvalue. It is undefined behavior if the storage of a ``__strong`` or ``__weak``; object is not properly initialized before the first managed operation; is performed on the object, or if the storage of such an object is freed; or reused before the object has been properly deinitialized. Storage for; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:44285,safe,safety,44285,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safety']
Safety,"elow, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.U",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16601,safe,safety-beta,16601,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety-beta']
Safety,"em --- A method of instruction selection for code; generation. An example is the `BURG; <http://www.program-transformation.org/Transform/BURG>`_ tool. C; -. **CFI**; This abbreviation has two meanings.; Either:; Call Frame Information. Used in DWARF debug info and in C++ unwind info; to show how the function prolog lays out the stack frame. Or:; Control Flow Integrity. A general term for computer security techniques; that prevent a wide variety of malware attacks from redirecting the flow; of execution (the control flow) of a program. **CIE**; Common Information Entry. A kind of CFI used to reduce the size of FDEs.; The compiler creates a CIE which contains the information common across all; the FDEs. Each FDE then points to its CIE. **CSE**; Common Subexpression Elimination. An optimization that removes common; subexpression computation. For example ``(a+b)*(a+b)`` has two; subexpressions that are the same: ``(a+b)``. This optimization would; perform the addition only once and then perform the multiply (but only if; it's computationally correct/safe). D; -. **DAG**; Directed Acyclic Graph. .. _derived pointer:; .. _derived pointers:. **Derived Pointer**; A pointer to the interior of an object, such that a garbage collector is; unable to use the pointer for reachability analysis. While a derived pointer; is live, the corresponding object pointer must be kept in a root, otherwise; the collector might free the referenced object. With copying collectors,; derived pointers pose an additional hazard that they may be invalidated at; any `safe point`_. This term is used in opposition to `object pointer`_. **DSA**; Data Structure Analysis. **DSE**; Dead Store Elimination. E; -. **ento**; This namespace houses the; `Clang Static Analyzer <https://clang.llvm.org/docs/ClangStaticAnalyzer.html>`_.; It is an abbreviation of `entomology <https://en.wikipedia.org/wiki/Entomology>`_. *""Entomology is the scientific study of insects.""*. In the past, this namespace had not only the na",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:2346,safe,safe,2346,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['safe'],['safe']
Safety,"ement; -------------------------------------. Expressions and statements are one of the most fundamental constructs within a; compiler, because they interact with many different parts of the AST, semantic; analysis, and IR generation. Therefore, adding a new expression or statement; kind into Clang requires some care. The following list details the various; places in Clang where an expression or statement needs to be introduced, along; with patterns to follow to ensure that the new expression or statement works; well across all of the C languages. We focus on expressions, but statements; are similar. #. Introduce parsing actions into the parser. Recursive-descent parsing is; mostly self-explanatory, but there are a few things that are worth keeping; in mind:. * Keep as much source location information as possible! You'll want it later; to produce great diagnostics and support Clang's various features that map; between source code and the AST.; * Write tests for all of the ""bad"" parsing cases, to make sure your recovery; is good. If you have matched delimiters (e.g., parentheses, square; brackets, etc.), use ``Parser::BalancedDelimiterTracker`` to give nice; diagnostics when things go wrong. #. Introduce semantic analysis actions into ``Sema``. Semantic analysis should; always involve two functions: an ``ActOnXXX`` function that will be called; directly from the parser, and a ``BuildXXX`` function that performs the; actual semantic analysis and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:145473,recover,recovery,145473,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10580,recover,recover,10580,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['recover'],['recover']
Safety,"en no such child cycle ``C'`` is detected.; Threads that diverge at ``Q`` execute converged dynamic instances of; ``S`` since they do not encounter the cycle header on any path from; ``Q`` to ``S``. Informally, threads that diverge at ``Q``; reconverge at ``S`` in the same iteration of ``C``. .. table::; :align: left. +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+------+; | | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |; +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+------+; | Thread1 | Entry | P1 | Q1 | R1 | S1 | P3 | Q3 | R3 | S3 | Exit |; +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+------+; | Thread2 | Entry | P2 | Q2 | | S2 | P4 | Q4 | R2 | S4 | Exit |; +---------+-------+-----+-----+-----+-----+-----+-----+-----+-----+------+. |. .. note::. In general, the cycle ``C`` in the above statements is not; expected to be the same cycle for different headers. Cycles and; their headers are tightly coupled; for different headers in the; same outermost cycle, the child cycles detected may be different.; The property relevant to the above examples is that for every; closed path, there is a cycle ``C`` that contains the path and; whose header is on that path. The diverged entry criterion must be checked for every closed path; passing through a divergent branch ``B`` and its join ``J``. Since; :ref:`every closed path passes through the header of some; cycle<cycle-closed-path-header>`, this amounts to checking every cycle; ``C`` that contains ``B`` and ``J``. When the header of ``C``; dominates the join ``J``, there can be no entry to any path from the; header to ``J``, which includes any diverged path from ``B`` to ``J``.; This is also true for any closed paths passing through the header of; an outer cycle that contains ``C``. Thus, the diverged entry criterion can be conservatively simplified; as follows:. For a divergent branch ``B`` and its join node ``J``, the nodes in a; cycle ``C`` that contains both ``B`` and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:25006,detect,detected,25006,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['detect'],['detected']
Safety,"enVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ; Fix a problem in the assignment operator of the ROOT::Math::PxPyPzM4D class. Avoid having nan when converting for example from PxPyPzME4D to PxPyPzM4D when the mass is negative. ; Throw always exception in the non-supported setters (i.e. SetPt on a PxPyPzEVector) methods, which are generated only for the CINT dictionary. These methods flag a compiled-error when running in C++ mode. SMatrix. Change implementation of the SMatrix::Invert and SMatrix::Inverse methods. Now the optimized method based on the Cramer rule is used only for matrix up to sizes 2x2. The standard methods based on LU (for ordinary square matrix) or Bunch-Kaufman factorization (for square matrix) are used. The factorization method, although slower for small size matrices, they suffer much less from numerical precision problems.; New methods SMatrix::Invert and SMatrix::InverseFast are added for using the Cramer rule for up to matrix of sizes 5x5. This method has exactly the same implementation as the Invert and Inverse of the previous ROOT version.; ; Physics. TLorentzVector:Change in the implementation of the function SetPtEtaPhi and SetPtEtaPhiM the algorithm to calculate z from pt and eta. Use now, as in the GenVector package, the expression z = pt * sinh(eta) instead of using the tangent and the arc-tangent. This is is more efficient and avoids a problem found on 64 bit machines when eta=0. by Dariusz Miskowiec. Unuran. New version (1.3) from Josef Leydold fixing some warnings on Windows Visual Studio 9. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:5924,avoid,avoids,5924,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['avoid'],['avoids']
Safety,"enable new feature, compact parameter should be 5:. ~~~ {.cpp}; std::map<std::string,int> obj;; obj[""name1""] = 11;; obj[""name1""] = 22;; auto json = TBufferJSON::ToJSON(&obj, 5);; // {""_typename"": ""map<string,int>"", ""name1"": 11, ""name2"": 22}; auto dflt_json = TBufferJSON::ToJSON(&obj);; // [{""$pair"" : ""pair<string,int>"", ""first"" : ""name1"", ""second"" : 11}, {""$pair"" : ""pair<string,int>"", ""first"" : ""name2"", ""second"" : 22}]; ~~~. Also one could put ""JSON_object"" string in class-member comments to enable this feature:. ~~~ {.cpp}; class Container {; int field{5};; std::unordered_map<std::string,double> data; ///< JSON_object indicates conversion; };; ~~~. Now one could disable storage of type information - `_typename` field. For that compact parameter; has to include value 100. Be aware that such JSON representation may not be recognized by JSROOT.; Maximal compression of JSON can be achieved now with compact parameter 128 = 100 + 20 + 5 + 3:; 3 - remove all spaces and new lines; 5 - convert map->object (when applicable); 20 - special compression of large arrays (auto-detected in JSROOT); 100 - suppressing `_typename` for all classes. ## TTree Libraries. ### RDataFrame; - Use TPRegexp instead of TRegexp to interpret the regex used to select columns; in the invocation of `Cache` and `Snapshot`. This allows usage of a larger set; of regular expressions to specify which columns should be written out.; - Speed up jitting of Filter and Define expressions passed as string; - Speed up event loop, improve scaling in the presence of a large amount of Defines; - Allow Filter expressions to return types convertible to bool, rather than only bool; - Add `GetNSlots` method to easily retrieve the number of slots that will be used by; `DefineSlot`, `ForeachSlot`, `OnPartialResultSlot`, ...; - Add support for TTrees/TChains with TEntryLists (currently only for single-thread event loops); - Add `HasColumn` method to check whether a column is available to a given RDF node; - PyROOT: add `A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:8011,detect,detected,8011,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['detect'],['detected']
Safety,"end saves the current stack pointer with; a call to :ref:`llvm.stacksave <int_stacksave>`. Then, it allocates the; argument stack space with alloca and calls the default constructor. The; default constructor could throw an exception, so the frontend has to; create a landing pad. The frontend has to destroy the already; constructed argument ``b`` before restoring the stack pointer. If the; constructor does not unwind, ``g`` is called. In the Microsoft C++ ABI,; ``g`` will destroy its arguments, and then the stack is restored in; ``f``. Design Considerations; =====================. Lifetime; --------. The biggest design consideration for this feature is object lifetime.; We cannot model the arguments as static allocas in the entry block,; because all calls need to use the memory at the top of the stack to pass; arguments. We cannot vend pointers to that memory at function entry; because after code generation they will alias. The rule against allocas between argument allocations and the call site; avoids this problem, but it creates a cleanup problem. Cleanup and; lifetime is handled explicitly with stack save and restore calls. In; the future, we may want to introduce a new construct such as ``freea``; or ``afree`` to make it clear that this stack adjusting cleanup is less; powerful than a full stack save and restore. Nested Calls and Copy Elision; -----------------------------. We also want to be able to support copy elision into these argument; slots. This means we have to support multiple live argument; allocations. Consider the evaluation of:. .. code-block:: c++. // Foo is non-trivial.; struct Foo { int a; Foo(); Foo(const &Foo); ~Foo(); };; Foo bar(Foo b);; int main() {; bar(bar(Foo()));; }. In this case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct retur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:3581,avoid,avoids,3581,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,1,['avoid'],['avoids']
Safety,"ent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes inside; irreducible cycles as having divergent outputs. But it is desirable to; recognize m-converged nodes in the CFG in order to maximize; uniformity. This section describes one such pattern of nodes derived; from *closed paths*, which are a property of the CFG and do not depend; on the cycle hierarchy. **Diverged Entry Criterion:**. The dynamic instances of all the nodes in a closed path ``P`` are; m-converged only if for every divergent branch ``B`` and its; join node ``J`` that lie on ``P``, there is no entry to ``P`` which; lies on a diverged path from ``B`` to ``J``. .. figure:: convergence-closed-path.png; :name: convergence-closed-path. Consider the closed path ``P -> Q -> R -> S`` in the above figure.; ``P`` and ``R`` are :ref:`entries to the closed; path<cycle-closed-path>`. ``Q`` is a divergent branch an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:21403,detect,detects,21403,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['detect'],['detects']
Safety,"ent; out-of-bounds (OOB) memory accesses, which remain a major source of security; vulnerabilities in C. ``-fbounds-safety`` aims to eliminate this class of bugs; by turning OOB accesses into deterministic traps. The ``-fbounds-safety`` extension offers bounds annotations that programmers can; use to attach bounds to pointers. For example, programmers can add the; ``__counted_by(N)`` annotation to parameter ``ptr``, indicating that the pointer; has ``N`` valid elements:. .. code-block:: c. void foo(int *__counted_by(N) ptr, size_t N);. Using this bounds information, the compiler inserts bounds checks on every; pointer dereference, ensuring that the program does not access memory outside; the specified bounds. The compiler requires programmers to provide enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted par",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:1214,safe,safety,1214,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"eople?`). ``` {.cpp}; Root.Html.XWho:; ```. If set to Doc++, allow method documentation in front of method even for; methods in the source file (default: `""""`). ``` {.cpp}; Root.Html.DescriptionStyle:; ```. Search path for the source and header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9384,detect,detecting,9384,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['detect'],['detecting']
Safety,"eportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and that their behavior may be deemed; inappropriate.; * Give them the opportunity to state their view of the incident.; * Explain the possible resolutions that may be enforced should the CoC; committee determine there is a breach. The reportee will be given a week to respond with the option to request; additional time if needed and subject to approval of the CoC Committee. .. _Resolutions:. Resolutions; ===========. The committee should agree unanimously on a resolution. In the event that the; committee cannot reach a unanimous resolution, the LLVM Foundation Board of; Directors will help resolve the situation and determine if the resolution can; proceed without a unanimous vote. When deciding on a resolution, the goal is to address the report in an; appropriate way, while also looking to prevent or reduce the risk of continuing; harm in the future. Any action deemed necessary by the committee will be; taken, but below is a list of possible resolutions:. * Taking no further action as the incident was determined not to be a; violation.; * A private verbal warning and/or reprimand from the committee to the; individual(s) involved and request to stop this behavior. This conversation; may happen in person, email, by phone, video chat, or IRC.; * Request that the reportee avoid any interaction with, and physical proximity; to, another person for the remainder of the event.; * Refusal of alcoholic beverage purchases by the reportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:7205,risk,risk,7205,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['risk'],['risk']
Safety,"epresentable; as ``unsigned char`` and is not equal to ``EOF``. You can think of this checker as defining restrictions (pre- and postconditions); on standard library functions. Preconditions are checked, and when they are; violated, a warning is emitted. Postconditions are added to the analysis, e.g.; that the return value of a function is not greater than 255. Preconditions are; added to the analysis too, in the case when the affected values are not known; before the call. For example, if an argument to a function must be in between 0 and 255, but the; value of the argument is unknown, the analyzer will assume that it is in this; interval. Similarly, if a function mustn't be called with a null pointer and the; analyzer cannot prove that it is null, then it will assume that it is non-null. These are the possible checks on the values passed as function arguments:; - The argument has an allowed range (or multiple ranges) of values. The checker; can detect if a passed value is outside of the allowed range and show the; actual and allowed values.; - The argument has pointer type and is not allowed to be null pointer. Many; (but not all) standard functions can produce undefined behavior if a null; pointer is passed, these cases can be detected by the checker.; - The argument is a pointer to a memory block and the minimal size of this; buffer is determined by another argument to the function, or by; multiplication of two arguments (like at function ``fread``), or is a fixed; value (for example ``asctime_r`` requires at least a buffer of size 26). The; checker can detect if the buffer size is too small and in optimal case show; the size of the buffer and the values of the corresponding arguments. .. code-block:: c. #define EOF -1; void test_alnum_concrete(int v) {; int ret = isalnum(256); // \; // warning: Function argument outside of allowed range; (void)ret;; }. void buffer_size_violation(FILE *file) {; enum { BUFFER_SIZE = 1024 };; wchar_t wbuf[BUFFER_SIZE];. const size_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:31895,detect,detect,31895,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['detect'],['detect']
Safety,"equire values; of the same base type and produces a result with the same base type. Allowing; these operations to act on location descriptions would permit the first operand; to be a location description and the second operand to be an integral value; type, or vice versa, and return a location description. This complicates the; rules for implicit conversions between default address space memory location; descriptions and generic base type values. Currently the rules would convert; such a location description to the memory address value and then perform two's; compliment wrap around arithmetic. If the result was used as a location; description, it would be implicitly converted back to a default address space; memory location description. This is different to the overflow rules on location; descriptions. To allow control, an operation that converts a memory location; description to an address integral type value would be required. Keeping a; separation of location description operations and arithmetic operations avoids; this semantic complexity. See ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.5 Generalize Creation of Undefined Location Descriptions; ----------------------------------------------------------. Current DWARF uses an empty expression to indicate an undefined location; description. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location descriptions to be created on the stack, it is necessary to have; an explicit way to specify an undefined location description. For example, the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware`); operation takes more than one location description on the stack. Without this; ability, it is not possible to specify that a particular one of the input; location descriptions is undefined. See the ``DW_OP_LLVM_undefined`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:14427,avoid,avoids,14427,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoids']
Safety,"er as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7198,detect,detect,7198,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['detect'],['detect']
Safety,"er assigns to the variable. Another usage is to create an expression that evaluates to provide a vector of; logical PCs for active and inactive lanes in a SIMT execution model. Again the; EXEC register is used to select between active and inactive PC values. In order; to represent a vector of PC values, a way to create a composite location; description that is a vector of a single location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operations for control flow to; create a loop. However, for the AMDGPU that would require loop iteration of 64.; A concern is that the resulting DWARF would have a significant size and would be; reasonably common as it is needed for every vector register that is spilled in a; function. AMDGPU can have up to 512 vector registers. Another concern is the; time taken to evaluate such non-trivial expressions repeatedly. To avoid these issues, a composite location description that can be created as a; masked select is proposed. In addition, an operation that creates a composite; location description that is a vector on another location description is needed.; These operations generate the composite location description using a single; DWARF operation that combines all lanes of the vector in one step. The DWARF; expression is more compact, and can be evaluated by a consumer far more; efficiently. An example that uses these operations is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_OP_LLVM_select_bit_piece`` and ``DW_OP_LLVM_extend`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.11 DWARF Operation to Access Call Frame Entry Registers; ---------------------------------------------------------. As described in; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`,; a DWARF expression involving the set of SIMT lanes active on entry to a; subprogram is required. The SIMT active lane ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:26163,avoid,avoid,26163,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoid']
Safety,"er overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1502,safe,safe,1502,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['safe'],['safe']
Safety,"er to memory, use; ``VirtRegMap::assignVirt2StackSlot(vreg)``. This method will return the stack; slot where ``vreg``'s value will be located. If it is necessary to map another; virtual register to the same stack slot, use; ``VirtRegMap::assignVirt2StackSlot(vreg, stack_location)``. One important point; to consider when using the indirect mapping, is that even if a virtual register; is mapped to memory, it still needs to be mapped to a physical register. This; physical register is the location where the virtual register is supposed to be; found before being stored or after being reloaded. If the indirect strategy is used, after all the virtual registers have been; mapped to physical registers or stack slots, it is necessary to use a spiller; object to place load and store instructions in the code. Every virtual that has; been mapped to a stack slot will be stored to memory after being defined and will; be loaded before being used. The implementation of the spiller tries to recycle; load/store instructions, avoiding unnecessary instructions. For an example of; how to invoke the spiller, see ``RegAllocLinearScan::runOnMachineFunction`` in; ``lib/CodeGen/RegAllocLinearScan.cpp``. Handling two address instructions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With very rare exceptions (e.g., function calls), the LLVM machine code; instructions are three address instructions. That is, each instruction is; expected to define at most one register, and to use at most two registers.; However, some architectures use two address instructions. In this case, the; defined register is also one of the used registers. For instance, an instruction; such as ``ADD %EAX, %EBX``, in X86 is actually equivalent to ``%EAX = %EAX +; %EBX``. In order to produce correct code, LLVM must convert three address instructions; that represent two address instructions into true two address instructions. LLVM; provides the pass ``TwoAddressInstructionPass`` for this specific purpose. It; must be run before regis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:66219,avoid,avoiding,66219,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['avoid'],['avoiding']
Safety,"er(c_int(0))``); by ptr-ptr **in** (ex.: ``int**``) ``pointer`` (ex.: ``pointer(c_int(0))``); by ptr-ptr **out** (ex.: ``int**``) ``POINTER`` (ex.: ``POINTER(c_int)()``); ======================================== ========================================. The ``ctypes`` pointer objects (from ``POINTER``, ``pointer``, or ``byref``); can also be used for pass by reference or pointer, instead of the direct; object, and ``ctypes.c_void_p`` can pass through all pointer types.; The addresses will be adjusted internally by cppyy. Note that ``ctypes.c_char_p`` is expected to be a NULL-terminated C string,; not a character array (see the `ctypes module`_ documentation), and that; ``ctypes.c_bool`` is a C ``_Bool`` type, not C++ ``bool``. `Memory`; --------. C++ has three ways of allocating heap memory (``malloc``, ``new``, and; ``new[]``) and three corresponding ways of deallocation (``free``,; ``delete``, and ``delete[]``).; Direct use of ``malloc`` and ``new`` should be avoided for C++ classes, as; these may override ``operator new`` to control their own allocation.; However these low-level allocators can be necessary for builtin types on; occasion if the C++ side takes ownership (otherwise, prefer either; ``array`` from the builtin module ``array`` or ``ndarray`` from Numpy). The low-level module adds the following functions:. * **ll.malloc**: an interface on top of C's malloc.; Use it as a template with the number of elements (not the number types) to; be allocated.; The result is a ``cppyy.LowLevelView`` with the proper type and size:. .. code-block:: python. >>> arr = cppyy.ll.malloc[int](4) # allocates memory for 4 C ints; >>> print(len(arr)); 4; >>> print(type(arr[0])); <type 'int'>; >>>. The actual C malloc can also be used directly, through ``cppyy.gbl.malloc``,; taking the number of *bytes* to be allocated and returning a ``void*``. * **ll.free**: an interface to C's free, to deallocate memory allocated by; C's malloc.; To continue to example above:. .. code-block::",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:9395,avoid,avoided,9395,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['avoid'],['avoided']
Safety,"er. When ROOT compiled with -Droot7=ON flag, one can enable geometry drawing in web browser.; Just apply --web option when starting root like: `root --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really required.; This improves compile times and reduces code inter-dependency; see https://github.com/include-what-you-use/include-what-you-use/blob/maste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7858,abort,abort,7858,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['abort'],['abort']
Safety,"er2) {; if (condition) {; // ... lots of code ...; leak(*pointer1);; } else {; // ... more code ...; leak(*pointer2);; }; }; ```. This would get transformed into something resembling the following:; ```; uintptr_t all_ones_mask = std::numerical_limits<uintptr_t>::max();; uintptr_t all_zeros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; if (condition) {; // Assuming ?: is implemented using branchless logic...; predicate_state = !condition ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predicate_state;; leak(*pointer1);; } else {; predicate_state = condition ? all_zeros_mask : predicate_state;; // ... more code ...; //; // Alternative: Harden the loaded value; int value2 = *pointer2 & predicate_state;; leak(value2);; }; }; ```. The result should be that if the `if (condition) {` branch is mis-predicted,; there is a *data* dependency on the condition used to zero out any pointers; prior to loading through them or to zero out all of the loaded bits. Even; though this code pattern may still execute speculatively, *invalid* speculative; executions are prevented from leaking secret data from memory (but note that; this data might still be loaded in safe ways, and some regions of memory are; required to not hold secrets, see below for detailed limitations). This; approach only requires the underlying hardware have a way to implement a; branchless and unpredicted conditional update of a register's value. All modern; architectures have support for this, and in fact such support is necessary to; correctly implement constant time cryptographic primitives. Crucial properties of this approach:; * It is not preventing any particular side-channel from working. This is; important as there are an unknown number of potential side channels and we; expect to continue discovering more. Instead, it prevents the observation of; secret data",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:4312,predict,predicted,4312,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['predicted']
Safety,"er:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kernels), these approaches require manual and/or static analysis aided auditing; of code and explicit source changes to apply the mitigation. They are unlikely; to scale well to large applications. We are proposing a comprehensive; mitigation approach that would apply automatically across an entire program; rather than through manual changes to the code. While this is likely to have a; high performance cost, some applications may be in a good position to take this; performance / security tradeoff. The specific technique we propose is to cause loads to be checked using; branchless code to ensure that they are executing along a valid control flow; path. Consider the following C-pseudo-code representing the core idea of a; predicate guarding potentially invalid loads:; ```; void leak(int data);; void example(int* pointer1, int* pointer2) {; if (condition) {; // ... lots of code ...; leak(*pointer1);; } else {; // ... more code ...; leak(*pointer2);; }; }; ```. This would get transf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:2474,risk,risky,2474,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['risk'],['risky']
Safety,"ere lost due to passing through a 32 bits temporary long).; Migrate the functionality of TStreamerInfo::TagFile to a new interface TBuffer::TagStreamerInfo; so that TMessage can customize the behavior. TMessage now relies on this new interface; instead of TBuffer::IncrementLevel.; New option to hadd, -O requesting the (re)optimization of the basket size (by avoid the fast merge technique). The equivalent in TFileMerger is to call; merger->SetFastMethod(kFALSE); To make sure that the class emulation layer of ROOT does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. The handling of memory by the collection proxy has been improved in the case of a; collection of pointers which can now become owner of its content. The default, for backward compatibility reasons and to avoid double delete (at the expense; of memory leaks), the container of pointers are still not owning their content; unless they are a free standing container (i.e. itself not contained in another; object).; To make a container of pointers become owner of its content do something like:. TClass::AddRule(""ObjectVector<LHCb::MCRichDigitSummary> m_vector options=Owner"");. Added TKey::Reset and TKey::WriteFileKeepBuffer to allow derived classes (TBasket) to be re-use as key rather than always recreated.; TH1::Streamer and TGraph2D::Streamer no longer reset the kCanDelete bit directly so that the user can give; ownership of the object to the canvas they are stored with. However, if they are saved on their own, the mechanism; that associates them to the current directory (DirectoryAutoAdd) will now reset the bit to avoid any possible; ownsership confusion.; Added TFile::SetOffset and TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); to drastically reduce; the number of fseek done on the physical file when using the TTreeCache.; To support ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:11544,avoid,avoid,11544,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['avoid'],['avoid']
Safety,"erience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what happens when their constructors are treated as opaque.; In the future, we may decide specific containers are ""safe"" to model through; inlining, or choose to model them directly using checkers instead. Basics of Implementation; ------------------------. The low-level mechanism of inlining a function is handled in; ExprEngine::inlineCall and ExprEngine::processCallExit. If the conditions are right for inlining, a CallEnter node is created and added; to the analysis work list. The CallEnter node marks the change to a new; LocationContext representing the called function, and its state includes the; contents of the new stack frame. When the CallEnter node is actually processed,; its single successor will be an edge to the first CFG block in the function. Exiting an inlined function is a bit more work, fortunately broken up into; reasonable steps:. 1. The CoreEngine realizes we're at the end of an inlined call and generates a; CallExitBegin node. 2. ExprEngine takes o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:4717,avoid,avoided,4717,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['avoid'],['avoided']
Safety,"erlying transport protocol to use ""s3:"",; ""s3http:"", ""s3https:"" [""s3"" uses HTTPS]. The current schema, namely; ""as3:"", is supported for backwards compatibility.; - extend support for other S3 service providers that do not offer the; virtual hosting functionality (currently only Amazon offers this).; - support the possibility of specifying user credentials on a per-file; basis or for all S3 files via environment variables.; - honor the ""NOPROXY"" option when specified in the constructor.; - exploit the capability of the S3 file server to provide partial; content responses to multi-range HTTP requests. Here are some examples of usages from the end user perspective:. ``` {.cpp}; TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"", ""AUTH=<accessKey>:<secretKey> NOPROXY""); TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plugin manager; in TFile::Open(). ### New HTTP Server package. A new HTTP Server package has been introduced. The id",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:1566,detect,detect,1566,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,1,['detect'],['detect']
Safety,"ern/doc/master/namespaceROOT_1_1RDF.html#adc17882b283c3d3ba85b1a236197c533) helper function to write out the RDF computation graph as a graphviz file.; - Add a [tutorial for RDataFrame helper functions](https://root.cern/doc/master/df020__helpers_8C.html).; - Throw if name of a custom column is not a valid C++ name.; - Allow every RDataFrame variable be cast to a common type `ROOT::RDF::RNode`.; - Speed up just-in-time compilation (and therefore runtime) of Snapshots with a large number of branches.; - Create names for histograms and graphs based on the input columns if no model is provided.; - RCutFlowReport can print cumulative efficiency of cuts.; - Reading and writing of columns holding `vector<bool>` instances and `bool` C arrays.; - Support `rdfentry_` and `rdfslot_` implicit columns (`tdfentry_` and `tdfslot_` kept for backwards compatibility).; - Remove `RDataFrame` from the 32-bit builds.; - Speed up interpreted usage of RDataFrame (i.e. in macros or from ROOT prompt) by removing certain cling runtime safety checks.; - Streamline and better document usage of multi-thread RDataFrame: edge cases in which processing of an event could start; before processing of another event finished have been removed, making it easier for user to write safe parallel RDF operations.; See the [relevant documentation](https://root.cern.ch/doc/master/classROOT_1_1RDataFrame.html#parallel-execution) for more information. ### TTreeProcessorMT; - Parallelise search of cluster boundaries for input datasets with no friends or TEntryLists. The net effect is a faster initialization time in this common case.; - Handle gracefully the presence of chains the files associated to which are corrupted.; - Reduce number of expensive `TChain::LoadTree` calls by spawning nested TBB tasks to ensure clusters of a given file will be most likely processed by the same thread. ### TTree; - TTrees can be forced to only create new baskets at event cluster boundaries.; This simplifies file layout and I/O a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:9713,safe,safety,9713,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['safe'],['safety']
Safety,"erpret the; stack map record given only the ID, offset, and the order of the; locations, records, and functions, which LLVM preserves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:18158,safe,safe,18158,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['safe'],['safe']
Safety,"error recovery.; When double checking whether a checksum difference is sustantial, ignore the std namespace. Use CompareContent also in the case of where; the class is versioned but the 'current' streamerInfo has not yet been built.; Prevent the I/O engine from mistakenly applying schema evolution to the TObject::fBits.; Make sure that when a streamer info of a base class is used to stream memberwise that is always not-optimized. If the StreamerInfo on file; has the same version as the StreamerInfo in memory but the one on file need to be 'not optimized' while the one in memory is not yet built, make; sure it will not be optimized.; Fix the reading of empty collection of object when reading without the library.; If the sequence of actions for streaming member-wise is not created correctly (i.e. where fReadMemberWise was null previously),; we now explicitly issue a Fatal error:. Fatal in <ReadSequence>: The sequence of actions to read AliESDVertex:7 member-wise was not initialized.; aborting. Add new optional parameter maxbuf to TXMLEngine::ParseFile() allowing the specification of the XML file size to be parsed. This fixes issue #78864.; Add function TBuffer::AutoExpand to centralize the automatic buffer extension policy. This enable the ability to tweak it later (for example instead of always doubling the size, increasing by only at most 2Mb or take hints from the number of entries already; in a TBasket).; Migrate the class TFileMerger from the proofplayer library to ROOT I/O library and update hadd to rely on; TFileMerger for everything but the command line argument parsing.; Fix support for schema evolution from:; TParameter<Int_t>* MyInt; //-> version 1to; TParameter<Int_t> MyInt; // version 2. The TZIPFile compressed archive reader now supports the Zip64 format for; archives and file members greater than 2 and 4 GB, respectively. MakeProject. Add support for the case when the requested project/files in path that in not under the current directory; Generate the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:1484,abort,aborting,1484,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,1,['abort'],['aborting']
Safety,"erruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled, by setting; ``-DGWP_ASAN_DEFAULT_OPTIONS`` to the options string you want set by default.; If you're building GWP-ASan as part of a compiler-rt/LLVM build, add it during; cmake configure time (e.g. ``cmake ... -DGWP_ASAN_DEFAULT_OPTIONS=""...""``). If; you're building GWP-ASan outside of compiler-rt, simply ensure that you; specify ``-DGWP_ASAN_DEFAULT_OPTIONS=""...""`` when building; ``optional/options_parser.cpp``)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4683,detect,detecting,4683,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detecting']
Safety,"ership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; than ``assign``. These modifiers only affect the synthesized getter and; setter; direct accesses to the ivar (even if synthesized) still have primitive; semantics, and the value in the ivar will not be automatically released during; deallocation. .. _arc.ownership.semantics:. Semantics; ---------. There are five :arc-term:`managed operations` which may be performed on an; object of retainable object pointer type. Each qualifier specifies differen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:36445,avoid,avoid,36445,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoid']
Safety,"erval. Similarly, if a function mustn't be called with a null pointer and the; analyzer cannot prove that it is null, then it will assume that it is non-null. These are the possible checks on the values passed as function arguments:; - The argument has an allowed range (or multiple ranges) of values. The checker; can detect if a passed value is outside of the allowed range and show the; actual and allowed values.; - The argument has pointer type and is not allowed to be null pointer. Many; (but not all) standard functions can produce undefined behavior if a null; pointer is passed, these cases can be detected by the checker.; - The argument is a pointer to a memory block and the minimal size of this; buffer is determined by another argument to the function, or by; multiplication of two arguments (like at function ``fread``), or is a fixed; value (for example ``asctime_r`` requires at least a buffer of size 26). The; checker can detect if the buffer size is too small and in optimal case show; the size of the buffer and the values of the corresponding arguments. .. code-block:: c. #define EOF -1; void test_alnum_concrete(int v) {; int ret = isalnum(256); // \; // warning: Function argument outside of allowed range; (void)ret;; }. void buffer_size_violation(FILE *file) {; enum { BUFFER_SIZE = 1024 };; wchar_t wbuf[BUFFER_SIZE];. const size_t size = sizeof(*wbuf); // 4; const size_t nitems = sizeof(wbuf); // 4096. // Below we receive a warning because the 3rd parameter should be the; // number of elements to read, not the size in bytes. This case is a known; // vulnerability described by the ARR38-C SEI-CERT rule.; fread(wbuf, size, nitems, file);; }. int test_alnum_symbolic(int x) {; int ret = isalnum(x);; // after the call, ret is assumed to be in the range [-1, 255]. if (ret > 255) // impossible (infeasible branch); if (x == 0); return ret / x; // division by zero is not reported; return ret;; }. Additionally to the argument and return value conditions, this checker ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:32518,detect,detect,32518,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['detect'],['detect']
Safety,"erwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that represents a bit displacement B. The action is the same as for ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_piece`` *when the piece to; be assembled is not byte-sized or is not at the start of the part location; description.*. *If a computed bit displacement is required, the* ``DW_OP_LLVM_bit_offset``; *operation can be used to update the location description before using it as; the part location description of a*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:136214,avoid,avoid,136214,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoid']
Safety,"es To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can contain a simple; sequence of statements like in the multi command line example given; above, but also arbitrarily complex class and function definitions. The most frequent interaction with the ROOT prompt uses `.x` to ""run"" a file:. ```; root [] .x myScript.C; ```. This loads myScript.C into the interpreter and calls the function `myScript()`.; You can pass arguments using `.x myScript.C(12, ""A String"")`. Alternatively you can load the script and then run a function explicitly:. ```; root [] .L myScript.C; root [] myScript(); ```. The above is equivalent to `.x myScript.C`. In a named script, the objects created on the stack are deleted when; the function exits. In a common scenario you; create a histogram in a named script on the stack. You draw the; histogram, but when the function exits the canvas is empty and the; histogram has disappeared. To avoid the histogram from disappearing you can; create it on the heap (by using new). This will leave the histogram; object intact, but the pointer in the named script scope will be; ""gone"". Since histograms (and trees) are added to the list of objects; in the current directory, you can always retrieve them to delete them; if needed. ``` {.cpp}; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; ```. In addition, histograms and trees are automatically deleted when the; current directory is closed. This will automatically take care of the; clean up. See ""Input/Output"". ### Executing a Script From a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:8470,avoid,avoid,8470,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['avoid'],['avoid']
Safety,"es or LLVM support libraries whenever they are; available for a particular task. LLVM and related projects emphasize and rely; on the standard library facilities and the LLVM support libraries as much as; possible. LLVM support libraries (for example, `ADT; <https://github.com/llvm/llvm-project/tree/main/llvm/include/llvm/ADT>`_); implement specialized data structures or functionality missing in the standard; library. Such libraries are usually implemented in the ``llvm`` namespace and; follow the expected standard interface, when there is one. When both C++ and the LLVM support libraries provide similar functionality, and; there isn't a specific reason to favor the C++ implementation, it is generally; preferable to use the LLVM library. For example, ``llvm::DenseMap`` should; almost always be used instead of ``std::map`` or ``std::unordered_map``, and; ``llvm::SmallVector`` should usually be used instead of ``std::vector``. We explicitly avoid some standard facilities, like the I/O streams, and instead; use LLVM's streams library (raw_ostream_). More detailed information on these; subjects is available in the :doc:`ProgrammersManual`. For more information about LLVM's data structures and the tradeoffs they make,; please consult `that section of the programmer's manual; <https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task>`_. Python version and Source Code Formatting; -----------------------------------------. The current minimum version of Python required is documented in the :doc:`GettingStarted`; section. Python code in the LLVM repository should only use language features; available in this version of Python. The Python code within the LLVM repository should adhere to the formatting guidelines; outlined in `PEP 8 <https://peps.python.org/pep-0008/>`_. For consistency and to limit churn, code should be automatically formatted with; the `black <https://github.com/psf/black>`_ utility, which is PEP 8 compliant.; Use its default ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:4129,avoid,avoid,4129,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6374,recover,recover,6374,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,2,['recover'],"['recover', 'recovery']"
Safety,"es, if they are still held.; // There is no warning if the scope was already unlocked before.; ~MutexLocker() RELEASE() {; if (locked); mut->GenericUnlock();; }. // Acquire all associated mutexes exclusively.; void Lock() ACQUIRE() {; mut->Lock();; locked = true;; }. // Try to acquire all associated mutexes exclusively.; bool TryLock() TRY_ACQUIRE(true) {; return locked = mut->TryLock();; }. // Acquire all associated mutexes in shared mode.; void ReaderLock() ACQUIRE_SHARED() {; mut->ReaderLock();; locked = true;; }. // Try to acquire all associated mutexes in shared mode.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true) {; return locked = mut->ReaderTryLock();; }. // Release all associated mutexes. Warn on double unlock.; void Unlock() RELEASE() {; mut->Unlock();; locked = false;; }. // Release all associated mutexes. Warn on double unlock.; void ReaderUnlock() RELEASE() {; mut->ReaderUnlock();; locked = false;; }; };. #ifdef USE_LOCK_STYLE_THREAD_SAFETY_ATTRIBUTES; // The original version of thread safety analysis the following attribute; // definitions. These use a lock-based terminology. They are still in use; // by existing thread safety code, and will continue to be supported. // Deprecated.; #define PT_GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_var). // Deprecated.; #define GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_var). // Replaced by REQUIRES; #define EXCLUSIVE_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_locks_required(__VA_ARGS__)). // Replaced by REQUIRES_SHARED; #define SHARED_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(shared_locks_required(__VA_ARGS__)). // Replaced by CAPABILITY; #define LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(lockable). // Replaced by SCOPED_CAPABILITY; #define SCOPED_LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). // Replaced by ACQUIRE; #define EXCLUSIVE_LOCK_FUNCTION(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_lock_function(__VA_ARGS__)). // Replaced by ACQUIRE_SHA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:31431,safe,safety,31431,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"es. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX6-GFX9 are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table`. .. table:: AMDHSA Memory Model Code Sequences GFX6-GFX9; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table. =========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:210675,avoid,avoid,210675,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"espective of whether normal (`NDEBUG`-based) assertions are; enabled or not. A version of LLVM built with ABI breaking checks; is not ABI compatible with a version built without it. **LLVM_ADDITIONAL_BUILD_TYPES**:LIST; Adding a semicolon separated list of additional build types to this flag; allows for them to be specified as values in CMAKE_BUILD_TYPE without; encountering a fatal error during the configuration process. **LLVM_UNREACHABLE_OPTIMIZE**:BOOL; This flag controls the behavior of `llvm_unreachable()` in release build; (when assertions are disabled in general). When ON (default) then; `llvm_unreachable()` is considered ""undefined behavior"" and optimized as; such. When OFF it is instead replaced with a guaranteed ""trap"". **LLVM_APPEND_VC_REV**:BOOL; Embed version control revision info (Git revision id).; The version info is provided by the ``LLVM_REVISION`` macro in; ``llvm/include/llvm/Support/VCSRevision.h``. Developers using git who don't; need revision info can disable this option to avoid re-linking most binaries; after a branch switch. Defaults to ON. **LLVM_FORCE_VC_REVISION**:STRING; Force a specific Git revision id rather than calling to git to determine it.; This is useful in environments where git is not available or non-functional; but the VC revision is available through other means. **LLVM_FORCE_VC_REPOSITORY**:STRING; Set the git repository to include in version info rather than calling git to; determine it. **LLVM_BUILD_32_BITS**:BOOL; Build 32-bit executables and libraries on 64-bit systems. This option is; available only on some 64-bit Unix systems. Defaults to OFF. **LLVM_BUILD_BENCHMARKS**:BOOL; Adds benchmarks to the list of default targets. Defaults to OFF. **LLVM_BUILD_DOCS**:BOOL; Adds all *enabled* documentation targets (i.e. Doxgyen and Sphinx targets) as; dependencies of the default build targets. This results in all of the (enabled); documentation targets being as part of a normal build. If the ``install``; target is run then thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:13313,avoid,avoid,13313,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['avoid'],['avoid']
Safety,"esponds to an LLVM IR intrinsic marked `convergent`. .. note::. Unlike SelectionDAG, there is no _VOID variant. Both of these are permitted; to have zero, one, or multiple results. Variadic Arguments; ------------------. G_VASTART; ^^^^^^^^^. .. caution::. I found no documentation for this instruction at the time of writing. G_VAARG; ^^^^^^^. .. caution::. I found no documentation for this instruction at the time of writing. Other Operations; ----------------. G_DYN_STACKALLOC; ^^^^^^^^^^^^^^^^. Dynamically realigns the stack pointer to the specified size and alignment.; An alignment value of `0` or `1` means no specific alignment. .. code-block:: none. %8:_(p0) = G_DYN_STACKALLOC %7(s64), 32. Optimization Hints; ------------------. These instructions do not correspond to any target instructions. They act as; hints for various combines. G_ASSERT_SEXT, G_ASSERT_ZEXT; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This signifies that the contents of a register were previously extended from a; smaller type. The smaller type is denoted using an immediate operand. For scalars, this is the; width of the entire smaller type. For vectors, this is the width of the smaller; element type. .. code-block:: none. %x_was_zexted:_(s32) = G_ASSERT_ZEXT %x(s32), 16; %y_was_zexted:_(<2 x s32>) = G_ASSERT_ZEXT %y(<2 x s32>), 16. %z_was_sexted:_(s32) = G_ASSERT_SEXT %z(s32), 8. G_ASSERT_SEXT and G_ASSERT_ZEXT act like copies, albeit with some restrictions. The source and destination registers must. - Be virtual; - Belong to the same register class; - Belong to the same register bank. It should always be safe to. - Look through the source register; - Replace the destination register with the source register. Miscellaneous; -------------. G_CONSTANT_FOLD_BARRIER; ^^^^^^^^^^^^^^^^^^^^^^^. This operation is used as an opaque barrier to prevent constant folding. Combines; and other transformations should not look through this. These have no other; semantics and can be safely eliminated if a target chooses.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:22470,safe,safe,22470,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,2,['safe'],"['safe', 'safely']"
Safety,"ession; evaluator. External bounds annotations; ---------------------------. Similar to internal bounds annotations, external bound annotations are described; as a typedef to their underlying pointer type in the debug info, and the bounds; are encoded as strings in the typedef’s name (e.g.,; ``__bounds_safety$counted_by:N``). Recognizing ``-fbounds-safety`` traps; -------------------------------------. Clang emits debug info for ``-fbounds-safety`` traps as inlined functions, where; the function name encodes the error message. LLDB implements a frame recognizer; to surface a human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:9864,safe,safety,9864,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['safe'],['safety']
Safety,"etely imported and; should not be cached.; `Issue 64170 <https://github.com/llvm/llvm-project/issues/64170>`_; - Fixed ``hasAnyBase`` not binding nodes in its submatcher.; (`#65421 <https://github.com/llvm/llvm-project/issues/65421>`_); - Fixed a bug where RecursiveASTVisitor fails to visit the; initializer of a bitfield.; `Issue 64916 <https://github.com/llvm/llvm-project/issues/64916>`_; - Fixed a bug where range-loop-analysis checks for trivial copyability,; rather than trivial copy-constructibility; `Issue 47355 <https://github.com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is begin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:57549,recover,recover,57549,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['recover'],['recover']
Safety,"ether a method's return type should be _Nullable or _Nonnull?; Depending on the implementation of the method, this puts you in one of five situations:. You actually never return nil.; You do return nil sometimes, and callers are supposed to handle that. This; includes cases where your method is documented to return nil given certain; inputs.; You return nil based on some external condition (such as an out-of-memory; error), but the client can't do anything about it either.; You return nil only when the caller passes input documented to be invalid.; That means it's the client's fault.; You return nil in some totally undocumented case. In (1) you should annotate the method as returning a _Nonnull; object.; In (2) the method should be marked _Nullable.; In (3) you should probably annotate the method _Nonnull. Why?; Because no callers will actually check for nil, given that they can't do; anything about the situation and don't know what went wrong. At this point; things have gone so poorly that there's basically no way to recover.; The least happy case is (4) because the resulting program will almost; certainly either crash or just silently do the wrong thing.; If this is a new method or you control the callers, you can use; NSParameterAssert() (or the equivalent) to check the precondition and; remove the nil return. But if you don't control the callers and they rely on; this behavior, you should return mark the method _Nonnull and return; nil cast to _Nonnull anyway.; (Note that (4) doesn't apply in cases where the caller can't know they passed; bad parameters. For example,; +[NSData dataWithContentsOfFile:options:error:] will fail if the file; doesn't exist, but there's no way to check for that in advance. This means; you're really in (2).); If you're in (5), document it, then figure out if you're now in (2), (3), or; (4). :-); Q: How do I tell the analyzer that I am intentionally violating nullability?; In some cases, it may make sense for methods to intentionally vi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:5789,recover,recover,5789,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['recover'],['recover']
Safety,"ety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annotations and the (late) parsing logic.; * Internal bounds annotations (wide pointers) and their parsing logic.; * Clang code generation for wide pointers with debug information.; * Pointer cast semantics involving bounds annotations (this could be divided; into multiple sub-PRs).; * CFG analysis for pairs of related pointer and cou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:10905,safe,safety,10905,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"ever, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack maps. Direct Stack Map Entries; ^^^^^^^^^^^^^^^^^^^^^^^^. As shown in :ref:`stackmap-section`, a Direct stack map location; records the address of frame index. This address is itself the value; that the runtime requested. This differs from Indirect locations,; which refer to a stack locations from which the requested values must; be loaded. Direct locations can communicate the address if an alloca,; while Indirect locations handle register spills. For example:. .. code-block:: none. entry:; %a = alloca i64...; llvm.experimental.stackmap(i64 <ID>, i32 <shadowBytes>, ptr %a). The runtime can determine this alloca's relative location on the; stack immediately after compilation, or at any time thereafter. This; differs from Register and Indirect locations, because the runtime can; only read",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:18955,avoid,avoided,18955,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['avoid'],['avoided']
Safety,"ew TLatex(0.01, 0.3, ""Font styles: #^{}bf{#bf{bold}}, #^{}it{#it{italic}}, #^{}bf{#^{}it{#bf{#it{bold italic}}}}, #^{}bf{#^{}bf{#bf{#bf{unbold}}}}""))->Draw();; (new TLatex(0.01, 0.1, ""Font styles: abc#alpha#beta#gamma, #^{}it{#it{abc#alpha#beta#gamma}}, #^{}it{#^{}it{#it{#it{abc#alpha#beta#gamma}}}}""))->Draw();; }. Done by: Oleksandr Grebenyuk <ogrebenyuk@lbl.gov>.; Two new characters: #forall and #exists. TText. New method GetTextAdvance to return the text advance for string; text taking the kerning into account or not. TGaxis. In case of horizontal axis with the font size in pixel (font precision = 3); the labels were not visible.; Alpha numeric labels are not scaled anymore in case of text precision 3; (size in pixels). They are in the other precisions.; Fix a precision issue on Mac. With the following lines the last label; (10^3) did not show:; ; t1 = new TH1F(""test"",""test"", 100,1,1000);; t1.Draw();; gPad->SetLogx(1);; . TPaveStats. The stats painting assumed that the stats position was always defined with; Y2>Y1 and X2>X1. This is true when the stats is created automatically but; might not true if the stats position is given by user. This is now; protected. The stats are correctly drawn whatever the orders of X and Y; coordinates are. ; Saving canvas as a .C macro discarded white title and stat box; background. Same thing with TPaveText. TCutG. IsInside(x,y) is now inherited from TGraph. TCanvas and TPad. In case of Canvas.MoveOpaque = true in $ROOTSYS/etc/system.rootrc; the rubberband was not visible during the zooming along axis.; TPad::SaveAs now takes care of the extensions .pdf],; .pdf[, .pad( and .pdf) to avoid the PS and PDF; mixing when a multiple pages PDF files is generated. To work around this; problem it was enough to specify the option ""pdf"" in SaveAs.; c->BuildLegend() created the legend in the current pad,; not in c (as it should). ; A square TCanvas saved in batch mode in a ROOT file was not square anymore; when displayed in interactive mode. . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html:6973,avoid,avoid,6973,graf2d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html,1,['avoid'],['avoid']
Safety,"exable``; implicitly adds to local variables, while ``__single`` implicitly adds to; pointer types specifying struct fields, function parameters, or global; variables. This means the parser may first create the pointer type without any; default pointer attribute and then recreate the type once the parser has the; declaration context and determined the default attribute accordingly. This also requires the parser to reset the type of the declaration with the; newly created type with the right default attribute. Promotion expression; ====================. A new expression will be introduced to represent the conversion from a pointer; with an external bounds annotation, such as ``__counted_by``, to; ``__bidi_indexable``. This type of conversion cannot be handled by normal; CastExprs because it requires an extra subexpression(s) to provide the bounds; information necessary to create a wide pointer. Bounds check expression; =======================. Bounds checks are part of semantics defined in the ``-fbounds-safety`` language; model. Hence, exposing the bounds checks and other semantic actions in the AST; is desirable. A new expression for bounds checks has been added to the AST. The; bounds check expression has a ``BoundsCheckKind`` to indicate the kind of checks; and has the additional sub-expressions that are necessary to perform the check; according to the kind. Paired assignment check; =======================. ``-fbounds-safety`` enforces that variables or fields related with the same; external bounds annotation (e.g., ``buf`` and ``count`` related with; ``__counted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear repr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:4665,safe,safety,4665,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"f Clang for Windows; that has libFuzzer from; `LLVM Snapshot Builds <https://llvm.org/builds/>`_. Using libFuzzer on Windows without ASAN is unsupported. Building fuzzers with the; ``/MD`` (dynamic runtime library) compile option is unsupported. Support for these; may be added in the future. Linking fuzzers with the ``/INCREMENTAL`` link option; (or the ``/DEBUG`` option which implies it) is also unsupported. Send any questions or comments to the mailing list: libfuzzer(#)googlegroups.com. Q. When libFuzzer is not a good solution for a problem?; ---------------------------------------------------------. * If the test inputs are validated by the target library and the validator; asserts/crashes on invalid inputs, in-process fuzzing is not applicable.; * Bugs in the target library may accumulate without being detected. E.g. a memory; corruption that goes undetected at first and then leads to a crash while; testing another input. This is why it is highly recommended to run this; in-process fuzzer with all sanitizers to detect most bugs on the spot.; * It is harder to protect the in-process fuzzer from excessive memory; consumption and infinite loops in the target library (still possible).; * The target library should not have significant global state that is not; reset between the runs.; * Many interesting target libraries are not designed in a way that supports; the in-process fuzzer interface (e.g. require a file path instead of a; byte array).; * If a single test run takes a considerable fraction of a second (or; more) the speed benefit from the in-process fuzzer is negligible.; * If the target library runs persistent threads (that outlive; execution of one test) the fuzzing results will be unreliable. Q. So, what exactly this Fuzzer is good for?; --------------------------------------------. This Fuzzer might be a good choice for testing libraries that have relatively; small inputs, each input takes < 10ms to run, and the library code is not expected; to crash on in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:29792,detect,detect,29792,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detect']
Safety,"f events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a RooCmdArg to various RooFit functions, such as [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5).; If this happens, please consult the documentation of [fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) to check which of the [free functions in the `RooFit` namespace](https://root.cern/doc/v626/group__CmdArgs.html) you need to use to achieve the desired configuration. **Example** of an error that is now caught at compile time: confusing the [RooAbsPdf::fitTo()]() function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:31018,avoid,avoided,31018,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['avoid'],['avoided']
Safety,"f the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evaluates to 0.; It can be used like this:. .. code-block:: c++. #ifndef __has_cpp_attribute // For backwards compatibility; #define __has_cpp_attribute(x) 0; #endif. ...; #if __has_cpp_attribute(clang::fallthrough); #define FALLTHROUGH [[clang::fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracket syntax in C mode. The argument; can either be a single identifier or a scoped identifier. If the attribute is; supported, a nonzero value is returned. If the attribute is not supported by the; current compilation target, this macro evaluates to 0. It can be used like this:. .. code-block:: c. #ifndef __has_c_attribute // Optional of course.; #define __has_c_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_c_attribute(fallthrough); #define FALLTHROUGH [[fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:6268,avoid,avoid,6268,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"f the first argument to `llvm.coro.suspend` is; token `none`. If a user calls `__builin_suspend`, clang will insert `token none`; as the first argument to the intrinsic. Source location builtins; ------------------------. Clang provides builtins to support C++ standard library implementation; of ``std::source_location`` as specified in C++20. With the exception; of ``__builtin_COLUMN``, ``__builtin_FILE_NAME`` and ``__builtin_FUNCSIG``,; these builtins are also implemented by GCC. **Syntax**:. .. code-block:: c. const char *__builtin_FILE();; const char *__builtin_FILE_NAME(); // Clang only; const char *__builtin_FUNCTION();; const char *__builtin_FUNCSIG(); // Microsoft; unsigned __builtin_LINE();; unsigned __builtin_COLUMN(); // Clang only; const std::source_location::__impl *__builtin_source_location();. **Example of use**:. .. code-block:: c++. void my_assert(bool pred, int line = __builtin_LINE(), // Captures line of caller; const char* file = __builtin_FILE(),; const char* function = __builtin_FUNCTION()) {; if (pred) return;; printf(""%s:%d assertion failed in function %s\n"", file, line, function);; std::abort();; }. struct MyAggregateType {; int x;; int line = __builtin_LINE(); // captures line where aggregate initialization occurs; };; static_assert(MyAggregateType{42}.line == __LINE__);. struct MyClassType {; int line = __builtin_LINE(); // captures line of the constructor used during initialization; constexpr MyClassType(int) { assert(line == __LINE__); }; };. **Description**:. The builtins ``__builtin_LINE``, ``__builtin_FUNCTION``, ``__builtin_FUNCSIG``,; ``__builtin_FILE`` and ``__builtin_FILE_NAME`` return the values, at the; ""invocation point"", for ``__LINE__``, ``__FUNCTION__``, ``__FUNCSIG__``,; ``__FILE__`` and ``__FILE_NAME__`` respectively. ``__builtin_COLUMN`` similarly; returns the column, though there is no corresponding macro. These builtins are; constant expressions. When the builtins appear as part of a default function argument the invocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:148602,abort,abort,148602,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['abort'],['abort']
Safety,"f the program that as they are excluded from the testcase.; These options allow you to choose the; static native code compiler, or a custom command, (see **--exec-command**); respectively. The interpreter and the JIT backends cannot currently; be used as the ""safe"" backends. **--exec-command** *command*. This option defines the command to use with the **--run-custom** and; **--safe-custom** options to execute the bitcode testcase. This can; be useful for cross-compilation. **--compile-command** *command*. This option defines the command to use with the **--compile-custom**; option to compile the bitcode testcase. The command should exit with a; failure exit code if the file is ""interesting"" and should exit with a; success exit code (i.e. 0) otherwise (this is the same as if it crashed on; ""interesting"" inputs). This can be useful for; testing compiler output without running any link or execute stages. To; generate a reduced unit test, you may add CHECK directives to the; testcase and pass the name of an executable compile-command script in this form:. .. code-block:: sh. #!/bin/sh; llc ""$@""; not FileCheck [bugpoint input file].ll < bugpoint-test-program.s. This script will ""fail"" as long as FileCheck passes. So the result; will be the minimum bitcode that passes FileCheck. **--safe-path** *path*. This option defines the path to the command to execute with the; **--safe-{int,jit,llc,custom}**; option. **--verbose-errors**\ =\ *{true,false}*. The default behavior of bugpoint is to print ""<crash>"" when it finds a reduced; test that crashes compilation. This flag prints the output of the crashing; program to stderr. This is useful to make sure it is the same error being; tracked down and not a different error that happens to crash the compiler as; well. Defaults to false. EXIT STATUS; -----------. If **bugpoint** succeeds in finding a problem, it will exit with 0. Otherwise,; if an error occurs, it will exit with a non-zero value. SEE ALSO; --------. :manpage:`opt(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:6031,safe,safe-path,6031,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,2,['safe'],"['safe', 'safe-path']"
Safety,"f:`amdgpu-amdhsa-sgpr-register-set-up-order-table`. .. table:: SGPR Register Set Up Order; :name: amdgpu-amdhsa-sgpr-register-set-up-order-table. ========== ========================== ====== ==============================; SGPR Order Name Number Description; (kernel descriptor enable of; field) SGPRs; ========== ========================== ====== ==============================; First Private Segment Buffer 4 See; (enable_sgpr_private :ref:`amdgpu-amdhsa-kernel-prolog-private-segment-buffer`.; _segment_buffer); then Dispatch Ptr 2 64-bit address of AQL dispatch; (enable_sgpr_dispatch_ptr) packet for kernel dispatch; actually executing.; then Queue Ptr 2 64-bit address of amd_queue_t; (enable_sgpr_queue_ptr) object for AQL queue on which; the dispatch packet was; queued.; then Kernarg Segment Ptr 2 64-bit address of Kernarg; (enable_sgpr_kernarg segment. This is directly; _segment_ptr) copied from the; kernarg_address in the kernel; dispatch packet. Having CP load it once avoids; loading it at the beginning of; every wavefront.; then Dispatch Id 2 64-bit Dispatch ID of the; (enable_sgpr_dispatch_id) dispatch packet being; executed.; then Flat Scratch Init 2 See; (enable_sgpr_flat_scratch :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`.; _init); then Preloaded Kernargs N/A See; (kernarg_preload_spec :ref:`amdgpu-amdhsa-kernarg-preload`.; _length); then Private Segment Size 1 The 32-bit byte size of a; (enable_sgpr_private single work-item's memory; _segment_size) allocation. This is the; value from the kernel; dispatch packet Private; Segment Byte Size rounded up; by CP to a multiple of; DWORD. Having CP load it once avoids; loading it at the beginning of; every wavefront. This is not used for; GFX7-GFX8 since it is the same; value as the second SGPR of; Flat Scratch Init. However, it; may be needed for GFX9-GFX11 which; changes the meaning of the; Flat Scratch Init value.; then Work-Group Id X 1 32-bit work-group id in X; (enable_sgpr_workgroup_id dimension of grid for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:184868,avoid,avoids,184868,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoids']
Safety,"f; optimizations are disabled (``-O0``), if stack objects already exist (for; locals, etc.), or if there are any function calls. - Otherwise, four high numbered SGPRs beginning at a four-aligned SGPR index; are reserved for the tentative scratch V#. These will be used if it is; determined that spilling is needed. - If no use is made of the tentative scratch V#, then it is unreserved,; and the register count is determined ignoring it.; - If use is made of the tentative scratch V#, then its register numbers; are shifted to the first four-aligned SGPR index after the highest one; allocated by the register allocator, and all uses are updated. The; register count includes them in the shifted location.; - In either case, if the processor has the SGPR allocation bug, the; tentative allocation is not shifted or unreserved in order to ensure; the register count is higher to workaround the bug. .. note::. This approach of using a tentative scratch V# and shifting the register; numbers if used avoids having to perform register allocation a second; time if the tentative V# is eliminated. This is more efficient and; avoids the problem that the second register allocation may perform; spilling which will fail as there is no longer a scratch V#. When the kernel prolog code is being emitted it is known whether the scratch V#; described above is actually used. If it is, the prolog code must set it up by; copying the Private Segment Buffer to the scratch V# registers and then adding; the Private Segment Wavefront Offset to the queue base address in the V#. The; result is a V# with a base address pointing to the beginning of the wavefront; scratch backing memory. The Private Segment Buffer is always requested, but the Private Segment; Wavefront Offset is only requested if it is used (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). .. _amdgpu-amdhsa-memory-model:. Memory Model; ~~~~~~~~~~~~. This section describes the mapping of the LLVM memory model onto AMDGPU machine; code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:199901,avoid,avoids,199901,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoids']
Safety,"factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Chec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85053,unsafe,unsafe,85053,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['unsafe'],['unsafe']
Safety,"fe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling; -----------------------------. The `OSDI'14 paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ mentions that; on Linux the instrumentation pass finds calls to setjmp or functions that; may throw an exception, and inserts required instrumentation at their call; sites. Specifically, the instrumentation pass saves the shadow stack pointer; on the safe stack before the cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7699,unsafe,unsafe,7699,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"fect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate earlier variable locations; and let the debugger present ``optimized out`` to the developer. Withholding; these potentially stale variable values from the developer diminishes the; amount of available debug information, but increases the reliability of the; remaining information. To illustrate some potential issues, consider the following example:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); br i1 %cond, label %truebr, label %falsebr; truebr:; %tval = add i32 %bar, 1; call @llvm.dbg.value(metadata i32 %tval, metadata !1, metadata !2); %g1 = call i32 @gazonk(); br label %exit; falsebr:; %fval = add i32 %bar, 2; call @llvm.dbg.value(metadata i32 %fval, metadata !1, metadata !2); %g2 = call i32 @gazonk(); br label %exit; exit:; %merge = phi [ %tval, %tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:19439,redund,redundant,19439,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['redund'],['redundant']
Safety,"fety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20180,safe,safety,20180,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"few deserve mention. If the parsed form of the attribute is more complex, or differs from the; semantic form, the ``HasCustomParsing`` bit can be set to ``1`` for the class,; and the parsing code in `Parser::ParseGNUAttributeArgs(); <https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/ParseDecl.cpp>`_; can be updated for the special case. Note that this only applies to arguments; with a GNU spelling -- attributes with a __declspec spelling currently ignore; this flag and are handled by ``Parser::ParseMicrosoftDeclSpec``. Note that setting this member to 1 will opt out of common attribute semantic; handling, requiring extra implementation efforts to ensure the attribute; appertains to the appropriate subject, etc. If the attribute should not be propagated from a template declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:138745,avoid,avoid,138745,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoid']
Safety,"fferMerger. An excerpt of the; [tutorial](https://github.com/root-project/root/blob/master/tutorials/multicore/mt103_fillNtuples.C); is shown below.; ```{.cpp}; // Create the TBufferMerger; TBufferMerger merger(""mp103_fillNtuple.root"");. // Define what each worker will do; auto work_function = [&]() {; auto f = merger.GetFile();; TNtuple ntrand(""ntrand"", ""Random Numbers"", ""r"");; fill(ntrand, nEventsPerWorker);; ntrand.Write();; f->Write();; };; ```. ## Language Bindings. - Add in PyROOT the converter for std::string_view; - Fix ROOT-8811: pickling of ROOT.Long now works; - Fix ROOT-8809: push_back on a vector of pointers; - Fix ROOT-8805: itemsize was not set on buffers returned by PyROOT functions. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - rlibmap has been removed; it was deprecated for three years.; - Added the CMake exported ROOT libraries into the ROOT:: namespace. In this way, projects based on CMake using ROOT can avoid; conflicts in library target names. As an example, this is the way to build a project consisting of one library and one; executable using ROOT.; ```; find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}). include_directories(${CMAKE_SOURCE_DIR} ${ROOT_INCLUDE_DIRS}); add_definitions(${ROOT_CXX_FLAGS}). ROOT_GENERATE_DICTIONARY(G__Event Event.h LINKDEF EventLinkDef.h). add_library(Event SHARED Event.cxx G__Event.cxx); target_link_libraries(Event ROOT::Hist ROOT::Tree). add_executable(Main MainEvent.cxx); target_link_libraries(Main Event); ```; - Added option `builtin_all` to enable all the built in options.; - For rootcling_stage1 (formerly known as rootcling_tmp), the package structure was changed to enable homogenous visibility; settings across object files. See core/README for an overview.; - Several non-public headers are not copied into include/ anymore; they reside in the PACKAGE/res/ subdirectory in the source tree.; - The IMT switch is set to on by default.; - A new",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:17687,avoid,avoid,17687,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoid']
Safety,"fficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred method to proxy a C++ address,; and lives in ``cppyy``, not ``cppyy.ll``, as it is not a low-level C++; cast, but a ``cppyy`` API that is also used internally.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1323,avoid,avoid,1323,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['avoid'],['avoid']
Safety,"ffsets to a; live frame pointer to recover the address of the allocation. The offset is; computed during frame layout of the caller of ``llvm.localescape``. Arguments:; """""""""""""""""""". All arguments to '``llvm.localescape``' must be pointers to static allocas or; casts of static allocas. Each function can only call '``llvm.localescape``'; once, and it can only do so from the entry block. The ``func`` argument to '``llvm.localrecover``' must be a constant; bitcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It is zero-indexed. Semantics:; """""""""""""""""""". These intrinsics allow a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:514612,recover,recover,514612,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recover']
Safety,"fied version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-specified ISA naming strings (e.g. ``-march``). We are actively deciding not to support multiple specification revisions; at this time. We acknowledge a likely future need, but actively defer the; decisions making around handling this until we have a concrete example of; real hardware having shipped and an incompatible change to the; specification made afterwards. Base ISAs; =========. The specification defines five base instruction sets: RV32I, RV32E, RV64I,; RV64E, and RV128I.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:1528,avoid,avoid,1528,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst,1,['avoid'],['avoid']
Safety,"figure how LLVM should be built on your system,. - ninja: runs the C++ compiler to (re)build specific parts of LLVM,. - python: to run the LLVM tests,. As an example, on Ubuntu:. .. code:: console. $ sudo apt-get install git clang cmake ninja-build python arcanist. Building LLVM; =============. Checkout; --------. The source code is stored `on; Github <https://github.com/llvm/llvm-project>`__ in one large repository; (""the monorepo""). It may take a while to download!. .. code:: console. $ git clone https://github.com/llvm/llvm-project.git. This will create a directory ""llvm-project"" with all of the source; code. (Checking out anonymously is OK - pushing commits uses a different; mechanism, as we'll see later.). Configure your workspace; ------------------------. Before we can build the code, we must configure exactly how to build it; by running CMake. CMake combines information from three sources:. - explicit choices you make (is this a debug build?). - settings detected from your system (where are libraries installed?). - project structure (which files are part of 'clang'?). First, create a directory to build in. Usually, this is; llvm-project/build. .. code:: console. $ mkdir llvm-project/build; $ cd llvm-project/build. Now, run CMake:. .. code:: console. $ cmake -G Ninja ../llvm -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=clang. If all goes well, you'll see a lot of ""performing test"" lines, and; finally:. .. code:: console. Configuring done; Generating done; Build files have been written to: /path/llvm-project/build. And you should see a build.ninja file. Let's break down that last command a little:. - **-G Ninja**: we're going to use ninja to build; please create; build.ninja. - **../llvm**: this is the path to the source of the ""main"" LLVM; project. - The two **-D** flags set CMake variables, which override; CMake/project defaults:. - **CMAKE_BUILD_TYPE=Release**: build in optimized mode, which is; (surprisingly) the fastest option. If you want to run unde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:2529,detect,detected,2529,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['detect'],['detected']
Safety,"files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:1381,detect,detecting,1381,geom/gdml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md,1,['detect'],['detecting']
Safety,"finalize state; for the ``MaterializationResponsibility`` if needed. .. code-block:: c++. Error notifyEmitted(MaterializationResponsibility &MR). * ``notifyFailed`` is called if the link fails at any point. It can be; overridden to react to the failure (e.g. to deallocate any already allocated; resources). .. code-block:: c++. Error notifyFailed(MaterializationResponsibility &MR). * ``notifyRemovingResources`` is called when a request is made to remove any; resources associated with the ``ResourceKey`` *K* for the; ``MaterializationResponsibility``. .. code-block:: c++. Error notifyRemovingResources(ResourceKey K). * ``notifyTransferringResources`` is called if/when a request is made to; transfer tracking of any resources associated with ``ResourceKey``; *SrcKey* to *DstKey*. .. code-block:: c++. void notifyTransferringResources(ResourceKey DstKey,; ResourceKey SrcKey). Plugin authors are required to implement the ``notifyFailed``,; ``notifyRemovingResources``, and ``notifyTransferringResources`` methods in; order to safely manage resources in the case of resource removal or transfer,; or link failure. If no resources are managed by the plugin then these methods; can be implemented as no-ops returning ``Error::success()``. Plugin instances are added to an ``ObjectLinkingLayer`` by; calling the ``addPlugin`` method [1]_. E.g. .. code-block:: c++. // Plugin class to print the set of defined symbols in an object when that; // object is linked.; class MyPlugin : public ObjectLinkingLayer::Plugin {; public:. // Add passes to print the set of defined symbols after dead-stripping.; void modifyPassConfig(MaterializationResponsibility &MR,; const Triple &TT,; jitlink::PassConfiguration &Config) override {; Config.PostPrunePasses.push_back([this](jitlink::LinkGraph &G) {; return printAllSymbols(G);; });; }. // Implement mandatory overrides:; Error notifyFailed(MaterializationResponsibility &MR) override {; return Error::success();; }; Error notifyRemovingResources(ResourceKey ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:4459,safe,safely,4459,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['safe'],['safely']
Safety,"fine void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not yet documented; here. Supported Architectures; =======================. Support for statepoint generation requires some code for each backend.; Today, only Aarch64 and X86_64 are supported. .. _OpenWork:. Limitations and Half Baked Ideas; ================================. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:33030,safe,safepoint,33030,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"fined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76618,recover,recover,76618,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recover']
Safety,"floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108556,redund,redundant,108556,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['redund'],['redundant']
Safety,"for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; library features LLVM should use; avoid miscompiles in particular compiler; versions, etc).; - Detail downsides on important platforms (e.g. Ubuntu LTS status). * Once the RFC reaches consensus, update the CMake toolchain version checks as; well as the :doc:`getting started<GettingStarted>` guide. This provides a; softer transition path for developers compiling LLVM, because the; error can be turned into a warning using a CMake flag. This is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the soft-error into a hard-error after said LLVM release has branched. * Update the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new feature",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:34634,avoid,avoid,34634,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['avoid'],['avoid']
Safety,"for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via using the following scripts. Similarly to the local environment, configuration is split in different files; to allow for a system-wide configuration, which has precedence over; user's configuration in the home directory. If a script cannot be found,; it will be silently skipped. - `<output_of_payload>`. - `common.before`. - `remote.before`. - `remote.conf`. - `common.after`. - `remote.after`. For an explanation on how to pass extra data to the workers safely; through the payload, see below. ### Payload: sending local files to the remote nodes. In many cases it is necessary to send some local data to the remote; workers: it is very common, for instance, to distribute a local Grid; authentication proxy on the remote workers to let them authenticate to; access a data storage. The `payload` file must be an executable generating some output that; will be prepended to the remote environment preparation. Differently; than the other environment scripts, it is not executed: instead, it is; first run, then *the output it produces will be executed*. Let's see a practical example to better understand how it works. We need; to send our Grid proxy to the master node. This is our `payload` executable script:. ``` {.bash}; #!/bin/bash; echo ""echo '`cat /tmp/x509up_u$UID | base64 | tr -d '\r\n'`'"" \; ""| base64 -d > /tmp/x509up_u\$UID""; ```. This script will be executed locally, providing another ""script line"" as; output:. ``` {.bash}; ech",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:4986,safe,safely,4986,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['safe'],['safely']
Safety,"fp. v2, v3, v2; mfcr r3, 2; rlwinm r3, r3, 25, 31, 31; cmpwi cr0, r3, 0; bne cr0, LBB1_2 ; entry; LBB1_1: ; entry; mr r6, r5; LBB1_2: ; entry; mr r3, r6; mtspr 256, r2; blr. //===----------------------------------------------------------------------===//. CodeGen/PowerPC/vec_constants.ll has an and operation that should be; codegen'd to andc. The issue is that the 'all ones' build vector is; SelectNodeTo'd a VSPLTISB instruction node before the and/xor is selected; which prevents the vnot pattern from matching. //===----------------------------------------------------------------------===//. An alternative to the store/store/load approach for illegal insert element ; lowering would be:. 1. store element to any ol' slot; 2. lvx the slot; 3. lvsl 0; splat index; vcmpeq to generate a select mask; 4. lvsl slot + x; vperm to rotate result into correct slot; 5. vsel result together. //===----------------------------------------------------------------------===//. Should codegen branches on vec_any/vec_all to avoid mfcr. Two examples:. #include <altivec.h>; int f(vector float a, vector float b); {; int aa = 0;; if (vec_all_ge(a, b)); aa |= 0x1;; if (vec_any_ge(a,b)); aa |= 0x2;; return aa;; }. vector float f(vector float a, vector float b) { ; if (vec_any_eq(a, b)) ; return a; ; else ; return b; ; }. //===----------------------------------------------------------------------===//. We should do a little better with eliminating dead stores.; The stores to the stack are dead since %a and %b are not needed. ; Function Attrs: nounwind; define <16 x i8> @test_vpmsumb() #0 {; entry:; %a = alloca <16 x i8>, align 16; %b = alloca <16 x i8>, align 16; store <16 x i8> <i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15, i8 16>, <16 x i8>* %a, align 16; store <16 x i8> <i8 113, i8 114, i8 115, i8 116, i8 117, i8 118, i8 119, i8 120, i8 121, i8 122, i8 123, i8 124, i8 125, i8 126, i8 127, i8 112>, <16 x i8>* %b, align 16; %0 = load <16 x i8>*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:5542,avoid,avoid,5542,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,1,['avoid'],['avoid']
Safety,"frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:40257,detect,detect,40257,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['detect'],['detect']
Safety,"from RooFit and; then it translates that into a single piece of code (a C++ function), that can; then be differentiated using Clad. It also helps evaluate the model. In RooFit, evaluation is done using the 'evaluate()' function. It also; performs a lot of book-keeping, caching, etc. that is required for RooFit (but; not necessarily for AD). A new `translate()` function is added to RooFit classes that includes a call; to this `evaluate()` function. `translate()` helps implement the Code; Squashing logic. All RooFit classes that should support AD need to use this; function. It creates a string of code, which is then just-in-time compiled; using Cling (C++ interpreter for ROOT). For each of the `translate()`; functions, it is important to call `addResult()` since this is what enables; the squashing to happen. #### Helper Functions. - **RooFit::Detail::CodeSquashContext**: this class maintains the context for squashing of; RooFit models into code. It keeps track of the results of various; expressions to avoid redundant calculations. - **Loop Scopes()**: `beginloop()` and `endloop()` are used to create a scope; for iterating over vector observables (collections of data). This is; especially useful when dealing with data that comes in sets or arrays. - **addToGlobalScope()**: helps add code statements to the global scope; (e.g., to declare variables). - **addToCodeBody()**: adds the input string to the squashed code body. If a; class implements a translate function that wants to emit something to the; squashed code body, it must call this function with the code it wants to; emit. In case of loops, it automatically determines if the code needs to be; stored inside or outside the scope of that loop. - **makeValidVarName()**: takes a string (e.g., a variable name) and converts; it into a valid C++ variable name by replacing any forbidden characters with; underscores. - **buildArg()**: helps convert RooFit objects into arrays or other C++; representations for efficient computa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:31321,avoid,avoid,31321,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"from_indexable(T, PTR [, PTR_TO_TERM])`` casts any; safe pointer PTR to a ``__terminated_by(T)`` pointer. ``PTR_TO_TERM`` is an; optional argument where the programmer can provide the exact location of the; terminator. With this argument, the function can skip reading the entire; array in order to locate the end of the pointer (or the upper bound).; Providing an incorrect ``PTR_TO_TERM`` causes a run-time trap. + ``__unsafe_forge_terminated_by(T, P, E)`` creates ``T __terminated_by(E)``; pointer given any pointer ``P``. Tmust be a pointer type. Portability with toolchains that do not support the extension; -------------------------------------------------------------. The language model is designed so that it doesn't alter the semantics of the; original C program, other than introducing deterministic traps where otherwise; the behavior is undefined and/or unsafe. Clang provides a toolchain header; (``ptrcheck.h``) that macro-defines the annotations as type attributes when; ``-fbounds-safety`` is enabled and defines them to empty when the extension is; disabled. Thus, the code adopting ``-fbounds-safety`` can compile with; toolchains that do not support this extension, by including the header or adding; macros to define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ================================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:45539,safe,safety,45539,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requires a combination of language design, runtime; support, and often operating system support. It is certainly possible to implement a safe language in LLVM, but LLVM; IR does not itself guarantee safety. The LLVM IR allows unsafe pointer; casts, use after free bugs, buffer over-runs, and a variety of other; problems. Safety needs to be implemented as a layer on top of LLVM and,; conveniently, several groups have investigated this. Ask on the `LLVM; forums <https://discourse.llvm.org>`_ if you are interested in more details. Language-Specific Optimizations; -------------------------------. One thing about LLVM that turns off many people is that it does not; solve all the world's problems in one system. One specific; complaint is that people perceive LLVM as being incapable of performing; high-level language-specific optimization: LLVM ""loses too much; information"". Here are a few observations about this:. First, you're right that LLVM does lose information. For example, as of; this writing, there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:8339,unsafe,unsafe,8339,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['unsafe'],['unsafe']
Safety,"function entry block, 0 otherwise.; }. Tracing PCs; ===========. With ``-fsanitize-coverage=trace-pc`` the compiler will insert; ``__sanitizer_cov_trace_pc()`` on every edge.; With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call.; These callbacks are not implemented in the Sanitizer run-time and should be defined; by the user.; This mechanism is used for fuzzing the Linux kernel; (https://github.com/google/syzkaller). Instrumentation points; ======================; Sanitizer Coverage offers different levels of instrumentation. * ``edge`` (default): edges are instrumented (see below).; * ``bb``: basic blocks are instrumented.; * ``func``: only the entry block of every function will be instrumented. Use these flags together with ``trace-pc-guard`` or ``trace-pc``,; like this: ``-fsanitize-coverage=func,trace-pc-guard``. When ``edge`` or ``bb`` is used, some of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:7895,redund,redundant,7895,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['redund'],['redundant']
Safety,"function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81880,avoid,avoid,81880,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"fval, %falsebr ]; %g = phi [ %g1, %truebr ], [ %g2, %falsebr ]; call @llvm.dbg.value(metadata i32 %merge, metadata !1, metadata !2); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %plusten = add i32 %merge, 10; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. Containing two source-level variables in ``!1`` and ``!3``. The function could,; perhaps, be optimized into the following code:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; %g = call i32 @gazonk(); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; ret i32 %toret; }. What ``llvm.dbg.value`` intrinsics should be placed to represent the original variable; locations in this code? Unfortunately the second, third and fourth; dbg.values for ``!1`` in the source function have had their operands; (%tval, %fval, %merge) optimized out. Assuming we cannot recover them, we; might consider this placement of dbg.values:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. However, this will cause ``!3`` to have the return value of ``@gazonk()`` at; the same time as ``!1`` has the constant value zero -- a pair of assignments; that never occurred in the unoptimized program. To avoid this, we must terminate; the range that ``!1`` has the constant value assignment by inserting a poison; dbg.value before the dbg.value for ``!3``:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:21412,recover,recover,21412,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['recover'],['recover']
Safety,"g a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4616,detect,detection,4616,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['detect'],['detection']
Safety,"g a linear congruential random; generator. The multipliers used are the same of the BSD `rand()` random; generator. Its sequence is:. $x_{n+1} = (ax_n + c) mod m$ with $a =1103515245$,; $c = 12345$ and $m =2^{31}$. This type of generator uses a state of only a 32 bit integer and it has; a very short period, 2^31^,about 10^9^, which can be exhausted in just; few seconds. The quality of this generator is therefore BAD and it is; strongly recommended to NOT use for any statistical study. ### TRandom1. This random number generator is based on the Ranlux engine, developed by; M. Lüsher and implemented in Fortran by F. James. This engine has; mathematically proven random proprieties and a long period of about; 10^171^. Various luxury levels are provided `(1,2,3,4)` and can be; specified by the user in the constructor. Higher the level, better; random properties are obtained at a price of longer CPU time for; generating a random number. The level 3 is the default, where any; theoretical possible correlation has very small chance of being; detected. This generator uses a state of 24 32-bits words. Its main; disadvantage is that is much slower than the others (see timing table).; For more information on the generator see the following article:. - F. James, ""RANLUX: A Fortran implementation of the high quality; pseudo-random number generator of Lüscher"", Computer Physics; Communication, 79 (1994) 111. ### TRandom2. This generator is based on the maximally equi-distributed combined; Tausworthe generator by L'Ecuyer. It uses only 3 32-bits words for the; state and it has a period of about 10^26^. It is fast and given its; small states, it is recommended for applications, which require a very; small random number size. For more information on the generator see the; following article:. - P. L'Ecuyer, ""Maximally Equi-distributed Combined Tausworthe; Generators"", Mathematics of Computation, 65, 213 (1996), 203-213. ### TRandom3. This is based on the Mersenne and Twister pseudo-rand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:11869,detect,detected,11869,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['detect'],['detected']
Safety,"g from the old instruction number /; operand pair to new instruction number / operand pair. Consider if we replace; a three-address add instruction with a two-address add:. ```text; %2:gr32 = ADD32rr %0, %1, debug-instr-number 1; ```. becomes. ```text; %2:gr32 = ADD32rr %0(tied-def 0), %1, debug-instr-number 2; ```. With a substitution from ""instruction number 1 operand 0"" to ""instruction number; 2 operand 0"" recorded in the `MachineFunction`. In `LiveDebugValues`,; `DBG_INSTR_REF`s will be mapped through the substitution table to find the most; recent instruction number / operand number of the value it refers to. Use `MachineFunction::substituteDebugValuesForInst` to automatically produce; substitutions between an old and new instruction. It assumes that any operand; that is a def in the old instruction is a def in the new instruction at the; same operand position. This works most of the time, for example in the example; above. If operand numbers do not line up between the old and new instruction, use; `MachineInstr::getDebugInstrNum` to acquire the instruction number for the new; instruction, and `MachineFunction::makeDebugValueSubstitution` to record the; mapping between register definitions in the old and new instructions. If some; values computed by the old instruction are no longer computed by the new; instruction, record no substitution -- `LiveDebugValues` will safely drop the; now unavailable variable value. Should your target clone instructions, much the same as the `TailDuplicator`; optimisation pass, do not attempt to preserve the instruction numbers or; record any substitutions. `MachineFunction::CloneMachineInstr` should drop the; instruction number of any cloned instruction, to avoid duplicate numbers; appearing to `LiveDebugValues`. Dealing with duplicated instructions is a; natural extension to instruction referencing that's currently unimplemented. [LiveDebugValues]: project:SourceLevelDebugging.rst#LiveDebugValues expansion of variable locations; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:8689,safe,safely,8689,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,2,"['avoid', 'safe']","['avoid', 'safely']"
Safety,"g it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:150959,avoid,avoid,150959,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoid']
Safety,"g report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfering with gRandom (bug 83021).; Now the same random sequence is always used for drawing the same histograms, giving therefore exactly the same scatter plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:1988,avoid,avoid,1988,hist/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html,1,['avoid'],['avoid']
Safety,"g): Determines whether a; reference of type ``T`` bound to an expression of type ``U`` would bind to a; materialized temporary object. If ``T`` is not a reference type the result; is false. Note this trait will also return false when the initialization of; ``T`` from ``U`` is ill-formed.; Deprecated, use ``__reference_constructs_from_temporary``.; * ``__reference_constructs_from_temporary(T, U)`` (C++); Returns true if a reference ``T`` can be constructed from a temporary of type; a non-cv-qualified ``U``.; * ``__underlying_type`` (C++, GNU, Microsoft). In addition, the following expression traits are supported:. * ``__is_lvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is an lvalue expression.; Deprecated, use ``__is_lvalue_reference(decltype((e)))`` instead.; * ``__is_rvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is a prvalue expression.; Deprecated, use ``!__is_reference(decltype((e)))`` instead. There are multiple ways to detect support for a type trait ``__X`` in the; compiler, depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:65322,detect,detect,65322,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['detect'],['detect']
Safety,"g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the start of the; guard region in TLS and deallocate the entire guard region including the; shadow call stack at thread exit. This is considered acceptable given that; the address of the start of the guard region is already somewhat guessable. One way in which the address of the shadow call stack could leak is in the; ``jmp_buf`` data structure used by ``setjmp`` and ``longjmp``. The Android; runtime `avoids this`_ by only storing the low bits of ``SCSReg`` in the; ``jmp_buf``, which requires the address of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one may need to execute different code depending on whether; ShadowCallStack is enabled. The macro ``__has_feature",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:7838,avoid,avoids,7838,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoids']
Safety,"g.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the wrong thing. //===---------------------------------------------------------------------===//. It would be really nice to be able to write patterns in .td files for copies,; which would eliminate a bunch of explicit predicates on them (e.g. no side; effects). Once this is in place, it would be even better to have tblgen; synthesize the various copy insertion/inspection methods in TargetInstrInfo. //===---------------------------------------------------------------------===//. Stack coloring improvements:. 1. Do proper LiveStacks analysis on all stack objects including those which are; not spill slots.; 2. Reorder objects to fill in gaps between objects.; e.g. 4, 1, <gap>, 4, 1, 1, 1, <gap>, 4 => 4, 1, 1, 1, 1, 4, 4. //===---------------------------------------------------------------------===//. The scheduler should be able to sort nearby instructions by their address. For; example, in an expanded memset sequence it's not uncommon to see code like this:. movl $0, 4(%rdi); movl $0, 8(%rdi); movl $0, 12(%rdi); movl $0, 0(%rdi). Each of the stores is independent, and the scheduler is currently making an; arbitrary decision about the order. //===---------------------------------------------------------------------===//. Another opportunitiy in this code is that the $0 could be moved to a register:. movl $0, 4(%rdi); movl $0, 8(%rdi); movl $0, 12(%rdi); movl $0, 0(%rdi). This would save substantial code size, especially for longer sequences like; this. It would be easy to have a rule telling isel to avoid matching MOV32mi; if the immediate has more than some fixed number of uses. It's more involved; to teach the register allocator how to do late folding to recover from; excessive register pressure. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:5942,avoid,avoid,5942,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,2,"['avoid', 'recover']","['avoid', 'recover']"
Safety,"g; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37883,detect,detects,37883,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['detect'],['detects']
Safety,"gInfoMetadata.h`` and the implementations of the; helper functions in ``lib/IR/DIBuilder.cpp``. C/C++ source file information; -----------------------------. ``llvm::Instruction`` provides easy access to metadata attached with an; instruction. One can extract line number information encoded in LLVM IR using; ``Instruction::getDebugLoc()`` and ``DILocation::getLine()``. .. code-block:: c++. if (DILocation *Loc = I->getDebugLoc()) { // Here I is an LLVM instruction; unsigned Line = Loc->getLine();; StringRef File = Loc->getFilename();; StringRef Dir = Loc->getDirectory();; bool ImplicitCode = Loc->isImplicitCode();; }. When the flag ImplicitCode is true then it means that the Instruction has been; added by the front-end but doesn't correspond to source code written by the user. For example. .. code-block:: c++. if (MyBoolean) {; MyObject MO;; ...; }. At the end of the scope the MyObject's destructor is called but it isn't written; explicitly. This information is useful to avoid to have counters on brackets when; making code coverage. C/C++ global variable information; ---------------------------------. Given an integer global variable declared as follows:. .. code-block:: c. _Alignas(8) int MyGlobal = 100;. a C/C++ front-end would generate the following descriptors:. .. code-block:: text. ;;; ;; Define the global itself.; ;;; @MyGlobal = global i32 100, align 8, !dbg !0. ;;; ;; List of debug info of globals; ;;; !llvm.dbg.cu = !{!1}. ;; Some unrelated metadata.; !llvm.module.flags = !{!6, !7}; !llvm.ident = !{!8}. ;; Define the global variable itself; !0 = distinct !DIGlobalVariable(name: ""MyGlobal"", scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64). ;; Define the compile unit.; !1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,; producer: ""clang version 4.0.0"",; isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,; enums: !3, globals: !4). ;;; ;; Define the file; ;;; !2 = !DIFile(filename: ""/dev/stdin"",; direc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:42453,avoid,avoid,42453,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"gReport. BugType, as the name would suggest, represents a type of bug. The; constructor for BugType takes two parameters: The name of the bug; type, and the name of the category of the bug. These are used (e.g.) in the; summary page generated by the scan-build tool. The BugReport class represents a specific occurrence of a bug. In; the most common case, three parameters are used to form a BugReport:. The type of bug, specified as an instance of the BugType class.; A short descriptive string. This is placed at the location of the bug in; the detailed line-by-line output generated by scan-build.; The context in which the bug occurred. This includes both the location of; the bug in the program and the program's state when the location is reached. These are; both encapsulated in an ExplodedNode. In order to obtain the correct ExplodedNode, a decision must be made; as to whether or not analysis can continue along the current path. This decision; is based on whether the detected bug is one that would prevent the program under; analysis from continuing. For example, leaking of a resource should not stop; analysis, as the program can continue to run after the leak. Dereferencing a; null pointer, on the other hand, should stop analysis, as there is no way for; the program to meaningfully continue after such an error. If analysis can continue, then the most recent ExplodedNode; generated by the checker can be passed to the BugReport constructor; without additional modification. This ExplodedNode will be the one; returned by the most recent call to CheckerContext::addTransition.; If no transition has been performed during the current callback, the checker should call CheckerContext::addTransition(); and use the returned node for bug reporting. If analysis can not continue, then the current state should be transitioned; into a so-called sink node, a node from which no further analysis will be; performed. This is done by calling the ; CheckerContext::generateSink function; this f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:16781,detect,detected,16781,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['detect'],['detected']
Safety,"generated, and that supports performance measurements.; However, it is possible to stop at some stage before measuring. Choices are:; * ``prepare-snippet``: Only generate the minimal instruction sequence.; * ``prepare-and-assemble-snippet``: Same as ``prepare-snippet``, but also dumps an excerpt of the sequence (hex encoded).; * ``assemble-measured-code``: Same as ``prepare-and-assemble-snippet``. but also creates the full sequence that can be dumped to a file using ``--dump-object-to-disk``.; * ``measure``: Same as ``assemble-measured-code``, but also runs the measurement. .. option:: --x86-lbr-sample-period=<nBranches/sample>. Specify the LBR sampling period - how many branches before we take a sample.; When a positive value is specified for this option and when the mode is `latency`,; we will use LBRs for measuring.; On choosing the ""right"" sampling period, a small value is preferred, but throttling; could occur if the sampling is too frequent. A prime number should be used to; avoid consistently skipping certain blocks. .. option:: --x86-disable-upper-sse-registers. Using the upper xmm registers (xmm8-xmm15) forces a longer instruction encoding; which may put greater pressure on the frontend fetch and decode stages,; potentially reducing the rate that instructions are dispatched to the backend,; particularly on older hardware. Comparing baseline results with this mode; enabled can help determine the effects of the frontend and can be used to; improve latency and throughput estimates. .. option:: --repetition-mode=[duplicate|loop|min]. Specify the repetition mode. `duplicate` will create a large, straight line; basic block with `num-repetitions` instructions (repeating the snippet; `num-repetitions`/`snippet size` times). `loop` will, optionally, duplicate the; snippet until the loop body contains at least `loop-body-size` instructions,; and then wrap the result in a loop which will execute `num-repetitions`; instructions (thus, again, repeating the snippet; `num",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:11751,avoid,avoid,11751,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['avoid'],['avoid']
Safety,"get specific predefined macros or/and language version; predefined macros (see `feature/extension preprocessor macros defined in; opencl-c-base.h; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Headers/opencl-c-base.h>`__). **Pragmas**. Some extensions alter standard parsing dynamically via pragmas. Clang provides a mechanism to add the standard extension pragma; ``OPENCL EXTENSION`` by setting a dedicated flag in the extension list entry of; ``OpenCLExtensions.def``. Note that there is no default behavior for the; standard extension pragmas as it is not specified (for the standards up to and; including version 3.0) in a sufficient level of detail and, therefore,; there is no default functionality provided by clang. Pragmas without detailed information of their behavior (e.g. an explanation of; changes it triggers in the parsing) should not be added to clang. Moreover, the; pragmas should provide useful functionality to the user. For example, such; functionality should address a practical use case and not be redundant i.e.; cannot be achieved using existing features. Note that some legacy extensions (published prior to OpenCL 3.0) still; provide some non-conformant functionality for pragmas e.g. add diagnostics on; the use of types or functions. This functionality is not guaranteed to remain in; future releases. However, any future changes should not affect backward; compatibility. .. _opencl_addrsp:. Address spaces attribute; ------------------------. Clang has arbitrary address space support using the ``address_space(N)``; attribute, where ``N`` is an integer number in the range specified in the; Clang source code. This addresses spaces can be used along with the OpenCL; address spaces however when such addresses spaces converted to/from OpenCL; address spaces the behavior is not governed by OpenCL specification. An OpenCL implementation provides a list of standard address spaces using; keywords: ``private``, ``local``, ``global``, and ``generic``. In th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:11142,redund,redundant,11142,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['redund'],['redundant']
Safety,"gh LLVM's struct types and reason about the; underlying memory offsets. The community realized that pointee types hinder LLVM; development, rather than helping it. Some of the initially proposed high-level; optimizations have evolved into `TBAA; <https://llvm.org/docs/LangRef.html#tbaa-metadata>`_ due to limitations with; representing higher-level language information directly via SSA values. Pointee types provide some value to frontends because the IR verifier uses types; to detect straightforward type confusion bugs. However, frontends also have to; deal with the complexity of inserting bitcasts everywhere that they might be; required. The community consensus is that the costs of pointee types; outweight the benefits, and that they should be removed. Many operations do not actually care about the underlying type. These; operations, typically intrinsics, usually end up taking an arbitrary pointer; type ``i8*`` and sometimes a size. This causes lots of redundant no-op bitcasts; in the IR to and from a pointer with a different pointee type. No-op bitcasts take up memory/disk space and also take up compile time to look; through. However, perhaps the biggest issue is the code complexity required to; deal with bitcasts. When looking up through def-use chains for pointers it's; easy to forget to call `Value::stripPointerCasts()` to find the true underlying; pointer obfuscated by bitcasts. And when looking down through def-use chains; passes need to iterate through bitcasts to handle uses. Removing no-op pointer; bitcasts prevents a category of missed optimizations and makes writing LLVM; passes a little bit easier. Fewer no-op pointer bitcasts also reduces the chances of incorrect bitcasts in; regards to address spaces. People maintaining backends that care a lot about; address spaces have complained that frontends like Clang often incorrectly; bitcast pointers, losing address space information. An analogous transition that happened earlier in LLVM is integer signedness.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:3675,redund,redundant,3675,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['redund'],['redundant']
Safety,"gma(""clang abi_ptr_attr set(bidi_indexable)""). #define __ptrcheck_abi_assume_unsafe_indexable() \; _Pragma(""clang abi_ptr_attr set(unsafe_indexable)""). ABI implications of default bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although simply modifying types of a local variable doesn't normally impact the; ABI, taking the address of such a modified type could create a pointer type that; has an ABI mismatch. Looking at the following example, ``int *local`` is; implicitly ``int *__bidi_indexable`` and thus the type of ``&local`` is a; pointer to ``int *__bidi_indexable``. On the other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:24165,safe,safety,24165,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"gnal programmer error and; are not intended to be recovered from. Making code exceptions-safe by; default would impose severe runtime and code size penalties on code that; typically does not actually care about exceptions safety. Therefore,; ARC-generated code leaks by default on exceptions, which is just fine if the; process is going to be immediately terminated anyway. Programs which do care; about recovering from exceptions should enable the option. In Objective-C++, ``-fobjc-arc-exceptions`` is enabled by default. .. admonition:: Rationale. C++ already introduces pervasive exceptions-cleanup code of the sort that ARC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to be corruption of the Objective-C runtime, so we want to be safer; here. Of course, potentially massive leaks are about as likely to take down; the process as this corruption is if the program does try to recover from; exceptions. .. _arc.misc.interior:. Interior pointers; -----------------. An Objective-C method returning a non-retainable pointer may be annotated with; the ``objc_returns_inner_pointer`` attribute to indicate that it returns a; handle to the internal data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use of the returned pointer, or any pointer derived from it, in the; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:99364,safe,safer,99364,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safer']
Safety,"gned for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12491,detect,detect,12491,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['detect'],['detect']
Safety,"gral pointers which has not been addressed upstream. To work around; this, you need to disable speculation of loads unless the memory type; (non-integral pointer vs anything else) is known to unchanged. That is, it is; not safe to speculate a load if doing causes a non-integral pointer value to; be loaded as any other type or vice versa. In practice, this restriction is; well isolated to isSafeToSpeculate in ValueTracking.cpp. Explicit Representation; ^^^^^^^^^^^^^^^^^^^^^^^. A frontend could directly generate this low level explicit form, but; doing so may inhibit optimization. Instead, it is recommended that; compilers with relocating collectors target the abstract machine model just; described. The heart of the explicit approach is to construct (or rewrite) the IR in a; manner where the possible updates performed by the garbage collector are; explicitly visible in the IR. Doing so requires that we:. #. create a new SSA value for each potentially relocated pointer, and; ensure that no uses of the original (non relocated) value is; reachable after the safepoint,; #. specify the relocation in a way which is opaque to the compiler to; ensure that the optimizer can not introduce new uses of an; unrelocated value after a statepoint. This prevents the optimizer; from performing unsound optimizations.; #. recording a mapping of live pointers (and the allocation they're; associated with) for each statepoint. At the most abstract level, inserting a safepoint can be thought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The reco",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:6794,safe,safepoint,6794,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"gram with the ""safe"" backend and running it. **--run-{int,jit,llc,custom}**. Whenever the test program is compiled, **bugpoint** should generate code for it; using the specified code generator. These options allow you to choose the; interpreter, the JIT compiler, the static native code compiler, or a; custom command (see **--exec-command**) respectively. **--safe-{llc,custom}**. When debugging a code generator, **bugpoint** should use the specified code; generator as the ""safe"" code generator. This is a known-good code generator; used to generate the ""reference output"" if it has not been provided, and to; compile portions of the program that as they are excluded from the testcase.; These options allow you to choose the; static native code compiler, or a custom command, (see **--exec-command**); respectively. The interpreter and the JIT backends cannot currently; be used as the ""safe"" backends. **--exec-command** *command*. This option defines the command to use with the **--run-custom** and; **--safe-custom** options to execute the bitcode testcase. This can; be useful for cross-compilation. **--compile-command** *command*. This option defines the command to use with the **--compile-custom**; option to compile the bitcode testcase. The command should exit with a; failure exit code if the file is ""interesting"" and should exit with a; success exit code (i.e. 0) otherwise (this is the same as if it crashed on; ""interesting"" inputs). This can be useful for; testing compiler output without running any link or execute stages. To; generate a reduced unit test, you may add CHECK directives to the; testcase and pass the name of an executable compile-command script in this form:. .. code-block:: sh. #!/bin/sh; llc ""$@""; not FileCheck [bugpoint input file].ll < bugpoint-test-program.s. This script will ""fail"" as long as FileCheck passes. So the result; will be the minimum bitcode that passes FileCheck. **--safe-path** *path*. This option defines the path to the command to execu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:5113,safe,safe-custom,5113,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['safe'],['safe-custom']
Safety,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69508,safe,safe,69508,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"gure iossim; make. To build a native iOS armv7 version do:. ./configure ios; make. Both builds create a libRoot.a that can be used to create ROOT based iOS apps; (iOS does not allow apps to load non-system dynamic libraries at run time).; Some sample Xcode projects using ROOT will soon be made available. Base. Change TTime data member from Long_t to Long64_t. On 32-bit systems the; Long_t is 32-bits and too small to keep the time in milliseconds since the ROOT EPOCH (1-1-1995). Added new operators:. operator long long(); operator unsigned long long(). The existing operators long and unsigned long on 32-bit machines return; an error in case the stored time is larger then 32-bit and truncation; occurs (like was always the case till now, but silently). New method ExitOnException() which allows to set the behaviour of; TApplication in case of an exception (sigsegv, sigbus, sigill, sigfpe).; The default is to trap the signal and continue with the event loop,; using this method one can specify to exit with the signal number to the; shell, or to abort() which in addition generates a core dump. New command line argument -x which forces ROOT to exit on an exception.; Add TSystem::AddDynamicPath. Build. New option '-t' for rmkdepend to allow the caller to fully specify the name to be used as a target; This supersedes the name calculated from the input file name and the -p and -o option. ACLiC. Allow ACLiC to use a flat directory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:1677,abort,abort,1677,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,1,['abort'],['abort']
Safety,"h can be used at link; time. Link Time Optimization (LTO) is another name for intermodular; optimization when performed during the link stage. This document describes the; interface and design between the LTO optimizer and the linker. Design Philosophy; =================. The LLVM Link Time Optimizer provides complete transparency, while doing; intermodular optimization, in the compiler tool chain. Its main goal is to let; the developer take advantage of intermodular optimizations without making any; significant changes to the developer's makefiles or build system. This is; achieved through tight integration with the linker. In this model, the linker; treats LLVM bitcode files like native object files and allows mixing and; matching among them. The linker uses `libLTO`_, a shared object, to handle LLVM; bitcode files. This tight integration between the linker and LLVM optimizer; helps to do optimizations that are not possible in other models. The linker; input allows the optimizer to avoid relying on conservative escape analysis. .. _libLTO-example:. Example of link time optimization; ---------------------------------. The following example illustrates the advantages of LTO's integrated approach; and clean interface. This example requires a system linker which supports LTO; through the interface described in this document. Here, clang transparently; invokes system linker. * Input source file ``a.c`` is compiled into LLVM bitcode form.; * Input source file ``main.c`` is compiled into native object code. .. code-block:: c++. --- a.h ---; extern int foo1(void);; extern void foo2(void);; extern void foo4(void);. --- a.c ---; #include ""a.h"". static signed int i = 0;. void foo2(void) {; i = -1;; }. static int foo3() {; foo4();; return 10;; }. int foo1(void) {; int data = 0;. if (i < 0); data = foo3();. data = data + 42;; return data;; }. --- main.c ---; #include <stdio.h>; #include ""a.h"". void foo4(void) {; printf(""Hi\n"");; }. int main() {; return foo1();; }. To compile, r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:1271,avoid,avoid,1271,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['avoid'],['avoid']
Safety,"h variable and then looping through all; events, placing the cuts always in the middle between two; of the sorted events, and finding the true possible; maximum separation gain in the training sample by cutting; on this variable.; . BDT, AdaBoost The beta parameter is now an; option (default is 1).; . BDT: The node purity at which a node is; classified as signal (respective background node) for; determining the error fraction in the pruning became a; parameter that can be set via the option NodePurityLimit; (default is 0.5).; . Dataset preparation:. First implementation of a new preprocessing method: transformation of the; variables first into a Gaussian distribution, then performing a decorrelation of; the ""Gaussianised"" variables. The transformation is again done by default such that; (by default) the signal distributions become Gaussian and are decorrelated. Note ; that simultaneous Gaussianisation and decorrelation of signal and background is ; only possible (and done) for methods, such as Likelihood, which test both hypotheses.; . Bug fixes:. Fix in Expected error pruning: Rather than multiplying both sides, the error on ; the node and the sub-tree, with the prune strength, now only the expected error ; of the sub-tree is scaled.; . Fix in FDA parsing of the input formula. There were problems when treating; more than 10 parameters (thanks to Hugh Skottowe for reporting this).; . Calculation of ""Separation"": fixed bin-shift and; normalisation bugs. Thanks to Dag Gillberg (Fraser U) for; spotting these.; . Fixed problem in ""SetSignal(Background)WeightExpression"":; signal (background weight expressions not existing in the; background (signal) tree led to an abort of the tree; reading (""Bad numerical expression""). Thanks to Alfio; Rizzo (Brussels) for pointing this out.; . Fixed problem when specifying train and test tree; explicitly. Some code was forgotten in the background; part, creating incompatibilities. Thanks to Zhiyi Liu; (Fraser U) for reporting this.; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html:2366,abort,abort,2366,tmva/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html,1,['abort'],['abort']
Safety,"h) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit) so that user can inforce the use of a custom streamer in all possible split cases. Resolve several issues with the creation of StreamerInfo for abstract classes. When looking for the value corresponding to an enum type, skip global that are not enums. (This improves the speed of TFile::Open by 60%). TStyle. The Modern style has now a transparent background for the histogram title. Misc. In the root executable, auto-detect command line arguments that are local root files even if their name does not end with "".root"". If home directory is not correctly set in pw file or user is not known, use the HOME shell variable to find the desired home directory. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:4139,detect,detect,4139,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['detect'],['detect']
Safety,"handle this:. R1 = X + 4; R2 = X + 7; R3 = X + 15. loop:; R1 = X + 4 @ re-materialized; load [i + R1]; ...; R2 = X + 7 @ re-materialized; load [i + R2]; ...; R3 = X + 15 @ re-materialized; load [i + R3]. Furthermore, with re-association, we can enable sharing:. R1 = X + 4; R2 = X + 7; R3 = X + 15. loop:; T = i + X; load [T + 4]; ...; load [T + 7]; ...; load [T + 15]; //===---------------------------------------------------------------------===//. It's not always a good idea to choose rematerialization over spilling. If all; the load / store instructions would be folded then spilling is cheaper because; it won't require new live intervals / registers. See 2003-05-31-LongShifts for; an example. //===---------------------------------------------------------------------===//. With a copying garbage collector, derived pointers must not be retained across; collector safe points; the collector could move the objects and invalidate the; derived pointer. This is bad enough in the first place, but safe points can; crop up unpredictably. Consider:. %array = load { i32, [0 x %obj] }** %array_addr; %nth_el = getelementptr { i32, [0 x %obj] }* %array, i32 0, i32 %n; %old = load %obj** %nth_el; %z = div i64 %x, %y; store %obj* %new, %obj** %nth_el. If the i64 division is lowered to a libcall, then a safe point will (must); appear for the call site. If a collection occurs, %array and %nth_el no longer; point into the correct object. The fix for this is to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The oca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:2926,safe,safe,2926,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['safe'],['safe']
Safety,"happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; `TGeo` offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. \anchor GP05a; ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In `TGeo`, physical nodes are represented by; the class TGeoPhysicalNode and can be created on demand for; alignment purposes:. ~~~{.cpp}; TGeoPhysicalNode(const char* path); ~~~. The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can; however create ""symbolic links"" to any complex path to make it more; representable for the object it designates:. ~~~{.cpp}; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); ~~~. Such a symbolic link hides the complexity of the path to the align; object and replaces it with a more meaningful name. In addition,; TGeoPNEntry objects are faster to search by name and they may; optionally store an additional user matrix. ~~~{.cpp}; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *uni",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:107051,detect,detector,107051,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,"haracterization of the performance, and specific benchmarks are unlikely to; reveal especially interesting properties. ### Future Work: Fine Grained Control and API-Integration. The performance overhead of this technique is likely to be very significant and; something users wish to control or reduce. There are interesting options here; that impact the implementation strategy used. One particularly appealing option is to allow both opt-in and opt-out of this; mitigation at reasonably fine granularity such as on a per-function basis,; including intelligent handling of inlining decisions -- protected code can be; prevented from inlining into unprotected code, and unprotected code will become; protected when inlined into protected code. For systems where only a limited; set of code is reachable by externally controlled inputs, it may be possible to; limit the scope of mitigation through such mechanisms without compromising the; application's overall security. The performance impact may also be focused in a; few key functions that can be hand-mitigated in ways that have lower; performance overhead while the remainder of the application receives automatic; protection. For both limiting the scope of mitigation or manually mitigating hot functions,; there needs to be some support for mixing mitigated and unmitigated code; without completely defeating the mitigation. For the first use case, it would; be particularly desirable that mitigated code remains safe when being called; during misspeculation from unmitigated code. For the second use case, it may be important to connect the automatic; mitigation technique to explicit mitigation APIs such as what is described in; http://wg21.link/p0928 (or any other eventual API) so that there is a clean way; to switch from automatic to manual mitigation without immediately exposing a; hole. However, the design for how to do this is hard to come up with until the; APIs are better established. We will revisit this as those APIs mature.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:50166,safe,safe,50166,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['safe'],['safe']
Safety,"hat have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds anno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2938,safe,safety,2938,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"have been removed, after deprecation in v6.08. ### CINT remnants, dysfunctional for ROOT 6. - `TInterpreter`'s `Getgvp()`, `Getp2f2funcname(void*)`, `Setgvp(Long_t)`, `SetRTLD_NOW()`, `SetRTLD_LAZY()`.; - `SetFCN(void*)` from TVirtualFitter, TFitter, TBackCompFitter, TMinuit; - `TFoam::SetRhoInt(void*)`. ### Core. - The enum constant `TRef::kNotComputed`, `TLink::kObjIsParent` were never used and have been removed.; - The enum constant `TClonesArray::kNoSplit` has not been used since v2.26 and has been removed. ## Interpreter. - Automatic declaration of variables (`h = new TH1F(...)`) is *only* available at the prompt. The side-effects of relying on this in source files is simply too grave. Due to a bug (ROOT-8538), automatically declared variables must currently reside on the top-most scope, i.e. not inside an `if` block etc.; - Improved the stack frame information generated by the JIT. By avoiding interleaving of the memory associated to multiple JIT module, the generation of stack trace involving jitted code and the catching of exception going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.; - Add support for std::array_view also for C++11 builds. The implementation has been modified to work before C++14.; - Added TCollection::Notify to allow notifying more than one object.; ```{.cpp}; TList formulas;; // Add several TTreeFormula to the list;; chain.SetNotify(&formulas);; ```; - For classes that need the `ClassDef` support",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:1684,avoid,avoiding,1684,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoiding']
Safety,"have only one address space), one function stores a 64-bit; integer, while another one stores a pointer. If the target is the machine; mentioned above, and if functions are identical, except the parameter type (we; could consider it as a part of function type), then we can treat a ``uint64_t``; and a ``void*`` as equal. This is just an example; more possible details are described a bit below. As another example, the reader may imagine two more functions. The first; function performs a multiplication by 2, while the second one performs an; logical left shift by 1. Possible solutions; ^^^^^^^^^^^^^^^^^^; Let's briefly consider possible options about how and what we have to implement; in order to create full-featured functions merging, and also what it would; mean for us. Equal function detection obviously supposes that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:4830,detect,detector,4830,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,2,['detect'],"['detector', 'detectors']"
Safety,"havior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from normal; qualifiers. Rather than signifying that the declaration containing ``precise``; qualifier be precise, it signifies that the operations contributing to the; declaration's value be ``precise``. Additionally, ``precise`` is a misnomer:; values attributed as ``precise`` comply with IEEE-754 floating point semantics,; and are prevented from optimizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing HLSL in Clang; use of some C and C++ features will produce diagnostics under HLSL, and others; will be supported as language extensions. In general, any C or C++ feature that; can be supported by the DXIL and SPIR-V code generation targets could be treated; as a clang HLSL extension. Features that cannot be lowered to DXIL or SPIR-V,; must be diagnosed as errors. HLSL does not support the following C features:.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:8994,detect,detects,8994,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['detect'],['detects']
Safety,"he Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68746,detect,detection,68746,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['detect'],['detection']
Safety,"he Python buffer interface, such; as numpy arrays) and a low-level view type from ``cppyy`` for returns and; variable access (that implements the buffer interface as well).; Out-of-bounds checking is limited to those cases where the size is known at; compile time.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> from array import array; >>> c = Concrete(); >>> c.array_method(array('d', [1., 2., 3., 4.]), 4); 1 2 3 4; >>> c.m_data[4] # static size is 4, so out of bounds; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: buffer index out of range; >>>. Arrays of arrays are supported through the C++ low-level view objects.; This only works well if sizes are known at compile time or can be inferred.; If sizes are not known, the size is set to a large integer (depending on the; array element size) to allow access.; It is then up to the developer not to access the array out-of-bounds.; There is limited support for arrays of instances, but those should be avoided; in C++ anyway:. .. code-block:: python. >>> cppyy.cppdef('std::string str_array[3][2] = {{""aa"", ""bb""}, {""cc"", ""dd""}, {""ee"", ""ff""}};'); True; >>> type(cppyy.gbl.str_array[0][1]); <class cppyy.gbl.std.string at 0x7fd650ccb650>; >>> cppyy.gbl.str_array[0][1]; 'bb'; >>> cppyy.gbl.str_array[4][0]; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: tuple index out of range; >>>. `Pointers`; """""""""""""""""""". When the C++ code takes a pointer or reference type to a specific builtin; type (such as an ``unsigned int`` for example), then types need to match; exactly.; ``cppyy`` supports the types provided by the standard modules ``ctypes`` and; ``array`` for those cases.; Example of using a reference to builtin:. .. code-block:: python. >>> from ctypes import c_uint; >>> u = c_uint(0); >>> c.uint_ref_assign(u, 42); >>> u.value; 42; >>>. For objects, an object, a pointer to an object, and a smart pointer to an; object are represented th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:4244,avoid,avoided,4244,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['avoid'],['avoided']
Safety,"he TMinuit class. ## RooFit Libraries. - Remove deprecated `RooComplex` superseded by `std::complex`. ## TTree Libraries. - `TTreeReader` now supports `TEntryList`s, `Double32_t` / `Float16_t`.; - `TTreeReader::SetLastEntry()` has been deprecated. Its name is misleading; please use `TTreePlayer::SetEntriesRange()` instead.; - `TTree::Branch()` now complains for wrong leaf list strings, e.g. ""value/F[4]"" (which should really be spelled as ""value[4]/F"").; - Allow reading of older version of TTreePerfStats (ROOT-8520); - In `TTree::OptimizeBaskets()` do not call GetBasket(0) to avoid disc reads; - It is now possible to define the precision of the default histogram created; by `TTree::Draw`. Three new parameters are available in `$ROOTSYS/etcsystem.rootrc`; ```{.cpp}; Hist.Precision.1D: float; Hist.Precision.2D: float; Hist.Precision.3D: float; ```; the default values are `float`. They can be set to `double`.; - Fix ROOT-8742: TTree::SetBranchAddress could not be invoked safely even when dealing with the same tree obtained from the same file opened in different threads.; - TTree::Branch() now complains if a ""name[size]/F"" branch specification is passed wrongly (e.g. as ""name/F[size]""). ### TDataFrame; - Creation of the TDataFrame class. The TDataFrame allows to interact with data; stored in columnar format in a functional and intuitive way in order to perform; data analysis. Parallelism is accessible simply by activating implicit; multi-threading with the ROOT::EnableImplicitMT() function.; In a nutshell, the functionality provided is:; - Create and fill histograms with one single method invocation; - Express filtering of entries with strings, lambdas or functions; - Easy creation of efficiencies of cut-flows; - Possibility to run on ranges of entries; - Creating columns not present in the original dataset; - Chain multiple actions to be executed on the same event loop; - Creation of events on-the-fly (e.g. via Pythia or user-define generator functors), with no need for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:5872,safe,safely,5872,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['safe'],['safely']
Safety,"he bin volume corresponding to the variables *not* in `sumSet`. ### New fully parametrised Crystal Ball shape class. So far, the Crystal Ball distribution has been represented in RooFit only by the `RooCBShape` class, which has a Gaussian core and a single power-law tail on one side.; This release introduces [`RooCrystalBall`](https://root.cern/doc/v624/classRooCrystalBall.html), which implements some common generalizations of the Crystal Ball shape:. - symmetric or asymmetric power-law tails on both sides; - different width parameters for the left and right sides of the Gaussian core. The new `RooCrystalBall` class can substitute the `RooDSCBShape` and `RooSDSCBShape`, which were passed around in the community. ## 2D Graphics Libraries. - Add the method `AddPoint`to `TGraph(x,y)` and `TGraph2D(x,y,z)`, equivalent to `SetPoint(g->GetN(),x,y)`and `SetPoint(g->GetN(),x,y,z)`; - Option `E0` draws error bars and markers are drawn for bins with 0 contents. Now, combined; with options E1 and E2, it avoids error bars clipping. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### Multithreaded support for FastCGI. Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests; received via FastCGI channel. This significantly increase a performance, especially when; several clients are connected. ### Better security for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:24891,avoid,avoids,24891,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['avoid'],['avoids']
Safety,"he call site they're attached to, and can be; used by a suitable runtime to deoptimize the compiled frame at the; specified call site. There can be at most one ``""deopt""`` operand; bundle attached to a call site. Exact details of deoptimization is; out of scope for the language reference, but it usually involves; rewriting a compiled frame into a set of interpreted frames. From the compiler's perspective, deoptimization operand bundles make; the call sites they're attached to at least ``readonly``. They read; through all of their pointer typed operands (even if they're not; otherwise escaped) and the entire visible heap. Deoptimization; operand bundles do not capture their operands except during; deoptimization, in which case control will not be returned to the; compiled frame. The inliner knows how to inline through calls that have deoptimization; operand bundles. Just like inlining through a normal call site; involves composing the normal and exceptional continuations, inlining; through a call site with a deoptimization operand bundle needs to; appropriately compose the ""safe"" deoptimization continuation. The; inliner does this by prepending the parent's deoptimization; continuation to every deoptimization continuation in the inlined body.; E.g. inlining ``@f`` into ``@g`` in the following example. .. code-block:: llvm. define void @f() {; call void @x() ;; no deopt state; call void @y() [ ""deopt""(i32 10) ]; call void @y() [ ""deopt""(i32 10), ""unknown""(ptr null) ]; ret void; }. define void @g() {; call void @f() [ ""deopt""(i32 20) ]; ret void; }. will result in. .. code-block:: llvm. define void @g() {; call void @x() ;; still no deopt state; call void @y() [ ""deopt""(i32 20, i32 10) ]; call void @y() [ ""deopt""(i32 20, i32 10), ""unknown""(ptr null) ]; ret void; }. It is the frontend's responsibility to structure or encode the; deoptimization state in a way that syntactically prepending the; caller's deoptimization state to the callee's deoptimization state is; semantic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:120230,safe,safe,120230,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"he control flow) of a program. **CIE**; Common Information Entry. A kind of CFI used to reduce the size of FDEs.; The compiler creates a CIE which contains the information common across all; the FDEs. Each FDE then points to its CIE. **CSE**; Common Subexpression Elimination. An optimization that removes common; subexpression computation. For example ``(a+b)*(a+b)`` has two; subexpressions that are the same: ``(a+b)``. This optimization would; perform the addition only once and then perform the multiply (but only if; it's computationally correct/safe). D; -. **DAG**; Directed Acyclic Graph. .. _derived pointer:; .. _derived pointers:. **Derived Pointer**; A pointer to the interior of an object, such that a garbage collector is; unable to use the pointer for reachability analysis. While a derived pointer; is live, the corresponding object pointer must be kept in a root, otherwise; the collector might free the referenced object. With copying collectors,; derived pointers pose an additional hazard that they may be invalidated at; any `safe point`_. This term is used in opposition to `object pointer`_. **DSA**; Data Structure Analysis. **DSE**; Dead Store Elimination. E; -. **ento**; This namespace houses the; `Clang Static Analyzer <https://clang.llvm.org/docs/ClangStaticAnalyzer.html>`_.; It is an abbreviation of `entomology <https://en.wikipedia.org/wiki/Entomology>`_. *""Entomology is the scientific study of insects.""*. In the past, this namespace had not only the name `GR` (aka. Graph Reachability); but also `entoSA`. F; -. **FCA**; First Class Aggregate. **FDE**; Frame Description Entry. A kind of CFI used to describe the stack frame of; one function. G; -. **GC**; Garbage Collection. The practice of using reachability analysis instead of; explicit memory management to reclaim unused memory. **GEP**; ``GetElementPtr``. An LLVM IR instruction that is used to get the address; of a subelement of an aggregate data structure. It is documented in detail; `here <https://ll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:2797,hazard,hazard,2797,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,2,"['hazard', 'safe']","['hazard', 'safe']"
Safety,"he dataset repository is checked for newly; incoming staging requests. Defaults to **10**. dsmgrd.parallelxfrs *n*; : Number of concurrent transfers. Defaults to **8**. dsmgrd.stagecmd *shell\_command*; : Command to run in order to stage each file. It might be whatever you; want (executable, shell script...). If you add `$URLTOSTAGE` and/or; `$TREENAME` in the *shell\_command*, they'll be substituted; respectively with the destination URL and the default ROOT tree name; in the file (as specified in the dataset staging request from ROOT). An example:. dsmgrd.stagecmd /path/to/afdsmgrd-xrd-stage-verify.sh ""$URLTOSTAGE"" ""$TREENAME"". Return value of the command is ignored: standard output is; considered, as explained here. Defaults to `/bin/false`. dsmgrd.cmdtimeoutsecs *secs*; : Timeout on staging command, expressed in seconds: after this; timeout, the command is considered failed and it is killed (in first; place with `SIGSTOP`, then if it is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:4462,timeout,timeout,4462,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['timeout'],['timeout']
Safety,"he new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited functionality. ## PyROOT. - Introduce the `ROOT.Numba.Declare` decorator which provides a simple way to call Python callables from C++. The Python callables are; just-in-time compiled with [numba](http://numba.pydata.org/), which ensures a runtime performance similar to a C++ implementation.; The feature is targeted to improve the performance of Python based analyses, e.g., allows seamless integration into `RDataFrame` workflows.; See the tutorial [`pyroot004_NumbaDeclare.py`](https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html) for further information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:10805,safe,safe,10805,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['safe'],['safe']
Safety,"he non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:12012,unsafe,unsafe,12012,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['unsafe'],['unsafe']
Safety,"he ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6664,safe,safety,6664,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,"['redund', 'safe']","['redundant', 'safety']"
Safety,"he parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parame",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6522,avoid,avoid,6522,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoid']
Safety,"he right default attribute. Promotion expression; ====================. A new expression will be introduced to represent the conversion from a pointer; with an external bounds annotation, such as ``__counted_by``, to; ``__bidi_indexable``. This type of conversion cannot be handled by normal; CastExprs because it requires an extra subexpression(s) to provide the bounds; information necessary to create a wide pointer. Bounds check expression; =======================. Bounds checks are part of semantics defined in the ``-fbounds-safety`` language; model. Hence, exposing the bounds checks and other semantic actions in the AST; is desirable. A new expression for bounds checks has been added to the AST. The; bounds check expression has a ``BoundsCheckKind`` to indicate the kind of checks; and has the additional sub-expressions that are necessary to perform the check; according to the kind. Paired assignment check; =======================. ``-fbounds-safety`` enforces that variables or fields related with the same; external bounds annotation (e.g., ``buf`` and ``count`` related with; ``__counted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or ana",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:5091,safe,safety,5091,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"her options you can use are:. .. code-block:: bash. Use Ninja instead of Make: ""-G Ninja""; Build with assertions on: ""-DLLVM_ENABLE_ASSERTIONS=True""; Local (non-sudo) install path: ""-DCMAKE_INSTALL_PREFIX=$HOME/llvm/install""; CPU flags: ""DCMAKE_C_FLAGS=-mcpu=cortex-a15"" (same for CXX_FLAGS). After that, just typing ``make -jN`` or ``ninja`` will build everything.; ``make -jN check-all`` or ``ninja check-all`` will run all compiler tests. For; running the test suite, please refer to :doc:`TestingGuide`. #. If you are building LLVM/Clang on an ARM board with 1G of memory or less,; please use ``gold`` rather then GNU ``ld``. In any case it is probably a good; idea to set up a swap partition, too. .. code-block:: bash. $ sudo ln -sf /usr/bin/ld /usr/bin/ld.gold. #. ARM development boards can be unstable and you may experience that cores; are disappearing, caches being flushed on every big.LITTLE switch, and; other similar issues. To help ease the effect of this, set the Linux; scheduler to ""performance"" on **all** cores using this little script:. .. code-block:: bash. # The code below requires the package 'cpufrequtils' to be installed.; for ((cpu=0; cpu<`grep -c proc /proc/cpuinfo`; cpu++)); do; sudo cpufreq-set -c $cpu -g performance; done. Remember to turn that off after the build, or you may risk burning your; CPU. Most modern kernels don't need that, so only use it if you have; problems. #. Running the build on SD cards is ok, but they are more prone to failures; than good quality USB sticks, and those are more prone to failures than; external hard-drives (those are also a lot faster). So, at least, you; should consider to buy a fast USB stick. On systems with a fast eMMC,; that's a good option too. #. Make sure you have a decent power supply (dozens of dollars worth) that can; provide *at least* 4 amperes, this is especially important if you use USB; devices with your board. Externally powered USB/SATA harddrives are even; better than having a good power supply.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst:2862,risk,risk,2862,interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst,1,['risk'],['risk']
Safety,"her.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and havi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134061,safe,safety,134061,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"herefore casting should be relatively uncommon. For example all; of the arithmetic operations work on almost all data types. > Making the second arg. to 'shl' a ubyte seems good enough to me.; > 255 positions seems adequate for several generations of machines. Okay, that comment is removed. > and is more compact than uint. No, it isn't. Remember that the bytecode encoding saves value slots into; the bytecode instructions themselves, not constant values. This is; another case where we may introduce more cast instructions (but we will; also reduce the number of opcode variants that must be supported by a; virtual machine). Because most shifts are by constant values, I don't; think that we'll have to cast many shifts. :). > I still have some major concerns about including malloc and free in the; > language (either as builtin functions or instructions). Agreed. How about this proposal:. malloc/free are either built in functions or actual opcodes. They provide; all of the type safety that the document would indicate, blah blah; blah. :). Now, because of all of the excellent points that you raised, an; implementation may want to override the default malloc/free behavior of; the program. To do this, they simply implement a ""malloc"" and; ""free"" function. The virtual machine will then be defined to use the user; defined malloc/free function (which return/take void*'s, not type'd; pointers like the builtin function would) if one is available, otherwise; fall back on a system malloc/free. Does this sound like a good compromise? It would give us all of the; typesafety/elegance in the language while still allowing the user to do; all the cool stuff they want to... > 'alloca' on the other hand sounds like a good idea, and the; > implementation seems fairly language-independent so it doesn't have the; > problems with malloc listed above. Okay, once we get the above stuff figured out, I'll put it all in the; spec. > About indirect call:; > Your option #2 sounded good to me. I'm not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:4181,safe,safety,4181,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['safe'],['safety']
Safety,"herwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65009,avoid,avoid,65009,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoid']
Safety,"hich asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16289,safe,safety-negative,16289,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety-negative']
Safety,"hich pass is being used,; ASAN or HWASAN are being applied, based on the function attributes. This does mean that users of HWASAN may need to add the new attribute; to the code that already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:9893,detect,detect,9893,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,2,['detect'],"['detect', 'detection']"
Safety,"hich provide their own algorithms for boundary; crossing). ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ```. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119569,safe,safe,119569,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"his code path error prone.; ```cpp; // ROOT prompt; root [] namespace foo { };struct S;; root [] foo::bar/*store parsing state*/; gSystem->Load(""Foo"");; // More scaffolding.; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; /*restore parsing state*/ baz1 /*store parsing state*/; #include <Foo.h>/*restore parsing state*/;; ```. To recap, unfortunately, ROOT PCH is not extendable; ROOTMAP requires a lot of; maintenance and goes on a very untested codepath, while RDICT has a very limited; scope. The three features require a lot of mechanisms to work together and the; corner cases are very many. The interaction between some of the features often; break design and introduce layering violations. ## From C++ Modules to Dictionaries. C++ Modules have native capabilities to avoid reparsing. It combines all; home-grown solutions to avoid the costly operation at industry quality. Currently, when ROOT is built with `-Druntime_cxxmodules=On` it gives priority to; C++ Module files (real *pcm* files). If such a file is present it reads all; necessary information from it. If no such file is present ROOT falls back to the; standard information flow. ### Observable differences from 'standard' ROOT. As always, ROOT is (mostly) API and ABI compatible. C++ Modules-aware ROOT is no; different. There are several differences which can be noticed:; * \*modulemap files in $ROOTSYS/include -- those files are used by rootcling to; put a set of header files in a single pcm file. For example, all related; headers of *libGeom* are persisted in *Geom.pcm*. There are a few notable; examples, which are specific to the way we build ROOT. In certain cases we; want some header files to be compiled within C context or with RTTI on/off.; That's mostly for bootstrapping ROOT (aka rootcling stage1).; * modulemap.overlay.yaml -- automatically crea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:11313,avoid,avoid,11313,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,"his new format is now online; and can be seen from the [ROOT home page](https://root.cern.ch/doc/master/index.html). ## Core Libraries. ### Dictionary generation. Fixed the dictionary generation in the case of class inside a namespace; marked inlined. Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates. Fix [ROOT-7760] : fully allow the usage of the dylib extension on OSx. Fix [ROOT-7723] : allow IOCtors to have as argument a ref to a type called __void__. We added a dictionary for map<string,string> as part of the default STL dictionary. We added support for template parameter packs in class name involved in the I/O. ### Thread safety and thread awareness. We added the function `TMethodCall::GetCallFunc` to allow direct access to the function wrapper. We reduced thread serialization in `TClass::GetCheckSum`, `TClass::GetBaseClassOffset` and `TClass::Property`. `TObjArray::Delete` was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock). We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: `ROOT::EnableThreadSafety()` which is the successor of the existing `TThread::Initialize`. This call must take place if ROOT needs to be used in a thread safe manner. The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TContext` which record the current directory; and will restore it at destruction time and does not change the current directory. The constructor for `TDirectory::TContext` that takes a single TDirectory pointer as; an argument was changed to set `gDirectory` to zero when being passed a null",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:2354,avoid,avoid,2354,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['avoid'],['avoid']
Safety,"his would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribute__((arm_streaming_compatible)) some_use(svfloat32_t *);. // Use a float argument type, to check the value isn't clobbered by smstart.; // Use a float return type to check the value isn't clobbered by smstop.; float __attribute__((noinline, arm_locally_streaming)) foo(float arg) {; // Create local for SVE vector to check local is created with correct; // size when not yet in streaming mode (ADDSVL).; float array[N];; svfloat32_t vector;. some_use(&vector);; svst1_f32(svptrue_b32(), &array[0], vector);; return array[N - 1] + arg;; }. should use ADDSVL for allocating the stack space and should avoid clobbering; the return/argument values. .. code-block:: none. _Z3foof: // @_Z3foof; // %bb.0: // %entry; stp d15, d14, [sp, #-96]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; stp x29, x30, [sp, #64] // 16-byte Folded Spill; add x29, sp, #64; str x28, [sp, #80] // 8-byte Folded Spill; addsvl sp, sp, #-1; sub sp, sp, #256; str s0, [x29, #28] // 4-byte Folded Spill; smstart sm; sub x0, x29, #64; addsvl x0, x0, #-1; bl _Z10some_usePu13__SVFloat32_t; sub x8, x29, #64; ptrue p0.s; ld1w { z0.s }, p0/z, [x8, #-1, mul vl]; ldr s1, [x29, #28] // 4-byte Folded Reload; st1w { z0.s }, p0, [sp]; ldr s0, [sp, #252]; fadd s0, s0, s1; str s0, [x29, #28] // 4-byte Folded Spill; smstop sm; ldr s0, [x29, #28] // 4-byte Folded Reload; addsvl sp, sp, #1; add sp, sp, #256; ldp x29, x30, [sp, #64] // 16-byte Folded Reload; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:13110,avoid,avoid,13110,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,1,['avoid'],['avoid']
Safety,"hod is used to specify the selector and the; entries. Before we can use **`TTree::Process`** we need to make a; selector. We can call the `TTree::MakeSelector` method. It creates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this function returns `kFALSE`. It; combines the methods **`TSelector::ProcessCut()` and; `TSelector`**`::ProcessFill()` in one, avoiding the necessity to; maintain the state in the class to communicate between these two; functions. It reduces the information that needs to be shared; between them and promotes a more granular data access by reading; branches as they are needed. - `TSelector::Terminate() -` it is called at the end of a loop on a; **`TTree`**. This is a convenient place to draw and fit your; histograms. - `TSelector::Version()` `-` this function provides backward; compatibility for old versions and support for the future upgrades. - The **`TSelector`**, unlike the resulting class from `MakeClass`,; separates the processing into a `ProcessCut()` and `ProcessFill()`,; so we can limit reading of branches to the ones we need. - When a selector is used with a **`TChain`** in methods `Process()`,; `ProcessFill()`, `ProcessCut()`, you must use the pointer to the; current **`TTree`** to call the method `GetEntry(entry)`. The; parameter `entry` is always the local entry number in the current; tree. Assuming th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:132379,avoid,avoiding,132379,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['avoid'],['avoiding']
Safety,"hoices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes inside; irreducible cycles as having divergent outputs. But it is desirable to; recognize m-converged nodes in the CFG in order to maximize; uniformity. This section describes one such pattern of nodes derived; from *closed paths*, which are a property of the CFG and do not depend; on the cycle hierarchy. **Diverged Entry Criterion:**. The dynamic instances of all the nodes in a closed path ``P`` are; m-converged only if for every divergent branch ``B`` and its; join node ``J`` that lie on ``P``, there is no entry to ``P`` which; lies on a diverged path from ``B`` to ``J``. .. figure:: convergence-closed-path.png; :name: convergence-closed-path. Consider the closed path `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:21272,detect,detects,21272,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['detect'],['detects']
Safety,"hought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update local values in the; current frame. If we don't, we'll be accessing a potential invalid reference; once we eventually return from the call. In this example, we need to relocate the SSA value ``%obj``. Since we can't; actually change the value in the SSA value ``%obj``, we need to introduce a new; SSA value ``%obj.relocated`` which represents the potentially changed value of; ``%obj`` after the safepoint and update any following uses appropriately. The; resulting relocation sequence is:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 7, i32 7); ret i8 addrspace(1)* %obj.re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:8213,safe,safepoint,8213,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks are; classified as ""Spectre variant #1"". Notably, this does not attempt to; mitigate against miss-speculation of branch target, classified as; ""Spectre variant #2"" vulnerabilities. When inlining, the attribute is sticky. Inlining a function that carries; this attribute will cause the caller to gain the attribute. This is intended; to provide a maximally conservative model where the code in a function; annotated with this attribute will always (even after inlining) end u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:101048,safe,safety,101048,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:10486,safe,safe,10486,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['safe'],"['safe', 'safety']"
Safety,"i32); declare i64 @llvm.loop.decrement.reg.i64(i64, i64). Overview:; """""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics are used to lower the loop; iteration counter and return an updated value that will be used in the next; loop test check. Arguments:; """""""""""""""""""". Both arguments must have identical integer types. The first operand is the; loop iteration counter. The second operand is the maximum number of elements; processed in an iteration. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.reg.*``' intrinsics do an integer ``SUB`` of its; two operands, which is not allowed to wrap. They return the remaining number of; iterations still to be executed, and can be used together with a ``PHI``,; ``ICMP`` and ``BR`` to control the number of loop iterations executed. Any; optimisations are allowed to treat it is a ``SUB``, and it is supported by; SCEV, so it's the backends responsibility to handle cases where it may be; optimised. These intrinsics are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. '``llvm.loop.decrement.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.loop.decrement.i32(i32); declare i1 @llvm.loop.decrement.i64(i64). Overview:; """""""""""""""""". The HardwareLoops pass allows the loop decrement value to be specified with an; option. It defaults to a loop decrement value of 1, but it can be an unsigned; integer value provided by this option. The '``llvm.loop.decrement.*``'; intrinsics decrement the loop iteration counter with this value, and return a; false predicate if the loop should exit, and true otherwise.; This is emitted if the loop counter is not updated via a ``PHI`` node, which; can also be controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iterati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:648825,avoid,avoid,648825,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89546,recover,recoveryExpr,89546,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recoveryExpr']
Safety,"ial for RDataFrame helper functions](https://root.cern/doc/master/df020__helpers_8C.html).; - Throw if name of a custom column is not a valid C++ name.; - Allow every RDataFrame variable be cast to a common type `ROOT::RDF::RNode`.; - Speed up just-in-time compilation (and therefore runtime) of Snapshots with a large number of branches.; - Create names for histograms and graphs based on the input columns if no model is provided.; - RCutFlowReport can print cumulative efficiency of cuts.; - Reading and writing of columns holding `vector<bool>` instances and `bool` C arrays.; - Support `rdfentry_` and `rdfslot_` implicit columns (`tdfentry_` and `tdfslot_` kept for backwards compatibility).; - Remove `RDataFrame` from the 32-bit builds.; - Speed up interpreted usage of RDataFrame (i.e. in macros or from ROOT prompt) by removing certain cling runtime safety checks.; - Streamline and better document usage of multi-thread RDataFrame: edge cases in which processing of an event could start; before processing of another event finished have been removed, making it easier for user to write safe parallel RDF operations.; See the [relevant documentation](https://root.cern.ch/doc/master/classROOT_1_1RDataFrame.html#parallel-execution) for more information. ### TTreeProcessorMT; - Parallelise search of cluster boundaries for input datasets with no friends or TEntryLists. The net effect is a faster initialization time in this common case.; - Handle gracefully the presence of chains the files associated to which are corrupted.; - Reduce number of expensive `TChain::LoadTree` calls by spawning nested TBB tasks to ensure clusters of a given file will be most likely processed by the same thread. ### TTree; - TTrees can be forced to only create new baskets at event cluster boundaries.; This simplifies file layout and I/O at the cost of memory. Recommended for; simple file formats such as ntuples but not more complex data types. To; enable, invoke `tree->SetBit(TTree::kOnlyFlushAtCluste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:9950,safe,safe,9950,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['safe'],['safe']
Safety,"ial stack frame,; not accounting for any dynamic allocation. * ``roots_size()``: The count of roots in the function. To access the stack map, use ``GCFunctionMetadata::roots_begin()`` and; -``end()`` from the :ref:`GCMetadataPrinter <assembly>`:. .. code-block:: c++. for (iterator I = begin(), E = end(); I != E; ++I) {; GCFunctionInfo *FI = *I;; unsigned FrameSize = FI->getFrameSize();; size_t RootCount = FI->roots_size();. for (GCFunctionInfo::roots_iterator RI = FI->roots_begin(),; RE = FI->roots_end();; RI != RE; ++RI) {; int RootNum = RI->Num;; int RootStackOffset = RI->StackOffset;; Constant *RootMetadata = RI->Metadata;; }; }. If the ``llvm.gcroot`` intrinsic is eliminated before code generation by a; custom lowering pass, LLVM will compute an empty stack map. This may be useful; for collector plugins which implement reference counting or a shadow stack. .. _init-roots:. Initializing roots to null; ---------------------------. It is recommended that frontends initialize roots explicitly to avoid; potentially confusing the optimizer. This prevents the GC from visiting; uninitialized pointers, which will almost certainly cause it to crash. As a fallback, LLVM will automatically initialize each root to ``null``; upon entry to the function. Support for this mode in code generation is; largely a legacy detail to keep old collector implementations working. Custom lowering of intrinsics; ------------------------------. For GCs which use barriers or unusual treatment of stack roots, the; implementor is responsibly for providing a custom pass to lower the; intrinsics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such a pass is the ShadowStackGC and it's; ShadowStackGCLowering pass. There is currently no way to register such a custom lowering pass; without building a custom copy of LLVM. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:33673,avoid,avoid,33673,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['avoid'],['avoid']
Safety,"ialSquare; | Circle. A Bug to be Aware Of; --------------------. The example just given opens the door to bugs where the ``classof``\s are; not updated to match the ``Kind`` enum when adding (or removing) classes to; (from) the hierarchy. Continuing the example above, suppose we add a ``SomewhatSpecialSquare`` as; a subclass of ``Square``, and update the ``ShapeKind`` enum like so:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_Circle; }. Now, suppose that we forget to update ``Square::classof()``, so it still; looks like:. .. code-block:: c++. static bool classof(const Shape *S) {; // BUG: Returns false when S->getKind() == SK_SomewhatSpecialSquare,; // even though SomewhatSpecialSquare ""is a"" Square.; return S->getKind() >= SK_Square &&; S->getKind() <= SK_OtherSpecialSquare;; }. As the comment indicates, this code contains a bug. A straightforward and; non-clever way to avoid this is to introduce an explicit ``SK_LastSquare``; entry in the enum when adding the first subclass(es). For example, we could; rewrite the example at the beginning of `Concrete Bases and Deeper; Hierarchies`_ as:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; + SK_LastSquare,; SK_Circle; }; ...; // Square::classof(); - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_LastSquare;; + }. Then, adding new subclasses is easy:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_LastSquare,; SK_Circle; }. Notice that ``Square::classof`` does not need to be changed. .. _classof-contract:. The Contract of ``classof``; ---------------------------. To be more precise, let ``classof`` be inside a class ``C``. Then the; contract for ``classof`` is ""return ``true`` if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:9860,avoid,avoid,9860,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['avoid'],['avoid']
Safety,"iant.load and TBAA's constant flags. Pass Ordering; ^^^^^^^^^^^^^. One of the most common mistakes made by new language frontend projects is to; use the existing -O2 or -O3 pass pipelines as is. These pass pipelines make a; good starting point for an optimizing compiler for any language, but they have; been carefully tuned for C and C++, not your target language. You will almost; certainly need to use a custom pass order to achieve optimal performance. A; couple specific suggestions:. #. For languages with numerous rarely executed guard conditions (e.g. null; checks, type checks, range checks) consider adding an extra execution or; two of LoopUnswitch and LICM to your pass order. The standard pass order,; which is tuned for C and C++ applications, may not be sufficient to remove; all dischargeable checks from loops. #. If your language uses range checks, consider using the IRCE pass. It is not; currently part of the standard pass order. #. A useful sanity check to run is to run your optimized IR back through the; -O2 pipeline again. If you see noticeable improvement in the resulting IR,; you likely need to adjust your pass order. I Still Can't Find What I'm Looking For; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If you didn't find what you were looking for above, consider proposing a piece; of metadata which provides the optimization hint you need. Such extensions are; relatively common and are generally well received by the community. You will; need to ensure that your proposal is sufficiently general so that it benefits; others if you wish to contribute it upstream. You should also consider describing the problem you're facing on `Discourse; <https://discourse.llvm.org>`_ and asking for advice.; It's entirely possible someone has encountered your problem before and can; give good advice. If there are multiple interested parties, that also; increases the chances that a metadata extension would be well received by the; community as a whole. Adding to this document; ===",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:13261,sanity check,sanity check,13261,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['sanity check'],['sanity check']
Safety,"iate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16062,avoid,avoid,16062,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['avoid'],['avoid']
Safety,"ibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and non-LTO object files, any hidden; visibility class defined in both a translation unit built with LTO and; a translation unit built without LTO must be defined with public LTO; visibility in order to avoid an ODR violation. 2. Some ABIs provide the ability to define an abstract base class without; visibility attributes in multiple linkage units and have virtual calls; to derived classes in other linkage units work correctly. One example of; this is COM on Windows platforms. If the ABI allows this, any base class; used in this way must be defined with public LTO visibility. Classes that fall into either of these categories can be marked up with the; ``[[clang::lto_visibility_public]]`` attribute. To specifically handle the; COM case, classes with the ``__declspec(uuid())`` attribute receive public; LTO visibility. On Windows platforms, clang-cl's ``/MT`` and ``/MTd``; flags statically link the program against a prebuilt standard library;; these flags imply public LTO visibility for every class declared in the; ``std`` and ``stdext`` namespace",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:3533,avoid,avoid,3533,interpreter/llvm-project/clang/docs/LTOVisibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst,1,['avoid'],['avoid']
Safety,"ible lowerings for the memcpy and memmove operations:; GC leaf lowering and GC parseable lowering. If a call is explicitly marked with; ""gc-leaf-function"" attribute the call is lowered to a GC leaf call to; '``__llvm_memcpy_element_unordered_atomic_*``' or; '``__llvm_memmove_element_unordered_atomic_*``' symbol. Such a call can not; take a safepoint. Otherwise, the call is made GC parseable by wrapping the; call into a statepoint. This makes it possible to take a safepoint during; copy operation. Note that a GC parseable copy operation is not required to; take a safepoint. For example, a short copy operation may be performed without; taking a safepoint. GC parseable calls to '``llvm.memcpy.element.unordered.atomic.*``',; '``llvm.memmove.element.unordered.atomic.*``' intrinsics are lowered to calls; to '``__llvm_memcpy_element_unordered_atomic_safepoint_*``',; '``__llvm_memmove_element_unordered_atomic_safepoint_*``' symbols respectively.; This way the runtime can provide implementations of copy operations with and; without safepoints. GC parseable lowering also involves adjusting the arguments for the call.; Memcpy and memmove intrinsics take derived pointers as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in the copy operation. In order to make the base; pointers available RewriteStatepointsForGC replaces derived pointers with base; pointer and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:30705,safe,safepoints,30705,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"ibute; would prevent this:. .. code-block:: c. my_sub_group_shuffle() __attribute__((convergent));. Using ``convergent`` guarantees correct execution by keeping CFG equivalence; wrt operations marked as ``convergent``. CFG ``G´`` is equivalent to ``G`` wrt; node ``Ni`` : ``iff ∀ Nj (i≠j)`` domination and post-domination relations with; respect to ``Ni`` remain the same in both ``G`` and ``G´``. noduplicate; ^^^^^^^^^^^. ``noduplicate`` is more restrictive with respect to optimizations than; ``convergent`` because a convergent function only preserves CFG equivalence.; This allows some optimizations to happen as long as the control flow remains; unmodified. .. code-block:: c. for (int i=0; i<4; i++); my_sub_group_shuffle(). can be modified to:. .. code-block:: c. my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();. while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:151957,safe,safe,151957,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['safe'],['safe']
Safety,"ic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is either pointing to a single; object or null. Hence, pointers with ``__single`` do not permit pointer; arithmetic nor being subscripted with a non-zero index. Dereferencing a; ``__single`` pointer is allowed but it requires a null check. Upper and lower; bounds checks are not required because the ``__single`` pointer should point; to a valid object unless it's null. ``__single`` is the default annotation for ABI-visible pointers. This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit, overriding bounds annotation that can; be used to verify the safety of the operation. The compiler issues an error when; a ``__single`` pointer is utilized for pointer arithmetic or array access, as; these operations would immediately cause the pointer to exceed its bounds.; Consequently, this prompts programmers to provide sufficient bounds information; to pointers. In the following example, the pointer on parameter p is; single-by-default, and is employed for array access. As a result, the compiler; generates an error suggesting to add ``__counted_by`` to the pointer. .. code-block:: c. void fill_array_with_indices(int *p, unsigned count) {; for (unsigned i = 0; i < count; ++i) {; p[i] = i; // error; }; }. External bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ""External"" bounds annotations provide a way to express a relationship between a; pointer variable and another variable (or expression) containing the bounds; information of the pointer. In the followin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:8273,safe,safety,8273,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"icGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42235,avoid,avoid,42235,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"icTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1176,detect,detecting,1176,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['detect'],['detecting']
Safety,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180661,detect,detection,180661,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,3,"['detect', 'recover']","['detection', 'recover', 'recovery']"
Safety,"icates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:57287,avoid,avoids,57287,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoids']
Safety,"ication does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>` call. The runtime must provide a number of new entrypoints which the compiler may; emit, which are described in the remainder of this section. .. admonition:: Rationale. Several of these functions are semantically equivalent to a message send; we; emit calls to C functions instead because:. * the machine code to do so is significantly smaller,; * it is much easier to recognize the C functions in the ARC optimizer, and; * a sufficient sophisticated runtime may be able to avoid the message send in; common cases. Several other of these functions are ""fused"" operations which can be; described entirely in terms of other operations. We use the fused operations; primarily as a code-size optimization, although in some cases there is also a; real potential for avoiding redundant operations in the runtime. .. _arc.runtime.objc_autorelease:. ``id objc_autorelease(id value);``; ----------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it adds the object; to the innermost autorelease pool exactly as if the object had been sent the; ``autorelease`` message. Always returns ``value``. .. _arc.runtime.objc_autoreleasePoolPop:. ``void objc_autoreleasePoolPop(void *pool);``; ---------------------------------------------. *Precondition:* ``pool`` is the result of a previous call to; :ref:`objc_autore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:106609,avoid,avoid,106609,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoid']
Safety,"ics and the; intrinsic is completely dropped during instruction selection. '``llvm.codeview.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This annotation emits a label at its program point and an associated; ``S_ANNOTATION`` codeview record with some additional string metadata. This is; used to implement MSVC's ``__annotation`` intrinsic. It is marked; ``noduplicate``, so calls to this intrinsic prevent inlining and should be; considered expensive. ::. declare void @llvm.codeview.annotation(metadata). Arguments:; """""""""""""""""""". The argument should be an MDTuple containing any number of MDStrings. '``llvm.trap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.trap() cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.trap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to the target dependent trap instruction. If; the target does not have a trap instruction, this intrinsic will be; lowered to a call of the ``abort()`` function. '``llvm.debugtrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.debugtrap() nounwind. Overview:; """""""""""""""""". The '``llvm.debugtrap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an; execution trap with the intention of requesting the attention of a; debugger. '``llvm.ubsantrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.ubsantrap(i8 immarg) cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behavi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:928598,abort,abort,928598,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['abort'],['abort']
Safety,"idden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can operate without modifications within this; programming model, reducing the adoption burden. The rest of the section will discuss individual bounds annotations and the; programming model in more detail. Bounds annotations; ------------------. Annotation for pointers to a single object; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The C language allows pointer arithmetic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is either pointing to a single; object or null. Hence, pointers with ``__single`` do not permit pointer; arithmetic nor being subscripted with a non-zero index. Dereferencing a; ``__single`` pointer is allowed but it requires a null check. Upper and lower; bounds checks are not required because the ``__single`` pointer should point; to a valid object unless it's null. ``__single`` is the default annotation for ABI-visible pointers. This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:7257,safe,safety,7257,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89797,recover,recoveryExpr,89797,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recoveryExpr']
Safety,"ides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and print them. To find a specific object on the; file we can use the **`TFile::Get()` method.**. ``` {.cpp}; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:16104,recover,recovery,16104,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['recover'],['recovery']
Safety,"idi_indexable``, with ``&vla[n]`` as the upper bound and ``&vla[0]`` as the; lower bound. Then, it's copied to ``int *p``, which is implicitly ``int; *__bidi_indexable p``. Please note that value of ``n`` used to create the upper; bound is ``10``, not ``100``, in this case because ``10`` is the actual length; of ``vla``, the value of ``n`` at the time when the array is being allocated. .. code-block:: c. void foo(void) {; int n = 10;; int vla[n];; n = 100;; int *p = vla; // { .ptr: &vla[0], .upper: &vla[10], .lower: &vla[0] }; // it's `&vla[10]` because the value of `n` was 10 at the; // time when the array is actually allocated.; // ...; }. By promoting array references to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that ``buf`` has ``count`` number of elements available. This; relationship must hold even after any of these related variables are updated. To; this end, the model requires that assignments to ``buf`` and ``count`` must be; side by side, with no side effects between them. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35210,safe,safety,35210,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"idi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler reports a warning when ``typeof()`` is used on an implicit wide pointer; at any ABI visible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:25133,avoid,avoid,25133,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"iding some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17810,detect,detected,17810,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['detect'],['detected']
Safety,"ier; regardless of where their work is applied to. What is covered; ---------------. The core tier is composed of:; * Core code (``llvm-project``) present in official releases and buildbots:; compiler, debugger, linker, libraries, etc, including infrastructure code; (table-gen, lit, file-check, unit-tests, etc).; * Build infrastructure that creates releases and buildbots (CMake, scripts).; * `Phabricator <https://github.com/llvm/phabricator>`_ and; `buildbot <https://github.com/llvm/llvm-zorg>`_ infrastructure.; * The `test-suite <https://github.com/llvm/llvm-test-suite>`_. Requirements; ------------. Code in this tier must:; * Keep official buildbots green, with warnings on breakages being emailed to; all affected developers. Those must be fixed as soon as possible or patches; must be reverted, as per review policy.; * Bit-rot of a component in the core tier will result in that component being; downgraded to the peripheral tier or being removed. Sub-communities can; avoid this by fixing all raised issues in a timely manner. Peripheral Tier; ===============. The peripheral tier encompass the parts of LLVM that cater to a specific; sub-community and which don't usually affect the core components directly. This includes experimental back-ends, disabled-by-default options and; alternative paths (work-in-progress replacements) in the same repository, as; well as separate efforts to integrate LLVM development with local practices. It is the responsibility of each sub-community to care about their own parts; and the intersection of that with the core tier and other peripheral parts. There are three main groups of code that fit in this category:; * Code that is making its way into LLVM, via the `experimental <https://llvm.org/docs/DeveloperPolicy.html#introducing-new-components-into-llvm>`_; roadmap or similar efforts.; * Code that is making its way out of LLVM, via deprecation, replacement or; bit-rot, and will be removed if the sub-community that cares about it; cannot m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:3077,avoid,avoid,3077,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['avoid'],['avoid']
Safety,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6022,recover,recovery,6022,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['recover'],"['recover', 'recovery']"
Safety,"if (...) {; c->name = ...; // Overwritten: {c->account_id, c->name}; } else {; c->name = ...; // Overwritten: {c->account_id, c->name}; }; // Overwritten: {c->account_id, c->name}; }; ```. When the data flow algorithm computes a normal state, but not all fields are; proven to be overwritten we can't perform the refactoring. ```c++; void target(bool b, Customer* c) {; // Overwritten: {}; if (b) {; c->account_id = 42; // Overwritten: {c->account_id}; } else {; c->name = ""Konrad""; // Overwritten: {c->name}; }; // Overwritten: {}; }; ```. Similarly, when the data flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; print(c->name); // Unsafe read; } else {; kGlobalCustomer = c; // Pointer escape; }; // Unsafe read, Pointer escape; }; ```. ## Example: finding dead stores. Let's say we want to find redundant stores, because they indicate potential; bugs. ```c++; x = GetX();; x = GetY();; ```. The first store to `x` is never read, probably there is a bug. The implementation of dead store analysis is very similar to output parameter; analysis: we need to track stores and loads, and find stores that were never; read. [Liveness analysis](https://en.wikipedia.org/wiki/Live_variable_analysis) is a; generalization of this idea, which is often used to answer many related; questions, for example:. * finding dead stores,; * finding uninitialized variables,; * finding a good point to deallocate memory,; * finding out if it would be safe to move an object. ## Example: definitive initialization. Definitive initialization proves that variables are known to be initialized when; read. If we find a variable which is read when not initialized then we generate; a warning. ```c++; void Init() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; } else {; x = 20; // x is initialized; }; prin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:19684,redund,redundant,19684,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['redund'],['redundant']
Safety,"ig ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12885,safe,safely,12885,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['safe'],['safely']
Safety,"ike ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed descriptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85130,safe,safe,85130,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"ile located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:2505,detect,detects,2505,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['detect'],['detects']
Safety,"ile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:147900,safe,safely,147900,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"iling on 632 and main; * [[#15370](https://github.com/root-project/root/issues/15370)] - Broken link in HS3 printout; * [[#15340](https://github.com/root-project/root/issues/15340)] - Webgraphics: canvas displayed, but many error printed; * [[#15253](https://github.com/root-project/root/issues/15253)] - C++ standard not propagated via CMake anymore; * [[#15197](https://github.com/root-project/root/issues/15197)] - RBDT does not support xgboost inference; * [[#15156](https://github.com/root-project/root/issues/15156)] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; * [[#15139](https://github.com/root-project/root/issues/15139)] - cmake option -Dall=YES breaks the cmake; * [[#15118](https://github.com/root-project/root/issues/15118)] - jsoninterface does not build if provided with RapidYAML; * [[#15108](https://github.com/root-project/root/issues/15108)] - Turn off clang-format for Linkdef files; * [[#15090](https://github.com/root-project/root/issues/15090)] - TClass::GetClassInfo() is not thread safe; * [[#15077](https://github.com/root-project/root/issues/15077)] - Passing different floating point types to `RVec` utility functions; * [[#15048](https://github.com/root-project/root/issues/15048)] - [ntuple] Handling of virtual inheritance broken; * [[#15040](https://github.com/root-project/root/issues/15040)] - [RDataFrame] Inaccurate example of progress bar from documentation; * [[#15028](https://github.com/root-project/root/issues/15028)] - [RDataFrame] Unable to cacheread remote file; * [[#15027](https://github.com/root-project/root/issues/15027)] - spurrious cmake message about AfterImage with -Dminimal=ON; * [[#14981](https://github.com/root-project/root/issues/14981)] - RVecs leak memory with np.asarray in pyROOT; * [[#14964](https://github.com/root-project/root/issues/14964)] - ROOT-HEAD fails with ""cling interactive line includer >>>: fatal error: module file '[snip]/Vc.pcm' not found: module file not found""; * [[#14958](https://github.com/root-proj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:26794,safe,safe,26794,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['safe'],['safe']
Safety,"ime unrolling, the original loop of. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; Stmt(i);. is transformed into (using an unroll factor of 4):. .. code-block:: c. int i = 0;; for (; i + 3 < n; i+=4) { // unrolled loop; Stmt(i);; Stmt(i+1);; Stmt(i+2);; Stmt(i+3);; }; for (; i < n; i+=1) // remainder loop; Stmt(i);. ``llvm.loop.unroll.followup_unrolled`` will set the loop attributes of; the unrolled loop. If not specified, the attributes of the original loop; without the ``llvm.loop.unroll.*`` attributes are copied and; ``llvm.loop.unroll.disable`` added to it. ``llvm.loop.unroll.followup_remainder`` defines the attributes of the; remainder loop. If not specified the remainder loop will have no; attributes. The remainder loop might not be present due to being fully; unrolled in which case this attribute has no effect. Attributes defined in ``llvm.loop.unroll.followup_all`` are added to the; unrolled and remainder loops. To avoid that the partially unrolled loop is unrolled again, it is; recommended to add ``llvm.loop.unroll.disable`` to; ``llvm.loop.unroll.followup_all``. If no follow-up attribute specified; for a generated loop, it is added automatically. Unroll-And-Jam; --------------. Unroll-and-jam uses the following transformation model (here with an; unroll factor if 2). Currently, it does not support a fallback version; when the transformation is unsafe. .. code-block:: c. for (int i = 0; i < n; i+=1) { // original outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // original inner loop; SubLoop(i, j);; Aft(i);; }. .. code-block:: c. int i = 0;; for (; i + 1 < n; i+=2) { // unrolled outer loop; Fore(i);; Fore(i+1);; for (int j = 0; j < m; j+=1) { // unrolled inner loop; SubLoop(i, j);; SubLoop(i+1, j);; }; Aft(i);; Aft(i+1);; }; for (; i < n; i+=1) { // remainder outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // remainder inner loop; SubLoop(i, j);; Aft(i);; }. ``llvm.loop.unroll_and_jam.followup_outer`` will set the loop attributes; o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:8499,avoid,avoid,8499,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoid']
Safety,"ime), unless you use its ""pop_back"" method, which is; faster. ``SetVector`` is an adapter class that defaults to using ``std::vector`` and a; size 16 ``SmallSet`` for the underlying containers, so it is quite expensive.; However, ``""llvm/ADT/SetVector.h""`` also provides a ``SmallSetVector`` class,; which defaults to using a ``SmallVector`` and ``SmallSet`` of a specified size.; If you use this, and if your sets are dynamically smaller than ``N``, you will; save a lot of heap traffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implementation based on an AVL; tree. Adding or removing elements is done through a Factory object and results; in the creation of a new ImmutableSet object. If an ImmutableSet already exists; with the given contents, then the existing one is returned; equality is compared; with a FoldingSetNodeID. The time and space complexity of add or remove; operations is logarithmic in the size of the original set. There is no method for returning an element of the set, you can only check for; membership. .. _dss_otherset:. Other Set-Like Container Options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The STL provides several other options, such as std::multiset and; std::unordered_set. We never use containers like unordered_set because; they are generally very expensive (each insertion requires a malloc). std::multiset is useful if you're not interested in elimination of duplica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:86523,avoid,avoided,86523,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoided']
Safety,"imization. Instead, it is recommended that; compilers with relocating collectors target the abstract machine model just; described. The heart of the explicit approach is to construct (or rewrite) the IR in a; manner where the possible updates performed by the garbage collector are; explicitly visible in the IR. Doing so requires that we:. #. create a new SSA value for each potentially relocated pointer, and; ensure that no uses of the original (non relocated) value is; reachable after the safepoint,; #. specify the relocation in a way which is opaque to the compiler to; ensure that the optimizer can not introduce new uses of an; unrelocated value after a statepoint. This prevents the optimizer; from performing unsound optimizations.; #. recording a mapping of live pointers (and the allocation they're; associated with) for each statepoint. At the most abstract level, inserting a safepoint can be thought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:7191,safe,safepoint,7191,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71948,safe,safely,71948,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safely']
Safety,"in...', that's a; non-trivial issue."" [JSonnRevNum]_; - ""Sequential IDs are important for LNT and llvmlab bisection tool."" [MatthewsRevNum]_. However, Git can emulate this increasing revision number:; ``git rev-list --count <commit-hash>``. This identifier is unique only; within a single branch, but this means the tuple `(num, branch-name)` uniquely; identifies a commit. We can thus use this revision number to ensure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; We could supply a pre-push hook on the client side that would run and check the; history, before allowing the commit being pushed [statuschecks]_.; However this solution would be somewhat fragile (how do you update a script; installed on every developer machine?) and prevents SVN access to the; repository. What About Commit Emails?; -------------------------. We will need a new bot to send emails for each commit. This proposal leaves the; email format unchanged besides the commit URL. Straw Man Migration Plan; ========================. Step #1 : Before The Move; -------------------------. 1. Update docs to mention the move, so people are aware of what is going on.; 2. Set up a read-only version of the GitHub project, mirroring our current SVN; repository.; 3. Add the required bots to implement the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:5917,avoid,avoid,5917,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['avoid'],['avoid']
Safety,"in_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115901,avoid,avoid,115901,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"indNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ``` {.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ```. Otherwise, the computation of safety can always be forced:. ``` {.cpp}; Double_t safety = gGeoManager->Safety();; ```. #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ``` {.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ```. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:119836,safe,safety,119836,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"index, and up to 256 characters for a category name. Now, such states are; stored only using an integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since categories are mappings from state names; to state index, this is now reflected in the interface. Among others, this is now possible:; | ROOT 6.22 | Before (still supported) |; |------------------------------------------------|----------------------------------------------------------------|; | `RooCategory cat(""cat"", ""Lepton flavour"");` | `RooCategory cat(""cat"", ""Lepton flavour"");` |; | `cat[""electron""] = 1;` | `cat.defineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; mor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:4078,safe,safe,4078,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['safe'],['safe']
Safety,"inear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float's. To use them, one; must include the header file `Math/Vector3D.h`. The following typedef's,; defined in the header file `Math/Vector3Dfwd.h`, are available for the; different instantiations of the template class; `ROOT::Math::`**`DisplacementVector3D`**:. - `ROOT::Math::`**`XYZVector`** vector based on `x,y,z` coordinates; (Cartesian) in double precision. - `ROOT::Math::`**`XYZVectorF`** vector based on `x,y,z` coordinates; (Cartesian) in float precision. - `ROOT::Math::`**`Polar3DVector`** vector based on `r,theta,phi`; coordinates (polar) in double precision. - `ROOT::Math::`**`Polar3DVectorF`** vector based on `r,theta,phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiVector`** vector based on `rho,z,phi`; coordinates (cylindrical) in double precision. - `ROOT::Math::`**`RhoZPhiVectorF`** vector based on `rho,z,phi`; coordinates (cylindrical) in float precision. - `ROOT::Math::`**`RhoEtaPhiVector`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:77495,avoid,avoid,77495,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"ined in the model is read; auto reader = RNTupleReader::Open(std::move(model), ntuple);; reader->LoadEntry(0);. // Option 3: through views; // Each view will only trigger reading of the related field, without reading other fields at the same entry number.; auto reader = RNTupleReader::Open(ntuple);; auto viewPt = reader->GetView<float>(""pt"");; // Load the pt from the first entry; auto pt = viewPt(0);; ```. In the above cases, RNTuple creates the objects being read into.; It is also possible to bind already existing objects.; This is shown below for entries and works similarly for views. ```c++; // A bare entry is an entry that has initially no bindings (all top-level fields need to be bound by the caller); auto entry = reader->GetModel().CreateBareEntry();; auto ptToken = entry->GetToken(""pt"");. // Option 1: type safe, shared ownership; std::shared_ptr<float> ptTypedSharedPtr;; entry->BindValue(ptToken, ptTypedSharedPtr);. // Option 2: type unsafe, shared ownership; std::shared_ptr<void> ptVoidSharedPtr;; entry->BindValue(ptToken, ptVoidSharedPtr);. // Option 3: type unsafe, application owns the object; void *ptVoidPtr;; entry->BindRawPtr(ptToken, ptVoidPtr);. // Option 4: switch back from application-provided object to RNTuple-created object; entry->EmplaceNewValue(ptToken);. // For all options: use an explicit entry; reader->LoadEntry(0, *entry);; ```. Walkthrough: Writing Data; -------------------------. ```c++; auto model = RNTupleModel::Create();; // Add a field to the model and return the shared pointer for that field in the model's default entry.; auto ptrPt = model->MakeField<float>(""pt"");. auto file = std::make_unique<TFile>(""data.root"", ""APPEND"");; // The writer creates a page sink and connects the model's fields to it; auto writer = RNTupleWriter::Append(std::move(model), ""ntpl"", *file);; *ptrPt = 1.0;; // Append the model's default entry; writer->Fill();; // Commit the dataset by destructing the writer; writer.reset();; ```. The points on object type-safe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:3967,unsafe,unsafe,3967,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['unsafe'],['unsafe']
Safety,"information to be included. For; example, the AMD OpenCL runtime records kernel argument information. .. _amdgpu-amdhsa-code-object-metadata-v2:. Code Object V2 Metadata; +++++++++++++++++++++++. .. warning::; Code object V2 generation is no longer supported by this version of LLVM. Code object V2 metadata is specified by the ``NT_AMD_HSA_METADATA`` note record; (see :ref:`amdgpu-note-records-v2`). The metadata is specified as a YAML formatted string (see [YAML]_ and; :doc:`YamlIO`). .. TODO::. Is the string null terminated? It probably should not if YAML allows it to; contain null characters, otherwise it should be. The metadata is represented as a single YAML document comprised of the mapping; defined in table :ref:`amdgpu-amdhsa-code-object-metadata-map-v2-table` and; referenced tables. For boolean values, the string values of ``false`` and ``true`` are used for; false and true respectively. Additional information can be added to the mappings. To avoid conflicts, any; non-AMD key names should be prefixed by ""*vendor-name*."". .. table:: AMDHSA Code Object V2 Metadata Map; :name: amdgpu-amdhsa-code-object-metadata-map-v2-table. ========== ============== ========= =======================================; String Key Value Type Required? Description; ========== ============== ========= =======================================; ""Version"" sequence of Required - The first integer is the major; 2 integers version. Currently 1.; - The second integer is the minor; version. Currently 0.; ""Printf"" sequence of Each string is encoded information; strings about a printf function call. The; encoded information is organized as; fields separated by colon (':'):. ``ID:N:S[0]:S[1]:...:S[N-1]:FormatString``. where:. ``ID``; A 32-bit integer as a unique id for; each printf function call. ``N``; A 32-bit integer equal to the number; of arguments of printf function call; minus 1. ``S[i]`` (where i = 0, 1, ... , N-1); 32-bit integers for the size in bytes; of the i-th FormatString argument ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:118964,avoid,avoid,118964,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"ing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:69971,detect,detect,69971,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['detect'],['detect']
Safety,"ing function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can operate without modifications within this; programming model, reducing the adoption burden. The rest of the section will discuss individual bounds annotations and the; programming model in more detail. Bounds annotations; ------------------. Annotation for pointers to a single object; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The C language allows pointer arithmetic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is either pointing to a single; object or null. Hence, pointers with ``__single`` do not permit pointer; arithmetic nor being subscripted with a non-zero index. Dereferencing a; ``__single`` pointer is allowed but it requires a null check. Upper and lower; bounds checks are not required because the ``__single`` pointer should point; to a valid object unless it's null. ``__single`` is the default annotation for ABI-visible pointers. This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit, overriding bounds annotation that can; be used to verify the safety of the operation. The compiler issues an error when; a ``__single`` pointer is utilized for pointer arithmetic or array access, as; these operations would immediately cause the pointer to exceed its bounds.; Consequently, this prompts pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:7452,unsafe,unsafety,7452,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,"['safe', 'unsafe']","['safety', 'unsafety']"
Safety,"ing launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each function in them to be compiled the; first time it is called. To do this, the CompileOnDemandLayer creates two small; utilities for each function that it scans: a *stub* and a *compile; callback*. The stub is a pair of a function pointer (which will be pointed at; the function's implementation once the function has been compiled) and an; indirect jump through the pointer. By fixing the address of the indirect jump; for the lifetime of the program we can give the function a permanent ""effective; address"", one that can be safely used for indirection and function pointer; comparison even if the function's implementation is never compiled, or if it is; compiled more than once (due to, for example, recompiling the function at a; higher optimization level) and changes address. The second utility, the compile; callback, represents a re-entry point from the program into the compiler that; will trigger compilation and then execution of a function. By initializing the; function's stub to point at the function's compile callback, we enable lazy; compilation: The first attempted call to the function will follow the function; pointer and trigger the compile callback instead. The compile callback will; compile the function, update the function pointer for the stub, then execute; the function. On all subsequent calls to the function, the function pointer; will point at the already-compiled function, so there is no further overhead; from the compiler. We will look at this process in more detail in the next; chapter of this tutorial, but for now we'll trust the Compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:2528,safe,safely,2528,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['safe'],['safely']
Safety,"ing of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*. ## How to use; C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). Enjoy. To disable C++ Modules in ROOT use `-Druntime_cxxmodules=Off`. ## Citing ROOT's C++ Modules; ```latex; % Peer-Reviewed Publication; %; % 22nd International Conference on Computing in High Energy and Nuclear Physics (CHEP); % 8-14 October, 2016, San Francisco, USA; %; @inproceedings{Vassilev_ROOTModules,; author = {Vassilev,V.},; title = {{Optimizing ROOT's Performance Using C++ Modules}},; journal = {Journal of Physics: Conference Series},; year = 2017,; month = {oct},; volume = {898},; number = {7},; pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18961,avoid,avoid,18961,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,"ing the content of a workspace, as well as perform basic fitting operations with the models and datasets. ![Demonstration of RooBrowser using json workspace from the roofit tutorials directory](RooBrowser.png). ### Removal of deprecated HistFactory functionality. #### Removal of HistoToWorkspaceFactory (non-Fast version). The original `HistoToWorkspaceFactory` produced models that consisted of a; Poisson term for each bin. In this ""number counting form"" the dataset has one; row and the collumns corresponded to the number of events for each bin. This; led to severe performance problems in statistical tools that generated; pseudo-experiments and evaluated likelihood ratio test statistics. Nowadays, everyone uses the faster `HistoToWorkspaceFactoryFast` implementation that; produces a model in the ""standard form"" where the dataset has one row for each; event, and the column corresponds to the value of the observable in the; histogram. Therefore, the original `HistoToWorkspaceFactory` is now removed to avoid; confusion and maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:23249,avoid,avoid,23249,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoid']
Safety,"ing with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20403,safe,safety,20403,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"ing. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal interface of a function, and should; always go in the header, where they are visible to anything that includes; the header. Attributes in the .cpp file are not visible outside of the; immediate translation unit, which leads to false negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:18562,safe,safety-negative,18562,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety-negative']
Safety,"ing. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7393,avoid,avoid,7393,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['avoid'],['avoid']
Safety,"initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103364,safe,safety,103364,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"ink your program with ``-fsanitize=memtag`` flag. This; will only work when targeting AArch64 with MemTag extension. One; possible way to achieve that is to add ``-target; aarch64-linux -march=armv8+memtag`` to compilation flags. Implementation; ==============. See `HardwareAssistedAddressSanitizer`_ for a general overview of a; tag-based approach to memory safety. MemTagSanitizer follows a; similar implementation strategy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:1875,detect,detected,1875,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['detect'],['detected']
Safety,"inning at a four-aligned SGPR index; are reserved for the tentative scratch V#. These will be used if it is; determined that spilling is needed. - If no use is made of the tentative scratch V#, then it is unreserved,; and the register count is determined ignoring it.; - If use is made of the tentative scratch V#, then its register numbers; are shifted to the first four-aligned SGPR index after the highest one; allocated by the register allocator, and all uses are updated. The; register count includes them in the shifted location.; - In either case, if the processor has the SGPR allocation bug, the; tentative allocation is not shifted or unreserved in order to ensure; the register count is higher to workaround the bug. .. note::. This approach of using a tentative scratch V# and shifting the register; numbers if used avoids having to perform register allocation a second; time if the tentative V# is eliminated. This is more efficient and; avoids the problem that the second register allocation may perform; spilling which will fail as there is no longer a scratch V#. When the kernel prolog code is being emitted it is known whether the scratch V#; described above is actually used. If it is, the prolog code must set it up by; copying the Private Segment Buffer to the scratch V# registers and then adding; the Private Segment Wavefront Offset to the queue base address in the V#. The; result is a V# with a base address pointing to the beginning of the wavefront; scratch backing memory. The Private Segment Buffer is always requested, but the Private Segment; Wavefront Offset is only requested if it is used (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). .. _amdgpu-amdhsa-memory-model:. Memory Model; ~~~~~~~~~~~~. This section describes the mapping of the LLVM memory model onto AMDGPU machine; code (see :ref:`memmodel`). The AMDGPU backend supports the memory synchronization scopes specified in; :ref:`amdgpu-memory-scopes`. The code sequences used to implement the m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:200024,avoid,avoids,200024,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoids']
Safety,"instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; than ``assign``. These modifiers only affect the synthesized getter and; setter; direct accesses to the ivar (even if synthesized) still have primitive; semantics, and the value in the ivar will not be automatically released during; deallocation. .. _arc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:36384,unsafe,unsafe,36384,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['unsafe'],['unsafe']
Safety,"ints in a 2D space. Its constructor is:. ``` {.cpp}; TPolyLine(Int_t n,Double_t* x,Double_t* y,Option_t* option); ```. Where `n` is the number of points, and `x` and `y` are arrays of `n`; elements with the coordinates of the points. **`TPolyLine`** can be used; by it self, but is also a base class for other objects, such as curly; arcs. ### Circles and Ellipses. An ellipse can be truncated and rotated. It is defined by its center; `(x1,y1)` and two radii `r1` and `r2`. A minimum and maximum angle may; be specified `(phimin,phimax)`. The ellipse may be rotated with an angle; `theta`. All these angles are in degrees. The attributes of the outline; line are set via **`TAttLine`**, of the fill area - via **`TAttFill`**; class. They are described in ""Graphical Objects Attributes"". ![Different types of ellipses](pictures/030000AE.png). When an ellipse sector is drawn only, the lines between the center and; the end points of the sector are drawn by default. By specifying the; drawn option ""`only`"", these lines can be avoided. Alternatively, the; method `SetNoEdges()` can be called. To remove completely the ellipse; outline, specify zero (0) as a line style. The **`TEllipse`** constructor is:. ``` {.cpp}; TEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2,; Double_t phimin, Double_t phimax, Double_t theta); ```. An ellipse may be created with:. ``` {.cpp}; root[] e = new TEllipse(0.2,0.2,0.8,0.3); root[] e->Draw(); ```. ### Rectangles. The class **`TBox`** defines a rectangle. It is a base class for many; different higher-level graphical primitives. Its bottom left coordinates; `x1`, `y1` and its top right coordinates `x2`, `y2`, defines a box. The; constructor is:. ``` {.cpp}; TBox(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. It may be used as in:. ``` {.cpp}; root[] b = new TBox(0.2,0.2,0.8,0.3); root[] b->SetFillColor(5); root[] b->Draw(); ```. ![A rectangle with a border](pictures/020000AF.jpg). A **`TWbox`** is a rectangle (**`TBox`**) with a border",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:34945,avoid,avoided,34945,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['avoid'],['avoided']
Safety,"ion type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; release",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4355,avoid,avoid,4355,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['avoid'],['avoid']
Safety,"ion with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:16985,safe,safe,16985,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,1,['safe'],['safe']
Safety,"ion; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the dis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121786,safe,safety,121786,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ional optional tasks:. `|stepmax| < TGeoShape::Big()`. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121576,safe,safe,121576,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"ions will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereference (``*p``), array subscript (``p[i]``), member access (``p->``), and; pointer arithmetic, with some restrictions on bounds-unsafe uses. ``-fbounds-safety`` has a set of ""internal"" bounds annotations to turn pointers; into wide pointers. These are ``__bidi_indexable`` and ``__indexable``. When a; pointer has either of these annotations, the compiler changes the pointer to the; corresponding wide pointer. This means these annotations will break the ABI and; will not be compatible with plain C, and thus they should generally not be used; in ABI surfaces. * ``__bidi_indexable`` : A pointer with this annotation becomes a wide pointer; to carry the upper bound and the lower bound, the layout of which is; equivalent to ``struct { T *ptr; T *upper_bound; T *lower_bound; };``. As the; name indicates, pointers with this annotation are ""bidirectionally indexable"",; meaning that they can be indexed with either a negative or a positive offset; and the pointers can be incremented or decre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:13797,unsafe,unsafe,13797,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"ions:. 1. Every divergent branch inside the cycle satisfies the; :ref:`diverged entry criterion<convergence-diverged-entry>`, and,; 2. There are no :ref:`diverged paths reaching the; cycle<convergence-diverged-outside>` from a divergent branch; outside it. .. note::. A reducible cycle :ref:`trivially satisfies; <convergence-reducible-cycle>` the above conditions. In particular,; if the whole CFG is reducible, then all nodes in the CFG are; m-converged. The uniformity of each output of a static instance; is determined using the criteria; :ref:`described earlier <convergence-uniformity>`. The discovery of; divergent outputs may cause their uses (including branches) to also; become divergent. The analysis propagates this divergence until a; fixed point is reached. The convergence inferred using these criteria is a safe subset of the; maximal converged-with relation for any cycle hierarchy. In; particular, it is sufficient to determine if a static instance is; m-converged for a given cycle hierarchy ``T``, even if that fact is; not detected when examining some other cycle hierarchy ``T'``. This property allows compiler transforms to use the uniformity; analysis without being affected by DFS choices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:20146,detect,detected,20146,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['detect'],['detected']
Safety,"iorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15126,recover,recoverable,15126,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recoverable']
Safety,"irectory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copied. TStreamerInfo::New inserts the address of the creating TStreamerInfo into; the object. This address is inserted in each emulated that does not inherit; from an emulated class and is positioned after all the base classes (which; are compiled classes). A derived class will set this value inside each; of its emulated base class.; TStreamerInfo::Destruct and the new method TStreamerInfo::GetActualClass; use this information to detect the TStreamerInfo actually used to create; the object and hence run the proper emulated destructor. Add a new function GenerateDictionary to TInterpreter which allows for the quick and easy creation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");; This replaces the recommendation of creating a small 'loader.C' script to create the dictionaries. Implement a ShowMembers function for interpreted classes, by querying the interpreter for the data member; information.; In order to fix possible buffer overflow of parent string buffer in TMemberInspector,; the signature of ShowMember() was changed to no longer require (nor request) the; caller to provide a buffer (of length unknown to the callee.); Improve the uniqueness of globally visible symbols to allow for the mixing of; dictionaries ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:3053,detect,detect,3053,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,1,['detect'],['detect']
Safety,"is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, such non-integral pointer type have no defined mapping to an; integer representation. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3929,safe,safepoints,3929,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"is done by compile-time restrictions or; run-time checks (see `Maintaining correctness of bounds annotations`_; for more detail). For instance, initializing ``buf`` with ``null`` while; assigning non-zero value to ``count``, as shown in the following example, would; violate the ``__counted_by`` annotation because a null pointer does not point to; any valid memory location. To avoid this, the compiler produces either a; compile-time error or run-time trap. .. code-block:: c. void null_with_count_10(int *__counted_by(count) buf, unsigned count) {; buf = 0;; // This is not allowed as it creates a null pointer with non-zero length; count = 10;; }. However, there are use cases where a pointer is either a null pointer or is; pointing to memory of the specified size. To support this idiom,; ``-fbounds-safety`` provides ``*_or_null`` variants,; ``__counted_by_or_null(N)``, ``__sized_by_or_null(N)``, and; ``__ended_by_or_null(P)``. Accessing a pointer with any of these bounds; annotations will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereferen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:12703,avoid,avoid,12703,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"is necessary to insert; bounds checking for ``buf[i]``. .. code-block:: c. void *__sized_by(size) malloc(size_t size);. int *__counted_by(n) get_array_with_0_to_n_1(size_t n) {; int *buf = malloc(sizeof(int) * n);; for (size_t i = 0; i < n; ++i); buf[i] = i;; return buf;; }. Annotations for sentinel-delimited arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A C string is an array of characters. The null terminator — the first null; character ('\0') element in the array — marks the end of the string.; ``-fbounds-safety`` provides ``__null_terminated`` to annotate C strings and the; generalized form ``__terminated_by(T)`` to annotate pointers and arrays with an; end marked by a sentinel value. The model prevents dereferencing a; ``__terminated_by`` pointer beyond its end. Calculating the location of the end; (i.e., the address of the sentinel value), requires reading the entire array in; memory and would have some performance costs. To avoid an unintended performance; hit, the model puts some restrictions on how these pointers can be used.; ``__terminated_by`` pointers cannot be indexed and can only be incremented one; element at a time. To allow these operations, the pointers must be explicitly; converted to ``__indexable`` pointers using the intrinsic function; ``__unsafe_terminated_by_to_indexable(P, T)`` (or; ``__unsafe_null_terminated_to_indexable(P)``) which converts the; ``__terminated_by`` pointer ``P`` to an ``__indexable`` pointer. * ``__null_terminated`` : The pointer or array is terminated by ``NULL`` or; ``0``. Modifying the terminator or incrementing the pointer beyond it is; prevented at run time. * ``__terminated_by(T)`` : The pointer or array is terminated by ``T`` which is; a constant expression. Accessing or incrementing the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:18446,avoid,avoid,18446,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even if; the type of comparison is inverted, but GVN only runs late in the pipeline.; As a result, you may miss the opportunity to run other important; optimizations. #. Avoid using arithmetic intrinsics unless you are *required* by your source; language specification to emit a particular code sequence. The optimizer; is quite good at reasoning about general control flow and arithmetic, it is; not anywhere near as strong at reasoning about the various intrinsics. If; profitable for code generation purposes, the optimiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:8137,predict,predictable,8137,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['predict'],['predictable']
Safety,"is not provided in compiler-rt so one must be provided by the; compiled application or the operating system. Integrating the runtime into; the operating system should be preferred since otherwise all thread creation; and destruction would need to be intercepted by the application. The instrumentation makes use of the platform register ``x18`` on AArch64 and; ``x3`` (``gp``) on RISC-V. For simplicity we will refer to this as the; ``SCSReg``. On some platforms, ``SCSReg`` is reserved, and on others, it is; designated as a scratch register. This generally means that any code that may; run on the same thread as code compiled with ShadowCallStack must either target; one of the platforms whose ABI reserves ``SCSReg`` (currently Android, Darwin,; Fuchsia and Windows) or be compiled with a flag to reserve that register (e.g.,; ``-ffixed-x18``). If absolutely necessary, code compiled without reserving the; register may be run on the same thread as code that uses ShadowCallStack by; saving the register value temporarily on the stack (`example in Android`_) but; this should be done with care since it risks leaking the shadow call stack; address. .. _`example in Android`: https://android-review.googlesource.com/c/platform/frameworks/base/+/803717. Because it requires a dedicated register, the ShadowCallStack feature is; incompatible with any other feature that may use ``SCSReg``. However, there is; no inherent reason why ShadowCallStack needs to use a specific register; in; principle, a platform could choose to reserve and use another register for; ShadowCallStack, but this would be incompatible with the ABI standards; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:3613,risk,risks,3613,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['risk'],['risks']
Safety,"is program to create a little endian version of the table. The table; is used in PPCISelLowering.cpp, PPCTargetLowering::LOWERVECTOR_SHUFFLE(). //===----------------------------------------------------------------------===//. Opportunies to use instructions from PPCInstrVSX.td during code gen; - Conversion instructions (Sections 7.6.1.5 and 7.6.1.6 of ISA 2.07); - Scalar comparisons (xscmpodp and xscmpudp); - Min and max (xsmaxdp, xsmindp, xvmaxdp, xvmindp, xvmaxsp, xvminsp). Related to this: we currently do not generate the lxvw4x instruction for either; v4f32 or v4i32, probably because adding a dag pattern to the recognizer requires; a single target type. This should probably be addressed in the PPCISelDAGToDAG logic. //===----------------------------------------------------------------------===//. Currently EXTRACT_VECTOR_ELT and INSERT_VECTOR_ELT are type-legal only; for v2f64 with VSX available. We should create custom lowering; support for the other vector types. Without this support, we generate; sequences with load-hit-store hazards. v4f32 can be supported with VSX by shifting the correct element into; big-endian lane 0, using xscvspdpn to produce a double-precision; representation of the single-precision value in big-endian; double-precision lane 0, and reinterpreting lane 0 as an FPR or; vector-scalar register. v2i64 can be supported with VSX and P8Vector in the same manner as; v2f64, followed by a direct move to a GPR. v4i32 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 1, using a direct move to a GPR, and; sign-extending the 32-bit result to 64 bits. v8i16 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 3, using a direct move to a GPR, and; sign-extending the 16-bit result to 64 bits. v16i8 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 7, using a direct move to a GPR, and; sign-extending the 8-bit result to 64 bits.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:10315,hazard,hazards,10315,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,1,['hazard'],['hazards']
Safety,"is still in active development. This document may become outdated; over time. If you see something that's incorrect, please update it. Use Cases; ---------. MIR patterns are supported in the following places:. * GlobalISel ``GICombineRule``; * GlobalISel ``GICombinePatFrag``. Syntax; ------. MIR patterns use the DAG datatype in TableGen. .. code-block:: text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for; patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):$mypat``.; This may also be helpful to debug issues. Patterns are *always* named, and if; they don't have a name, an ""anonymous"" one is given to them. If you're trying; to debug an error related to a M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:1368,redund,redundant,1368,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['redund'],['redundant']
Safety,"is to check whether there; is another execution and if not, immediately exit without doing any work; (also see :ref:`loop-terminology-loop-rotate`), loop trip count is not; the best measure of a loop's number of iterations. For instance, the; number of header executions of the code below for a non-positive n; (before loop rotation) is 1, even though the loop body is not executed; at all. .. code-block:: C. for (int i = 0; i < n; ++i); body(i);. A better measure is the **backedge-taken count**, which is the number of; times any of the backedges is taken before the loop. It is one less than; the trip count for executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:9454,detect,detection,9454,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['detect'],['detection']
Safety,"is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class; describes the record headers of objects in the file. For example, we can; get the list of keys and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15788,recover,recover,15788,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,['recover'],"['recover', 'recovered']"
Safety,"is written and will be reused),; if the TBuffer size is greater than. - twice the data in the current basket; and - twice the average data in each basket (of this branch); and - twice the requeste basket size (TBranch::GetBasketSize).; the size of the buffer is reduced to the max of; 'the data in the current basket' and 'the average' and the requested; buffer size and aligned to next highest multiple of 512.; In TBranchRef distinguish between the entry we need (now called RequestedEntry) and the; entry we have read (fReadEntry) so that we can avoid re-reading the same entry too many; times when executing TRef::GetObject.; Reduce by 40% the time taken GetEntry for a branch created using a leaflist (exclusive of the decompression time).; Introduce TVirtualPerfStats::FileUnzipEvent to be able to keep track of the cost of unzipping and use this in TTreePerfStats and TBasket ... This give a good picture of where the time in unzip or in unstreaming; Add more clusters to the TTreeCache buffer until fBufferMinSize is hit to avoid severely underfilled buffer when; a low number of branches is selected/used.; When reading backwards, make sure to load a full (new) cluster and several other fixes to TTreeCache.; Reduce the memory used by a TTree in half. Refactor the code reading and writing the TBasket data.; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch.; In TTree::Fill, call FlushBasket before calling OptimizeBaskets so that we have a correct; and accurate value of fTotBytes to use as the requested memory.; In TTree::OptimizeBasket enforces hard minimun for the basket size (no lower than the; estimate size of one entry in the branch and no lower than 8 bytes). TTree::Process. Add support for the flag TSelector::kAbortFile. TTree::Draw. The line width setting was missing in a few places.; Namely support the option 'a' for TGraphs in TTree::Draw (delegate the axis management to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html:1881,avoid,avoid,1881,tree/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html,1,['avoid'],['avoid']
Safety,"is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>` call. The runtime must provide a number of new entrypoints which the compiler may; emit, which are described in the remainder of this section. .. admonition:: Rationale. Several of these functions are semantically equivalent to a message send; we; emit calls to C functions instead because:. * the machine code to do so is significantly smaller,; * it is much easier to recognize the C functions in the ARC optimizer, and; * a sufficient sophisticated runtime may be able to avoid the message send in; common cases. Several other of these functions are ""fused"" operations which can be; described entirely in terms of other operations. We use the fused operations; primarily as a code-size optimization, although in some cases there is also a; real potential for avoiding redundant operations in the runtime. .. _arc.runtime.objc_autorelease:. ``id objc_autorelease(id value);``; ----------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it adds the object; to the innermost autorelease pool exactly as if the object had been sent the; ``autorelease`` message. Always returns ``value``. .. _arc.runtime.objc_autoreleasePoolPop:. ``void objc_autoreleasePoolPop(void *pool);``; ---------------------------------------------. *Precondition:* ``pool`` is the result of a previous call to; :ref:`objc_autoreleasePoolPush <arc.runtime.objc_autoreleasePoolPush>` on the; current thread, where neither ``pool`` nor any enclosing pool have previously; been popped. Releases all the objects added to the given autorelease pool and any; autorelease pools it encloses, then sets the current autorelease pool to the; pool directly en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:106896,avoid,avoiding,106896,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,"['avoid', 'redund']","['avoiding', 'redundant']"
Safety,"istics. Nowadays, everyone uses the faster `HistoToWorkspaceFactoryFast` implementation that; produces a model in the ""standard form"" where the dataset has one row for each; event, and the column corresponds to the value of the observable in the; histogram. Therefore, the original `HistoToWorkspaceFactory` is now removed to avoid; confusion and maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:23791,avoid,avoid,23791,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoid']
Safety,"it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2797,recover,recover,2797,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recover']
Safety,"itcast of an alloca. The second contains a pointer to metadata that should be; associated with the pointer, and **must** be a constant or global value; address. If your target collector uses tags, use a null pointer for metadata. A compiler which performs manual SSA construction **must** ensure that SSA; values representing GC references are stored in to the alloca passed to the; respective ``gcroot`` before every call site and reloaded after every call.; A compiler which uses mem2reg to raise imperative code using ``alloca`` into; SSA form need only add a call to ``@llvm.gcroot`` for those variables which; are pointers into the GC heap. It is also important to mark intermediate values with ``llvm.gcroot``. For; example, consider ``h(f(), g())``. Beware leaking the result of ``f()`` in the; case that ``g()`` triggers a collection. Note, that stack variables must be; initialized and marked with ``llvm.gcroot`` in function's prologue. The ``%metadata`` argument can be used to avoid requiring heap objects to have; 'isa' pointers or tag bits. [Appel89_, Goldberg91_, Tolmach94_] If specified,; its value will be tracked along with the location of the pointer in the stack; frame. Consider the following fragment of Java code:. .. code-block:: java. {; Object X; // A null-initialized reference to an object; ...; }. This block (which may be located in the middle of a function or in a loop nest),; could be compiled to this LLVM code:. .. code-block:: llvm. Entry:; ;; In the entry block for the function, allocate the; ;; stack space for X, which is an LLVM pointer.; %X = alloca %Object*. ;; Tell LLVM that the stack space is a stack root.; ;; Java has type-tags on objects, so we pass null as metadata.; %tmp = bitcast %Object** %X to i8**; call void @llvm.gcroot(i8** %tmp, i8* null); ... ;; ""CodeBlock"" is the block corresponding to the start; ;; of the scope above.; CodeBlock:; ;; Java null-initializes pointers.; store %Object* null, %Object** %X. ... ;; As the pointer goes out o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:11560,avoid,avoid,11560,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['avoid'],['avoid']
Safety,"iterator's destructor. TFile::MakeProject. Extend TFile::MakeProject to support genreflex, cases of user's data model where; the 2 distincts pointers point to a single object and more cases where we are; missing the StreamerInfo and need to guess whether the symbol represent an enum,; a class or a namespace. To use genreflex, call MakeProject with the ""genreflex"" option, for example:. file->MakeProject(libdir,""*"",""NEW+genreflex"");. To make sure the library created by MakeProject does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. MakeProject now implements a move constructor for each classes. For the implementation, we 'use' the 'copy constructor' until the C++ compilers properly support the official move constructor notation. Implementing a move constructor avoid having to delete and reconstruct resource during a std::vector resize and avoid the double delete induced by using the default copy constructor. MakeProject now adds dictionaries for auto_ptr. MakeProject no longer request the dictionary for std::pair instances that already have been loaded. Misc. TFile::Open now does variable expansion so that you can include the protocol in the variable (for example: export H1=""http://root.cern/files/h1""; ...; TFile::Open(""$H1/dstarmb.root"");; Added warning if the file does contain any StreamerInfo objects and was written with a different version of ROOT.; Implemented polymorphism for Emulated object (still not supporting polymorphism of Emulated Object inheriting from compiled class). See the Core/Meta section for details.; Add support for streaming auto_ptr when generating their dictionary via rootcint; Enable the use of the I/O customization rules on data members that are either a variable size array or a fixed size array. For example:. #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" vers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:8870,avoid,avoid,8870,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,2,['avoid'],['avoid']
Safety,"ith ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the start of the; guard region in TLS and deallocate the entire guard region including the; shadow call stack at thread exit. This is considered acceptable given that; the address of the start of the guard region is already somewhat guessable. One way in which the address of the shadow call stack could leak is in the; ``jmp_buf`` data structure used by ``setjmp`` and ``longjmp``. The Android; runtime `avoids this`_ by only storing the low bits of ``SCSReg`` in the; ``jmp_buf``, which requires the address of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:7675,avoid,avoids,7675,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoids']
Safety,"ithout any additional terms or conditions.; Notwithstanding the above, nothing herein shall supersede or modify; the terms of any separate license agreement you may have executed; with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade; names, trademarks, service marks, or product names of the Licensor,; except as required for reasonable and customary use in describing the; origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or; agreed to in writing, Licensor provides the Work (and each; Contributor provides its Contributions) on an ""AS IS"" BASIS,; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or; implied, including, without limitation, any warranties or conditions; of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A; PARTICULAR PURPOSE. You are solely responsible for determining the; appropriateness of using or redistributing the Work and assume any; risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory,; whether in tort (including negligence), contract, or otherwise,; unless required by applicable law (such as deliberate and grossly; negligent acts) or agreed to in writing, shall any Contributor be; liable to You for damages, including any direct, indirect, special,; incidental, or consequential damages of any character arising as a; result of this License or out of the use or inability to use the; Work (including but not limited to damages for loss of goodwill,; work stoppage, computer failure or malfunction, or any and all; other commercial damages or losses), even if such Contributor; has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing; the Work or Derivative Works thereof, You may choose to offer,; and charge a fee for, acceptance of support, warranty, in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:8022,risk,risks,8022,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,4,['risk'],['risks']
Safety,"itution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ^^^^^^^^^^^^^^^^^^^^^^^^. Now that you've created the diagnostic in the ``Diagnostic*Kinds.td`` file, you; need to write the code that detects the condition in question and emits the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operands); << lex->getType() << rex->getType(); << lex->getSourceRange() << rex->getSourceRange();. This shows that use of the ``Diag`` method: it takes a location (a; :ref:`SourceLocation <SourceLocation>` object) and a diagnostic enum value; (which matches the name from ``Diagnostic*Kinds.td``). If the diagnostic takes; arguments, they are specified with the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:16120,detect,detects,16120,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['detect'],['detects']
Safety,"ity. And when the types are obvious from people's experience; (e.g., in the br instruction), it doesn't seem to help as much. o On reflection, I really like your idea of having the two different switch; types (even though they encode implementation techniques rather than; semantics). It should simplify building the CFG and my guess is it could; enable some significant optimizations, though we should think about which. o In the lookup-indirect form of the switch, is there a reason not to make; the val-type uint? Most HLL switch statements (including Java and C++); require that anyway. And it would also make the val-type uniform ; in the two forms of the switch. I did see the switch-on-bool examples and, while cute, we can just use; the branch instructions in that particular case. o I agree with your comment that we don't need 'neg'. o There's a trade-off with the cast instruction:; + it avoids having to define all the upcasts and downcasts that are; valid for the operands of each instruction (you probably have thought; of other benefits also); - it could make the bytecode significantly larger because there could; be a lot of cast operations. o Making the second arg. to 'shl' a ubyte seems good enough to me.; 255 positions seems adequate for several generations of machines; and is more compact than uint. o I still have some major concerns about including malloc and free in the; language (either as builtin functions or instructions). LLVM must be; able to represent code from many different languages. Languages such as; C, C++ Java and Fortran 90 would not be able to use our malloc anyway; because each of them will want to provide a library implementation of it. This gets even worse when code from different languages is linked; into a single executable (which is fairly common in large apps).; Having a single malloc would just not suffice, and instead would simply; complicate the picture further because it adds an extra variant in; addition to the one each language provid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:1585,avoid,avoids,1585,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['avoid'],['avoids']
Safety,"ivate member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:21309,safe,safety,21309,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"ive username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still destroyed at the end of the query, but there was no; memory advantage in TH1::Add wrt TH1::Merge.; Make sure that the performance tree is removed from the output; list when saved to the output file. Solves a segv at quit.; Decouple from registered TChains in already TProof::Close(); allows; to avoid possible crash at exit ('.q') occuring after the recent; revision of the socket cleanup policy.; In XrdProofd, fix a few issues with option 'xpd.multiuser'.; In TXSocket::ProcessUnsolicitedMsg, fix an issue preventig server; messages to be displayed during setup, i.e. when the XrdClientConn; instance is not yet defined.; In XrdProofd, fix the behavior of the 'xpd.allowedusers' and; 'xpd.allowedgroups' directives. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:4248,avoid,avoid,4248,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,1,['avoid'],['avoid']
Safety,"ix - correct tooltip handling for graphs with lines and markers; 8. Fix - interactive zooming in TH2 when doing histogram update. ## Changes in 4.4.2; 1. Fix - statistic collection for TH2; 2. Fix - correct handling of empty TList in browser/inspector; 3. Fix - support TFolder in browser/inspector (#40). ## Changes in 4.4.1; 1. Fix - colz palette resize when drawing histogram second time; 2. Fix - use embedded in TCanvas color for background color of canvas itself; 3. Fix - rotate too long X axis text labels; 4. Fix - draw histogram bins on frame boundary; 5. Fix - use alternative color for shapes with default black color; 6. Fix - correctly handle pcon/pgon shape with rmin==rmax on top or bottom side. ## Changes in 4.4; 1. Fix faces orientation for all TGeo shapes.; 2. Improve TGeoTorus creation - handle all parameters combinations; 3. Implement TGeoCompositeShape, using ThreeCSG.js; 4. Fix problem with color palette when switch to 3D mode (#28); 5. Use nested CSS classes to avoid conflicts with other libraries (#29); 6. Let move and resize TFrame; 7. Improve TH1/TH2 drawings; - draw all histograms points in the range (no any skipped bins); - minimize SVG code for drawing (up to factor 100); - gives significant speedup in drawings; 8. SVG code improvement for TGraph, TF1, TAxis drawings; 9. Provide new tooltip kind; - created only when needed (minimizing SVG code); - tooltip can be drawn for every object in the frame; - touch devices are supported; 10. Fix - let draw same object on the canvas with different options; 11. Create cached list of known class methods. It can be extended by users.; 12. Use of cached methods improves binary I/O performance by 20%; 13. Support TGaxis; 14. Project now can be obtained via 'bower install jsroot'; 15. Support 'scat' and 'text' draw options for TH2; 16. Support in binary I/O zipped buffer bigger than 16M; 17. Correctly handle in binary I/O pointer on TArray object (like in THnSparseArrayChunk). ## Changes in 4.3; 1. Implement TGe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:56685,avoid,avoid,56685,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['avoid'],['avoid']
Safety,"ix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121916,safe,safety,121916,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4325,unsafe,unsafe,4325,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"ize by a factor 10 (compare to the previous; implementation) for normal plots with math formulae and greek characters.; - Offer 0 as line width option. Useful to make a line invisible. ### TPDF. - When a text size was equal or smaller than 0 the PDF file was corrupted.; - Small fix for fill patterns 1, 2 and 3.; - When printing a coloured 2D histograms (with option COLZ) into a PDF or PostScript; file, the preview on screen using many standard PDF previewer tools showed very; thin white lines between the bins as well as in the color palette.; This made very ugly the final output.; This problem is due to bad implementation of anti-aliasing in these previewers.; A way to bypass this issue was to turn off the anti-aliasing in the previewer; but then the rest of the document does not look nice. This problem is now bypassed; with a fix in both PDF and PostScript output.; - Offer 0 as line width option. Useful to make a line invisible. ### TSVG. - Use float numbers instead of integer to describe graphics paths to avoid; rounding problems.; - Implement missing math symbols.; - Offer 0 as line width option. Useful to make a line invisible. ### TASImage. - In the animated gif it is now possible to specify the delay between the last; image and the fist image in case of infinite loop. (Fernando Hueso González; <f.gonzalez@hzdr.de>). ### TPadPainter; - Offer 0 as line width option. Useful to make a line invisible. ### TPad. - In `TPad::ShowGuidelines` the number of guide lines is limited to 15. Above; that they become useless.; - Print a warning if one of the pad limit is a NaN.; - Fix https://sft.its.cern.ch/jira/browse/ROOT-6703. ### TCanvas. - Make sure that ""/"" and ""."" are not part of the method name when a canvas is; saved as a .C file. ### TLatex. - With the Cocoa backend the PDF and PS output produced miss-aligned exponents; because the `GetTextExtend` method behaved differently in batch mode and ""screen""; mode. This is now fixed. See http://root.cern.ch/phpBB3/viewtopic.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:22917,avoid,avoid,22917,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['avoid'],['avoid']
Safety,"jective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71856,unsafe,unsafe,71856,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=und",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2410,recover,recover,2410,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recover']
Safety,"k:: c++. #include ""llvm/CodeGen/AsmPrinter.h""; #include ""llvm/IR/Function.h""; #include ""llvm/IR/DataLayout.h""; #include ""llvm/Target/TargetAsmInfo.h""; #include ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. //",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37715,safe,safe,37715,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ke this:. .. code-block:: text. ; Function Attrs: nounwind ssp uwtable; define void @foo() #0 !dbg !4 {; entry:; %X = alloca i32, align 4; %Y = alloca i32, align 4; %Z = alloca i32, align 4; call void @llvm.dbg.declare(metadata i32* %X, metadata !11, metadata !13), !dbg !14; store i32 21, i32* %X, align 4, !dbg !14; call void @llvm.dbg.declare(metadata i32* %Y, metadata !15, metadata !13), !dbg !16; store i32 22, i32* %Y, align 4, !dbg !16; call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; store i32 23, i32* %Z, align 4, !dbg !19; %0 = load i32, i32* %X, align 4, !dbg !20; store i32 %0, i32* %Z, align 4, !dbg !21; %1 = load i32, i32* %Y, align 4, !dbg !22; store i32 %1, i32* %X, align 4, !dbg !23; ret void, !dbg !24; }. ; Function Attrs: nounwind readnone; declare void @llvm.dbg.declare(metadata, metadata, metadata) #1. attributes #0 = { nounwind ssp uwtable ""less-precise-fpmad""=""false"" ""frame-pointer""=""all"" ""no-infs-fp-math""=""false"" ""no-nans-fp-math""=""false"" ""stack-protector-buffer-size""=""8"" ""unsafe-fp-math""=""false"" ""use-soft-float""=""false"" }; attributes #1 = { nounwind readnone }. !llvm.dbg.cu = !{!0}; !llvm.module.flags = !{!7, !8, !9}; !llvm.ident = !{!10}. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)"", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, subprograms: !3, globals: !2, imports: !2); !1 = !DIFile(filename: ""/dev/stdin"", directory: ""/Users/dexonsmith/data/llvm/debug-info""); !2 = !{}; !3 = !{!4}; !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: false, retainedNodes: !2); !5 = !DISubroutineType(types: !6); !6 = !{null}; !7 = !{i32 2, !""Dwarf Version"", i32 2}; !8 = !{i32 2, !""Debug Info Version"", i32 3}; !9 = !{i32 1, !""PIC Level"", i32 2}; !10 = !{!""clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)""}; !11 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:13856,unsafe,unsafe-fp-math,13856,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['unsafe'],['unsafe-fp-math']
Safety,"ked just like; `LLVMFuzzerTestOneInput`, and has the same signature. .. code-block:: c++. extern ""C"" int LLVMFuzzerRunDriver(int *argc, char ***argv,; int (*UserCb)(const uint8_t *Data, size_t Size));. Rejecting unwanted inputs; -------------------------. It may be desirable to reject some inputs, i.e. to not add them to the corpus. For example, when fuzzing an API consisting of parsing and other logic,; one may want to allow only those inputs into the corpus that parse successfully. If the fuzz target returns -1 on a given input,; libFuzzer will not add that input top the corpus, regardless of what coverage; it triggers. .. code-block:: c++. extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; if (auto *Obj = ParseMe(Data, Size)) {; Obj->DoSomethingInteresting();; return 0; // Accept. The input may be added to the corpus.; }; return -1; // Reject; The input will not be added to the corpus.; }. Leaks; -----. Binaries built with AddressSanitizer_ or LeakSanitizer_ will try to detect; memory leaks at the process shutdown.; For in-process fuzzing this is inconvenient; since the fuzzer needs to report a leak with a reproducer as soon as the leaky; mutation is found. However, running full leak detection after every mutation; is expensive. By default (``-detect_leaks=1``) libFuzzer will count the number of; ``malloc`` and ``free`` calls when executing every mutation.; If the numbers don't match (which by itself doesn't mean there is a leak); libFuzzer will invoke the more expensive LeakSanitizer_; pass and if the actual leak is found, it will be reported with the reproducer; and the process will exit. If your target has massive leaks and the leak detection is disabled; you will eventually run out of RAM (see the ``-rss_limit_mb`` flag). Developing libFuzzer; ====================. LibFuzzer is built as a part of LLVM project by default on macos and Linux.; Users of other operating systems can explicitly request compilation using; ``-DCOMPILER_RT_BUILD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:26412,detect,detect,26412,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detect']
Safety,"kers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Saurav Shekhar, GSOC 2017,\; Xavier Valls Pla, UJI, CERN/SFT,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit,\; Stefan Wunsch, CERN/SFT, \; Zhe Zhang, UNL. ## Important Notice. The default compression algorithm used when writing ROOT files has been updated to use LZ4 in particular to improve read (decompression) performance. You can change this default for each file through (for example) the `TFile constructor` or `TFile::SetCompressionAlgorithm`. It should be noted that ROOT files written with LZ4 compression can not be read with older release of ROOT. Support for LZ4 was however back-ported to the patch branches of previous releases and the following tags (and later release in the same patch series) can read ROOT files written with LZ4 compression:. * v5.34/38; * v6.08/06 [not yet released]; * v6.10/08; * v6.12/02. ## Removed interfaces. ## Core Libraries; - Optimize away redundant deserialization of template specializations. This reduces the memory footprint for hsimple by around 30% while improving the runtime performance for various cases by around 15%.; - When ROOT is signaled with a SIGUSR2 (i.e. on Linux and MacOS X) it will now print a backtrace.; - Move RStringView.h to ROOT/RStringView.hxx and always include ROOT/RStringView.hxx instead of RStringView.h for backward compatibility; - In `TClingCallFunc`, support r-value reference parameters. This paves the way for the corresponding support in PyROOT (implemented now in the latest Cppyy).; - Included the new TSequentialExecutor in ROOT, sharing the interfaces of TExecutor.This should improve code economy when providing a fallback for TThreadExecutor/TProcessExecutor. ### Thread safety; - Resolved several race conditions, dead-locks, performance and order of initialization/destruction issues still lingering because of or despite the new read-write lock mechanism. ## Interpreter. - Enabled use of multi-thre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:1755,redund,redundant,1755,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['redund'],['redundant']
Safety,"kground estimate. The signal is always assumed to be Poisson;; background may be Poisson, Gaussian, or user-supplied; efficiency may be; Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum.; Meth. A551:493-503,2005. **`TLimit`** class computes 95% C.L. limits using the Likelihood ratio; semi-Bayesian method ( <CLs> method; see e.g. T. Junk, NIM A434, p.; 435-443, 1999). It takes signal background and data histograms wrapped; in a `TLimitDataSource` as input, and runs a set of Monte Carlo; experiments in order to compute the limits. If needed, inputs are; fluctuated according to systematic. ### Specialized Classes for Fitting. **`TFractionFitter`** fits Monte Carlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:118317,predict,predictions,118317,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['predict'],['predictions']
Safety,"king inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (and; common practice) to initialize guarded members without acquiring any locks.; The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the; object being initialized or destroyed, while still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:22771,safe,safety,22771,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26485,safe,safe,26485,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"l be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163610,safe,safe,163610,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['safe'],['safe']
Safety,"l""; LABELS ${labels}; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}). if(${t} IN_LIST multithreaded); # Makes sure that this doesn't run in parallel with other multithreaded tutorials, and that cmake doesn't start too; # many other tests. That we use 4 processors is actually a lie, because IMT takes whatever it finds.; # However, even this poor indication of MT behaviour is a good hint for cmake to reduce congestion.; set_tests_properties(tutorial-${tname} PROPERTIES RESOURCE_LOCK multithreaded PROCESSORS ${NProcessors}); endif(); endforeach(). #---Loop over all MPI tutorials and define the corresponding test---------; foreach(t ${mpi_tutorials}); list(FIND returncode_1 ${t} index); if(index EQUAL -1); set(rc 0); else(); set(rc 255); endif(); string(REPLACE "".C"" """" tname ${t}); string(REPLACE ""/"" ""-"" tname ${tname}). # These tests on ARM64 need much more than 20 minutes - increase the timeout; if(ROOT_ARCHITECTURE MATCHES arm64 OR ROOT_ARCHITECTURE MATCHES ppc64); set(thisTestTimeout 3000) # 50m; else(); set(thisTestTimeout 1200) # 20m; endif(). ROOT_ADD_TEST(tutorial-${tname}; COMMAND ${MPIEXEC_EXECUTABLE} ${MPIEXEC_NUMPROC_FLAG} 4 ${ROOT_root_CMD} -b -l -q ${CMAKE_CURRENT_SOURCE_DIR}/${t}${${tname}-aclic}; PASSRC ${rc} FAILREGEX ""Error in <"" "": error:"" ""segmentation violation"" ""FROM HESSE STATUS=FAILED"" ""warning: Failed to call""; LABELS tutorial; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}); endforeach(). #---Python tutorials-----------------------------------------------------; if(ROOT_pyroot_FOUND). # Copy .rootlogon.py file into the build directory. It disables graphics for the Python tutorials; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/.rootlogon.py ${CMAKE_CURRENT_BINARY_DIR} COPYONLY); # Copy .enableImplicitMTWrapper.py file into the build directory. It can limit the size of the thread pool; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/.enableImpli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:25467,timeout,timeout,25467,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['timeout'],['timeout']
Safety,"l, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has_constexpr_builtin`` is used in libcxx's implementation of; the ``<cmath>`` header file to conditionally make a function constexpr whenever; the constant evaluation of the corresponding builtin (for exa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1675,detect,detect,1675,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['detect'],['detect']
Safety,"language, for example by; lifting a restriction or by adding new syntax, the change will be annotated; with a revision marker, like so:. ARC applies to Objective-C pointer types, block pointer types, and; :when-revised:`[beginning Apple 8.0, LLVM 3.8]` :revision:`BPTRs declared; within` ``extern ""BCPL""`` blocks. For now, it is sensible to version this document by the releases of its sole; implementation (and its host project), clang. ""LLVM X.Y"" refers to an; open-source release of clang from the LLVM project. ""Apple X.Y"" refers to an; Apple-provided release of the Apple LLVM Compiler. Other organizations that; prepare their own, separately-versioned clang releases and wish to maintain; similar information in this document should send requests to cfe-dev. If a change decreases the expressiveness of the language, for example by; imposing a new restriction, this should be taken as an oversight in the; original specification and something to be avoided in all versions. Such; changes are generally to be avoided. .. _arc.general:. General; =======. Automatic Reference Counting implements automatic memory management for; Objective-C objects and blocks, freeing the programmer from the need to; explicitly insert retains and releases. It does not provide a cycle collector;; users must explicitly manage the lifetime of their objects, breaking cycles; manually or with weak or unsafe references. ARC may be explicitly enabled with the compiler flag ``-fobjc-arc``. It may; also be explicitly disabled with the compiler flag ``-fno-objc-arc``. The last; of these two flags appearing on the compile line ""wins"". If ARC is enabled, ``__has_feature(objc_arc)`` will expand to 1 in the; preprocessor. For more information about ``__has_feature``, see the; :ref:`language extensions <langext-__has_feature-__has_extension>` document. .. _arc.objects:. Retainable object pointers; ==========================. This section describes retainable object pointers, their basic operations, and; the restr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:8709,avoid,avoided,8709,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoided']
Safety,"lap with any other pass executions (thus it should be very fast). .. _writing-an-llvm-pass-runOnSCC:. The ``runOnSCC`` method; ^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnSCC(CallGraphSCC &SCC) = 0;. The ``runOnSCC`` method performs the interesting work of the pass, and should; return ``true`` if the module was modified by the transformation, ``false``; otherwise. The ``doFinalization(CallGraph &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization(CallGraph &CG);. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnSCC; <writing-an-llvm-pass-runOnSCC>` for every SCC in the program being compiled. .. _writing-an-llvm-pass-FunctionPass:. The ``FunctionPass`` class; --------------------------. In contrast to ``ModulePass`` subclasses, `FunctionPass; <https://llvm.org/doxygen/classllvm_1_1Pass.html>`_ subclasses do have a; predictable, local behavior that can be expected by the system. All; ``FunctionPass`` execute on each function in the program independent of all of; the other functions in the program. ``FunctionPass``\ es do not require that; they are executed in a particular order, and ``FunctionPass``\ es do not modify; external functions. To be explicit, ``FunctionPass`` subclasses are not allowed to:. #. Inspect or modify a ``Function`` other than the one currently being processed.; #. Add or remove ``Function``\ s from the current ``Module``.; #. Add or remove global variables from the current ``Module``.; #. Maintain state across invocations of :ref:`runOnFunction; <writing-an-llvm-pass-runOnFunction>` (including global data). Implementing a ``FunctionPass`` is usually straightforward (See the :ref:`Hello; World <writing-an-llvm-pass-basiccode>` pass for example).; ``FunctionPass``\ es may override three virtual methods to do their work. All; of these methods should return ``true`` if they modified the program, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:17256,predict,predictable,17256,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['predict'],['predictable']
Safety,"laration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In parti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22121,unsafe,unsafe,22121,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['unsafe'],['unsafe']
Safety,"lating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:6507,safe,safety,6507,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"lation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124140,safe,safe,124140,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['safe'],['safe']
Safety,"lations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity prote",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3047,safe,safe,3047,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,3,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"le header file. Don't do this!. If you really need to do something like this, put a private header file in the; same directory as the source files, and include it locally. This ensures that; your private interface remains private and undisturbed by outsiders. .. note::. It's okay to put extra implementation methods in a public class itself. Just; make them private (or protected) and all is well. Use Namespace Qualifiers to Implement Previously Declared Functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When providing an out of line implementation of a function in a source file, do; not open namespace blocks in the source file. Instead, use namespace qualifiers; to help ensure that your definition matches an existing declaration. Do this:. .. code-block:: c++. // Foo.h; namespace llvm {; int foo(const char *s);; }. // Foo.cpp; #include ""Foo.h""; using namespace llvm;; int llvm::foo(const char *s) {; // ...; }. Doing this helps to avoid bugs where the definition does not match the; declaration from the header. For example, the following C++ code defines a new; overload of ``llvm::foo`` instead of providing a definition for the existing; function declared in the header:. .. code-block:: c++. // Foo.cpp; #include ""Foo.h""; namespace llvm {; int foo(char *s) { // Mismatch between ""const char *"" and ""char *""; }; } // namespace llvm. This error will not be caught until the build is nearly complete, when the; linker fails to find a definition for any uses of the original function. If the; function were instead defined with a namespace qualifier, the error would have; been caught immediately when the definition was compiled. Class method implementations must already name the class and new overloads; cannot be introduced out of line, so this recommendation does not apply to them. .. _early exits:. Use Early Exits and ``continue`` to Simplify Code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When reading code, keep in mind how much state and ho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:34321,avoid,avoid,34321,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"le hierarchy"". Each node ``X`` in a given CFG is reported to be m-converged if and; only if every cycle that contains ``X`` satisfies the following necessary; conditions:. 1. Every divergent branch inside the cycle satisfies the; :ref:`diverged entry criterion<convergence-diverged-entry>`, and,; 2. There are no :ref:`diverged paths reaching the; cycle<convergence-diverged-outside>` from a divergent branch; outside it. .. note::. A reducible cycle :ref:`trivially satisfies; <convergence-reducible-cycle>` the above conditions. In particular,; if the whole CFG is reducible, then all nodes in the CFG are; m-converged. The uniformity of each output of a static instance; is determined using the criteria; :ref:`described earlier <convergence-uniformity>`. The discovery of; divergent outputs may cause their uses (including branches) to also; become divergent. The analysis propagates this divergence until a; fixed point is reached. The convergence inferred using these criteria is a safe subset of the; maximal converged-with relation for any cycle hierarchy. In; particular, it is sufficient to determine if a static instance is; m-converged for a given cycle hierarchy ``T``, even if that fact is; not detected when examining some other cycle hierarchy ``T'``. This property allows compiler transforms to use the uniformity; analysis without being affected by DFS choices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:19925,safe,safe,19925,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['safe'],['safe']
Safety,"le nested bounds annotations; can be allowed using an explicit cast (e.g., C-style cast). Hereafter, the rules; only apply to the top pointer types. ``__unsafe_indexable`` cannot be converted; to any other safe pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, etc) using a cast. The extension provides builtins to force; this conversion, ``__unsafe_forge_bidi_indexable(type, pointer, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicitly be ``FILE; *__unsafe_indexable`` and thus it cannot be directly assigned to ``FILE *fp``; in the bounds-safe source. To allow this operation, ``__unsafe_forge_single``; is used to create a ``__single`` from the return value of ``fopen``. * Simila",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:40752,unsafe,unsafe,40752,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"le pass clean up dead defs for such calls, as it does; for stores. //===---------------------------------------------------------------------===//. Consider implementing optimizeSelect, optimizeCompareInstr, optimizeCondBranch,; optimizeLoadInstr, and/or getMachineCombinerPatterns. //===---------------------------------------------------------------------===//. Find a clean way to fix the problem which leads to the Shrink Wrapping pass; being run after the WebAssembly PEI pass. //===---------------------------------------------------------------------===//. When setting multiple local variables to the same constant, we currently get; code like this:. i32.const $4=, 0; i32.const $3=, 0. It could be done with a smaller encoding like this:. i32.const $push5=, 0; local.tee $push6=, $4=, $pop5; local.copy $3=, $pop6. //===---------------------------------------------------------------------===//. WebAssembly registers are implicitly initialized to zero. Explicit zeroing is; therefore often redundant and could be optimized away. //===---------------------------------------------------------------------===//. Small indices may use smaller encodings than large indices.; WebAssemblyRegColoring and/or WebAssemblyRegRenumbering should sort registers; according to their usage frequency to maximize the usage of smaller encodings. //===---------------------------------------------------------------------===//. Many cases of irreducible control flow could be transformed more optimally; than via the transform in WebAssemblyFixIrreducibleControlFlow.cpp. It may also be worthwhile to do transforms before register coloring,; particularly when duplicating code, to allow register coloring to be aware of; the duplication. //===---------------------------------------------------------------------===//. WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more; aggressively. //===---------------------------------------------------------------------===//. WebAssemblyRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:4315,redund,redundant,4315,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['redund'],['redundant']
Safety,"le path references in ``.rc`` files; concatenated from multiple string literals. * The ``llvm-windres`` option ``--preprocessor`` now resolves its argument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:15906,avoid,avoiding,15906,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['avoid'],['avoiding']
Safety,"le still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:23458,safe,safety,23458,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"le, customize differently the quotas.Fix an issue with TTreeFriends. New tutorial showing how to use friends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative values were ignored and there was no way for the user to disable the use of submergers). . Packetizer optimizations: improved worked distribution when; the number of files left to be processed is smaller than the number of; workers and at least one file has a number of events significantly; larger than the average; better apply the upper/lower limits on the; expected packet processing time.; Add the possibility to single-out disk partitions in the; packetizer; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:6527,timeout,timeout,6527,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['timeout'],['timeout']
Safety,"leView` objects for the independent reading of individual fields.; The reader can create `RBulk` objects for bulk reading of individual fields. Additionally, the reader provides access to a cached copy of the descriptor.; It can display individual entries (`RNTupleReader::Show()`) and summary information (`RNTupleReader::PrintInfo()`). ### RNTupleView<T>; RNTuple views provide read access to individual fields.; Views are created from an RNTupleReader.; Views are templated; for simple types (e.g., `float`, `int`), views provide read-only access directly to an RNTuple page in memory.; Complex types and void views require additional memory copies to populate an object in memory from the column data. A view can iterate over the entry range, over the field range, and over the range of a collection within an entry.; For instance, for a field `std::vector<float> pt`, a view can iterate over all `pt` values of all entries, or over the `pt` values of a particular entry. A view can safely outlive its originating reader.; Once the reader is deconstructed, any attempt to read data will throw an exception, but the view is still properly destructed. Views that originate from the same reader _cannot_ be used concurrently by different threads. Internal Classes; ----------------. ### RNTupleDS; The `RNTupleDS` class is an internal class that provides an RNTuple data source for RDataFrame.; It is part of the `ROOTDataFrame` library.; The RNTuple data source supports chains with a constructor that takes a list of input files.; The RNTuple data source also supports multi-threaded dataframes, parallelized on the file and cluster level. The data source exposes inner fields of complex collections.; For instance, if the data model contains a vector of `Event` classes, where each `Event` has `pt` and `eta` floats,; the dataframe can use the event vector itself (`Event` column) as well as the `float` columns `Event.pt` and `Event.eta`. ### RClusterPool; The RClusterPool is an internal class ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:14120,safe,safely,14120,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['safe'],['safely']
Safety,"led. Thus, the code adopting ``-fbounds-safety`` can compile with; toolchains that do not support this extension, by including the header or adding; macros to define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ==================================================. The bounds annotations provided by the ``-fbounds-safety`` programming model; have potential use cases beyond the language extension itself. For example,; static and dynamic analysis tools could use the bounds information to improve; diagnostics for out-of-bounds accesses, even if ``-fbounds-safety`` is not used.; The bounds annotations could be used to improve C interoperability with; bounds-safe languages, providing a better mapping to bounds-safe types in the; safe language interface. The bounds annotations can also serve as documentation; specifying the relationship between declarations. Limitations; ===========. ``-fbounds-safety`` aims to bring the bounds safety guarantee to the C language,; and it does not guarantee other types of memory safety properties. Consequently,; it may not prevent some of the secondary bounds safety violations caused by; other types of safety violations such as type confusion. For instance,; ``-fbounds-safety`` does not perform type-safety checks on conversions between; `__single`` pointers of different pointee types (e.g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:46594,safe,safety,46594,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"lee upon return. The idea is that it saves callers from having to remember this value,; which would often require a callee-saved register. Callees usually; need to keep this value live for most of their body anyway, so it; doesn't add a significant burden on them. We currently implement this in codegen, however this is suboptimal; because it means that it would be quite awkward to implement the; optimization for callers. A better implementation would be to relax the LLVM IR rules for sret; arguments to allow a function with an sret argument to have a non-void; return type, and to have the front-end to set up the sret argument value; as the return value of the function. The front-end could more easily; emit uses of the returned struct value to be in terms of the function's; lowered return value, and it would free non-C frontends from a; complication only required by a C-based ABI. //===---------------------------------------------------------------------===//. We get a redundant zero extension for code like this:. int mask[1000];; int foo(unsigned x) {; if (x < 10); x = x * 45;; else; x = x * 78;; return mask[x];; }. _foo:; LBB1_0:	## entry; 	cmpl	$9, %edi; 	jbe	LBB1_3	## bb; LBB1_1:	## bb1; 	imull	$78, %edi, %eax; LBB1_2:	## bb2; 	movl	%eax, %eax <----; 	movq	_mask@GOTPCREL(%rip), %rcx; 	movl	(%rcx,%rax,4), %eax; 	ret; LBB1_3:	## bb; 	imull	$45, %edi, %eax; 	jmp	LBB1_2	## bb2; ; Before regalloc, we have:. %reg1025 = IMUL32rri8 %reg1024, 45, implicit-def %eflags; JMP mbb<bb2,0x203afb0>; Successors according to CFG: 0x203afb0 (#3). bb1: 0x203af60, LLVM BB @0x1e02310, ID#2:; Predecessors according to CFG: 0x203aec0 (#0); %reg1026 = IMUL32rri8 %reg1024, 78, implicit-def %eflags; Successors according to CFG: 0x203afb0 (#3). bb2: 0x203afb0, LLVM BB @0x1e02340, ID#3:; Predecessors according to CFG: 0x203af10 (#1) 0x203af60 (#2); %reg1027 = PHI %reg1025, mbb<bb,0x203af10>,; %reg1026, mbb<bb1,0x203af60>; %reg1029 = MOVZX64rr32 %reg1027. so we'd have to know that IMUL32rri8 le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt:2843,redund,redundant,2843,interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt,1,['redund'],['redundant']
Safety,"lename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68886,safe,safe,68886,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"ligned stores of the same width as the unaligned store. Backends are; also expected to generate an i8 store as an i8 store, and not an instruction; which writes to surrounding bytes. (If you are writing a backend for an; architecture which cannot satisfy these restrictions and cares about; concurrency, please send an email to llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part of a special atomic structure or depend on a separate per-process; global lock. Note that code generation will fail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:8585,safe,safe,8585,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['safe'],['safe']
Safety,"ling convention is `swifttailcc` or `swiftcc`:. - Only these ABI-impacting attributes attributes are allowed: sret, byval,; swiftself, and swiftasync.; - Prototypes are not required to match. Tail call optimization for calls marked ``tail`` is guaranteed to occur if; the following conditions are met:. - Caller and callee both have the calling convention ``fastcc`` or ``tailcc``.; - The call is in tail position (ret immediately follows call and ret; uses value of call or is void).; - Option ``-tailcallopt`` is enabled,; ``llvm::GuaranteedTailCallOpt`` is ``true``, or the calling convention; is ``tailcc``; - `Platform-specific constraints are; met. <CodeGenerator.html#tailcallopt>`_. #. The optional ``notail`` marker indicates that the optimizers should not add; ``tail`` or ``musttail`` markers to the call. It is used to prevent tail; call optimization from being performed on the call. #. The optional ``fast-math flags`` marker indicates that the call has one or more; :ref:`fast-math flags <fastmath>`, which are optimization hints to enable; otherwise unsafe floating-point optimizations. Fast-math flags are only valid; for calls that return a floating-point scalar or vector type, or an array; (nested to any depth) of floating-point scalar or vector types. #. The optional ""cconv"" marker indicates which :ref:`calling; convention <callingconv>` the call should use. If none is; specified, the call defaults to using C calling conventions. The; calling convention of the call must match the calling convention of; the target function, or else the behavior is undefined.; #. The optional :ref:`Parameter Attributes <paramattrs>` list for return; values. Only '``zeroext``', '``signext``', and '``inreg``' attributes; are valid here.; #. The optional addrspace attribute can be used to indicate the address space; of the called function. If it is not specified, the program address space; from the :ref:`datalayout string<langref_datalayout>` will be used.; #. '``ty``': the type of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:475806,unsafe,unsafe,475806,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"lization with designators, you; need to create and edit the configuration struct explicitely:; ```C++; RooStats::HistFactory::HistoToWorkspaceFactoryFast::Configuration hfCfg;; hfCfg.binnedFitOptimization = false;; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, hfCfg);; ```. ### Disable copy assignment for RooAbsArg and derived types. Copy assignment for RooAbsArgs was implemented in an unexpected and; inconsistent way. While one would expect that the copy assignment is copying; the object, it said in the documentation of `RooAbsArg::operator=` that it will; ""assign all boolean and string properties of the original bject. Transient; properties and client-server links are not assigned."" This contradicted with; the implementation, where the server links were actually copied too.; Furthermore, in `RooAbsRealLValue`, the assigment operator was overloaded by a; function that only assigns the value of another `RooAbsReal`. With all these inconsistencies, it was deemed safer to disable copy assignment; of RooAbsArgs from now on. ### RooBrowser: a graphical user interface for workspace exploration, visualization, and analysis. This experimental new feature utilises the technology from ROOT's familiar `TBrowser` in order to create an interface for graphically exploring and visualizing the content of a workspace, as well as perform basic fitting operations with the models and datasets. ![Demonstration of RooBrowser using json workspace from the roofit tutorials directory](RooBrowser.png). ### Removal of deprecated HistFactory functionality. #### Removal of HistoToWorkspaceFactory (non-Fast version). The original `HistoToWorkspaceFactory` produced models that consisted of a; Poisson term for each bin. In this ""number counting form"" the dataset has one; row and the collumns corresponded to the number of events for each bin. This; led to severe performance problems in statistical tools that generated; pseudo-experiments and evaluated likelihood ratio test statist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:21919,safe,safer,21919,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['safe'],['safer']
Safety,"lized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant powe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:19317,redund,redundant,19317,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['redund'],['redundant']
Safety,"ll arguments specified after **--args** to the test program whenever it runs.; Note that if any of the *program args* start with a ""``-``"", you should use:. .. code-block:: bash. bugpoint [bugpoint args] --args -- [program args]. The ""``--``"" right after the **--args** option tells **bugpoint** to consider; any options starting with ""``-``"" to be part of the **--args** option, not as; options to **bugpoint** itself. **--tool-args** *tool args*. Pass all arguments specified after **--tool-args** to the LLVM tool under test; (**llc**, **lli**, etc.) whenever it runs. You should use this option in the; following way:. .. code-block:: bash. bugpoint [bugpoint args] --tool-args -- [tool args]. The ""``--``"" right after the **--tool-args** option tells **bugpoint** to; consider any options starting with ""``-``"" to be part of the **--tool-args**; option, not as options to **bugpoint** itself. (See **--args**, above.). **--safe-tool-args** *tool args*. Pass all arguments specified after **--safe-tool-args** to the ""safe"" execution; tool. **--gcc-tool-args** *gcc tool args*. Pass all arguments specified after **--gcc-tool-args** to the invocation of; **gcc**. **--opt-args** *opt args*. Pass all arguments specified after **--opt-args** to the invocation of **opt**. **--disable-{dce,simplifycfg}**. Do not run the specified passes to clean up and reduce the size of the test; program. By default, **bugpoint** uses these passes internally when attempting to; reduce test programs. If you're trying to find a bug in one of these passes,; **bugpoint** may crash. **--enable-valgrind**. Use valgrind to find faults in the optimization phase. This will allow; bugpoint to find otherwise asymptomatic problems caused by memory; mis-management. **-find-bugs**. Continually randomize the specified passes and run them on the test program; until a bug is found or the user kills **bugpoint**. **-help**. Print a summary of command line options. **--input** *filename*. Open *filename* and redirect th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:2207,safe,safe-tool-args,2207,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,2,['safe'],"['safe', 'safe-tool-args']"
Safety,"ll be costly for downstream maintainers. See `Big bang`_ for potential; mitigations. Laissez faire; -------------. The coding standard could allow both ``CamelCase`` and ``camelBack`` styles for; variable names [LattnerTransition]_. A code review to implement this is at https://reviews.llvm.org/D57896. Advantages; **********. * Very easy to implement initially. Disadvantages; *************. * Leads to inconsistency [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ************************. ``git blame`` (or ``git annotate``) permits quickly identifying the commit that; changed a given line in a file. After renaming variables, many lines will show; as being changed by that one commit, requiring a further invocation of ``git; blame`` to identify prior, more interesting commits [GreeneGitBlame]_; [RicciAcronyms]_. **Mitigation**: `git-hyper-blame; <https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/git-hyper-blame.html>`_; can ignore or ""look through"" a given set of commits.; A ``.git-blame-ignore-revs`` file identifying the variable renaming commits; could be added to the LLVM git repository root directory.; It is being `investigated; <https://public-inbox.org/git/20190324235020.49706-1-michael@platin.gs/>`_; whether similar functionality could b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:8803,avoid,avoiding,8803,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['avoid'],['avoiding']
Safety,"ll designate non-overlapping; nodes as ONLY and the others MANY as in GEANT3, where this concept was; introduced:. 1. The part of a MANY node B extruding its container A will never be; ""seen"" during navigation, as if B was in fact the result of the; intersection of A and B. 2. If we have two nodes A (ONLY) and B (MANY) inside the same container,; all points in the overlapping region of A and B will be designated as; belonging to A. 3. If A an B in the above case were both MANY, points in the overlapping; part will be designated to the one defined first. Both nodes must have; the same medium. 4. The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is; much slower. Any overlapping part can be defined based on composite; shapes - might be in some cases a better way out. #### Replicating Volumes. What can we do if our chamber contains two identical wires instead of; one? What if then we would need 1000 chambers in our detector? Should we; create 2000 wires and 1000 chamber volumes? No, we will just need to; replicate the ones that we have already created. ``` {.cpp}; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ```. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:79098,detect,detector,79098,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"llowing relocations of objects; without visible effects. This high level abstract machine model is used for most of the optimizer. As; a result, transform passes do not need to be extended to look through explicit; relocation sequence. Before starting code generation, we switch; representations to an explicit form. The exact location chosen for lowering; is an implementation detail. Note that most of the value of the abstract machine model comes for collectors; which need to model potentially relocatable objects. For a compiler which; supports only a non-relocating collector, you may wish to consider starting; with the fully explicit form. Warning: There is one currently known semantic hole in the definition of; non-integral pointers which has not been addressed upstream. To work around; this, you need to disable speculation of loads unless the memory type; (non-integral pointer vs anything else) is known to unchanged. That is, it is; not safe to speculate a load if doing causes a non-integral pointer value to; be loaded as any other type or vice versa. In practice, this restriction is; well isolated to isSafeToSpeculate in ValueTracking.cpp. Explicit Representation; ^^^^^^^^^^^^^^^^^^^^^^^. A frontend could directly generate this low level explicit form, but; doing so may inhibit optimization. Instead, it is recommended that; compilers with relocating collectors target the abstract machine model just; described. The heart of the explicit approach is to construct (or rewrite) the IR in a; manner where the possible updates performed by the garbage collector are; explicitly visible in the IR. Doing so requires that we:. #. create a new SSA value for each potentially relocated pointer, and; ensure that no uses of the original (non relocated) value is; reachable after the safepoint,; #. specify the relocation in a way which is opaque to the compiler to; ensure that the optimizer can not introduce new uses of an; unrelocated value after a statepoint. This prevents the opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:5948,safe,safe,5948,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safe']
Safety,"lls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, Fre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5105,detect,detected,5105,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['detect'],['detected']
Safety,"llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part of a special atomic structure or depend on a separate per-process; global lock. Note that code generation will fail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These operations are required to be atomic in the sense that if you use; unordered loads and unordered stores, a load cannot see a value which was; never stored. A normal load or store instruction is usually sufficient, but; note that an unordered load or store cannot be split into multiple; instructions (or an instruction which doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:8882,safe,safe,8882,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['safe'],['safe']
Safety,"llvm-diff - LLVM structural 'diff'; ==================================. .. program:: llvm-diff. SYNOPSIS; --------. **llvm-diff** [*options*] *module 1* *module 2* [*global name ...*]. DESCRIPTION; -----------. **llvm-diff** compares the structure of two LLVM modules, primarily; focusing on differences in function definitions. Insignificant; differences, such as changes in the ordering of globals or in the; names of local values, are ignored. An input module will be interpreted as an assembly file if its name; ends in '.ll'; otherwise it will be read in as a bitcode file. If a list of global names is given, just the values with those names; are compared; otherwise, all global values are compared, and; diagnostics are produced for globals which only appear in one module; or the other. **llvm-diff** compares two functions by comparing their basic blocks,; beginning with the entry blocks. If the terminators seem to match,; then the corresponding successors are compared; otherwise they are; ignored. This algorithm is very sensitive to changes in control flow,; which tend to stop any downstream changes from being detected. **llvm-diff** is intended as a debugging tool for writers of LLVM; passes and frontends. It does not have a stable output format. EXIT STATUS; -----------. If **llvm-diff** finds no differences between the modules, it will exit; with 0 and produce no output. Otherwise it will exit with a non-zero; value. BUGS; ----. Many important differences, like changes in linkage or function; attributes, are not diagnosed. Changes in memory behavior (for example, coalescing loads) can cause; massive detected differences in blocks.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-diff.rst:1126,detect,detected,1126,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-diff.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-diff.rst,2,['detect'],['detected']
Safety,"llvm-ifs - shared object stubbing tool; ======================================. .. program:: llvm-ifs. SYNOPSIS; --------. :program:`llvm-ifs` [*options*] *inputs*. DESCRIPTION; -----------. :program:`llvm-ifs` is a tool that jointly produces human readable text-based; stubs (.ifs files) for shared objects and linkable shared object stubs; (.so files) from either ELF shared objects or text-based stubs. The text-based; stubs is useful for monitoring ABI changes of the shared object. The linkable; shared object stubs can be used to avoid unnecessary relinks when the ABI of; shared libraries does not change. IFS FORMATS; -----------. Here is an example of the text representation (IFS) of a shared object produced; by the :program:`llvm-ifs`:. ::. --- !ifs-v1; IFSVersion: 3.0; SoName: libtest.so /* Optional */; Target: x86_64-unknown-linux-gnu /* Optional, format 1, same format as llvm target triple */; Target: { Arch: x86_64, Endianness: little, Bitwidth: 64 } /* Optional, format 2 */; NeededLibs:; - libc.so.6; Symbols:; - { Name: sym0, Type: Notype }; - { Name: sym1, Type: Object, Size: 0 }; - { Name: sym2, Type: Func, Weak: false }; - { Name: sym3, Type: TLS }; - { Name: sym4, Type: Unknown, Warning: foo }; ... * ``IFSVersion``: Version of the IFS file for reader compatibility. * ``SoName`` (optional): Name of the shared object file that is being stubbed. * ``Target`` (optional): The architecture, endianness and bitwise information of; this shared object. It can be either in explicit format or in implicit LLVM; triple format. It can be optional and can be overridden from command line; options. * ``NeededLibs``: The list of the external shared objects that this library depends on. * ``Symbols``: A collection of all data needed to link objects for each symbol, sorted by name in ascending order. + ``Name``: Symbol name. + ``Type``: Whether the symbol is an object, function, no-type, thread local storage, or unknown. Symbol types not explicitly supported are mapped as unkn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst:536,avoid,avoid,536,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,1,['avoid'],['avoid']
Safety,"llvm-mca - LLVM Machine Code Analyzer; =====================================. .. program:: llvm-mca. SYNOPSIS; --------. :program:`llvm-mca` [*options*] [input]. DESCRIPTION; -----------. :program:`llvm-mca` is a performance analysis tool that uses information; available in LLVM (e.g. scheduling models) to statically measure the performance; of machine code in a specific CPU. Performance is measured in terms of throughput as well as processor resource; consumption. The tool currently works for processors with a backend for which; there is a scheduling model available in LLVM. The main goal of this tool is not just to predict the performance of the code; when run on the target, but also help with diagnosing potential performance; issues. Given an assembly code sequence, :program:`llvm-mca` estimates the Instructions; Per Cycle (IPC), as well as hardware resource pressure. The analysis and; reporting style were inspired by the IACA tool from Intel. For example, you can compile code with clang, output assembly, and pipe it; directly into :program:`llvm-mca` for analysis:. .. code-block:: bash. $ clang foo.c -O2 --target=x86_64 -S -o - | llvm-mca -mcpu=btver2. Or for Intel syntax:. .. code-block:: bash. $ clang foo.c -O2 --target=x86_64 -masm=intel -S -o - | llvm-mca -mcpu=btver2. (:program:`llvm-mca` detects Intel syntax by the presence of an `.intel_syntax`; directive at the beginning of the input. By default its output syntax matches; that of its input.). Scheduling models are not just used to compute instruction latencies and; throughput, but also to understand what processor resources are available; and how to simulate them. By design, the quality of the analysis conducted by :program:`llvm-mca` is; inevitably affected by the quality of the scheduling models in LLVM. If you see that the performance report is not accurate for a processor,; please `file a bug <https://github.com/llvm/llvm-project/issues>`_; against the appropriate backend. OPTIONS; -------. If ``input",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:625,predict,predict,625,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['predict'],['predict']
Safety,"llvm-reduce - LLVM automatic testcase reducer.; ==============================================. .. program:: llvm-reduce. SYNOPSIS; --------. :program:`llvm-reduce` [*options*] [*input...*]. DESCRIPTION; -----------. The :program:`llvm-reduce` tool project that can be used for reducing the size of LLVM test cases.; It works by removing redundant or unnecessary code from LLVM test cases while still preserving ; their ability to detect bugs. If ``input`` is ""``-``"", :program:`llvm-reduce` reads from standard; input. Otherwise, it will read from the specified ``filenames``. LLVM-Reduce is a useful tool for reducing the size and ; complexity of LLVM test cases, making it easier to identify and debug issues in ; the LLVM compiler infrastructure. GENERIC OPTIONS; ---------------. .. option:: --help. Display available options (--help-hidden for more). .. option:: --abort-on-invalid-reduction. Abort if any reduction results in invalid IR. .. option::--delta-passes=<string> . Delta passes to run, separated by commas. By default, run all delta passes. .. option:: --in-place . WARNING: This option will replace your input file with the reduced version!. .. option:: --ir-passes=<string> . A textual description of the pass pipeline, same as what's passed to `opt -passes`. .. option:: -j <uint> . Maximum number of threads to use to process chunks. Set to 1 to disable parallelism. .. option:: --max-pass-iterations=<int>. Maximum number of times to run the full set of delta passes (default=5). .. option:: --mtriple=<string> . Set the target triple. .. option:: --preserve-debug-environment. Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps). .. option:: --print-delta-passes . Print list of delta passes, passable to --delta-passes as a comma separated liste. .. option:: --skip-delta-passes=<string> . Delta passes to not run, separated by commas. By default, run all delta passes. .. option:: --starting-granularity-level=<uint>. Number of time",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst:338,redund,redundant,338,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,3,"['abort', 'detect', 'redund']","['abort-on-invalid-reduction', 'detect', 'redundant']"
Safety,"lly be a pointer to a block object, and if it has; ``Class`` type (possibly protocol-qualified) then it must actually be a pointer; to a class object. Otherwise ARC does not enforce the Objective-C type system; as long as the implementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; modifying code in ways it deems safe according to these constraints, will not; violate their requirements. For example, if the user puts logging statements; in ``retain``, they should not be surprised if those statements are executed; more or less often depending on optimization settings. These constraints are; not exhaustive of the optimization opportunities: values held in local; variables are subject to additional restrictions, described later in this; document. It is undefined behavior if a computation history featuring a send of; ``retain`` followed by a send of ``release`` to the same object, with no; intervening ``release`` on that object, is not equivalent under the high-level; semantics to a computation history in which these sends are removed. Note that; this implies that these methods may not raise exceptions. It is undefined behavior if a computation history features any use whatsoever; of an object following the completion of a send of ``rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:13653,safe,safe,13653,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safe']
Safety,"lly is a; recursive acronym, ""**G**\WP-ASan **W**\ill **P**\rovide **A**\llocation; **SAN**\ity"". GWP-ASan is based on the classic; `Electric Fence Malloc Debugger <https://linux.die.net/man/3/efence>`_, with a; key adaptation. Notably, we only choose a very small percentage of allocations; to sample, and apply guard pages to these sampled allocations only. The sampling; is small enough to allow us to have very low performance overhead. There is a small, tunable memory overhead that is fixed for the lifetime of the; process. This is approximately ~40KiB per process using the default settings,; depending on the average size of your allocations. GWP-ASan vs. ASan; =================. Unlike `AddressSanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_,; GWP-ASan does not induce a significant performance overhead. ASan often requires; the use of dedicated canaries to be viable in production environments, and as; such is often impractical. GWP-ASan is only capable of finding a subset of the memory issues detected by; ASan. Furthermore, GWP-ASan's bug detection capabilities are only probabilistic.; As such, we recommend using ASan over GWP-ASan in testing, as well as anywhere; else that guaranteed error detection is more valuable than the 2x execution; slowdown/binary size bloat. For the majority of production environments, this; impact is too high, and GWP-ASan proves extremely useful. Design; ======. **Please note:** The implementation of GWP-ASan is largely in-flux, and these; details are subject to change. There are currently other implementations of; GWP-ASan, such as the implementation featured in; `Chromium <https://cs.chromium.org/chromium/src/components/gwp_asan/>`_. The; long-term support goal is to ensure feature-parity where reasonable, and to; support compiler-rt as the reference implementation. Allocator Support; -----------------. GWP-ASan is not a replacement for a traditional allocator. Instead, it works by; inserting stubs into a supporting allo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:1268,detect,detected,1268,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detected']
Safety,"load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3655,safe,safely,3655,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safely']
Safety,"loop (15 mins) after client disconnectionsAvoid potential deadlocks when trying to remove a node from a clusterCorrect matching of incoming connection with previously dropped connectionCorrect export of cluster identificationCorrectly propagate information about files that could not be stagedPrevent endsess deadlock when parallel streams stall due to large WAN RTTFix infinite wait for primary login that will never; happen if you are a manager without a meta-managerPrevent annoying (but not deadly) infinite loop should a; server go offline that is subject to a locate request display.Client sideBetter handling of errno, especially for parallel streamsAllow the client to cycle through all the remaining valid security protocols in the list of protocols returned by the serverMake the readahead strategy more conservativeFix a rare race condition happening when destroying instances with outstanding open requestsEnforce cache coherency in the case of reads+writes in the same fileCorrectly guess the filesize of a file opened for writing in sync modeMake server host name check more flexible for GSI authenticationFix some relevant issues with cache handling on the client, including a rare but fatal bug in; determining the cache holes list and the end of a cache lookupMore complete detection of async read errorsGeneralFix problem in handling the return code; of X509_REQ_verify; in XrdCryptosslX509Req.ccAvoid SEGV when doing an lsd admin command with; authenticated xrootd clientsClose race conditions that allowed a supervisor/manager; to subscribe without declaring a data port. Initialize nostage state in; XrdCmsState to prevent erroneous state declaration during; initialization.Fix a problem with the subject name of proxies of level; > 1; this was creating a failure when a Globus application was; trying to use the proxy certificateFix a problem with cache refreshing in XrdSutCache; affecting automatic reloading of password filesFor now, turn off IPV6 processing as it seems to cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html:2618,detect,detection,2618,net/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html,1,['detect'],['detection']
Safety,"lor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->SetStyle(""Modern"");; ; It has very little decoration. It was made looking at the default styles; usually used by the experiments.; ; A new parameter Canvas.Style in etc/system.rootrc allows; to define the default style. If it is not specified, the Modern; style is used. To use the old default style one can set it to Classic or add. gROOT->SetStyle(""Classic"");; ; to your scripts. We seek feedback on improving the Modern style.; Please leave comments in the forum.; ; The following table shows the two plots hpx->Draw() and hpxpy->Draw(""colz""); in the ""Classic"" and ""Modern"" styles.; . Classic Style; Modern Style. An other example:; ; Classic style:. Modern style:. ACLiC. ACLiC now passes the macro __ACLIC__ to both the rootcint and compiler phases. TWinNTSystem. Fix 64-bit compatibility issues (__asm keyword is not allowed).; Try (as much as possible) to avoid the disturbing ""There is no disk in the drive. Please insert a disk into drive \Device\..."" popup message box when calling AccessPathName() on removable disk drives with no media installed. This should fix the problem reported on the forum.; Prevent short timers (e.g. 10ms) to keep looping in the DispatchOneEvent() infinite loop.; Better stdout/stderr redirection (it was impossible to restore stdout using freopen on Windows 7, leaving the console as a zombie...); Make sure the stdout/stderr redirection works also in the case there is no console (i.e. in stand-alone applications).; Make sure the file descriptors are valid before using them.; The shortcuts are now working on Windows. Building with CMake. ROOT can now be build using the CMake build system (version 2.8). ; The initial supported platforms are Linux(gcc), Windows (vc9), MacOSX(gcc). The installed libraries and executables should be compatible to the standard build of ROOT.  CMake generates native makefiles and workspaces (i.e. Xc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:3336,avoid,avoid,3336,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,1,['avoid'],['avoid']
Safety,"lose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strncmp, strcpy, strlen, strsep`` and many more. .. code-block:: c. void test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitialized/garbage values; }. Limitations:. - Due to limitations of the memory modeling in the analyzer, one can likely; observe a lot of false-positive reports like this:. .. code-block:: c. v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:78716,detect,detect,78716,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['detect'],['detect']
Safety,"low and instruction referencing debug info, corresponding to the earlier; LLVM IR:. ```text; %2:gr32 = ADD32rr %0, %1, implicit-def $eflags, debug-instr-number 1; DBG_INSTR_REF 1, 0, !123, !456, debug-location !789; ```. While the function remains in SSA form, virtual register `%2` is sufficient to; identify the value computed by the instruction -- however the function; eventually leaves SSA form, and register optimisations will obscure which; register the desired value is in. Instead, a more consistent way of identifying; the instruction's value is to refer to the `MachineOperand` where the value is; defined: independently of which register is defined by that `MachineOperand`. In; the code above, the `DBG_INSTR_REF` instruction refers to instruction number; one, operand zero, while the `ADD32rr` has a `debug-instr-number` attribute; attached indicating that it is instruction number one. De-coupling variable locations from registers avoids difficulties involving; register allocation and optimisation, but requires additional instrumentation; when the instructions are optimised instead. Optimisations that replace; instructions with optimised versions that compute the same value must either; preserve the instruction number, or record a substitution from the old; instruction / operand number pair to the new instruction / operand pair -- see; `MachineFunction::substituteDebugValuesForInst`. If debug info maintenance is; not performed, or an instruction is eliminated as dead code, the variable; location is safely dropped and marked ""optimised out"". The exception is; instructions that are mutated rather than replaced, which always need debug info; maintenance. # Register allocator considerations. When the register allocator runs, debugging instructions do not directly refer; to any virtual registers, and thus there is no need for expensive location; maintenance during regalloc (i.e. `LiveDebugVariables`). Debug instructions are; unlinked from the function, then linked back ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:2453,avoid,avoids,2453,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['avoid'],['avoids']
Safety,"lowup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] = B[0];. into:. .. code-block:: c. if (rtc) {; auto b = B[0];; for (int i = 0; i < n; i+=1) // versioned loop; A[i] = b;; } else {; for (int i = 0; i < n; i+=1) // unversioned loop; A[i] = B[0];; }. The runtime condition (``rtc``) checks that the array ``A`` and the; element `B[0]` do not alias. Currently, this transformation does not support followup-attributes. Loop Interchange; ----------------. Currently, the ``LoopInterchange`` pass does not use any metadata. Ambiguous Transformation Order; ==============================. If there multiple transformations defined, the order in which they are; executed depends on the order in LLVM's pass pipeline, which is subject; to change. The def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:12620,avoid,avoids,12620,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoids']
Safety,"lowup_unrolled`` will set the loop attributes of; the unrolled loop. If not specified, the attributes of the original loop; without the ``llvm.loop.unroll.*`` attributes are copied and; ``llvm.loop.unroll.disable`` added to it. ``llvm.loop.unroll.followup_remainder`` defines the attributes of the; remainder loop. If not specified the remainder loop will have no; attributes. The remainder loop might not be present due to being fully; unrolled in which case this attribute has no effect. Attributes defined in ``llvm.loop.unroll.followup_all`` are added to the; unrolled and remainder loops. To avoid that the partially unrolled loop is unrolled again, it is; recommended to add ``llvm.loop.unroll.disable`` to; ``llvm.loop.unroll.followup_all``. If no follow-up attribute specified; for a generated loop, it is added automatically. Unroll-And-Jam; --------------. Unroll-and-jam uses the following transformation model (here with an; unroll factor if 2). Currently, it does not support a fallback version; when the transformation is unsafe. .. code-block:: c. for (int i = 0; i < n; i+=1) { // original outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // original inner loop; SubLoop(i, j);; Aft(i);; }. .. code-block:: c. int i = 0;; for (; i + 1 < n; i+=2) { // unrolled outer loop; Fore(i);; Fore(i+1);; for (int j = 0; j < m; j+=1) { // unrolled inner loop; SubLoop(i, j);; SubLoop(i+1, j);; }; Aft(i);; Aft(i+1);; }; for (; i < n; i+=1) { // remainder outer loop; Fore(i);; for (int j = 0; j < m; j+=1) // remainder inner loop; SubLoop(i, j);; Aft(i);; }. ``llvm.loop.unroll_and_jam.followup_outer`` will set the loop attributes; of the unrolled outer loop. If not specified, the attributes of the; original outer loop without the ``llvm.loop.unroll.*`` attributes are; copied and ``llvm.loop.unroll.disable`` added to it. ``llvm.loop.unroll_and_jam.followup_inner`` will set the loop attributes; of the unrolled inner loop. If not specified, the attributes of the; original inner loop are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:8938,unsafe,unsafe,8938,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['unsafe'],['unsafe']
Safety,"lso optimize constants by emitting them directly in the stack map,; either in the ``Offset`` of a ``Constant`` location or in the constant; pool, referred to by ``ConstantIndex`` locations. At each callsite, a ""liveout"" register list is also recorded. These; are the registers that are live across the stackmap and therefore must; be saved by the runtime. This is an important optimization when the; patchpoint intrinsic is used with a calling convention that by default; preserves most registers as callee-save. Each entry in the liveout register list contains a DWARF register; number and size in bytes. The stackmap format deliberately omits; specific subregister information. Instead the runtime must interpret; this information conservatively. For example, if the stackmap reports; one byte at ``%rax``, then the value may be in either ``%al`` or; ``%ah``. It doesn't matter in practice, because the runtime will; simply save ``%rax``. However, if the stackmap reports 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A JIT compiler can easily access this section by providing its own; memory manager via the LLVM C API;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:15291,safe,safely,15291,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['safe'],['safely']
Safety,"lt behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:194906,detect,detected,194906,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"lt of optimization; passes -- e.g., the result can change depending on whether a; function gets inlined or not. A function's parameters are; obviously not constant. However, a call like; ``llvm.is.constant.i32(i32 %param)`` *can* return true after the; function is inlined, if the value passed to the function parameter was; a constant. .. _int_ptrmask:. '``llvm.ptrmask``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) speculatable memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer or vector of pointers. The second argument is; an integer or vector of integers with the same bit width as the index type; size of the first argument. Overview:; """""""""""""""""""". The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a mask.; This allows stripping data from tagged pointers without converting them to an; integer (ptrtoint/inttoptr). As a consequence, we can preserve more information; to facilitate alias analysis and underlying-object detection. Semantics:; """""""""""""""""""". The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following expansion,; where ``iPtrIdx`` is the index type size of the pointer::. %intptr = ptrtoint ptr %ptr to iPtrIdx ; this may truncate; %masked = and iPtrIdx %intptr, %mask; %diff = sub iPtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:954547,detect,detection,954547,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detection']
Safety,"ltin_expect(long expr, long val). **Example of use**:. .. code-block:: c++. if (__builtin_expect(x, 0)) {; bar();; }. **Description**:. The ``__builtin_expect()`` builtin is typically used with control flow; conditions such as in ``if`` and ``switch`` statements to help branch; prediction. It means that its first argument ``expr`` is expected to take the; value of its second argument ``val``. It always returns ``expr``. Query for this feature with ``__has_builtin(__builtin_expect)``. ``__builtin_expect_with_probability``; -------------------------------------. ``__builtin_expect_with_probability`` is similar to ``__builtin_expect`` but it; takes a probability as third argument. **Syntax**:. .. code-block:: c++. long __builtin_expect_with_probability(long expr, long val, double p). **Example of use**:. .. code-block:: c++. if (__builtin_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115141,predict,prediction,115141,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['predict'],['prediction']
Safety,"lting semantics provides a new notion of ""cycle iteration"" even for; irreducible cycles. But this allows a natural loop to have a heart in a; node other than its header, which has interesting consequences on the; meaning of a loop iteration in terms of convergence. For now, we disallow; this situation since its practical application is very rare. .. _llvm.experimental.convergence.anchor:. ``llvm.experimental.convergence.anchor``; ----------------------------------------. .. code-block:: llvm. token @llvm.experimental.convergence.anchor() convergent readnone. This intrinsic produces an initial convergence token that is independent from; any ""outer scope"". The set of threads executing converged dynamic instances of; this intrinsic is implementation-defined. It is an error to pass a ``convergencectrl`` operand bundle at a; call to this intrinsic. .. note::. The expectation is that all threads within a group that ""happen to be active; at the same time"" will execute converged dynamic instances, so that programs; can detect the maximal set of threads that can communicate efficiently within; some local region of the program. .. _convergence_uncontrolled:. Uncontrolled Convergent Operations; ==================================. Convergent operations with an explicit ``convergencectrl`` operand bundle are; called *controlled convergent operations*. All other convergent operations are; said to be *uncontrolled*. An uncontrolled convergent operation is said to have *implicit convergence; control* determined by the ``convergent`` attribute alone. The semantics of the; ``convergent`` attribute as implemented in LLVM differs from the documented; semantics. The implementation tries to follow common intuition about convergent; operations, which remains under-specified. As such, it is not possible to fully; translate implicit convergence control into explicit convergence control tokens,; and these two modes cannot be mixed in the same function. If a function contains a controlled conv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:27012,detect,detect,27012,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['detect'],['detect']
Safety,"lude full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related information. In the following somewhat; nonsensical example you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error. Because clang prints a; point, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about.; Range information is very useful for; cases involving precedence issues and many other cases. $ gcc-4.9 -fsyntax-only t.c; t.c: In function 'int f(int, int)':; t.c:7:39: error: invali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:1668,detect,detected,1668,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['detect'],['detected']
Safety,"lue ``%obj``, we need to introduce a new; SSA value ``%obj.relocated`` which represents the potentially changed value of; ``%obj`` after the safepoint and update any following uses appropriately. The; resulting relocation sequence is:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 7, i32 7); ret i8 addrspace(1)* %obj.relocated; }. Ideally, this sequence would have been represented as a M argument, N; return value function (where M is the number of values being; relocated + the original call arguments and N is the original return; value + each relocated value), but LLVM does not easily support such a; representation. Instead, the statepoint intrinsic marks the actual site of the; safepoint or statepoint. The statepoint returns a token value (which; exists only at compile time). To get back the original return value; of the call, we use the ``gc.result`` intrinsic. To get the relocation; of each pointer in turn, we use the ``gc.relocate`` intrinsic with the; appropriate index. Note that both the ``gc.relocate`` and ``gc.result`` are; tied to the statepoint. The combination forms a ""statepoint relocation; sequence"" and represents the entirety of a parseable call or 'statepoint'. When lowered, this example would generate the following x86 assembly:. .. code-block:: gas. 	 .globl	test1; 	 .align	16, 0x90; 	 pushq	%rax; 	 callq	foo; .Ltmp1:; 	 movq	(%rsp), %rax # This load is redundant (oops!); 	 popq	%rdx; 	 retq. Each of the potentially relocated values has been spilled to the; stack, and a record of that location has been recorded to the; :ref:`Stack Map section <stackmap-section>`. If the garbage collector; needs to update any of these pointe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:9577,safe,safepoint,9577,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"lue of an address to indicate the object it is associated; with. If the garbage collector wishes to move any object, the; compiler must provide a mapping, for each pointer, to an indication of; its allocation. To simplify the interaction between a collector and the compiled code,; most garbage collectors are organized in terms of three abstractions:; load barriers, store barriers, and safepoints. #. A load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3138,safe,safepoint,3138,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"lumns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1668,predict,prediction,1668,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['predict'],['prediction']
Safety,"ly be compiled with the -std=c++11 and -std=gnu++11; // options, because rvalue references are only standardized in C++11.; #endif. #if __has_extension(cxx_rvalue_references); // This code will be compiled with the -std=c++11, -std=gnu++11, -std=c++98; // and -std=gnu++98 options, because rvalue references are supported as a; // language extension in C++98.; #endif. .. _langext-has-feature-back-compat:. For backward compatibility, ``__has_feature`` can also be used to test; for support for non-standardized features, i.e. features not prefixed ``c_``,; ``cxx_`` or ``objc_``. Another use of ``__has_feature`` is to check for compiler features not related; to the language standard, such as e.g. :doc:`AddressSanitizer; <AddressSanitizer>`. If the ``-pedantic-errors`` option is given, ``__has_extension`` is equivalent; to ``__has_feature``. The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can either be a; single identifier or a scoped identifier. If the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evalu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:4746,avoid,avoid,4746,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"ly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing work on developing such; a verifier. Please ask on llvm-dev if you're interested in; experimenting with the current version. .. _statepoint-utilities:. Utility Passes for Safepoint Insertion; ======================================. .. _RewriteStatepointsForGC:. RewriteStatepointsForGC; ^^^^^^^^^^^^^^^^^^^^^^^^. The pass RewriteStatepointsForGC transforms a function's IR to lower from the; abstract machine model described above to the explicit statepoint model of; relocations. To do this, it replaces all calls or invokes of functions which; might contain a safepoint poll with a ``gc.statepoint`` and associated full; relocation sequence, including all required ``gc.relocates``. This pass only applies to GCStrategy instances where the ``UseRS4GC`` flag; is set. The two builtin GC strategies with this set are the; ""statepoint-example"" and ""coreclr"" strategies. As an example, given this code:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void @foo(); ret i8 addrspace(1)* %obj; }. The pass would produce this IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 12, i32 12); ret i8 addr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:25602,safe,safepoint,25602,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"m of CPU time. More detailed information on the new mathematical functions can be found in this presentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms like TMath::LocMin, TMath::LocMax or TMath::Permute the original implementation is faster than STL and has been maintained.; ; Add a generic iterator interface, similar to the STL algorithm interface, to the following TMath functions:; MinElement, MaxElement, LocMin, LocMax, Mean, GeomMean, RMS,; BinarySearch. The iterator interface for sort is called; TMath::SortItr to avoid a compilation ambiguity. For example,; for finding the mean of a std::vector<double> v, one simply needs to call TMath::Mean(v.begin(), v.end() ) .; ; Various changes have been applied to the mathematical functions to remove duplications in the implementation with the special and statistical functions defined in ROOT::Math. The functions which have been changed and thus they can return a sightly different result than before are:; ; TMath::Erf and TMath::Erfc call ROOT::Math::erf and ROOT::math::erfc which are implemented using the Cephes algorithms, which is accurate at the required double precision level.; TMath::Gamma(z) is implemented with ROOT::Math::tgamma, which again uses Cephes.; The incomplete gamma function, TMath::Gamma(a,x) it is implemented using ROOT::Math::inc_gamma based on a corresponding Cephes function.; TMath::Prob (the upper chi2 probability) is implemented also using ROOT::Math::chisquared_cdf_c which uses ROOT::Math::inc_gamma_c based on a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:2373,avoid,avoid,2373,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['avoid'],['avoid']
Safety,"m.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310731,avoid,avoid,310731,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"mand erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanvas * canvas = new TCanvas(""glC"",""C"",800,800);; TH3D *h = new TH3D(""h3"",""h3"",150,0,20,150,-5,5,150,-5,5);; ntuple->Draw(""px:py+1:pz+4.7>>h3"","""",""Q"");; }. TGraph. TGraph::SavePrimitive() uses a greater precision to output the; X and Y vectors. The following macro generated a wrong output (tmp.C). void testGraphPrec() {; double offset=55.0;; TCanvas* myC = new TCanvas(""myC"",""myC"",600,400);; TGraph* gr=new TGraph();; for (int i=0; i < 1000; i++) {; double",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:2359,avoid,avoid,2359,hist/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html,1,['avoid'],['avoid']
Safety,"mdgpu_synid_integer_number>` or; :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Examples:. .. parsed-literal::. mul:2; mul:x // x must be equal to 2 or 4. .. _amdgpu_synid_vop3_operand_modifiers:. VOP3 Operand Modifiers; ----------------------. Operand modifiers are not used separately. They are applied to source operands. .. _amdgpu_synid_abs:. abs; ~~~. Computes the absolute value of its operand. Must be applied before :ref:`neg<amdgpu_synid_neg>`; (if any). Valid for floating-point operands only. ======================================== ====================================================; Syntax Description; ======================================== ====================================================; abs(<operand>) Get the absolute value of a floating-point operand.; \|<operand>| The same as above (an SP3 syntax).; ======================================== ====================================================. Note: avoid using SP3 syntax with operands specified as expressions because the trailing '|'; may be misinterpreted. Such operands should be enclosed into additional parentheses, as shown; in examples below. Examples:. .. parsed-literal::. abs(v36); \|v36|; abs(x|y) // ok; \|(x|y)| // additional parentheses are required. .. _amdgpu_synid_neg:. neg; ~~~. Computes the negative value of its operand. Must be applied after :ref:`abs<amdgpu_synid_abs>`; (if any). Valid for floating-point operands only. ================== ====================================================; Syntax Description; ================== ====================================================; neg(<operand>) Get the negative value of a floating-point operand.; An optional :ref:`abs<amdgpu_synid_abs>` modifier; may be applied to the operand before negation.; -<operand> The same as above (an SP3 syntax).; ================== ====================================================. Note: SP3 syntax is supported with limitations because of a potential ambiguity.; Currently, it is allo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:55969,avoid,avoid,55969,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['avoid'],['avoid']
Safety,"me optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks are; classified as ""Spectre variant #1"". Notably, this does not attempt to; mitigate against miss-speculation of branch target, classified as; ""Spectre variant #2"" vulnerabilities. When inlining, the attribute is sticky. Inlining a function that carries; this attribute will cause the caller to gain the att",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:100881,safe,safety,100881,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"mechanisms and interfaces provided by LLVM to; support accurate garbage collection. Goals and non-goals; -------------------. LLVM's intermediate representation provides :ref:`garbage collection intrinsics; <gc_intrinsics>` that offer support for a broad class of collector models. For; instance, the intrinsics permit:. * semi-space collectors. * mark-sweep collectors. * generational collectors. * incremental collectors. * concurrent collectors. * cooperative collectors. * reference counting. We hope that the support built into the LLVM IR is sufficient to support a; broad class of garbage collected languages including Scheme, ML, Java, C#,; Perl, Python, Lua, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize increm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:5932,safe,safepoint,5932,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safepoint']
Safety,"mehow. Yes yes yes! :) I think it would be *VERY* useful to include this kind; of information (which EPIC architectures *implicitly* encode. The trend; that we are seeing supports this greatly:. 1. Commodity processors are getting massive SIMD support:; * Intel/Amd MMX/MMX2; * AMD's 3Dnow!; * Intel's SSE/SSE2; * Sun's VIS; 2. SMP is becoming much more common, especially in the server space.; 3. Multiple processors on a die are right around the corner. If nothing else, not designing this in would severely limit our future; expansion of the project... > Also, this will require some reading on at least two other; > projects:; > -- Multiscalar architecture from Wisconsin; > -- Simultaneous multithreading architecture from Washington; >; > o Or forget all this and stick to a traditional instruction set?. Heh... :) Well, from a pure research point of view, it is almost more; attactive to go with the most extreme/different ISA possible. On one axis; you get safety and conservatism, and on the other you get degree of; influence that the results have. Of course the problem with pure research; is that often times there is no concrete product of the research... :). > BTW, on an unrelated note, after the meeting yesterday, I did remember; > that you had suggested doing instruction scheduling on SSA form instead; > of a dependence DAG earlier in the semester. When we talked about; > it yesterday, I didn't remember where the idea had come from but I; > remembered later. Just giving credit where its due... :) Thanks. . > Perhaps you can save the above as a file under RCS so you and I can; > continue to expand on this. I think it makes sense to do so when we get our ideas more formalized and; bounce it back and forth a couple of times... then I'll do a more formal; writeup of our goals and ideas. Obviously our first implementation will; not want to do all of the stuff that I pointed out above... be we will; want to design the project so that we do not artificially limit ourselves; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:8349,safe,safety,8349,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['safe'],['safety']
Safety,"ment (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spilled to stack.; The `RET` instruction is replaced with a load of the jump table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-precise*. Returns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:26177,abort,abort,26177,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['abort'],['abort']
Safety,"ments, not; an exact sequence of operations that a program will be compiled into. .. _arc.objects.operands:. Retainable object pointers as operands and arguments; ----------------------------------------------------. In general, ARC does not perform retain or release operations when simply using; a retainable object pointer as an operand within an expression. This includes:. * loading a retainable pointer from an object with non-weak :ref:`ownership; <arc.ownership>`,; * passing a retainable pointer as an argument to a function or method, and; * receiving a retainable pointer as the result of a function or method call. .. admonition:: Rationale. While this might seem uncontroversial, it is actually unsafe when multiple; expressions are evaluated in ""parallel"", as with binary operators and calls,; because (for example) one expression might load from an object while another; writes to it. However, C and C++ already call this undefined behavior; because the evaluations are unsequenced, and ARC simply exploits that here to; avoid needing to retain arguments across a large number of calls. The remainder of this section describes exceptions to these rules, how those; exceptions are detected, and what those exceptions imply semantically. .. _arc.objects.operands.consumed:. Consumed parameters; ^^^^^^^^^^^^^^^^^^^. A function or method parameter of retainable object pointer type may be marked; as :arc-term:`consumed`, signifying that the callee expects to take ownership; of a +1 retain count. This is done by adding the ``ns_consumed`` attribute to; the parameter declaration, like so:. .. code-block:: objc. void foo(__attribute((ns_consumed)) id x);; - (void) foo: (id) __attribute((ns_consumed)) x;. This attribute is part of the type of the function or method, not the type of; the parameter. It controls only how the argument is passed and received. When passing such an argument, ARC retains the argument prior to making the; call. When receiving such an argument, ARC releases",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:16308,avoid,avoid,16308,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoid']
Safety,"meter correlations, and worst of all cannot be expected to converge; accurately to the minimum in a finite time. Its estimate of the; *expected distance to the minimum* $\mbox{EDM}$ is largely fantasy,; so it would not even know if it did converge. ## Floating point precision ##. M figures out at execution time the machine precision [api:epsmac], and; assumes that $\mbox{FCN}$ provides about the same precision. That; means not just the length of the numbers used and returned by; $\mbox{FCN}$, but the actual mathematical accuracy of the; calculations. Section [install:epsmac] describes what to do if this is; not the case. ## Parameter limits ##. Putting limits (absolute bounds) on the allowed values for a given; parameter, causes M to make a non-linear transformation of its own; internal parameter values to obtain the (external) parameter values; passed to $\mbox{FCN}$. To understand the adverse effect of limits,; see [intro:limits]. Basically, the use of limits should be avoided unless needed to keep the; parameter inside a desired range. If parameter limits are needed, in spite of the effects described in; Chapter One, then the user should be aware of the following techniques; to alleviate problems caused by limits. ### Getting the Right Minimum with Limits ###. If $\mbox{MIGRAD}$ converges normally to a point where no parameter; is near one of its limits, then the existence of limits has probably not; prevented M from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimizer has become ""blocked"" at a limit. This may normally happen only; if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{ \pi}{ 2}$ that M prints a warning to this effect; when it prints the parameter values. The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer; $\partia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:63595,avoid,avoided,63595,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoided']
Safety,"milar to how; MCJIT is commonly used). However ORC also provides built-in support for lazy; compilation via lazy-reexports (see :ref:`Laziness`). **Support for Custom Compilers and Program Representations**; Clients can supply custom compilers for each symbol that they define in their; JIT session. ORC will run the user-supplied compiler when the a definition of; a symbol is needed. ORC is actually fully language agnostic: LLVM IR is not; treated specially, and is supported via the same wrapper mechanism (the; ``MaterializationUnit`` class) that is used for custom compilers. **Concurrent JIT'd code** and **Concurrent Compilation**; JIT'd code may be executed in multiple threads, may spawn new threads, and may; re-enter the ORC (e.g. to request lazy compilation) concurrently from multiple; threads. Compilers launched my ORC can run concurrently (provided the client; sets up an appropriate dispatcher). Built-in dependency tracking ensures that; ORC does not release pointers to JIT'd code or data until all dependencies; have also been JIT'd and they are safe to call or use. **Removable Code**; Resources for JIT'd program representations. **Orthogonality** and **Composability**; Each of the features above can be used independently. It is possible to put; ORC components together to make a non-lazy, in-process, single threaded JIT; or a lazy, out-of-process, concurrent JIT, or anything in between. LLJIT and LLLazyJIT; ===================. ORC provides two basic JIT classes off-the-shelf. These are useful both as; examples of how to assemble ORC components to make a JIT, and as replacements; for earlier LLVM JIT APIs (e.g. MCJIT). The LLJIT class uses an IRCompileLayer and RTDyldObjectLinkingLayer to support; compilation of LLVM IR and linking of relocatable object files. All operations; are performed eagerly on symbol lookup (i.e. a symbol's definition is compiled; as soon as you attempt to look up its address). LLJIT is a suitable replacement; for MCJIT in most cases (no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:3208,safe,safe,3208,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['safe'],['safe']
Safety,"mine what proportion of rules were; successfully imported. The easiest way to use this is to copy the; ``-gen-globalisel`` tablegen command from ``ninja -v`` and modify it. Similarly, the ``--warn-on-skipped-patterns`` option can be used to obtain the; reasons that rules weren't imported. This can be used to focus on the most; important rejection reasons. PatLeaf Predicates; ^^^^^^^^^^^^^^^^^^. PatLeafs cannot be imported because their C++ is implemented in terms of; ``SDNode`` objects. PatLeafs that handle immediate predicates should be; replaced by ``ImmLeaf``, ``IntImmLeaf``, or ``FPImmLeaf`` as appropriate. There's no standard answer for other PatLeafs. Some standard predicates have; been baked into TableGen but this should not generally be done. Custom SDNodes; ^^^^^^^^^^^^^^. Custom SDNodes should be mapped to Target Pseudos using ``GINodeEquiv``. This; will cause the instruction selector to import them but you will also need to; ensure the target pseudo is introduced to the MIR before the instruction; selector. Any preceding pass is suitable but the legalizer will be a; particularly common choice. ComplexPatterns; ^^^^^^^^^^^^^^^. ComplexPatterns cannot be imported because their C++ is implemented in terms of; ``SDNode`` objects. GlobalISel versions should be defined with; ``GIComplexOperandMatcher`` and mapped to ComplexPattern with; ``GIComplexPatternEquiv``. The following predicates are useful for porting ComplexPattern:. * isBaseWithConstantOffset() - Check for base+offset structures; * isOperandImmEqual() - Check for a particular constant; * isObviouslySafeToFold() - Check for reasons an instruction can't be sunk and folded into another. There are some important points for the C++ implementation:. * Don't modify MIR in the predicate; * Renderer lambdas should capture by value to avoid use-after-free. They will be used after the predicate returns.; * Only create instructions in a renderer lambda. GlobalISel won't clean up things you create but don't use. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst:3479,avoid,avoid,3479,interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,1,['avoid'],['avoid']
Safety,"mis-behaving passes, you; can debug incorrect code generation by either LLC or the JIT, using; ``bugpoint``. The process ``bugpoint`` follows in this case is to try to; narrow the code down to a function that is miscompiled by one or the other; method, but since for correctness, the entire program must be run,; ``bugpoint`` will compile the code it deems to not be affected with the C; Backend, and then link in the shared object it generates. To debug the JIT:. .. code-block:: bash. bugpoint -run-jit -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to lli] \; --args -- [program arguments]. Similarly, to debug the LLC, one would run:. .. code-block:: bash. bugpoint -run-llc -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to llc] \; --args -- [program arguments]. **Special note:** if you are debugging MultiSource or SPEC tests that; already exist in the ``llvm/test`` hierarchy, there is an easier way to; debug the JIT, LLC, and CBE, using the pre-written Makefile targets, which; will pass the program options specified in the Makefiles:. .. code-block:: bash. cd llvm/test/../../program; make bugpoint-jit. At the end of a successful ``bugpoint`` run, you will be presented; with two bitcode files: a *safe* file which can be compiled with the C; backend and the *test* file which either LLC or the JIT; mis-codegenerates, and thus causes the error. To reproduce the error that ``bugpoint`` found, it is sufficient to do; the following:. #. Regenerate the shared object from the safe bitcode file:. .. code-block:: bash. llc -march=c safe.bc -o safe.c; gcc -shared safe.c -o safe.so. #. If debugging LLC, compile test bitcode native and link with the shared; object:. .. code-block:: bash. llc test.bc -o test.s; gcc test.s safe.so -o test.llc; ./test.llc [program options]. #. If debugging the JIT, load the shared object and supply the test; bitcode:. .. code-block:: bash. lli -load=safe.so test.bc [program options]; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:10618,safe,safe,10618,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,8,['safe'],['safe']
Safety,"mmend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:13698,avoid,avoid,13698,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['avoid'],['avoid']
Safety,"modify it. For example, if you distribute copies of such a program, whether; gratis or for a fee, you must give the recipients all the rights that; you have. You must make sure that they, too, receive or can get the; source code. And you must show them these terms so they know their; rights. We protect your rights with two steps: (1) copyright the software, and; (2) offer you this license which gives you legal permission to copy,; distribute and/or modify the software. Also, for each author's protection and ours, we want to make certain; that everyone understands that there is no warranty for this free; software. If the software is modified by someone else and passed on, we; want its recipients to know that what they have is not the original, so; that any problems introduced by others will not reflect on the original; authors' reputations. Finally, any free program is threatened constantly by software; patents. We wish to avoid the danger that redistributors of a free; program will individually obtain patent licenses, in effect making the; program proprietary. To prevent this, we have made it clear that any; patent must be licensed for everyone's free use or not licensed at all. The precise terms and conditions for copying, distribution and; modification follow. GNU GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License applies to any program or other work which contains; a notice placed by the copyright holder saying it may be distributed; under the terms of this General Public License. The ""Program"", below,; refers to any such program or work, and a ""work based on the Program""; means either the Program or any derivative work under copyright law:; that is to say, a work containing the Program or a portion of it,; either verbatim or with modifications and/or translated into another; language. (Hereinafter, translation is included without limitation in; the term ""modification"".) Each licensee is addressed as ""you"". Ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:2472,avoid,avoid,2472,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['avoid'],['avoid']
Safety,"module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16988,avoid,avoid,16988,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['avoid'],['avoid']
Safety,"monitoring information from the master; at each GetNextPacket (at each call of TPerfStat::PacketEvent) to allow; extrnal real-time progress monitoring.; Save the status of a 'proofserv' session into a new file; in the 'activesessions' area. The full path of the new file is;          ; <admin_path>/.xproofd.<port>/activesessions/<user>.<group>.<pid>.status. The status indicates whether the session is idle, running or queued.; The status is updated every 'checkfq' secs (see xpd.proofservmgr;; default 30 s). The status is dumped by the reader thread of TXProofServ; and therefore its r/w access is protected. Enable the use of the tree cache also for local files,; adapting the default settings for the cache to the recent changes; In the XrdProofd plug-in. Improve synchronization between parent and child during; fork; Optimize loops over directory entries; Improve error and notification messages. Improved handling of Ctrl-C; this follows from a fix in; TMonitor and an improved handling of non-finished query state in the; workers (results are not send to master if the query was aborted) . Fixes. TFileMerger. Fix a problem preventing correct transmission of all; non-mergeable objects (fixes bug #52886); Remove the argument isdir from the function; MergeRecursive; Do not remove the first file in the list when returning; from MergeRecursive (fixes bug #54591); Fix a major leak when merging files with collections; written using kSingleKey option.  The merger was reading each; key in memory and deleted the object at the end, but the container is; not owner by default, so all objects inside leaked. PROOF-Lite. Fix a couple of memory leaks showing up when running; repeated queries; Fix a problem in TProofServ::CopyFromCache affecting; the case where the sandbox dir has a '.' and the macro name has no '.',; e.g. compiled selectors in PROOF-Lite. TProofOutputFile. Fix a problem with the determination of the fDir member; affecting mostly PROOF-Lite; Fix a serious issue whose net effe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:6463,abort,aborted,6463,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['abort'],['aborted']
Safety,"more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192422,safe,safe,192422,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"move_element_unordered_atomic_*``' symbol. Such a call can not; take a safepoint. Otherwise, the call is made GC parseable by wrapping the; call into a statepoint. This makes it possible to take a safepoint during; copy operation. Note that a GC parseable copy operation is not required to; take a safepoint. For example, a short copy operation may be performed without; taking a safepoint. GC parseable calls to '``llvm.memcpy.element.unordered.atomic.*``',; '``llvm.memmove.element.unordered.atomic.*``' intrinsics are lowered to calls; to '``__llvm_memcpy_element_unordered_atomic_safepoint_*``',; '``__llvm_memmove_element_unordered_atomic_safepoint_*``' symbols respectively.; This way the runtime can provide implementations of copy operations with and; without safepoints. GC parseable lowering also involves adjusting the arguments for the call.; Memcpy and memmove intrinsics take derived pointers as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in the copy operation. In order to make the base; pointers available RewriteStatepointsForGC replaces derived pointers with base; pointer and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:30910,safe,safepoint,30910,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"mprises of the following classes. :LoopVectorizationPlanner:; A LoopVectorizationPlanner is designed to handle the vectorization of a loop; or a loop nest. It can construct, optimize and discard one or more VPlans,; each VPlan modelling a distinct way to vectorize the loop or the loop nest.; Once the best VPlan is determined, including the best VF and UF, this VPlan; drives the generation of output IR. :VPlan:; A model of a vectorized candidate for a given input IR loop or loop nest. This; candidate is represented using a Hierarchical CFG. VPlan supports estimating; the cost and driving the generation of the output IR code it represents. :Hierarchical CFG:; A control-flow graph whose nodes are basic-blocks or Hierarchical CFG's. The; Hierarchical CFG data structure is similar to the Tile Tree [5]_, where; cross-Tile edges are lifted to connect Tiles instead of the original; basic-blocks as in Sharir [6]_, promoting the Tile encapsulation. The terms; Region and Block are used rather than Tile [5]_ to avoid confusion with loop; tiling. :VPBlockBase:; The building block of the Hierarchical CFG. A pure-virtual base-class of; VPBasicBlock and VPRegionBlock, see below. VPBlockBase models the hierarchical; control-flow relations with other VPBlocks. Note that in contrast to the IR; BasicBlock, a VPBlockBase models its control-flow successors and predecessors; directly, rather than through a Terminator branch or through predecessor; branches that ""use"" the VPBlockBase. :VPBasicBlock:; VPBasicBlock is a subclass of VPBlockBase, and serves as the leaves of the; Hierarchical CFG. It represents a sequence of output IR instructions that will; appear consecutively in an output IR basic-block. The instructions of this; basic-block originate from one or more VPBasicBlocks. VPBasicBlock holds a; sequence of zero or more VPRecipes that model the cost and generation of the; output IR instructions. :VPRegionBlock:; VPRegionBlock is a subclass of VPBlockBase. It models a collection of; V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst:5026,avoid,avoid,5026,interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,1,['avoid'],['avoid']
Safety,"mproving performance especially for TTree::Map() by about 35%. This has been achieved with a better caching strategy for request strings (especially avoiding to recalculate the auth base64 encoding), and with a drastic optimization in reading the response headers.; Fixes in the counting of the bytes read. TWebSystem. New implementation of TSystem allowing to use TSystem::AccessPathName() and GetPathInfo() to check if a web file exists and to get its size. Directory browsing is not available yet. NETX; ; TXNetFile. Several fixes and optimisations, mainly in the use of the cache; Fix an offset issue affecting the use of the cache with files in archives. TXNetSystem. A few optimizations in the use of retry mechanism, path locality checks, file online checks. XROOTD. Import a new version of XROOTD (20091202-0509); ; Fixes in bulk prepare and sync readv operations; Add support for 'make install' / 'make uninstall' and; other improvements in configure.classic; Several improvements / fixes:; ; reduced memory and CPU consumption;; extreme cp optimizations;; windows porting; new cache policies on the client side; new listing features implemented recently in the 'cns' module.; optimizations in cmsd and cnsd (performance improvements); support for openssl 1.0.0 (required by Fedora 12). Support for if/else if/else/fi constructs; Several portability fixes; ; Support 32-bit builds with icc on 64-bit platforms; Improved detection of libreadline and lib(n)curses. Increase the flexibility for configuring with an external xrootd; ; Add standard switches to disentangle lib and inc dirs;       --with-xrootd-incdir=<path_to dir_containing_XrdVersion.hh>;       --with-xrootd-libdir=<path_to_dir_containing_xrootd_plugins_and_libs>; ; When; passing a global xrootd dir with --with-xrootd, check both; src/XrdVersion.hh and include/xrootd/XrdVersion.hh so that both build; and install distributions are supported. Fix a problem with the xrootd build when running make via 'sudo' (issue #47644). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html:1497,detect,detection,1497,net/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html,1,['detect'],['detection']
Safety,"must be followed by a ``DBG_VALUE`` use of that def. If; an instruction does not define a register, but can be followed by a debug inst,; MIRDebugify inserts a ``DBG_VALUE`` that references a constant. Insertion of; ``DBG_VALUE``'s can be disabled by setting ``-debugify-level=locations``. To run MIRDebugify once, simply insert ``mir-debugify`` into your ``llc``; invocation, like:. .. code-block:: bash. # Before some other pass.; $ llc -run-pass=mir-debugify,other-pass ... # After some other pass.; $ llc -run-pass=other-pass,mir-debugify ... To run MIRDebugify before each pass in a pipeline, use; ``-debugify-and-strip-all-safe``. This can be combined with ``-start-before``; and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-and-strip-all-safe -O1 <other llc args>. If you want to check it after each pass in a pipeline, use; ``-debugify-check-and-strip-all-safe``. This can also be combined with; ``-start-before`` and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-check-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-check-and-strip-all-safe -O1 <other llc args>. To check all debug info from a test, use ``mir-check-debugify``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-check-debugify. To strip out all debug info from a test, use ``mir-strip-debug``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other-pass,mir-strip-debug. It can be useful to combine ``mir-debugify``, ``mir-check-debugify`` and/or; ``mir-strip-debug`` to identify backend transformations which break in; the presence of debug info. For example, to run the AArch64 backend tests; with all normal passes ""sandwiched"" in between MIRDebugify and; MIRStripDebugify mutation passes, run:. .. code-block:: bash. $ llvm-lit test/CodeGen/AArch64 -Dllc=""llc -debugify-and-strip-all-safe"". Using LostDebugLocObserver; --------------------------. TODO; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:18518,safe,safe,18518,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,3,['safe'],['safe']
Safety,"n %0, i32 12, i32 12); ret i8 addrspace(1)* %obj.relocated; }. In the above examples, the addrspace(1) marker on the pointers is the mechanism; that the ``statepoint-example`` GC strategy uses to distinguish references from; non references. This is controlled via GCStrategy::isGCManagedPointer. The; ``statepoint-example`` and ``coreclr`` strategies (the only two default; strategies that support statepoints) both use addrspace(1) to determine which; pointers are references, however custom strategies don't have to follow this; convention. This pass can be used an utility function by a language frontend that doesn't; want to manually reason about liveness, base pointers, or relocation when; constructing IR. As currently implemented, RewriteStatepointsForGC must be; run after SSA construction (i.e. mem2ref). RewriteStatepointsForGC will ensure that appropriate base pointers are listed; for every relocation created. It will do so by duplicating code as needed to; propagate the base pointer associated with each pointer being relocated to; the appropriate safepoints. The implementation assumes that the following; IR constructs produce base pointers: loads from the heap, addresses of global; variables, function arguments, function return values. Constant pointers (such; as null) are also assumed to be base pointers. In practice, this constraint; can be relaxed to producing interior derived pointers provided the target; collector can find the associated allocation from an arbitrary interior; derived pointer. By default RewriteStatepointsForGC passes in ``0xABCDEF00`` as the statepoint; ID and ``0`` as the number of patchable bytes to the newly constructed; ``gc.statepoint``. These values can be configured on a per-callsite; basis using the attributes ``""statepoint-id""`` and; ``""statepoint-num-patch-bytes""``. If a call site is marked with a; ``""statepoint-id""`` function attribute and its value is a positive; integer (represented as a string), then that value is used as the ID",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:27606,safe,safepoints,27606,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"n __libc_start_main ??:0; ==9442== ABORTING. If that does not work for you (e.g. your process is sandboxed), you can use a; separate script to symbolize the result offline (online symbolization can be; force disabled by setting ``ASAN_OPTIONS=symbolize=0``):. .. code-block:: console. % ASAN_OPTIONS=symbolize=0 ./a.out 2> log; % projects/compiler-rt/lib/asan/scripts/asan_symbolize.py / < log | c++filt; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; ... Note that on macOS you may need to run ``dsymutil`` on your binary to have the; file\:line info in the AddressSanitizer reports. Additional Checks; =================. Initialization order checking; -----------------------------. AddressSanitizer can optionally detect dynamic initialization order problems,; when initialization of globals defined in one translation unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:5366,detect,detect,5366,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detect']
Safety,"n area which can be tuned to provide more comprehensive; protection at the cost of performance.; * [Hardened loads](#hardening-the-address-of-the-load) may still load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:8503,predict,prediction,8503,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['prediction']
Safety,"n badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly sc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62937,recover,recovers,62937,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['recover'],['recovers']
Safety,"n be; additional cycles between any two loops where one is contained in the other.; However, an LLVM :ref:`cycle<cycle-terminology>` covers both, loops and; irreducible control flow. * The `FixIrreducible <https://llvm.org/doxygen/FixIrreducible_8h.html>`_; pass can transform irreducible control flow into loops by inserting; new loop headers. It is not included in any default optimization pass; pipeline, but is required for some back-end targets. * Exiting edges are not the only way to break out of a loop. Other; possibilities are unreachable terminators, [[noreturn]] functions,; exceptions, signals, and your computer's power button. * A basic block ""inside"" the loop that does not have a path back to the; loop (i.e. to a latch or header) is not considered part of the loop.; This is illustrated by the following code. .. code-block:: C. for (unsigned i = 0; i <= n; ++i) {; if (c1) {; // When reaching this block, we will have exited the loop.; do_something();; break;; }; if (c2) {; // abort(), never returns, so we have exited the loop.; abort();; }; if (c3) {; // The unreachable allows the compiler to assume that this will not rejoin the loop.; do_something();; __builtin_unreachable();; }; if (c4) {; // This statically infinite loop is not nested because control-flow will not continue with the for-loop.; while(true) {; do_something();; }; }; }. * There is no requirement for the control flow to eventually leave the; loop, i.e. a loop can be infinite. A **statically infinite loop** is a; loop that has no exiting edges. A **dynamically infinite loop** has; exiting edges, but it is possible to be never taken. This may happen; only under some circumstances, such as when n == UINT_MAX in the code; below. .. code-block:: C. for (unsigned i = 0; i <= n; ++i); body(i);. It is possible for the optimizer to turn a dynamically infinite loop; into a statically infinite loop, for instance when it can prove that the; exiting condition is always false. Because the exiting edge is never",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:6345,abort,abort,6345,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['abort'],['abort']
Safety,"n exception. A program may be compiled with the option ``-fobjc-arc-exceptions`` in order to; enable these, or with the option ``-fno-objc-arc-exceptions`` to explicitly; disable them, with the last such argument ""winning"". .. admonition:: Rationale. The standard Cocoa convention is that exceptions signal programmer error and; are not intended to be recovered from. Making code exceptions-safe by; default would impose severe runtime and code size penalties on code that; typically does not actually care about exceptions safety. Therefore,; ARC-generated code leaks by default on exceptions, which is just fine if the; process is going to be immediately terminated anyway. Programs which do care; about recovering from exceptions should enable the option. In Objective-C++, ``-fobjc-arc-exceptions`` is enabled by default. .. admonition:: Rationale. C++ already introduces pervasive exceptions-cleanup code of the sort that ARC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to be corruption of the Objective-C runtime, so we want to be safer; here. Of course, potentially massive leaks are about as likely to take down; the process as this corruption is if the program does try to recover from; exceptions. .. _arc.misc.interior:. Interior pointers; -----------------. An Objective-C method returning a non-retainable pointer may be annotated with; the ``objc_returns_inner_pointer`` attribute to indicate that it returns a; handle to the internal data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:99047,safe,safety,99047,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safety']
Safety,"n hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive public LTO visibility. All; other classes receive hidden LTO visibility. Classes with internal linkage; (e.g. classes declared in unnamed namespaces) also receive hidden LTO; visibility. During the LTO link, all classes with public LTO visibility but not marked with; ``[[clang::lto_visibility_public]]`` (see below) will be refined to hidden LTO; visibility when the ``--lto-whole-program-visibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and non-LTO object files, any hidden; visibility class defined in both a translation unit built with LTO and; a translation unit built without LTO must be defined with public LTO; visibility in order to avoid an ODR violation. 2. Some ABIs provide the ability to define an abstract base class without; visibility attributes in multiple linkage units and have virtual calls; to derived classes in other linkage units work correctly. One example of; this is COM on Windows platforms. If the ABI allows this, any base class; used in this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:2814,unsafe,unsafe,2814,interpreter/llvm-project/clang/docs/LTOVisibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst,1,['unsafe'],['unsafe']
Safety,"n needed, currently they shared the global lock (ROOT::gCoreMutex). ### Interpreter. - cling's LLVM is upgraded to version 5.0; - All of cling's patches to llvm have been upstreamed.; - The interpreter-related lock is now locking only the compilation step, not the execution step. This reduces the scope for lock contention. Most significantly, it enables the use of concurrency on the prompt!. ## I/O Libraries. - Introduce TKey::ReadObject<typeName>. This is a user friendly wrapper around ReadObjectAny. For example; ```; auto h1 = key->ReadObject<TH1>; ```; after which h1 will either be null if the key contains something that is not a TH1 (or derived class); or will be set to the address of the histogram read from the file.; - Add the ability to store the 'same' object several time (assumingly with different data) in a single buffer. Instead of. ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer << arr;; }; ```; which would only really stream the array at the first iteration because it will be detected has having the same address and thus assumed to be the same object. We can now do:; ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer.WriteObject(&arr, kFALSE);; }; ```; where the last argument of WriteObject tells the buffer do *not* remember this object's address and to always stream it. This feature is also available via WriteObjectAny. - Added a new mechanism for providing clean forward-compatibility breaks in a ``TTree`` (i.e., a newer version of ROOT writes a ``TTree`` an older version cannot read). When future versions of ROOT utilize an IO feature that this version does not support, ROOT will provide a clear error message instead of crashing or returning garbage data. In future ROOT6 releases, forward-compatibility breaks will only be allowed if a non-default feature is enabled via the ``ROOT::Experimental`` namespace; it is expected ROOT7 will enable forward-compatibility breaks by default. - When a file using an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:6997,detect,detected,6997,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['detect'],['detected']
Safety,"n object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3545,abort,aborts,3545,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['abort'],['aborts']
Safety,"n obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18124,avoid,avoid,18124,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['avoid'],['avoid']
Safety,"n of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; compiler does not insert additional exception handling code into the interface; functions. This is a performance consideration: ``lib/Support`` functions are; at the bottom of many call chains and as such can be frequently called. We; need them to be as efficient as possible. However, no routines in the system; library should actually throw exceptions. Code Organization; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:8889,avoid,avoids,8889,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['avoid'],['avoids']
Safety,"n operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single stream of instructions. The Loop Vectorizer supports any; control flow in the innermost loop. The innermost loop may contain complex; nesting of IFs, ELSEs and even GOTOs. .. code-block:: c++. int foo(int *A, int *B, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); if (A[i] > B[i]); sum += A[i] + 5;; return sum;; }. Pointer Induction Variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. This example uses the ""accumulate"" function of the standard c++ library. This; loop uses C++ iterators, which are pointers, and not integer indices.; The Loop Vectorizer detects pointer induction variables and can vectorize; this loop. This feature is important because many C++ programs use iterators. .. code-block:: c++. int baz(int *A, int n) {; return std::accumulate(A, A + n, 0);; }. Reverse Iterators; ^^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize loops that count backwards. .. code-block:: c++. void foo(int *A, int n) {; for (int i = n; i > 0; --i); A[i] +=1;; }. Scatter / Gather; ^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize code that becomes a sequence of scalar instructions; that scatter/gathers memory. .. code-block:: c++. void foo(int * A, int * B, int n) {; for (intptr_t i = 0; i < n; ++i); A[i] += B[i * 4];; }. In many situations the cost model will inform LLVM that this is not beneficial; and LLVM will only vectorize such code if forced with ""-mllvm -force-vector-width=#"". Vectorization of Mixed Types; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize programs with mixed types. The Vectorizer; cost model can estimate the cost of the t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:7431,detect,detects,7431,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['detect'],['detects']
Safety,"n option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; boundary and to prevent potential exceptions from being moved across boundary.; Any set of operations can then be confined to the region by reading their leaf; inputs via volatile loads and writing their root outputs via volatile stores. '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.scope.begin(); declare void @llvm.seh.scope.end(). Overview:; """""""""""""""""". The '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' intrinsics mark; the boundary of a CPP object lifetime for Windows SEH Asynchrous Exception; Handling (MSVC option -EHa). Semantics:; """""""""""""""""""". LLVM's ordinary exception-handling representation associates EH cleanups and; handlers only with ``invoke``s, which normally correspond only to call sites. To; support arbitrary faulting instructions, it must be possible to recover the current; EH scope for any instruction. Turning every operation in LLVM that could fault; into an ``invoke`` of a new, potentially-throwing intrinsic would require adding a; large number of intrinsics, impede optimization of those operations, and make; compilation slower by introducing many extra basic blocks. These intrinsics can; be used instead to mark the region protected by a cleanup, such as for a local; C++ object with a non-trivial destructor. ``llvm.seh.scope.begin`` is used to mark; the start of the region; it is always called with ``invoke``, with the unwind block; being the desired unwind destination for any potentially-throwing instructions; within the region. `llvm.seh.scope.end` is used to mark when the scope ends; and the EH cleanup is no longer required (e.g. because the destructor is being; called). .. _int_read_register:; .. _int_read_volatile_register:; .. _int_write_register:. '``llvm.read_register``', '``llvm.read_volatile_register``', and '``l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:516648,recover,recover,516648,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recover']
Safety,"n provide the exact location of the; terminator. With this argument, the function can skip reading the entire; array in order to locate the end of the pointer (or the upper bound).; Providing an incorrect ``PTR_TO_TERM`` causes a run-time trap. + ``__unsafe_forge_terminated_by(T, P, E)`` creates ``T __terminated_by(E)``; pointer given any pointer ``P``. Tmust be a pointer type. Portability with toolchains that do not support the extension; -------------------------------------------------------------. The language model is designed so that it doesn't alter the semantics of the; original C program, other than introducing deterministic traps where otherwise; the behavior is undefined and/or unsafe. Clang provides a toolchain header; (``ptrcheck.h``) that macro-defines the annotations as type attributes when; ``-fbounds-safety`` is enabled and defines them to empty when the extension is; disabled. Thus, the code adopting ``-fbounds-safety`` can compile with; toolchains that do not support this extension, by including the header or adding; macros to define the annotations to empty. For example, the toolchain not; supporting this extension may not have a header defining ``__counted_by``, so; the code using ``__counted_by`` must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ==================================================. The bounds annotations provided by the ``-fbounds-safety`` programming model; have potential use cases beyond the language extension itself. For example,; static and d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:45653,safe,safety,45653,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"n the bounds of the allocation; they're associated with. As a result, the base object can be found at; runtime provided the bounds of allocations are known to the runtime system. ""Exterior derived pointers"" are outside the bounds of the associated object;; they may even fall within *another* allocations address range. As a result,; there is no way for a garbage collector to determine which allocation they; are associated with at runtime and compiler support is needed. The ``gc.relocate`` intrinsic supports an explicit operand for describing the; allocation associated with a derived pointer. This operand is frequently; referred to as the base operand, but does not strictly speaking have to be; a base pointer, but it does need to lie within the bounds of the associated; allocation. Some collectors may require that the operand be an actual base; pointer rather than merely an internal derived pointer. Note that during; lowering both the base and derived pointer operands are required to be live; over the associated call safepoint even if the base is otherwise unused; afterwards. If we extend our previous example to include a pointless derived pointer,; we get:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %gep = getelementptr i8, i8 addrspace(1)* %obj, i64 20000; %token = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj, i8 addrspace(1)* %gep); %obj.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 7); %gep.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 8); %p = getelementptr i8, i8 addrspace(1)* %gep, i64 -20000; ret i8 addrspace(1)* %p; }. Note that in this example %p and %obj.relocate are the same address and we; could replace one with the other, potentially removing the derived pointer; from the l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:15216,safe,safepoint,15216,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"n x86 processors may speculate into called functions and out of functions; to their return address. As a consequence, we need a way to check loads that; occur after a misspeculated predicate but where the load and the misspeculated; predicate are in different functions. In essence, we need some interprocedural; generalization of the predicate state tracking. A primary challenge to passing; the predicate state between functions is that we would like to not require a; change to the ABI or calling convention in order to make this mitigation more; deployable, and further would like code mitigated in this way to be easily; mixed with code not mitigated in this way and without completely losing the; value of the mitigation. ##### Embed the predicate state into the high bit(s) of the stack pointer. We can use the same technique that allows hardening pointers to pass the; predicate state into and out of functions. The stack pointer is trivially; passed between functions and we can test for it having the high bits set to; detect when it has been marked due to misspeculation. The callsite instruction; sequence looks like (assuming a misspeculated state value of `-1`):; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; shlq $47, %rax; orq %rax, %rsp; callq other_function; movq %rsp, %rax; sarq 63, %rax # Sign extend the high bit to all bits.; ```. This first puts the predicate state into the high bits of `%rsp` before calling; the function and then reads it back out of high bits of `%rsp` afterward. When; correctly executing (speculatively or not), these are all no-ops. When; misspeculating, the stack pointer will end up negative. We arrange for it to; remain a canonical address, but otherwise leave the low bits alone to allow; stack adjustments to proceed normally without disrupting this. Within the; called function, we can extract this predicate state and then reset it on; return:; ```; other_function:; # prolog; callq other_function; mov",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:38837,detect,detect,38837,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['detect'],['detect']
Safety,"n, CERN/SFT,\; Philippe Canal, FNAL,\; Cristina Cristescu, CERN/SFT,\; Olivier Couet, CERN/SFT,\; Kyle Cranmer, NYU, RooStats,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/Alice,\; Lukasz Janyst, CERN/IT,\; Christopher Jones, Fermilab, CMS,\; Wim Lavrijsen, LBNL, PyRoot,\; Sergey Linev, GSI, http,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Timur Pocheptsov, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Liza Sakellari, CERN/SFT,\; Manuel Tobias Schiller,\; David Smith, CERN/IT,\; Matevz Tadel, UCSD/CMS, Eve, \; Vassil Vassilev, CERN/SFT \; Wouter Verkerke, NIKHEF/Atlas, RooFit, \; Yue Shi Lai, MIT,\; Maciej Zimnoch. ## Core Libraries. ### General. #### Platform support. ROOT now works on linuxarm64 / AArch64 / ARMv8 64-bit - thanks, David Abdurachmanov!. ROOT supports GCC 5.0 (using the GCC4 ABI) and XCode 6.3, Mac OSX 10.10.3. #### Thread-Safety. A lot of effort went into improving the thread-safety of Core and Meta classes / functions. A special thanks to Chris Jones from CMS!. #### std::string_view. Introduce a preview of C++17's std::string_view. To take advantage of this new; class use:; ```{.cpp}; #include ""RStringView.h""; ```; The documentation of this can be found at `http://en.cppreference.com/w/cpp/experimental/basic_string_view`; The implementation provided is extracted from libcxx. Whenever the current; compiler and standard library provide an implmentation, it is used. The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. This type is used throughout the ROOT code to avoid copying strings when a; sub-string is needed and to extent interfaces that uses to take a const char*; to take a std::string_view as thus be able to be directly directly passed a; TString, a std::string or a std::string_view. Usage example:. ``` {.cpp}; // With SetName(std::strin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:1354,safe,safety,1354,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['safe'],['safety']
Safety,"n-linear least square.; . MathCore. Fixed a bug in setting the VEGAS integration mode in the GSLMCIntegrator class.; . Fumili. Add implementation of Minimizer interface using TFumili.; ; Minuit. In TMinuitMinimizer: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:3622,safe,safe,3622,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['safe'],['safe']
Safety,n. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:50419,safe,safely-derived,50419,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['safe'],['safely-derived']
Safety,"n; /tmp/foo/test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --basenames; main; test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --relativenames; main; foo/test.cpp:15:0. Example 7 - Addresses as symbol names:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf main; main; /tmp/test.cpp:14:0; $ llvm-symbolizer --obj=test.elf ""CODE foz""; foz; /tmp/test.h:1:0. OPTIONS; -------. .. option:: --adjust-vma <offset>. Add the specified offset to object file addresses when performing lookups.; This can be used to perform lookups as if the object were relocated by the; offset. .. option:: --basenames, -s. Print just the file's name without any directories, instead of the; absolute path. .. option:: --build-id. Look up the object using the given build ID, specified as a hexadecimal; string. Mutually exclusive with :option:`--obj`. .. option:: --color [=<always|auto|never>]. Specify whether to use color in :option:`--filter-markup` mode. Defaults to; ``auto``, which detects whether standard output supports color. Specifying; ``--color`` alone is equivalent to ``--color=always``. .. option:: --debug-file-directory <path>. Provide a path to a directory with a `.build-id` subdirectory to search for; debug information for stripped binaries. Multiple instances of this argument; are searched in the order given. .. option:: --debuginfod, --no-debuginfod. Whether or not to try debuginfod lookups for debug binaries. Unless specified,; debuginfod is only enabled if libcurl was compiled in (``LLVM_ENABLE_CURL``); and at least one server URL was provided by the environment variable; ``DEBUGINFOD_URLS``. .. _llvm-symbolizer-opt-C:. .. option:: --demangle, -C. Print demangled function names, if the names are mangled (e.g. the mangled; name `_Z3bazv` becomes `baz()`, whilst the non-mangled name `foz` is printed; as is). Defaults to true. .. option:: --dwp <path>. Use the specified DWP file at ``<path>`` for any CUs that have split DWARF; debug data. .. option:: --fallbac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:5374,detect,detects,5374,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['detect'],['detects']
Safety,"n; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,; `derived pointers`_ must not be retained across safe points and `object; pointers`_ must be reloaded from stack roots. **SDISel**; Selection DAG Instruction Selection. **SCC**; Strongly Connected Component. **SCCP**; Sparse Conditional Constant Propagation. **SLP**; Superword-Level Parallelism, same as :ref:`Basic-Block Vectorization; <lexicon-bb-vectorization>`. **Splat**; Splat refers to a vector of identical scalar elements. The term is based on the PowerPC Altivec instructions that provided; this functionality in hardware. For example, ""vsplth"" and the corresponding; software intrinsic ""vec_splat()"". Examples of other hardware names for this; action include ""duplicate"" (ARM) and ""broadcast"" (x86). **SRoA**; Scalar Replacement of Aggregates. **SSA**; Static Single Assignment. **Stack Map**; In garbage collection, metadata emitted by the code generator which; identifies `roots`_ within the stack frame of an executing function. T; -. **TBAA**; Type-Based Alias Analysis. W; -. **WPD**; Whole Program Devirtualization. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:7873,safe,safe,7873,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['safe'],['safe']
Safety,"nabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability checks:; ; Checker warning about uses of non-localized NSStrings passed to UI methods expecting localized strings.; Checker warning when the comment argument is missing from NSLocalizedString macros.; These can be enabled by passing the following command to scan-build:.   -enable-checker alpha.osx.cocoa.NonLocalizedStringChecker,alpha.osx.cocoa.EmptyLocalizationContextChecker. New checks for _Nonnull type qualifiers. These can be enabled with:.   -enable-checker nullability.NullPassedToNonnull,nullability.NullReturnedFromNonnull; New checks for misuse of Objective-C generics. These can be enabled with -enable-checker alpha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:1602,detect,detect,1602,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['detect'],['detect']
Safety,"nality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a single builder into two or more,; if you have multiple distinct purposes for the same builder. As an example,; if you want to both a) confirm that all of LLVM builds with your host; compiler, and b) want to do a multi-stage clang build on your target, you; may be better off with two separate bots. Splitting increases resource; consumption, but makes it easy for each bot to keep up with commit flow.; Additionally, splitting bots may assist in triage by narrowing attention to; relevant parts of the failing configuration. In general, we recommend Release build types with Assertions enabled. This; generally provides a good balance between build times and bug detection for; most buildbots. There may be room for including some debug info (e.g. with; `-gmlt`), but in general the balance between debug info quality and build; times is a delicate one. Use Ninja & LLD; Ninja really does help build times over Make, particularly for highly; parallel builds. LLD helps to reduce both link times and memory usage; during linking significantly. With a build machine with sufficient; parallelism, link times tend to dominate critical path of the build, and are; thus worth optimizing. Use CCache and NOT incremental builds; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:10527,detect,detection,10527,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['detect'],['detection']
Safety,"name syntax that includes pathnames with multiple dots, such as ""myBranch.mySubBranch.myLeaf"". This is available both for jitted expressions and for lists of column names.; - The CSV data source (TCsvDS) can now be constructed with a chunk size parameter, and as a result the CSV file will be read progressively, in chunks of the specified size. This can be used to prevent the whole CSV file from being read into memory at once, thus reducing the memory footprint of this data source.; - Add the `ROOT::Experimental::TAdoptAllocator<T>`, an allocator which allows to adopt existing memory. If memory is adopted, upon allocation a copy is performed in the new, potentially more extended, memory region.; - Add `ROOT::Experimental::VecOps::TVec<T>` a class which represents a contiguous array, inspired by Numpy arrays. `TVec` offer a convenient interface, almost identical to the one of `std::vector`. It can own or adopt its memory. As well as a set of tools which make analysis of collections easier, avoiding to loop over the individual elements of the collections. Basic arithmetic operations such as +,-,*,/,% between TVecs and scalars and TVecs are supported. Most popular math functions which act on TVecs are provided. Helpers to calculate basic quantities such as sum, mean, variance or standard deviation of TVecs are provided.; A powerful and concise syntax for expressing cuts is available:; ```; // mu_pts_tvec and mu_etas_tvec are two equally sized TVecs holding kinematic properties of muons; // a filter on muons pseudorapidities is applied considering a range in pseudo rapidity.; filtered_mu_pts_tvec = mu_pts_tvec[abs(mu_etas_tvec) < 2)];; ```; - The `TArrayBranch` class has been removed and replaced by the more powerful `TVec`.; - Columns on disk stored as C arrays should be read as `TVec`s, `std::vector` columns can be read as `TVec`s if requested. Jitted transformations and actions consider `std::vector` columns as well as C array columns `TVec`s.; - In jitted transformati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:8719,avoid,avoiding,8719,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoiding']
Safety,"natural semantics of value propagation, where; all basic operations on the type come down to copies and destroys,; and everything else is just an optimization on top of those. The most glaring weakness of programming with non-trivial types in C; is that there are no language mechanisms (akin to C++'s placement; ``new`` and explicit destructor calls) for explicitly creating and; destroying objects. Clang should consider adding builtins for this; purpose, as well as for common optimizations like destructive; relocation. Application of the formal C rules to nontrivial ownership qualifiers; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Nontrivially ownership-qualified types are considered non-trivial; to copy, destroy, and default-initialize. A dynamic object of nontrivially ownership-qualified type contingently; exists at a location if the memory is filled with a zero pattern, e.g.; by ``calloc`` or ``bzero``. Such an object can be safely accessed in; all of the cases above, but its memory can also be safely repurposed.; Assigning a null pointer into an l-value of ``__weak`` or; ``__strong``-qualified type accesses the dynamic object there (and thus; may have undefined behavior if no such object exists), but afterwards; the object's memory is guaranteed to be filled with a zero pattern; and thus may be either further accessed or repurposed as needed.; The upshot is that programs may safely initialize dynamically-allocated; memory for nontrivially ownership-qualified types by ensuring it is zero-initialized, and they may safely deinitialize memory before; freeing it by storing ``nil`` into any ``__strong`` or ``__weak``; references previously created in that memory. C/C++ compatibility for structs and unions with non-trivial members; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Structs and unions with non-trivial members are compatible in; different language modes (e.g. between Objective-C and Objective-C++,; or between AR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:60111,safe,safely,60111,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['safe'],['safely']
Safety,"ncatenated with the next one. In this way you can build up; long pipelines of commands without making huge line lengths. The lines; ending in ``\`` are concatenated until a RUN line that doesn't end in; ``\`` is found. This concatenated set of RUN lines then constitutes one; execution. :program:`lit` will substitute variables and arrange for the pipeline; to be executed. If any process in the pipeline fails, the entire line (and; test case) fails too. Below is an example of legal RUN lines in a ``.ll`` file:. .. code-block:: llvm. ; RUN: llvm-as < %s | llvm-dis > %t1; ; RUN: llvm-dis < %s.bc-13 > %t2; ; RUN: diff %t1 %t2. As with a Unix shell, the RUN lines permit pipelines and I/O; redirection to be used. There are some quoting rules that you must pay attention to when writing; your RUN lines. In general nothing needs to be quoted. :program:`lit` won't; strip off any quote characters so they will get passed to the invoked program.; To avoid this use curly braces to tell :program:`lit` that it should treat; everything enclosed as one value. In general, you should strive to keep your RUN lines as simple as possible,; using them only to run tools that generate textual output you can then examine.; The recommended way to examine output to figure out if the test passes is using; the :doc:`FileCheck tool <CommandGuide/FileCheck>`. *[The usage of grep in RUN; lines is deprecated - please do not send or commit patches that use it.]*. Put related tests into a single file rather than having a separate file per; test. Check if there are files already covering your feature and consider; adding your code there instead of creating a new file. Generating assertions in regression tests; -----------------------------------------. Some regression test cases are very large and complex to write/update by hand.; In that case to reduce the human work we can use the scripts available in; llvm/utils/ to generate the assertions. For example to generate assertions in an :program:`llc`-based ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:10440,avoid,avoid,10440,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoid']
Safety,"nce itself from the; costly full header inclusion. Unfortunately, several of them are home-grown and; in a few cases inaccurate (eg line #5) causing a noticeable technical debt. Here we will briefly describe the three common layers of optimizations: ROOT PCH,; ROOTMAP and RDICT. The ROOT precompiled header (PCH) reduces the CPU and memory cost for ROOT's; most used libraries. The precompiled header technology is well-understood since; decades [[4]]. It is an efficient on-disk representation of the state of the; compiler after parsing a set of headers. It can be loaded before starting the; next instance to avoid doing redundant work. At build time, rootcling (ROOT's; dictionary generator) creates such PCH file which is attached at ROOT startup; time. Its major drawback is the fact that if third-party users want to include; their libraries, they have to recompile it every time there is a change. RDICT files store some useful information (in particular about class offsets) in; ROOT files to avoid the potentially expensive call to the interpreter if the; information is not the PCH. For example, ROOT's libGeom and other third-party; code. This is done to circumvent the costly call to `ShowMembers` which will; require parsing. ROOTMAP files reduce parsing for code which is not in the PCH. Consider; `foo::bar` and `S` are defined in `libFoo`'s `Foo.h`:; ```cpp; // Foo.h; namespace foo { struct bar{}; }; struct S{};; ```. ```bash; # libFoo.rootmap; { decls }; namespace foo { }; struct S;; ; [ libFoo.so ]; # List of selected classes; class bar; struct S; ```. ```cpp; // G__Foo.cxx (aka libFoo dictionary); namespace {; void TriggerDictionaryInitialization_libFoo_Impl() {; static const char* headers[] = {""Foo.h""}; // More scaffolding; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; }; ```. The code snippet bellow d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:6591,avoid,avoid,6591,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoid']
Safety,"nce); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84675,recover,recovery,84675,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"nch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not yet documented; here. Supported Architectures; =======================. Support for statepoint generation requires some code for each backend.; Today, only Aarch64 and X86_64 are supported. .. _OpenWork:. Limitations and Half Baked Ideas; ================================. Mixing References and Raw Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Support for languages which allow unmanaged pointers to garbage collected; objects (i.e. pass a pointer to an object to a C routine) in the abstract; machine model. At the moment, the best idea on how to approach this; involves an intrinsic or opaque function which hides the connection between; the reference value and the raw pointer. The problem is that having ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:33511,safe,safepoints,33511,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"nd header files with their default settings:. ``` {.cpp}; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; ```. URL stem for ROOT documentation pages (default is `""""`). ``` {.cpp}; Root.Html.Root: http://root.cern.ch/root/html; ```. Filesystem output directory for generated web pages (default:; `htmldoc)`. ``` {.cpp}; Root.Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; ```. Regular backg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:9636,detect,detecting,9636,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['detect'],['detecting']
Safety,"nd nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1197,safe,safe,1197,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['safe'],['safe']
Safety,"nd notation for column name `R_rdf_sizeof_var`.; - Helpers have been added to export data from `RDataFrame` to RooFit datasets. See the ""RooFit Libraries"" section below for more details, or see [the tutorial](https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html). ### Notable changes in behavior. - Using `Alias`, it is now possible to register homonymous aliases (alternative column names) in different branches of the computation graph, in line with the behavior of `Define` (until now, aliases were required to be unique in the whole computaton graph).; - The `Histo*D` methods now support the combination of scalar values and vector-like weight values. For each entry, the histogram is filled once for each weight, always with the same scalar value.; - The `Histo*D` methods do not work on columns of type `std::string` anymore. They used to fill the histogram with the integer value corresponding to each of the characters in the string. Please use `Fill` with a custom class to recover the old behavior if that was what was desired. ### Other improvements. - The scaling to a large amount of threads of computation graphs with many simple `Filter`s or `Define`s has been greatly improved, see also [this talk](https://indico.cern.ch/event/1036730/#1-a-performance-study-of-the-r) for more details; - The output format of `Display` has been significantly improved.; - The `Fill` method now correctly supports user-defined classes with arbitrary `Fill` signatures (see [#9428](https://github.com/root-project/root/issues/9428)). ### Experimental Distributed RDataFrame. The distributed RDataFrame module has been improved. Now it supports sending RDataFrame tasks to a [Dask](https://dask.org/) scheduler. Through Dask, RDataFrame can be also scaled to a cluster of machines managed through a batch system like HTCondor or Slurm. Here is an example:. ```python; import ROOT; from dask.distributed import Client; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Pyt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:9693,recover,recover,9693,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['recover'],['recover']
Safety,"nd the tradeoffs they make,; please consult `that section of the programmer's manual; <https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task>`_. Python version and Source Code Formatting; -----------------------------------------. The current minimum version of Python required is documented in the :doc:`GettingStarted`; section. Python code in the LLVM repository should only use language features; available in this version of Python. The Python code within the LLVM repository should adhere to the formatting guidelines; outlined in `PEP 8 <https://peps.python.org/pep-0008/>`_. For consistency and to limit churn, code should be automatically formatted with; the `black <https://github.com/psf/black>`_ utility, which is PEP 8 compliant.; Use its default rules. For example, avoid specifying ``--line-length`` even; though it does not default to 80. The default rules can change between major; versions of black. In order to avoid unnecessary churn in the formatting rules,; we currently use black version 23.x in LLVM. When contributing a patch unrelated to formatting, you should format only the; Python code that the patch modifies. For this purpose, use the `darker; <https://pypi.org/project/darker/>`_ utility, which runs default black rules; over only the modified Python code. Doing so should ensure the patch will pass; the Python format checks in LLVM's pre-commit CI, which also uses darker. When; contributing a patch specifically for reformatting Python files, use black,; which currently only supports formatting entire files. Here are some quick examples, but see the black and darker documentation for; details:. .. code-block:: bash. $ pip install black=='23.*' darker # install black 23.x and darker; $ darker test.py # format uncommitted changes; $ darker -r HEAD^ test.py # also format changes from last commit; $ black test.py # format entire file. Instead of individual file names, you can specify directories to; darker, and it will find ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:5346,avoid,avoid,5346,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"nd their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101505,safe,safety,101505,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"nd write all memory. As a result,; memory operations can not be reordered past a statepoint. It is; illegal to mark a statepoint as being either 'readonly' or 'readnone'. Note that legal IR can not perform any memory operation on a 'gc; pointer' argument of the statepoint in a location statically reachable; from the statepoint. Instead, the explicitly relocated value (from a; ``gc.relocate``) must be used. '``llvm.experimental.gc.result``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare type; @llvm.experimental.gc.result(token %statepoint_token). Overview:; """""""""""""""""". ``gc.result`` extracts the result of the original call instruction; which was replaced by the ``gc.statepoint``. The ``gc.result``; intrinsic is actually a family of three intrinsics due to an; implementation limitation. Other than the type of the return value,; the semantics are the same. Operands:; """""""""""""""""". The first and only argument is the ``gc.statepoint`` which starts; the safepoint sequence of which this ``gc.result`` is a part.; Despite the typing of this as a generic token, *only* the value defined; by a ``gc.statepoint`` is legal here. Semantics:; """""""""""""""""""". The ``gc.result`` represents the return value of the call target of; the ``statepoint``. The type of the ``gc.result`` must exactly match; the type of the target. If the call target returns void, there will; be no ``gc.result``. A ``gc.result`` is modeled as a 'readnone' pure function. It has no; side effects since it is just a projection of the return value of the; previous call represented by the ``gc.statepoint``. '``llvm.experimental.gc.relocate``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <pointer type>; @llvm.experimental.gc.relocate(token %statepoint_token,; i32 %base_offset,; i32 %pointer_offset). Overview:; """""""""""""""""". A ``gc.relocate`` returns the potentially relocated value of a pointer; at the safepoint. Operands:; """""""""""""""""". The first argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:504275,safe,safepoint,504275,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safepoint']
Safety,"nd/or ``nsw`` keywords are present, the; result value of the ``add`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = add i32 4, %var ; yields i32:result = 4 + %var. .. _i_fadd:. '``fadd``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fadd [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fadd``' instruction returns the sum of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fadd``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point sum of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fadd float 4.0, %var ; yields float:result = 4.0 + %var. .. _i_sub:. '``sub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sub <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nsw <ty> <op1>, <op2> ; yields ty:result; <result> = sub nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``sub``' instruction returns the difference of its two operands. Note that the '``sub``' instruction is used to represent the '``neg``'; instruction present in most other intermediate representations. Arguments:; """""""""""""""""""". The two arguments to the '``sub``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer difference of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:379211,unsafe,unsafe,379211,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"ndeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81508,safe,safe,81508,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"ndif. .. _arc.misc.self:. ``self``; --------. The ``self`` parameter variable of an non-init Objective-C method is considered; :ref:`externally-retained <arc.misc.externally_retained>` by the implementation.; It is undefined behavior, or at least dangerous, to cause an object to be; deallocated during a message send to that object. In an init method, ``self``; follows the :ref:``init family rules <arc.family.semantics.init>``. .. admonition:: Rationale. The cost of retaining ``self`` in all methods was found to be prohibitive, as; it tends to be live across calls, preventing the optimizer from proving that; the retain and release are unnecessary --- for good reason, as it's quite; possible in theory to cause an object to be deallocated during its execution; without this retain and release. Since it's extremely uncommon to actually; do so, even unintentionally, and since there's no natural way for the; programmer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unretained``), we chose to make this optimizing; assumption and shift some amount of risk to the user. .. _arc.misc.enumeration:. Fast enumeration iteration variables; ------------------------------------. If a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:95327,risk,risk,95327,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['risk'],['risk']
Safety,"ndler --unbundle --inputs=libFatArchive.a -type=a \; -targets=openmp-amdgcn-amdhsa-gfx906:sramecc+:xnack+, \; openmp-amdgcn-amdhsa-gfx908:sramecc-:xnack+ \; -outputs=devicelib-gfx906.a,deviceLib-gfx908.a. .. _additional-options-archive-unbundling:. Additional Options while Archive Unbundling; -------------------------------------------. **-allow-missing-bundles**; Create an empty archive file if no compatible device binary is found. **-check-input-archive**; Check if input heterogeneous device archive follows rules for composition; as defined in :ref:`code-object-composition` before creating device-specific; archive(s). **-debug-only=CodeObjectCompatibility**; Verbose printing of matched/unmatched comparisons between bundle entry id of; a device binary from HDA and bundle entry ID of a given target processor; (see :ref:`compatibility-bundle-entry-id`). Compression and Decompression; =============================. ``clang-offload-bundler`` provides features to compress and decompress the full; bundle, leveraging inherent redundancies within the bundle entries. Use the; `-compress` command-line option to enable this compression capability. The compressed offload bundle begins with a header followed by the compressed binary data:. - **Magic Number (4 bytes)**:; This is a unique identifier to distinguish compressed offload bundles. The value is the string 'CCOB' (Compressed Clang Offload Bundle). - **Version Number (16-bit unsigned int)**:; This denotes the version of the compressed offload bundle format. The current version is `1`. - **Compression Method (16-bit unsigned int)**:; This field indicates the compression method used. The value corresponds to either `zlib` or `zstd`, represented as a 16-bit unsigned integer cast from the LLVM compression enumeration. - **Uncompressed Binary Size (32-bit unsigned int)**:; This is the size (in bytes) of the binary data before it was compressed. - **Hash (64-bit unsigned int)**:; This is a 64-bit truncated MD5 hash of the uncomp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:18941,redund,redundancies,18941,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['redund'],['redundancies']
Safety,"ne ZLIB_VERSION \""[^\""]*\""$""); string(REGEX REPLACE ""^.*ZLIB_VERSION \""([0-9]+).*$"" ""\\1"" ZLIB_VERSION_MAJOR ""${ZLIB_H}""); string(REGEX REPLACE ""^.*ZLIB_VERSION \""[0-9]+\\.([0-9]+).*$"" ""\\1"" ZLIB_VERSION_MINOR ""${ZLIB_H}""); string(REGEX REPLACE ""^.*ZLIB_VERSION \""[0-9]+\\.[0-9]+\\.([0-9]+).*$"" ""\\1"" ZLIB_VERSION_PATCH ""${ZLIB_H}""); set(ZLIB_VERSION_STRING ""${ZLIB_VERSION_MAJOR}.${ZLIB_VERSION_MINOR}.${ZLIB_VERSION_PATCH}""). set(ZLIB_VERSION_TWEAK """"); if(""${ZLIB_H}"" MATCHES ""ZLIB_VERSION \""[0-9]+\\.[0-9]+\\.[0-9]+\\.([0-9]+)""); set(ZLIB_VERSION_TWEAK ""${CMAKE_MATCH_1}""); string(APPEND ZLIB_VERSION_STRING "".${ZLIB_VERSION_TWEAK}""); endif(). set(ZLIB_VERSION ${ZLIB_VERSION_STRING} CACHE INTERNAL """"); set(ZLIB_VERSION_STRING ${ZLIB_VERSION_STRING} CACHE INTERNAL """"). set(ZLIB_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR} CACHE INTERNAL """"); set(ZLIB_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR} CACHE INTERNAL """"). if((CMAKE_SYSTEM_PROCESSOR MATCHES ""amd64|x86_64|AMD64|X86_64|aarch64"") AND (CMAKE_SYSTEM_NAME MATCHES ""Linux"")); # Calling helper to avoid using old unsupported binutils (e.g. with SL6); # macro is returning extra ${ROOT_DEFINITIONS} used after in ZLIB-CF; root_check_assembler(); # Calling helper to avoid using old unsupported binutils (e.g. with Centos7; # and native gcc compiler 4.8.5); # Macros are returning bools SSE_SUPPORT & AVX2_SUPPORT; root_check_sse41(); root_check_avx2(); if(SSE_SUPPORT OR AVX2_SUPPORT); set(ZLIB_CF TRUE CACHE INTERNAL """"); endif(); endif(). if(ZLIB_CF); add_library(ZLIB STATIC ${ZLIB_PUBLIC_HEADERS} ${ZLIBCF_PRIVATE_HEADERS} ${ZLIBCF_SOURCES}); else(); add_library(ZLIB STATIC ${ZLIB_PUBLIC_HEADERS} ${ZLIB_PRIVATE_HEADERS} ${ZLIB_SOURCES}); endif(). set_target_properties(ZLIB PROPERTIES C_VISIBILITY_PRESET hidden POSITION_INDEPENDENT_CODE ON); target_include_directories(ZLIB INTERFACE $<BUILD_INTERFACE:${ZLIB_INCLUDE_DIR}>). if((CMAKE_SYSTEM_PROCESSOR MATCHES ""amd64|x86_64|AMD64|X86_64"") AND (CMAKE_SYSTEM_NAME MATCHES ""Linux"")); target_compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/CMakeLists.txt:2067,avoid,avoid,2067,builtins/zlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/CMakeLists.txt,1,['avoid'],['avoid']
Safety,"ned by the method is the object which shape; boundary will be crossed first. The distance to the next crossing can be; retrieved after the call:. ~~~{.cpp}; Double_t TGeoManager::GetStep(); ~~~. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning ""step approved"". The default value for `stepmax` is; TGeoShape::Big with the meaning that boundaries are looked for; without limitation. \image html geometry017.png ""Finding the distance to the next crossed boundary"" width=600px. According the values of the input parameters the method will perform; additional optional tasks:. `|stepmax| < TGeoShape::Big()`. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial poin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:120638,safe,safe,120638,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"ned int count = 0;; for (unsigned int i = 0; i < 4 * 8; i++); count += (input >> i) & i;; return count;; }. This should be recognized as CLZ: https://github.com/llvm/llvm-project/issues/64167. unsigned clz_a(unsigned a) {; int i;; for (i=0;i<32;i++); if (a & (1<<(31-i))); return i;; return 32;; }. This sort of thing should be added to the loop idiom pass. //===---------------------------------------------------------------------===//. These should turn into single 16-bit (unaligned?) loads on little/big endian; processors. unsigned short read_16_le(const unsigned char *adr) {; return adr[0] | (adr[1] << 8);; }; unsigned short read_16_be(const unsigned char *adr) {; return (adr[0] << 8) | adr[1];; }. //===---------------------------------------------------------------------===//. -instcombine should handle this transform:; icmp pred (sdiv X / C1 ), C2; when X, C1, and C2 are unsigned. Similarly for udiv and signed operands. . Currently InstCombine avoids this transform but will do it when the signs of; the operands and the sign of the divide match. See the FIXME in ; InstructionCombining.cpp in the visitSetCondInst method after the switch case ; for Instruction::UDiv (around line 4447) for more details. The SingleSource/Benchmarks/Shootout-C++/hash and hash2 tests have examples of; this construct. . //===---------------------------------------------------------------------===//. [LOOP OPTIMIZATION]. SingleSource/Benchmarks/Misc/dt.c shows several interesting optimization; opportunities in its double_array_divs_variable function: it needs loop; interchange, memory promotion (which LICM already does), vectorization and; variable trip count loop unrolling (since it has a constant trip count). ICC; apparently produces this very nice code with -ffast-math:. ..B1.70: # Preds ..B1.70 ..B1.69; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; addl $8, %edx #; cmpl $131072, %edx #108.2; jb ..B1.70 # Prob 99% #108.2. It ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:7804,avoid,avoids,7804,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['avoid'],['avoids']
Safety,"newly introduced tuple-initialization; ```python; myHisto = myTdf.Histo1D(('histName', 'histTitle', 64, 0, 128), 'myColumn'); ```; - Add support for friend trees and chains. Just add the friends before passing the tree/chain to TDataFrame's constructor and refer to friend branches as usual. #### Fixes; - Fixed race condition: concurrent deletion of TTreeReader/TTreeReaderValue; - Fixed reading of c-style arrays from jitted transformations and actions; - Fixed writing of c-style arrays with `Snapshot`; - Improved checks for column name validity (throw if column does not exist and if `Define`d column overrides an already existing column). #### Other changes; - Improved documentation; - TDF now avoids performing virtual calls for parts of the analysis that are not jitted; - Removed ""custom column"" nodes from the internal functional graph therewith optimising its traversal; - Improvements in Cling drastically enhanced scaling and performance of TDF jitted code; - Test coverage has been increased with the introduction of google tests; - Interface change: users must now use TDF::TArrayBranch rather than std::array\_view to specify that the column being read is a c-style array TTree branch; - Interface change: `Min` and `Max` now return results as the same type specified as template parameter, or double if no template parameter was specified. ## Histogram Libraries; - Histogram-based fits are implicitly parallelized.; - Added new options to the histogram fitting interfaces to support explicit parallelization of the fit as well.; - `TF1` gradient evaluation supports vectorization.; - Refactor of `TF1` constructors, default initialization of its data members and fixed ambiguous TF1::operator().; - Extend `TFormula` parsing capabilities.; - The parsing of arguments for defining parametric function is improved. For example a Gaussian function in y can be defined as `gaus( y , [A], [Mean], [Sigma])`.; - One can define the function variables or parameters using another function o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:15117,avoid,avoids,15117,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['avoid'],['avoids']
Safety,"nfo format, which is usable with Microsoft debuggers such; as Visual Studio and WinDBG. LLVM's debug information format is mostly derived; from and inspired by DWARF, but it is feasible to translate into other target; debug info formats such as STABS. It would also be reasonable to use debug information to feed profiling tools; for analysis of generated code, or, tools for reconstructing the original; source from generated code. .. _intro_debugopt:. Debug information and optimizations; -----------------------------------. An extremely high priority of LLVM debugging information is to make it interact; well with optimizations and analysis. In particular, the LLVM debug; information provides the following guarantees:. * LLVM debug information **always provides information to accurately read; the source-level state of the program**, regardless of which LLVM; optimizations have been run. :doc:`HowToUpdateDebugInfo` specifies how debug; info should be updated in various kinds of code transformations to avoid; breaking this guarantee, and how to preserve as much useful debug info as; possible. Note that some optimizations may impact the ability to modify the; current state of the program with a debugger, such as setting program; variables, or calling functions that have been deleted. * As desired, LLVM optimizations can be upgraded to be aware of debugging; information, allowing them to update the debugging information as they; perform aggressive optimizations. This means that, with effort, the LLVM; optimizers could optimize debug code just as well as non-debug code. * LLVM debug information does not prevent optimizations from; happening (for example inlining, basic block reordering/merging/cleanup,; tail duplication, etc). * LLVM debug information is automatically optimized along with the rest of; the program, using existing facilities. For example, duplicate; information is automatically merged by the linker, and unused information; is automatically removed. Basically,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:4156,avoid,avoid,4156,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"nforces that variables or fields related with the same; external bounds annotation (e.g., ``buf`` and ``count`` related with; ``__counted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Insid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6027,safe,safety,6027,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['safe'],['safety']
Safety,"ng an issues for a bug, add enough description to reproduce the issue - at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md). Authors; -------. CivetWeb has been forked from the last MIT version of Mongoose in 2013.; Since then, CivetWeb has seen many improvements from various authors; (Copyright (c) 2013-2021 the CivetWeb developers, MIT license). A list of authors can be found in [CREDITS.md](https://github.com/civetweb/civetweb/blob/master/CREDITS.md). CivetWeb is based on the Mongoose project. The original author of Mongoose was; Sergey Lyubka (Copyright (c) 2004-2013 Sergey Lyubka, MIT license).; However, on August 16, 2013, the [license of Mongoose has been changed](https://groups.google.com/forum/#!topic/mongoose-users/aafbOnHonkI); after writing and distributing the original code this project is based on.; The license change and CivetWeb used to be mentioned on the Mongoose; [Wikipedia](https://en.wikipedia.org/wiki/Mongoose_(web_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:9728,safe,safely,9728,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['safe'],['safely']
Safety,"ng any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-swee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1178,unsafe,unsafe,1178,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"ng around `RVec` objects. `RVecN<T, N>`; It aggregates `RVecImpl` and `SmallVectorStorage` (see below) through public inheritance.; `N` is the small buffer size. `RVec<T>`; Inherits from `RVecN` and fixes the small buffer size `N` to a reasonable default.; We expect most users to use this type and only very rarely switch to `RVecN` to tweak the small buffer size. ### Helper types. - `SmallVectorAlignmentAndSize`: used to figure out the offset of the first small-buffer element in; `SmallVectorTemplateCommon::getFirstEl`; - `SmallVectorStorage`: properly aligned ""small buffer"" storage. It's a separate type so that it can be specialized to; be properly aligned also for the case of small buffer size = 0; - `RVecInlineStorageSize`: calculates the size of the small buffer in `RVec`. ## Memory adoption. We need RVec to be able to act as a view over an existing buffer rather than use its own; to save copies and allocations when reading ROOT data into `RVec`s, e.g. in `RDataFrame`. The feature is exposed via a dedicated constructor: `RVec(pointer, size)`.; `RVec` then switches to its own storage as soon as a resize is requested.; `fCapacity == -1` indicates that we are in ""memory adoption mode"". ## Exception safety guarantees. As per [its docs](https://llvm.org/doxygen/classllvm_1_1SmallVector.html), LLVM's; `SmallVector` implementation ""does not attempt to be exception-safe"".; In its current implementation, `RVec` does not attempt to fix that.; This should not be a problem for `RVec`'s usecases (an exception thrown during; construction of an `RVec` typically means there is a bug to fix in the analysis code),; and we expect to be able to revisit the implementation and fix broken behavior if it; ever turns out to be problematic. Relevant discussion on GitHub:. - https://github.com/root-project/root/pull/7502#issuecomment-818864506; - https://github.com/root-project/root/pull/7502#issuecomment-818905333; - https://github.com/root-project/root/pull/7502#issuecomment-821054757. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md:4498,safe,safety,4498,math/vecops/ARCHITECTURE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md,2,['safe'],"['safe', 'safety']"
Safety,"ng bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2317,safe,safety,2317,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"ng constant-term precalculation optimization in roofit likelihoods as these are now; also stored in vectors rather than trees. The faster access speed of vectors make that the constant; term optimization inside likelihoods results in a larger speed increase. This is particulatly noticeable in pdfs with; many constant expressions from pdfs that were moderately fast to begin with (e.g. RooHistPdf).; The second advantages allows new types of algorithmic likelihood optimization in RooFit detailed below. New algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2207,avoid,avoid,2207,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['avoid'],['avoid']
Safety,"ng for filled area for the Cocoa backend. Default is `no`.; - The ""BOX"" option, to draw 3D histograms, has been reimplemented by Evgueni Tcherniaev; The following picture show the old and new version. ![New box option for 3D histograms](NewBoxOption.png). - Implement options ""BOX1"", ""BOX2"" and ""BOX3"" for TH3 equivalent of ""LEGO1"", ""LEGO2"" and ""LEGO3""for TH2.; - When a 2d histogram was drawn with option `LEGO1` and white colored, the dark side; of the lego was red instead of gray.; - New option ""0"" to draw TH2Poly. When used with any `COL` options, the empty; bins are not drawn.; - Fix a long pending problem with Z axis drawing when a lego or a surface was drawn; upside-down.; - Add a protection in TLatex when a string has a syntax error. It was reported; [here](https://sft.its.cern.ch/jira/browse/ROOT-7424).; - Implement the automatic placement of the Y axis title. If the title offset is; set to 0:; ~~~ {.cpp}; h->GetYaxis()->SetTitleOffset(0.);; ~~~; the axis title is automatically placed to avoid overlaps with the axis labels.; - Implement the automatic placement of the `TLegend`. A new constructor not; specifying the legend position is available. Only width and height are defined.; - `ChangeLabel` is now available for log axis as well as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8537).; - The `TGraph` copy constructor also copy the underlying `TH1F` if it exists (it; holds the axis titles).; - `TGraph` axis range was computed differently depending on the order of SetLog[x|y]""; This issue was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8751); - Add the new markers suggested [here](https://root-forum.cern.ch/t/adding-custom-markers/24506).; Improve the marker style for the OpenGl backend (some where wrong or missing). ![New markers](NewMarkers.png). - Remove a large memory leak in TFITSHDU's GetArrayRow, GetArrayColumn and GetTabRealVectorColumn member functions.; - When `TGraph`s belonging to a `TMultiGraph` were changed (for instance w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:13058,avoid,avoid,13058,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoid']
Safety,"ng frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a large register set before and after the; call in the caller. If the arguments are passed in callee-saved registers,; then they will be preserved by the callee across the call. This doesn't; apply for values returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11 and return registers, if any. R11 can be used as a scratch register.; The treatment of floating-point registers (XMMs/YMMs) matches the OS's C; calling convention: on most platforms, they are not preserved and need to; be saved by the caller, but on Windows, xmm6-xmm15 are preserved. - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. The idea behind this convention is to support calls to runtime functions; that have a hot path and a cold path. The hot path is usually a small piece; of code that doesn't use many registers. The cold path might need to call out to; another function and therefore only needs to preserve the caller-saved",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:16539,recover,recovering,16539,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recovering']
Safety,"ng the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by TGeoNavigator; are interfaced by TGeoManager and will act on the current; navigator. \anchor GP02b; ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ~~~{.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ~~~. Initializing this point can be don",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:63748,safe,safety,63748,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ng to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM IR bitcode. * **Compiler backend**: This converts the intermediate representation; into target-specific assembly code.; The ``-S`` flag instructs Clang to stop after this step. * **Assembler**: This converts target-specific assembly code into; target-specific machine code object files.; The ``-c`` flag instructs Clang to stop after this step. * **Linker**: This combines multiple object files into a single image; (either a shared object or an executable). Clang provides all of these pieces other than the linker. When multiple; steps are performed by the same tool, it is common for the steps to be; fused together to avoid creating intermediate files. When given an output of one of the above steps as an input, earlier steps; are skipped (for instance, a ``.s`` file input will be assembled and linked). The Clang driver can be invoked with the ``-###`` flag (this argument will need; to be escaped under most shells) to see which commands it would run for the; above steps, without running them. The ``-v`` (verbose) flag will print the; commands in addition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:2696,avoid,avoid,2696,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['avoid'],['avoid']
Safety,"ng type of pass is the ""`ImmutablePass; <https://llvm.org/doxygen/classllvm_1_1ImmutablePass.html>`_"" class. This pass; type is used for passes that do not have to be run, do not change state, and; never need to be updated. This is not a normal type of transformation or; analysis, but can provide information about the current compiler configuration. Although this pass class is very infrequently used, it is important for; providing information about the current target machine being compiled for, and; other static information that can affect the various transformations. ``ImmutablePass``\ es never invalidate other transformations, are never; invalidated, and are never ""run"". .. _writing-an-llvm-pass-ModulePass:. The ``ModulePass`` class; ------------------------. The `ModulePass <https://llvm.org/doxygen/classllvm_1_1ModulePass.html>`_ class; is the most general of all superclasses that you can use. Deriving from; ``ModulePass`` indicates that your pass uses the entire program as a unit,; referring to function bodies in no predictable order, or adding and removing; functions. Because nothing is known about the behavior of ``ModulePass``; subclasses, no optimization can be done for their execution. A module pass can use function level passes (e.g. dominators) using the; ``getAnalysis`` interface ``getAnalysis<DominatorTree>(llvm::Function *)`` to; provide the function to retrieve analysis result for, if the function pass does; not require any module or immutable passes. Note that this can only be done; for functions for which the analysis ran, e.g. in the case of dominators you; should only ask for the ``DominatorTree`` for function definitions, not; declarations. To write a correct ``ModulePass`` subclass, derive from ``ModulePass`` and; override the ``runOnModule`` method with the following signature:. The ``runOnModule`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnModule(Module &M) = 0;. The ``runOnModule`` method performs the interest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:12975,predict,predictable,12975,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['predict'],['predictable']
Safety,"ng++ -O2 -fprofile-instr-generate -fprofile-list=fun.list code.cc -o code. The option can be specified multiple times to pass multiple files. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fcoverage-mapping -fprofile-list=fun.list -fprofile-list=code.list code.cc -o code. Supported sections are ``[clang]``, ``[llvm]``, and ``[csllvm]`` representing; clang PGO, IRPGO, and CSIRPGO, respectively. Supported prefixes are ``function``; and ``source``. Supported categories are ``allow``, ``skip``, and ``forbid``.; ``skip`` adds the ``skipprofile`` attribute while ``forbid`` adds the; ``noprofile`` attribute to the appropriate function. Use; ``default:<allow|skip|forbid>`` to specify the default category. .. code-block:: console. $ cat fun.list; # The following cases are for clang instrumentation.; [clang]. # We might not want to profile functions that are inlined in many places.; function:inlinedLots=skip. # We want to forbid profiling where it might be dangerous.; source:lib/unsafe/*.cc=forbid. # Otherwise we allow profiling.; default:allow. Older Prefixes; """"""""""""""""""""""""""""; An older format is also supported, but it is only able to add the; ``noprofile`` attribute.; To filter individual functions or entire source files use ``fun:<name>`` or; ``src:<file>`` respectively. To exclude a function or a source file, use; ``!fun:<name>`` or ``!src:<file>`` respectively. The format also supports; wildcard expansion. The compiler generated functions are assumed to be located; in the main source file. It is also possible to restrict the filter to a; particular instrumentation type by using a named section. .. code-block:: none. # all functions whose name starts with foo will be instrumented.; fun:foo*. # except for foo1 which will be excluded from instrumentation.; !fun:foo1. # every function in path/to/foo.cc will be instrumented.; src:path/to/foo.cc. # bar will be instrumented only when using backend instrumentation.; # Recognized section names are clang, llvm and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:117525,unsafe,unsafe,117525,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe']
Safety,"ng.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4198,safe,safety,4198,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['safe'],['safety']
Safety,"ng/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is required. See full example; in `Compiler Explorer <https://godbolt.org/z/5WbnTfb65>`_. More OpenCL specific C++",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23611,avoid,avoid,23611,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,2,"['avoid', 'unsafe']","['avoid', 'unsafe']"
Safety,"ngRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:21990,avoid,avoids,21990,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoids']
Safety,"ngRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23855,abort,abort,23855,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"nity in `RooNumber::infinity()`, which was `1e30` before. Now, it is defined as `std::numeric_limits<double>::infinity()`, to be consistent with the C++ standard library and other code. This change also affects the `RooNumber::isInfinite()` function. ### Remove `add(row, weight, weightError)` from RooAbsData interface. It was not good to have this signature in RooAbsData, because the; implementations in the two derived classes RooDataHist and RooDataSet were; inconsistent. The RooDataSet indeed took the weight error as the third argument, but; the RooDataHist version instead took the sum of weights squared, which; is equivalent to the squared weight error. Therefore, the virtual `RooAbsData::add(row, weight, weightError)` function was removed. ### Removal of `RooMomentMorphND` class. The `RooMomentMorphND` and `RooMomentMorphFuncND` were almost exactly the same,; only that one inherited from `RooAbsPdf` and the other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; RooMomentMorphFuncND func{<constructor args you previously passed to RooMomentMorphFunc>};. func.setPdfMode(); // change behavior to be exactly like the former RooMomentMorphND. // Pass the selfNormalized=true` flag to the wrapper because the; RooMomentMorphFuncND already normalizes itself in pdf mode.; RooWrapperPdf pdf{""pdf_name"", ""pdf_name"", func, /*selfNormalized=*/true};; ```. ### Removal of several internal classes from the public RooFit interface. Several RooFit classes of which the headers are publicly exposed in the interface were only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an impleme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:14055,avoid,avoided,14055,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['avoid'],['avoided']
Safety,"nk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android ver",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4596,predict,predictable,4596,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['predict'],['predictable']
Safety,"nkContext`` object to perform a (potentially high-latency); asynchronous operation: allocating memory, resolving external symbols, and; finally transferring linked memory to the executing process. #. Phase 1. This phase is called immediately by the ``link`` function as soon as the; initial configuration (including the pass pipeline setup) is complete. #. Run pre-prune passes. These passes are called on the graph before it is pruned. At this stage; ``LinkGraph`` nodes still have their original vmaddrs. A mark-live pass; (supplied by the ``JITLinkContext``) will be run at the end of this; sequence to mark the initial set of live symbols. Notable use cases: marking nodes live, accessing/copying graph data that; will be pruned (e.g. metadata that's important for the JIT, but not needed; for the link process). #. Prune (dead-strip) the ``LinkGraph``. Removes all symbols and blocks not reachable from the initial set of live; symbols. This allows JITLink to remove unreachable symbols / content, including; overridden weak and redundant ODR definitions. #. Run post-prune passes. These passes are run on the graph after dead-stripping, but before memory; is allocated or nodes assigned their final target vmaddrs. Passes run at this stage benefit from pruning, as dead functions and data; have been stripped from the graph. However new content can still be added; to the graph, as target and working memory have not been allocated yet. Notable use cases: Building Global Offset Table (GOT), Procedure Linkage; Table (PLT), and Thread Local Variable (TLV) entries. #. Asynchronously allocate memory. Calls the ``JITLinkContext``'s ``JITLinkMemoryManager`` to allocate both; working and target memory for the graph. As part of this process the; ``JITLinkMemoryManager`` will update the addresses of all nodes; defined in the graph to their assigned target address. Note: This step only updates the addresses of nodes defined in this graph.; External symbols will still have null addresses. #. Pha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:18676,redund,redundant,18676,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['redund'],['redundant']
Safety,"nknown identifier, the; implementation searches in the database if this is a known entity. Line #1 does not require a definition and the forward declaration consumed at; startup is sufficient. Parsing of `Foo.h` is not required. This comes at a cost; of having some non-trivial patches in clang to merge default function arguments; and default template arguments. The design of the ROOTMAP infrastructure; requires the default arguments to be attached to more than one declaration which; is not allowed by standard C++. The behavior of line #1 is equivalent to:; ```cpp; // ROOT prompt; root [] namespace foo { };struct S;; root [] S *s;; ```. Line #2 does not require a definition, however, the second identifier lookup; fails. The implementation knows that `foo::bar` is in *libFoo*. It `dlopen`s; libFoo which in turn, during its static initialization, inserts annotated forward; declaration as shown in `G__Foo.cxx`. In turn, this resolves `foo::bar` and; parsing of `Foo.h` is again avoided at relatively small overhead. However, this; is very hard to measure because the dictionary of each library can have different; amount of content. In the case where the library is big and the annotated; forward declarations are many, and we want to include a relatively small header; file it may not pay off. Moreover, the loading of the annotated forward; declarations can happen at any time during parsing. This is nick-named; ""recursive parsing"" and is a code path that exists only in ROOT, never exercised; by clang itself and is thus not well tested. The behavior of line #2 is; equivalent to:; ```cpp; // ROOT prompt; root [] namespace foo { };struct S;; root [] foo::bar/*store parsing state*/; gSystem->Load(""Foo"");; // More scaffolding.; extern int __Cling_AutoLoading_Map;; namespace foo{struct __attribute__((annotate(""$clingAutoload$Foo.h""))) bar;}; struct __attribute__((annotate(""$clingAutoload$Foo.h""))) S;; // More initialization scaffolding.; /*restore parsing state*/ *baz1;; ```. Line #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:9060,avoid,avoided,9060,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoided']
Safety,"nly``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-na",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59250,unsafe,unsafe,59250,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe']
Safety,"nning pass (2) SROA on function (g); BISECT: running pass (3) Early CSE on function (g); BISECT: running pass (4) Infer set function attributes on module (test.ll); BISECT: running pass (5) Interprocedural Sparse Conditional Constant Propagation on module (test.ll); BISECT: running pass (6) Global Variable Optimizer on module (test.ll); BISECT: running pass (7) Promote Memory to Register on function (g); BISECT: running pass (8) Dead Argument Elimination on module (test.ll); BISECT: running pass (9) Combine redundant instructions on function (g); BISECT: running pass (10) Simplify the CFG on function (g); BISECT: running pass (11) Remove unused exception handling info on SCC (<<null function>>); BISECT: running pass (12) Function Integration/Inlining on SCC (<<null function>>); BISECT: running pass (13) Deduce function attributes on SCC (<<null function>>); BISECT: running pass (14) Remove unused exception handling info on SCC (f); BISECT: running pass (15) Function Integration/Inlining on SCC (f); BISECT: running pass (16) Deduce function attributes on SCC (f); BISECT: NOT running pass (17) Remove unused exception handling info on SCC (g); BISECT: NOT running pass (18) Function Integration/Inlining on SCC (g); BISECT: NOT running pass (19) Deduce function attributes on SCC (g); BISECT: NOT running pass (20) SROA on function (g); BISECT: NOT running pass (21) Early CSE on function (g); BISECT: NOT running pass (22) Speculatively execute instructions if target has divergent branches on function (g); ... etc. ... Pass Skipping Implementation; ============================. The -opt-bisect-limit implementation depends on individual passes opting in to; the opt-bisect process. The OptBisect object that manages the process is; entirely passive and has no knowledge of how any pass is implemented. When a; pass is run if the pass may be skipped, it should call the OptBisect object to; see if it should be skipped. The OptBisect object is intended to be accessed through LLVMCo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:5782,redund,redundant,5782,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['redund'],['redundant']
Safety,"nnotation to parameter ``ptr``, indicating that the pointer; has ``N`` valid elements:. .. code-block:: c. void foo(int *__counted_by(N) ptr, size_t N);. Using this bounds information, the compiler inserts bounds checks on every; pointer dereference, ensuring that the program does not access memory outside; the specified bounds. The compiler requires programmers to provide enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This doc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:1597,safe,safety,1597,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"nnotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the default annotation for; ABI-visible pointers to be either ``__single``, ``__bidi_indexable``,; ``__indexable``, or ``__unsafe_indexable``. For instance,; ``__ptrcheck_abi_assume_unsafe_indexable()`` will make all ABI-visible pointers; be ``__unsafe_indexable``. Non-ABI visible pointers — the outermost pointer; types of local variables — are ``__bidi_indexable`` by default, so that these; pointers have the bounds information necessary to perform bounds checks without; the need for a manual annotation. All ``const char`` pointers or any typedefs; equivalent to ``const char`` pointers are ``__null_terminated`` by default. This; means that ``char8_t`` is ``unsigned char`` so ``const char8_t *`` won't be; ``__null_terminated`` by default. Similarly, ``const wchar_t *`` won't be; ``__null_terminated`` by default unless the platform defines it as ``typedef; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:21323,safe,safe,21323,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safe']
Safety,"non-ARC; modes. A property's specified ownership is preserved in its metadata, but otherwise; the meaning is purely conventional unless the property is synthesized. If a; property is synthesized, then the :arc-term:`associated instance variable` is; the instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:36072,safe,safe,36072,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safe']
Safety,"nown to be the backing storage for a variable is considered to represent an; assignment to that variable. This gives us a safe fall-back in cases where `llvm.dbg.assign` intrinsics have; been deleted, the `DIAssignID` attachment on the store has been dropped, or the; optimiser has made a once-indirect store (not tracked with Assignment Tracking); direct. ### Middle-end: Considerations for pass-writers. #### Non-debug instruction updates. **Cloning** an instruction: nothing new to do. Cloning automatically clones a; `DIAssignID` attachment. Multiple instructions may have the same `DIAssignID`; instruction. In this case, the assignment is considered to take place in; multiple positions in the program. **Moving** a non-debug instruction: nothing new to do. Instructions linked to an; `llvm.dbg.assign` have their initial IR position marked by the position of the; `llvm.dbg.assign`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `DIAssignID`; attachment. An `llvm.dbg.assign` that uses a `DIAssignID` that is not attached; to any instruction indicates that the memory location isn’t valid. **Merging** stores: In many cases no change is required as `DIAssignID`; attachments are automatically merged if `combineMetadata` is called. One way or; another, the `DIAssignID` attachments must be merged such that new store; becomes linked to all the `llvm.dbg.assign` intrinsics that the merged stores; were linked to. This can be achieved simply by calling a helper function; `Instruction::mergeDIAssignID`. **Inlining** stores: As stores are inlined we generate `llvm.dbg.assign`; intrinsics and `DIAssignID` attachments as if the stores represent source; assignments, just like the in frontend. This isn’t perfect, as stores may have; been moved, modified or deleted before inlining, but it does at least keep the; information about the variable correct within the non-inlined scope. **Splitting** store",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:6295,safe,safe,6295,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['safe'],['safe']
Safety,"nsafe_indexable`` because it doesn't; have any invariant to maintain. * ``__single`` casts to ``__bidi_indexable`` if the pointee type has a known; size. After the conversion, the resulting ``__bidi_indexable`` has the size of; a single object of the pointee type of ``__single``. ``__single`` cannot cast; to ``__bidi_indexable`` if the pointee type is incomplete or sizeless. For; example, ``void *__single`` cannot convert to ``void *__bidi_indexable``; because void is an incomplete type and thus the compiler cannot correctly; determine the upper bound of a single void pointer. * Similarly, ``__single`` can cast to ``__indexable`` if the pointee type has a; known size. The resulting ``__indexable`` has the size of a single object of; the pointee type. * ``__single`` casts to ``__counted_by(E)`` only if ``E`` is 0 or 1. * ``__single`` can cast to ``__single`` including when they have different; pointee types as long as it is allowed in the underlying C standard.; ``-fbounds-safety`` doesn't guarantee type safety. * ``__bidi_indexable`` and ``__indexable`` can cast to ``__single``. The; compiler may insert run-time checks to ensure the pointer has at least a; single element or is a null pointer. * ``__bidi_indexable`` casts to ``__indexable`` if the pointer does not have an; underflow. The compiler may insert run-time checks to ensure the pointer is; not below the lower bound. * ``__indexable`` casts to ``__bidi_indexable``. The resulting; ``__bidi_indexable`` gets the lower bound same as the pointer value. * A type conversion may involve both a bitcast and a bounds annotation cast. For; example, casting from ``int *__bidi_indexable`` to ``char *__single`` involve; a bitcast (``int *`` to ``char *``) and a bounds annotation cast; (``__bidi_indexable`` to ``__single``). In this case, the compiler performs; the bitcast and then converts the bounds annotation. This means, ``int; *__bidi_indexable`` will be converted to ``char *__bidi_indexable`` and then; to ``char *__sin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:43036,safe,safety,43036,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['safe'],['safety']
Safety,"nstance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the; deserialization and serialization. The (de-)serialization is a mapping from the C++ type to the more simple **column** type system. A column contains; an arbitrary number of fixed-sized elements of a well-defined se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1278,safe,safety,1278,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['safe'],['safety']
Safety,"nstant. For example, the user could use the tool to remove `example_flag` from this; code:. ```c++; DEFINE_FLAG(std::string, example_flag, """", ""A sample flag."");. void Example() {; bool x = GetFlag(FLAGS_example_flag).empty();; f();; if (x) {; g();; } else {; h();; }; }; ```. The tool would simplify the code to:. ```c++; void Example() {; f();; g();; }; ```. We can solve this problem with a classic constant propagation lattice combined; with symbolic evaluation. ## Example: finding inefficient usages of associative containers. Real-world code often accidentally performs repeated lookups in associative; containers:. ```c++; map<int, Employee> xs;; xs[42]->name = ""..."";; xs[42]->title = ""..."";; ```. To find the above inefficiency we can use the available expressions analysis to; understand that `m[42]` is evaluated twice. ```c++; map<int, Employee> xs;; Employee &e = xs[42];; e->name = ""..."";; e->title = ""..."";; ```. We can also track the `m.contains()` check in the flow condition to find; redundant checks, like in the example below. ```c++; std::map<int, Employee> xs;; if (!xs.contains(42)) {; xs.insert({42, someEmployee});; }; ```. ## Example: refactoring types that implicitly convert to each other. Refactoring one strong type to another is difficult, but the compiler can help:; once you refactor one reference to the type, the compiler will flag other places; where this information flows with type mismatch errors. Unfortunately this; strategy does not work when you are refactoring types that implicitly convert to; each other, for example, replacing `int32_t` with `int64_t`. Imagine that we want to change user IDs from 32 to 64-bit integers. In other; words, we need to find all integers tainted with user IDs. We can use data flow; analysis to implement taint analysis. ```c++; void UseUser(int32_t user_id) {; int32_t id = user_id;; // Variable `id` is tainted with a user ID.; ...; }; ```. Taint analysis is very well suited to this problem because the program rarely; br",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:29293,redund,redundant,29293,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['redund'],['redundant']
Safety,"nsw`` keywords are present, the; result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = mul i32 4, %var ; yields i32:result = 4 * %var. .. _i_fmul:. '``fmul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fmul [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fmul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fmul``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point product of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fmul float 4.0, %var ; yields float:result = 4.0 * %var. .. _i_udiv:. '``udiv``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = udiv <ty> <op1>, <op2> ; yields ty:result; <result> = udiv exact <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``udiv``' instruction returns the quotient of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``udiv``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the unsigned integer quotient of the two operands. Note that unsigned integer division and signed integer division are; distinct operations; for signed integer division, use '``sdiv``'. Division by zero is undefined behavior. For vectors, if any element; of the divisor is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:384275,unsafe,unsafe,384275,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"nt TGLCameraOverlay that allows to; display: a) coordinate axes for orthographic mode; b) intersection of; center of screen with a given plane. Add suport for fading in/out of the viewer contents. Many improvements in text and axis rendering for orthographic; view markup. In TGLSceneBase add data-member Bool_t; fSelectable allowing one to preventing any of its elements to be; selected. Useful when given scene is used as background to help guid; the eye. Eve. Added support for internal window management. Windows can be; arranged in horizontal/vertical stacks, tabs and main windows.; The containers and individaul windows can be moved to arbitrary; window-slot. See classes TEveWindow and TEveWindowManager. See tutorial tutorials/eve/test_windows.C. TEveQuadSet -- Add flag 'Bool_t fAntiFlick'. If on (now the; default) it causes each quad to be also rendered as a pixel, thus; preventing it from disappearing when zoomed away. This is needed for visualization of small quads, e.g. silicon; detectors digits. TEveCalo classes -- Add support for automatic rebinning; of 3D views (only supported for 2D views before). In 2D mode support; automatic determination of the cell color based on the most energetic; contribution from available calo slices. Add support for enumerative registration of calorimeter towers. Before; one had to provide THStack as input. See TEveCaloDataVec; class. TEveTrackList -- Generalized API for finding of momentum; limits. TEveTrackPropagator now supports propagation of charged; particles in arbitrary / external magnetic field. Propagation can be; done with the helix-stepper or with the Runge-Kutta method. New abstract interface to magnetic field TEveMagField to get; field vector at given position. Implement two interfaces:; TEveMagFieldConst for constant magnetic field and; TEveMagFieldDuo (two constant magnetic fields, chosen by; cylindrical radius). See examples in tutorials/eve/track.C. TEvePointSetArray -- Added underflow and overflow bins. Many improv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html:1213,detect,detectors,1213,graf3d/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html,1,['detect'],['detectors']
Safety,"nt along a straight line.; The starting point and direction for this procedure are the ones; corresponding to the current state. The boundary search is initialized; inside the current volume and the crossed boundary can belong either to; the current node or to one of its daughters. The full prototype of the; method is:. ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; ~~~. In the prototype above, besides the current point and direction that are; supposed already initialized, the only input parameter is `step`. This; represents the maximum step allowed by the tracking algorithm or the; `physical step`. The modeller will search for a boundary crossing only; up to a distance equal to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ~~~{.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig ` (default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag telli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:77219,safe,safety,77219,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"nt checks everywhere) and it can dramatically reduce the amount of; LLVM IR that is generated in some cases (particular for languages with a; macro preprocessor or that use a lot of constants). On the other hand, the ``IRBuilder`` is limited by the fact that it does; all of its analysis inline with the code as it is built. If you take a; slightly more complex example:. ::. ready> def test(x) (1+2+x)*(x+(1+2));; ready> Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 3.000000e+00, %x; %addtmp1 = fadd double %x, 3.000000e+00; %multmp = fmul double %addtmp, %addtmp1; ret double %multmp; }. In this case, the LHS and RHS of the multiplication are the same value.; We'd really like to see this generate ""``tmp = x+3; result = tmp*tmp;``""; instead of computing ""``x+3``"" twice. Unfortunately, no amount of local analysis will be able to detect and; correct this. This requires two transformations: reassociation of; expressions (to make the add's lexically identical) and Common; Subexpression Elimination (CSE) to delete the redundant add instruction.; Fortunately, LLVM provides a broad range of optimizations that you can; use, in the form of ""passes"". LLVM Optimization Passes; ========================. LLVM provides many optimization passes, which do many different sorts of; things and have different tradeoffs. Unlike other systems, LLVM doesn't; hold to the mistaken notion that one set of optimizations is right for; all languages and for all situations. LLVM allows a compiler implementor; to make complete decisions about what optimizations to use, in which; order, and in what situation. As a concrete example, LLVM supports both ""whole module"" passes, which; look across as large of body of code as they can (often a whole file,; but if run at link time, this can be a substantial portion of the whole; program). It also supports and includes ""per-function"" passes which just; operate on a single function at a time, without looking at other; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:3154,redund,redundant,3154,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['redund'],['redundant']
Safety,"nt in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds annotation defines an invariant for the pointer type, and the model; ensures that this invariant remains true. In the example below, pointer ``p``; annotated with ``__counted_by(count)`` must always point to a memory buffer; containing at least ``count`` elements of the pointee type. Changing the value; of ``count``, like in the example below, may violate this invariant and permit; out-of-bounds access to the pointer. To avoid this, the compiler employs; compile-time restrictions and emits run-time checks as necessary to ensure the; new count value doesn't exceed the actual length of the buffer. Section; `Maintaining correctness of bounds annotations`_ provides more details about; this programming model. .. code-block:: c. int g;. void foo(int *__counted_by(count) p, size_t count) {; count++; // may violate the invariant of __counted_by; count--; // may violate the invariant of __counted_by if count was 0.; count = g; // may violate the invariant of __counted_by; // depending on the value of `g`.; }. The requirement to annotate all pointers with explicit bounds information could; present a significant adoption burden. To tackle this issue, the model; incorporates the concept of a ""wide pointer"" (a.k.a. fat pointer) – a larger; pointer that carries bounds information alongside the pointer value. Utilizing; wide pointers can potentially reduce the adoption burden, as it contains bounds; information internally and eliminates the need for explicit bounds annotations.; However, wide pointers ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:4409,avoid,avoid,4409,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"ntact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13911,detect,detect,13911,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['detect'],['detect']
Safety,"nter otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10633,unsafe,unsafe,10633,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['unsafe'],['unsafe']
Safety,"nter, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicitly be ``FILE; *__unsafe_indexable`` and thus it cannot be directly assigned to ``FILE *fp``; in the bounds-safe source. To allow this operation, ``__unsafe_forge_single``; is used to create a ``__single`` from the return value of ``fopen``. * Similar to ``__unsafe_indexable``, any non-pointer type (including ``int``,; ``intptr_t``, ``uintptr_t``, etc.) cannot be converted to any safe pointer; type because these don't have bounds information. ``__unsafe_forge_single`` or; ``__unsafe_forge_bidi_indexable`` must be used to force the conversion. * Any safe pointer types can cast to ``__unsafe_indexable`` because it doesn't; have any invariant to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:41106,safe,safety,41106,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"ntics). It should simplify building the CFG and my guess is it; > could enable some significant optimizations, though we should think; > about which. Great. I added a note to the switch section commenting on how the VM; should just use the instruction type as a hint, and that the; implementation may choose altermate representations (such as predicated; branches). > In the lookup-indirect form of the switch, is there a reason not to; > make the val-type uint?. No. This was something I was debating for a while, and didn't really feel; strongly about either way. It is common to switch on other types in HLL's; (for example signed int's are particularly common), but in this case, all; that will be added is an additional 'cast' instruction. I removed that; from the spec. > I agree with your comment that we don't need 'neg'. Removed. > There's a trade-off with the cast instruction:; > + it avoids having to define all the upcasts and downcasts that are; > valid for the operands of each instruction (you probably have; > thought of other benefits also); > - it could make the bytecode significantly larger because there could; > be a lot of cast operations. + You NEED casts to represent things like:; void foo(float);; ...; int x;; ...; foo(x);; in a language like C. Even in a Java like language, you need upcasts; and some way to implement dynamic downcasts.; + Not all forms of instructions take every type (for example you can't; shift by a floating point number of bits), thus SOME programs will need; implicit casts. To be efficient and to avoid your '-' point above, we just have to be; careful to specify that the instructions shall operate on all common; types, therefore casting should be relatively uncommon. For example all; of the arithmetic operations work on almost all data types. > Making the second arg. to 'shl' a ubyte seems good enough to me.; > 255 positions seems adequate for several generations of machines. Okay, that comment is removed. > and is more compact than uin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:2411,avoid,avoids,2411,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['avoid'],['avoids']
Safety,"ntrinsic defining a variable; location. This *could* be converted to an SSA form by mem2reg, in the same way; that it uses use-def chains to identify control flow merges and insert phi; nodes for IR Values. However, because debug variable locations are defined for; every machine instruction, in effect every IR instruction uses every variable; location, which would lead to a large number of debugging intrinsics being; generated. Examining the example above, variable ``!30`` is assigned ``%input`` on both; conditional paths through the function, while ``!23`` is assigned differing; constant values on either path. Where control flow merges in ``%bb1`` we would; want ``!30`` to keep its location (``%input``), but ``!23`` to become undefined; as we cannot determine at runtime what value it should have in %bb1 without; inserting a PHI node. mem2reg does not insert the PHI node to avoid changing; codegen when debugging is enabled, and does not insert the other dbg.values; to avoid adding very large numbers of intrinsics. Instead, LiveDebugValues determines variable locations when control; flow merges. A dataflow analysis is used to propagate locations between blocks:; when control flow merges, if a variable has the same location in all; predecessors then that location is propagated into the successor. If the; predecessor locations disagree, the location becomes undefined. Once LiveDebugValues has run, every block should have all valid variable; locations described by DBG_VALUE instructions within the block. Very little; effort is then required by supporting classes (such as; DbgEntityHistoryCalculator) to build a map of each instruction to every; valid variable location, without the need to consider control flow. From; the example above, it is otherwise difficult to determine that the location; of variable ``!30`` should flow ""up"" into block ``%bb1``, but that the location; of variable ``!23`` should not flow ""down"" into the ``%exit`` block. .. _ccxx_frontend:. C/C++ front-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:39325,avoid,avoid,39325,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"ntrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.cttz`` on any; integer bit width, or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i42 @llvm.cttz.i42 (i42 <src>, i1 <is_zero_poison>); declare <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>). Overview:; """""""""""""""""". The '``llvm.cttz``' family of intrinsic functions counts the number of; trailing zeros. Arguments:; """""""""""""""""""". The first argument is the value to be counted. This argument may be of; any integer type, or a vector with integer element type. The return; type must match the first argument type. The second argument is a constant flag that indicates whether the intrinsic; returns a valid result if the first argument is zero. If the first; argument is zero and the second argument is true, the result is poison.; Historically some architectures did not provide a defined result for zero; values as efficiently, and many algorithms are now predicated on avoiding; zero-value inputs. Semantics:; """""""""""""""""""". The '``llvm.cttz``' intrinsic counts the trailing (least significant); zeros in a variable, or within each element of a vector. If ``src == 0``; then the result is the size in bits of the type of ``src`` if; ``is_zero_poison == 0`` and ``poison`` otherwise. For example,; ``llvm.cttz(2) = 1``. .. _int_overflow:. .. _int_fshl:. '``llvm.fshl.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.fshl`` on any; integer bit width or any vector of integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i8 @llvm.fshl.i8 (i8 %a, i8 %b, i8 %c); declare i64 @llvm.fshl.i64(i64 %a, i64 %b, i64 %c); declare <2 x i32> @llvm.fshl.v2i32(<2 x i32> %a, <2 x i32> %b, <2 x i32> %c). Overview:; """""""""""""""""". The '``llvm.fshl``' family of intrinsic functions performs a funnel shift left:; the first two v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:595964,avoid,avoiding,595964,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoiding']
Safety,"ntrol specific attributes of the target, such as whether SIMD; operations are enabled or not. The default set of attributes is set by the; current CPU. For a list of available attributes, use:. .. code-block:: none. llvm-as < /dev/null | llc -march=xyz -mattr=help. .. option:: --frame-pointer. Specify effect of frame pointer elimination optimization (all,non-leaf,none). .. option:: --disable-excess-fp-precision. Disable optimizations that may produce excess precision for floating point.; Note that this option can dramatically slow down code on some systems; (e.g. X86). .. option:: --enable-no-infs-fp-math. Enable optimizations that assume no Inf values. .. option:: --enable-no-nans-fp-math. Enable optimizations that assume no NAN values. .. option:: --enable-no-signed-zeros-fp-math. Enable FP math optimizations that assume the sign of 0 is insignificant. .. option:: --enable-no-trapping-fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which conta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:3817,unsafe,unsafe-fp-math,3817,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['unsafe'],['unsafe-fp-math']
Safety,"ntrol this merging:; ; NoIndex : all the TTreeIndex object are dropped.; DropIndexOnError : if any of the underlying TTree object do no have a TTreeIndex,; they are all dropped.; AsIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; BuildIndexOnError : If any of the underlying TTree object do no have a TTreeIndex,; all TTreeIndex are 'ignored' and the mising piece are rebuilt. Previously the index were kept only if the first files had an index and if there was any missing index,; the resulting index had gaps (the default was similar to AsIsIndexOnError). The new default is BuildIndexOnError ; i.e.; we now attempt by default to build the missing indices. In TBranch CopyAddress (and hence indirectly in the fast cloning); avoid having to read the first entry just to get the address set; and do the address setting directly. In TTree::CopyAddress when copying the addresses of a branch created by a leaflist; and where the memory buffer was allocated automatically (as opposed to set by the user); avoid deleting the memory allocated by the tree each time CopyAddress is called.; (This effectively prevented cloning more than once a TTree with a branch created by a leaflist.). Warning: The TTreeCache is no longer enabled by default in a TChain to align the behavior with a TTree. You need to call; TTree::SetCacheSize to enable the TTreeCache.; Correct and clarify the relationship between AutoFlush and AutoSave:; ; Both the AutoFlush and AutoSave interval can be specified in; terms of bytes (a negative value for fAutoFlush or fAutoSave); or in terms of the number of entries (positive values).; An AutoFlush is always done with an AutoSave.; If the interval specified for AutoSave is less than that for; AutoFlush, the AutoSave interval is used for both.; If the AutoFlush interval is less than the AutoSave interval,; the AutoSave interval is adjusted to the largest integer; multiple of the AutoFlush interval that is less than or equal; to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:2648,avoid,avoid,2648,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['avoid'],['avoid']
Safety,"nu.org/onlinedocs/gcc/C-Extensions.html>`_ for more information on; these extensions. .. _langext-feature_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1505,abort,abort,1505,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['abort'],['abort']
Safety,"nup.; Usually used in the first line, so it is visible without opening the; actual commit email. O; -; .. _object pointer:; .. _object pointers:. **Object Pointer**; A pointer to an object such that the garbage collector is able to trace; references contained within the object. This term is used in opposition to; `derived pointer`_. P; -. **PGO**; Profile-Guided Optimization. **PR**; Problem report. A bug filed on `the LLVM Bug Tracking System; <https://bugs.llvm.org/enter_bug.cgi>`_. **PRE**; Partial Redundancy Elimination. R; -. **RAUW**. Replace All Uses With. The functions ``User::replaceUsesOfWith()``,; ``Value::replaceAllUsesWith()``, and; ``Constant::replaceUsesOfWithOnConstant()`` implement the replacement of one; Value with another by iterating over its def/use chain and fixing up all of; the pointers to point to the new value. See; also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-def-chains>`_. **Reassociation**; Rearranging associative expressions to promote better redundancy elimination; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:6837,redund,redundancy,6837,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['redund'],['redundancy']
Safety,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17340,predict,predict,17340,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['predict'],['predict']
Safety,"nvisible). In order to activate; clipping, one has to first define the clipping shape(s):. 1. `TGeoShape *clip1, *clip2, ...`; One might switch between several clipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`; 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; rootgeom.C example looks clipped with a tube. \image html geometry014.png ""Ray-tracing example with box-clipping"". \anchor GP05; ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; `TGeo` offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. \anchor GP05a; ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In `TGeo`, physical nodes are represented by; the class TGeoPhysic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:106237,detect,detector,106237,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,"o ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25736,avoid,avoided,25736,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['avoid', 'risk']","['avoided', 'risking']"
Safety,"o all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigation algorithms. The problem is that in order to reproduce the; honeycomb structure out of rows of cells, we have to overlap row; containers. Whoops - we have not obeyed rule No. 2 in positioning.; The way out is to position our rows with a special prototype:. ``` {.cpp}; ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; ```. This will instruct the modeller that the daughter ROW inside CAL; overlaps with something else. The modeller will check this at closure; time and build a list of possibly overlapping candidates. This option is; equivalent with the option MANY in GEANT3. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:76433,avoid,avoid,76433,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['avoid'],['avoid']
Safety,"o all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigation algorithms. The problem is that in order to reproduce the; honeycomb structure out of rows of cells, we have to overlap row; containers. Whoops - we have not obeyed rule No. 2 in positioning.; The way out is to position our rows with a special prototype:. ~~~{.cpp}; ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; ~~~. This will instruct the modeller that the daughter ROW inside CAL; overlaps with something else. The modeller will check this at closure; time and build a list of possibly overlapping candidates. This option is; equivalent with the option MANY in GEANT3. The m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:36872,avoid,avoid,36872,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"o be modularized. As part of our ongoing efforts to move; CMSSW to use C++ Modules [[6]] we have implemented a helper tool [[7]]. The; tool detects (based on the include paths of the compiler) dependencies and; tries to generate the relevant vfs file. ## State of the union. Preloading all modules at start up time turn our motivating example into:. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition. ```. becomes equivalent to. ```cpp; // ROOT prompt; root [] import ROOT.*;; root [] import Foo.*;; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. The implementation avoids recursive actions and relies on a well-defined (by; the C++ standard) behavior. Currently, this comes with a constant performance; overhead which we go in details bellow. ROOT uses the global module index (GMI) to avoid the performance overhead. ROOT; only preloads the set of C++ modules which are not present in the GMI. The; example becomes equivalent to:. ```cpp; // ROOT prompt; root [] import Foo.*; // Preload Foo if it is not in the GMI.; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. Line #4 forces cling to send ROOT a callback that TCanvas in unknown but; the GMI resolves it to module Gpad, loads it and returns the control to cling. ### Performance; This section compares ROOT PCH technology with C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:16445,avoid,avoids,16445,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['avoid'],['avoids']
Safety,"o be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #define PT_GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x)). #define ACQUIRED_BEFORE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_before(__VA_ARGS__)). #define ACQUIRED_AFTER(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_after(__VA_ARGS__)). #define REQUIRES(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_capability(__VA_ARGS__)). #define REQUIRES_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_shared_capability(__VA_ARGS__)). #define ACQUIRE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquire_capability(__VA_ARGS__)). #define ACQUIRE_SHARED(...)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:25240,safe,safely,25240,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safely']
Safety,"o be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10401,avoid,avoid,10401,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['avoid'],['avoid']
Safety,"o detect when you're compiling CUDA code specifically with clang. This is tricky, because NVCC may invoke clang as part of its own compilation; process! For example, NVCC uses the host compiler's preprocessor when; compiling for device code, and that host compiler may in fact be clang. When clang is actually compiling CUDA code -- rather than being used as a; subtool of NVCC's -- it defines the ``__CUDA__`` macro. ``__CUDA_ARCH__`` is; defined only in device mode (but will be defined if NVCC is using clang as a; preprocessor). So you can use the following incantations to detect clang CUDA; compilation, in host and device modes:. .. code-block:: c++. #if defined(__clang__) && defined(__CUDA__) && !defined(__CUDA_ARCH__); // clang compiling CUDA code, host mode.; #endif. #if defined(__clang__) && defined(__CUDA__) && defined(__CUDA_ARCH__); // clang compiling CUDA code, device mode.; #endif. Both clang and nvcc define ``__CUDACC__`` during CUDA compilation. You can; detect NVCC specifically by looking for ``__NVCC__``. Dialect Differences Between clang and nvcc; ==========================================. There is no formal CUDA spec, and clang and nvcc speak slightly different; dialects of the language. Below, we describe some of the differences. This section is painful; hopefully you can skip this section and live your life; blissfully unaware. Compilation Models; ------------------. Most of the differences between clang and nvcc stem from the different; compilation models used by clang and nvcc. nvcc uses *split compilation*,; which works roughly as follows:. * Run a preprocessor over the input ``.cu`` file to split it into two source; files: ``H``, containing source code for the host, and ``D``, containing; source code for the device. * For each GPU architecture ``arch`` that we're compiling for, do:. * Compile ``D`` using nvcc proper. The result of this is a ``ptx`` file for; ``P_arch``. * Optionally, invoke ``ptxas``, the PTX assembler, to generate a file,; ``S_a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:8636,detect,detect,8636,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['detect'],['detect']
Safety,"o fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the way results are transferred and merged:. Output objects are added to the same TMessage until a; HWM is reached (default 1MB; controlled by 'ProofServ.MsgSizeHWM');; this limits the number of transfers in the case of large numbers of; small objects.; Reasonably small histograms (GetSize() <; MsgSizeHWM) are merged in one-go at the end instead of one-by-one to; exploit, for example, the better performance of TH1::Merge on the full; list of histos.; Add possibility to compress the messages; this is; controlled by ProofServ.CompressMessage; <compression_level>; The default is still 'no compression' but this will allow to study the; impact of compression. Add sort of 'progress' counter for merging is now shown; on the client:;  ;     root [n] p->Process(...);       ... ;       Mst-0: merging output objects ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full handshake.; In test/stressProof.cxx, avoid interferences between the; settings used for the PROOF tutorial and possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:7528,timeout,timeout,7528,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['timeout'],['timeout']
Safety,"o linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98536,redund,redundant,98536,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['redund'],['redundant']
Safety,"o specify an architecture that is not included in the; universal binary or to use an architecture that does not match a; non-universal binary. .. option:: -format=<FORMAT>. Use the specified output format. The supported formats are: ""text"" (JSON),; ""lcov"". .. option:: -summary-only. Export only summary information for each file in the coverage data. This mode; will not export coverage information for smaller units such as individual; functions or regions. The result will contain the same information as produced; by the :program:`llvm-cov report` command, but presented in JSON or lcov; format rather than text. .. option:: -ignore-filename-regex=<PATTERN>. Skip source code files with file paths that match the given regular expression. .. option:: -skip-expansions. Skip exporting macro expansion coverage data. .. option:: -skip-functions. Skip exporting per-function coverage data. .. option:: -num-threads=N, -j=N. Use N threads to export coverage data. When N=0, llvm-cov auto-detects an; appropriate number of threads to use. This is the default. .. option:: -compilation-dir=<dir>. Directory used as a base for relative coverage mapping paths. Only applicable; when binaries have been compiled with one of `-fcoverage-prefix-map`; `-fcoverage-compilation-dir`, or `-ffile-compilation-dir`. .. option:: -debuginfod. Attempt to look up coverage mapping from objects using debuginfod. This is; attempted by default for binary IDs present in the profile but not provided on; the command line, so long as debuginfod is compiled in and configured via; DEBUGINFOD_URLS. .. option:: -debug-file-directory=<dir>. Provides a directory to search for objects corresponding to binary IDs in the; profile. .. option:: -check-binary-ids. Fail if an object file cannot be found for a binary ID present in the profile,; neither on the command line nor via binary ID lookup. CONVERT-FOR-TESTING COMMAND; ---------------------------. .. warning::; This command is for the LLVM developers who are working on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:18297,detect,detects,18297,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['detect'],['detects']
Safety,"o traditional data structures; of computer science such as arrays, lists, and trees. Collections can be thought of as polymorphic containers that can contain; different types of elements. For this release of the ROOT system, elements; to be placed in collections must be instances of classes.; These may be classes defined by you or provided by ROOT. Collection elements; must be instances of classes descending from ; TObject. The dependence of collections on TObject may disappear; in the future when all C++ compilers used with the ROOT system fully; support templates. In the mean time, knowing the; role TObject plays in collections can be helpful. In general you don't need to worry about TObject. Many ROOT; classes have TObject as an ancestor. In fact, collections themselves; are descendants of TObject. This makes it possible for collections to; contain other collections (subcollections) in a tree structure. Such trees; are used in the ROOT system to implement components of the graphics system; (graphics pads containing pads), geometries (detectors in detectors), etc. The basic protocol TObject defines for collection elements is shown below:. IsEqual(); Compare(); IsSortable(); Hash(). How to use and override these member functions is shown in the; example program. Types of Collections. The ROOT system implements the following type of collections:; arrays, lists, sorted lists, B-trees, hashtables and maps.; The figure below shows the inheritance hierarchy for the primary; collection classes. Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they; were added. The following sequence collections are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. Both a TObjArray as well as a TOrdCollection can be sorted; using their Sort() member function (assuming the stored items are; sortable). Sorted Collections. Sorted collections are ordered by an int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html:1499,detect,detectors,1499,core/cont/doc/Understanding_Collections.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html,2,['detect'],['detectors']
Safety,"o trap the signal and continue with the event loop,; using this method one can specify to exit with the signal number to the; shell, or to abort() which in addition generates a core dump. New command line argument -x which forces ROOT to exit on an exception.; Add TSystem::AddDynamicPath. Build. New option '-t' for rmkdepend to allow the caller to fully specify the name to be used as a target; This supersedes the name calculated from the input file name and the -p and -o option. ACLiC. Allow ACLiC to use a flat directory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copied. TStreamerInfo::New inserts the address of the creating TStreamerInfo into; the object. This address is inserted in each emulated that does not inherit; from an emulated class and is positioned after all the base classes (which; are compiled classes). A derived class will set this value inside each; of its emulated base class.; TStreamerInfo::Destruct and the new method TStreamerInfo::GetActualClass; use this information to detect the TStreamerInfo actually used to create; the object and hence run the proper emulated destructor. Add a new function GenerateDictionary to TInterpreter which allows for the quick and easy creation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");; This replaces the recommend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:2459,avoid,avoids,2459,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,2,['avoid'],"['avoid', 'avoids']"
Safety,"o use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7623,safe,safe,7623,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['safe'],['safe']
Safety,"o-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59945,unsafe,unsafe-math-optimizations,59945,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe-math-optimizations']
Safety,"o; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates to M that it should economize function; calls; it is intended for cases where there are many variable parameters; and/or the function takes a long time to calculate and/or the user is; not interested in very precise values for parameter errors. On the other; hand, value 2 (high) indicates that M is allowed to waste function calls; in order to be sure that all va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:11074,safe,safe,11074,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,"['risk', 'safe']","['risk', 'safe']"
Safety,"oads do not alias; (`-noalias=true`) store operations. Under this assumption, younger loads are; always allowed to pass older stores. Essentially, the LSUnit does not attempt; to run any alias analysis to predict when loads and stores do not alias with; each other. Note that, in the case of write-combining memory, rule 3 could be relaxed to; allow reordering of non-aliasing store operations. That being said, at the; moment, there is no way to further relax the memory model (``-noalias`` is the; only option). Essentially, there is no option to specify a different memory; type (e.g., write-back, write-combining, write-through; etc.) and consequently; to weaken, or strengthen, the memory model. Other limitations are:. * The LSUnit does not know when store-to-load forwarding may occur.; * The LSUnit does not know anything about cache hierarchy and memory types.; * The LSUnit does not know how to identify serializing operations and memory; fences. The LSUnit does not attempt to predict if a load or store hits or misses the L1; cache. It only knows if an instruction ""MayLoad"" and/or ""MayStore."" For; loads, the scheduling model provides an ""optimistic"" load-to-use latency (which; usually matches the load-to-use latency for when there is a hit in the L1D). :program:`llvm-mca` does not (on its own) know about serializing operations or; memory-barrier like instructions. The LSUnit used to conservatively use an; instruction's ""MayLoad"", ""MayStore"", and unmodeled side effects flags to; determine whether an instruction should be treated as a memory-barrier. This was; inaccurate in general and was changed so that now each instruction has an; IsAStoreBarrier and IsALoadBarrier flag. These flags are mca specific and; default to false for every instruction. If any instruction should have either of; these flags set, it should be done within the target's InstrPostProcess class.; For an example, look at the `X86InstrPostProcess::postProcessInstruction` method; within `llvm/lib/Target/X",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:41186,predict,predict,41186,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['predict'],['predict']
Safety,"object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by invoking; **`TThread`**`::CancelPoint()`. Then, if a thread is canceled, the; cancellation is deferred up to the call of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:11648,safe,safely,11648,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safely']
Safety,"ock:: c++. if (__builtin_expect_with_probability(x > 0, 1, 0.8)) {; // This block is likely to be taken with probability 80%.; }. ``switch`` statement; ^^^^^^^^^^^^^^^^^^^^. This is basically the same as ``switch`` statement in ``__builtin_expect``.; The probability that ``exp`` is equal to the expect value is given in; the third argument ``probability``, while the probability of other value is; the average of remaining probability(``1.0 - probability``). For example:. .. code-block:: c++. switch (__builtin_expect_with_probability(x, 5, 0.7)) {; default: break; // Take this case with probability 10%; case 0: break; // Take this case with probability 10%; case 3: break; // Take this case with probability 10%; case 5: break; // This case is likely to be taken with probability 70%; }. CFG Modifications; =================. Branch Weight Metatada is not proof against CFG changes. If terminator operands'; are changed some action should be taken. In other case some misoptimizations may; occur due to incorrect branch prediction information. Function Entry Counts; =====================. To allow comparing different functions during inter-procedural analysis and; optimization, ``MD_prof`` nodes can also be assigned to a function definition.; The first operand is a string indicating the name of the associated counter. Currently, one counter is supported: ""function_entry_count"". The second operand; is a 64-bit counter that indicates the number of times that this function was; invoked (in the case of instrumentation-based profiles). In the case of; sampling-based profiles, this operand is an approximation of how many times; the function was invoked. For example, in the code below, the instrumentation for function foo(); indicates that it was called 2,590 times at runtime. .. code-block:: llvm. define i32 @foo() !prof !1 {; ret i32 0; }; !1 = !{!""function_entry_count"", i64 2590}. If ""function_entry_count"" has more than 2 operands, the later operands are; the GUID of the functions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst:5584,predict,prediction,5584,interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,1,['predict'],['prediction']
Safety,"ocumentation](https://github.com/civetweb/civetweb/blob/master/docs/); and have a look at the [examples](https://github.com/civetweb/civetweb/blob/master/examples/). Recent questions and discussions usually use [GitHub issues](https://github.com/civetweb/civetweb/issues).; Some old information may be found on the [mailing list](https://groups.google.com/d/forum/civetweb), ; but this information may be outdated. Feel free to create a GitHub issue for bugs, feature requests, questions, suggestions or if you want to share tips and tricks.; When creating an issues for a bug, add enough description to reproduce the issue - at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md). Authors; -------. CivetWeb has been forked from the last MIT version of Mongoose in 2013.; Since then, CivetWeb has seen many improvements from various authors; (Copyright (c) 2013-2021 the CivetWeb developers, MIT license). A list of authors can be found in [CREDITS.md](",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:9201,risk,risk,9201,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['risk'],['risk']
Safety,"od Anchor for Classes in Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If a class is defined in a header file and has a vtable (either it has virtual; methods or it derives from classes with virtual methods), it must always have at; least one out-of-line virtual method in the class. Without this, the compiler; will copy the vtable and RTTI into every ``.o`` file that ``#include``\s the; header, bloating ``.o`` file sizes and increasing link times. Don't use default labels in fully covered switches over enumerations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``-Wswitch`` warns if a switch, without a default label, over an enumeration; does not cover every enumeration value. If you write a default label on a fully; covered switch over an enumeration then the ``-Wswitch`` warning won't fire; when new elements are added to that enumeration. To help avoid adding these; kinds of defaults, Clang has the warning ``-Wcovered-switch-default`` which is; off by default but turned on when building LLVM with a version of Clang that; supports the warning. A knock-on effect of this stylistic requirement is that when building LLVM with; GCC you may get warnings related to ""control may reach end of non-void function""; if you return from each case of a covered switch-over-enum because GCC assumes; that the enum expression may take any representable value, not just those of; individual enumerators. To suppress this warning, use ``llvm_unreachable`` after; the switch. Use range-based ``for`` loops wherever possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The introduction of range-based ``for`` loops in C++11 means that explicit; manipulation of iterators is rarely necessary. We use range-based ``for``; loops wherever possible for all newly added code. For example:. .. code-block:: c++. BasicBlock *BB = ...; for (Instruction &I : *BB); ... use I ... Usage of ``std::for_each()``/``llvm::for_each()`` functions is discouraged,; unles",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:51451,avoid,avoid,51451,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"ode-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23745,abort,abort,23745,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"ode-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp sl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192532,safe,safe,192532,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"oduces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeoManager->PrintOverlaps() prints the list of overlaps. \anchor GP03b; ### Graphical Checking Methods. \image html geometry009.png ""Safety computation checking"" width=500px. In order to check a given point, `CheckPoint(x,y,z)` method of; TGeoManager draws the daughters of the volume containing the po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:95089,detect,detected,95089,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detected']
Safety,"of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4901,detect,detection,4901,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['detect'],['detection']
Safety,"of conduct applies to all spaces managed by the LLVM project or The; LLVM Foundation. This includes IRC channels, mailing lists, bug trackers, LLVM; events such as the developer meetings and socials, and any other forums created; by the project that the community uses for communication. It applies to all of; your communication and conduct in these spaces, including emails, chats, things; you say, slides, videos, posters, signs, or even t-shirts you display in these; spaces. . In rare cases, violations of this code outside of these spaces may affect a ; person’s ability to participate within these spaces. Important examples ; include `sexual and gender-based violence`_, `hate crimes`_, and `hate speech`_. ; We do not conduct proactive research, but we have an obligation to respond ; to any reported concerns. We are not interested in evaluating severity, ; responding punitively, or holding people accountable. Both the relevance ; and our response is instead focused on how a person’s continued participation ; impacts the community’s safety, wellbeing, and inclusivity. We specifically ; prioritize remaining a welcoming community to victims as well as groups ; subjected to systemic marginalization or underrepresentation. In addition, violations of this code outside these spaces may, in rare; cases, affect a person's ability to participate within them, when the conduct; amounts to an egregious violation of this code. If you believe someone is violating the code of conduct, we ask that you report; it by emailing conduct@llvm.org. For more details please see the ; :doc:`Reporting Guide <ReportingGuide>`. .. _be friendly and patient:. * **Be friendly and patient.**. .. _be welcoming:. * **Be welcoming.** We strive to be a community that welcomes and supports; people of all backgrounds and identities. This includes, but is not limited; to members of any race, ethnicity, culture, national origin, colour,; immigration status, social and economic class, educational level, sex, se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:1900,safe,safety,1900,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['safe'],['safety']
Safety,"of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only if thread is not; running. Often during the canceling, some clean up actions must be; taken. To define clean up functions use:. ``` {.cpp}; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; ```. Note: `CleanUpPush` and `CleanUpPop` should be used as corresponding; pairs like brackets; unlike `pthreads` cleanup stack (which is *not*; implemented here), **`TThread`** does not force this usage. #### Finishing thread. When a thread returns from a user function the thread is finished. It; also can be finished by `TThread::Exit()`. Then, in case of; `thread`-detached mode, the thread vanishes completely. By default, on; finishing **`TThread`** executes the most recent cleanup ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:12571,safe,safe,12571,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"oint/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ~~~. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the computation of safety can always be forced:. ~~~{.cpp}; Double_t safety = gGeoManager->Safety();; ~~~. \anchor GP02gd; #### Making a Step. The modeller is able to make steps starting from the current point along; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:79525,safe,safe,79525,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"older, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19922,avoid,avoid,19922,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['avoid'],['avoid']
Safety,"olume or it will exit inside its container:. ~~~{.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ~~~. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used instead of the method `FindNextBoundary()`; whenever the tracking is not imposed in association with an external MC; transport engine (which provide their own algorithms for boundary; crossing). ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; ~~~. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the comput",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:79307,safe,safety,79307,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ompoundColorSelectionBits enum. TEveElement: propagate transparency to projected replicas. As this; is implemented in the base-class, it works for all projectable classes. TEveVector, TEveVector4 and TEveVector2 are now typedefs to float; specialization of corresponding templates. Double versions use 'D' as; postfix, 'F' postfix is another alias for float versions, e.g.:; typedef TEveVectorT<Float_t> TEveVector;; typedef TEveVectorT<Float_t> TEveVectorF;; typedef TEveVectorT<Double_t> TEveVectorD;. All projectable classes now take into account their transformation; matrix. The projected versions are still stored in global; coordinates.; TEveShape -- a new abstract base-class for 2D/3D shapes that; require fill / outline color, line-width and various flags; controlling the area / outline drawing.; TEveGeoShape and projected classes: subclass from TEveShape. Add; support for TGeoCompositeShapes. In 2D projected class; (TEvePolygonSetProjected) improve detection of duplicate polygons; and add support for detection of minimal-outline (triggered via; Bool_t TEveShape::fMiniOutline).; TEveBox: New class to draw a simple cuboid with minimal memory; usage. It is projectable.; TEveBoxSet: for box-type kBT_FreeBox assure proper face; orientation at registration time and calculate normals when; rendering. TEveJetCone is now projectable.; Several performance improvements when dealing with large; collections of EVE objects. Profiled with simulated heavy-ion; data. In particular, for destruction of self-contained sub-hierarchies of objects; one can use TEveElement::Annihilate() and; TEveElement::AnnihilateElements(). See class docs for constraints. Minor changes. Add support for projecting a new child (all children) of an; element after the element and its old children have already been; projected. This is provided by the following virtual functions in; TEveElement:; void ProjectChild(TEveElement* el, Bool_t sameDepth=kTRUE);; void ProjectAllChildren(Bool_t same_depth=kTRUE);. Se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:5285,detect,detection,5285,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,2,['detect'],['detection']
Safety,"on file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ### List of VAF-specific variables. There are some special variables that need to be set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF mas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:2887,avoid,avoid,2887,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['avoid'],['avoid']
Safety,"on may describe the same; physical location. e.g. A stack slot may appear as a deopt location,; a gc base pointer, and a gc derived pointer. The LiveOut section of the StkMapRecord will be empty for a statepoint; record. Safepoint Semantics & Verification; ==================================. The fundamental correctness property for the compiled code's; correctness w.r.t. the garbage collector is a dynamic one. It must be; the case that there is no dynamic trace such that an operation; involving a potentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing wo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:24001,safe,safepoint,24001,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,2,['safe'],['safepoint']
Safety,"on methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84475,detect,detect,84475,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['detect'],['detect']
Safety,"on unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:6429,detect,detection,6429,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detection']
Safety,"on, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type conditional on `ROOFIT_MEMORY_SAFE_INTERFACES`.; If you are overriding such a function, you need to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:8564,avoid,avoided,8564,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['avoid'],['avoided']
Safety,"on; **SAN**\ity"". GWP-ASan is based on the classic; `Electric Fence Malloc Debugger <https://linux.die.net/man/3/efence>`_, with a; key adaptation. Notably, we only choose a very small percentage of allocations; to sample, and apply guard pages to these sampled allocations only. The sampling; is small enough to allow us to have very low performance overhead. There is a small, tunable memory overhead that is fixed for the lifetime of the; process. This is approximately ~40KiB per process using the default settings,; depending on the average size of your allocations. GWP-ASan vs. ASan; =================. Unlike `AddressSanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_,; GWP-ASan does not induce a significant performance overhead. ASan often requires; the use of dedicated canaries to be viable in production environments, and as; such is often impractical. GWP-ASan is only capable of finding a subset of the memory issues detected by; ASan. Furthermore, GWP-ASan's bug detection capabilities are only probabilistic.; As such, we recommend using ASan over GWP-ASan in testing, as well as anywhere; else that guaranteed error detection is more valuable than the 2x execution; slowdown/binary size bloat. For the majority of production environments, this; impact is too high, and GWP-ASan proves extremely useful. Design; ======. **Please note:** The implementation of GWP-ASan is largely in-flux, and these; details are subject to change. There are currently other implementations of; GWP-ASan, such as the implementation featured in; `Chromium <https://cs.chromium.org/chromium/src/components/gwp_asan/>`_. The; long-term support goal is to ensure feature-parity where reasonable, and to; support compiler-rt as the reference implementation. Allocator Support; -----------------. GWP-ASan is not a replacement for a traditional allocator. Instead, it works by; inserting stubs into a supporting allocator to redirect allocations to GWP-ASan; when they're chosen to be sampled. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:1315,detect,detection,1315,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"onditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:17794,safe,safety,17794,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"one (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75396,detect,detector,75396,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detector']
Safety,"oned above); whenever feasible.; - Include comments about what is tested/expected in a particular test. If there; are relevant issues in the bug tracker, add references to those bug reports; (for example, ""See PR999 for more details"").; - Avoid undefined behavior and poison/undef values unless necessary. For; example, do not use patterns like ``br i1 undef``, which are likely to break; as a result of future optimizations.; - Minimize tests by removing unnecessary instructions, metadata, attributes,; etc. Tools like ``llvm-reduce`` can help automate this.; - Outside PhaseOrdering tests, only run a minimal set of passes. For example,; prefer ``opt -S -passes=instcombine`` over ``opt -S -O3``.; - Avoid unnamed instructions/blocks (such as ``%0`` or ``1:``), because they may; require renumbering on future test modifications. These can be removed by; running the test through ``opt -S -passes=instnamer``.; - Try to give values (including variables, blocks and functions) meaningful; names, and avoid retaining complex names generated by the optimization; pipeline (such as ``%foo.0.0.0.0.0.0``). Extra files; -----------. If your test requires extra files besides the file containing the ``RUN:`` lines; and the extra files are small, consider specifying them in the same file and; using ``split-file`` to extract them. For example,. .. code-block:: llvm. ; RUN: split-file %s %t; ; RUN: llvm-link -S %t/a.ll %t/b.ll | FileCheck %s. ; CHECK: ... ;--- a.ll; ...; ;--- b.ll; ... The parts are separated by the regex ``^(.|//)--- <part>``. If you want to test relative line numbers like ``[[#@LINE+1]]``, specify; ``--leading-lines`` to add leading empty lines to preserve line numbers. If the extra files are large, the idiomatic place to put them is in a subdirectory ``Inputs``.; You can then refer to the extra files as ``%S/Inputs/foo.bar``. For example, consider ``test/Linker/ident.ll``. The directory structure is; as follows::. test/; Linker/; ident.ll; Inputs/; ident.a.ll; ident.b.ll.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:14527,avoid,avoid,14527,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoid']
Safety,"ones for; :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. The; differences in approach are covered in the `Garbage Collection with LLVM; <GarbageCollection.html>`_ documentation. The intrinsics themselves are; described in :doc:`Statepoints`. .. _int_gcroot:. '``llvm.gcroot``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.gcroot(ptr %ptrloc, ptr %metadata). Overview:; """""""""""""""""". The '``llvm.gcroot``' intrinsic declares the existence of a GC root to; the code generator, and allows some metadata to be associated with it. Arguments:; """""""""""""""""""". The first argument specifies the address of a stack object that contains; the root pointer. The second pointer (which must be either a constant or; a global value address) contains the meta-data to be associated with the; root. Semantics:; """""""""""""""""""". At runtime, a call to this intrinsic stores a null pointer into the; ""ptrloc"" location. At compile-time, the code generator generates; information to allow the runtime to find the pointer at GC safe points.; The '``llvm.gcroot``' intrinsic may only be used in a function which; :ref:`specifies a GC algorithm <gc>`. .. _int_gcread:. '``llvm.gcread``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.gcread(ptr %ObjPtr, ptr %Ptr). Overview:; """""""""""""""""". The '``llvm.gcread``' intrinsic identifies reads of references from heap; locations, allowing garbage collector implementations that require read; barriers. Arguments:; """""""""""""""""""". The second argument is the address to read from, which should be an; address allocated from the garbage collector. The first object is a; pointer to the start of the referenced object, if needed by the language; runtime (otherwise null). Semantics:; """""""""""""""""""". The '``llvm.gcread``' intrinsic has the same semantics as a load; instruction, but may be replaced with substantially more complex code by; the garbage collector runtime, as needed. The '``llvm.gcread``'; intrinsic may o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:497515,safe,safe,497515,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"only when referring to a; given volume and it is always accessible at that level. Several volumes; may reference a single shape; therefore its deletion is not possible; once volumes were defined based on it. The navigation features related for instance to tracking particles are; performed in the following way: Each shape implement its specific; algorithms for all required tasks in its local reference system. Note; that the manager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:50846,safe,safe,50846,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"only when referring to a; given volume and it is always accessible at that level. Several volumes; may reference a single shape; therefore its deletion is not possible; once volumes were defined based on it. The navigation features related for instance to tracking particles are; performed in the following way: Each shape implement its specific; algorithms for all required tasks in its local reference system. Note; that the manager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ~~~ {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ~~~. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ~~~ {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ~~~. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ~~~ {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:4562,safe,safe,4562,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['safe'],['safe']
Safety,"ons cannot overlap. Also, overlapping regions; cannot have the same name. There is no support for marking regions from high-level source code, like C or; C++. As a workaround, inline assembly directives may be used:. .. code-block:: c++. int foo(int a, int b) {; __asm volatile(""# LLVM-MCA-BEGIN foo"":::""memory"");; a += 42;; __asm volatile(""# LLVM-MCA-END"":::""memory"");; a *= b;; return a;; }. However, this interferes with optimizations like loop vectorization and may have; an impact on the code generated. This is because the ``__asm`` statements are; seen as real code having important side effects, which limits how the code; around them can be transformed. If users want to make use of inline assembly; to emit markers, then the recommendation is to always verify that the output; assembly is equivalent to the assembly generated in the absence of markers.; The `Clang options to emit optimization reports <https://clang.llvm.org/docs/UsersManual.html#options-to-emit-optimization-reports>`_; can also help in detecting missed optimizations. INSTRUMENT REGIONS; ------------------. An InstrumentRegion describes a region of assembly code guarded by; special LLVM-MCA comment directives. .. code-block:: none. # LLVM-MCA-<INSTRUMENT_TYPE> <data>; ... ## asm. where `INSTRUMENT_TYPE` is a type defined by the target and expects; to use `data`. A comment starting with substring `LLVM-MCA-<INSTRUMENT_TYPE>`; brings data into scope for llvm-mca to use in its analysis for; all following instructions. If a comment with the same `INSTRUMENT_TYPE` is found later in the; instruction list, then the original InstrumentRegion will be; automatically ended, and a new InstrumentRegion will begin. If there are comments containing the different `INSTRUMENT_TYPE`,; then both data sets remain available. In contrast with an AnalysisRegion,; an InstrumentRegion does not need a comment to end the region. Comments that are prefixed with `LLVM-MCA-` but do not correspond to; a valid `INSTRUMENT_TYPE` for t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:10715,detect,detecting,10715,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['detect'],['detecting']
Safety,"ons flow better. Prefer Preincrement; ^^^^^^^^^^^^^^^^^^^. Hard fast rule: Preincrement (``++X``) may be no slower than postincrement; (``X++``) and could very well be a lot faster than it. Use preincrementation; whenever possible. The semantics of postincrement include making a copy of the value being; incremented, returning it, and then preincrementing the ""work value"". For; primitive types, this isn't a big deal. But for iterators, it can be a huge; issue (for example, some iterators contains stack and set objects in them...; copying an iterator could invoke the copy ctor's of these as well). In general,; get in the habit of always using preincrement, and you won't have a problem. Namespace Indentation; ^^^^^^^^^^^^^^^^^^^^^. In general, we strive to reduce indentation wherever possible. This is useful; because we want code to `fit into 80 columns`_ without excessive wrapping, but; also because it makes it easier to understand the code. To facilitate this and; avoid some insanely deep nesting on occasion, don't indent namespaces. If it; helps readability, feel free to add a comment indicating what namespace is; being closed by a ``}``. For example:. .. code-block:: c++. namespace llvm {; namespace knowledge {. /// This class represents things that Smith can have an intimate; /// understanding of and contains the data associated with it.; class Grokable {; ...; public:; explicit Grokable() { ... }; virtual ~Grokable() = 0;. ... };. } // namespace knowledge; } // namespace llvm. Feel free to skip the closing comment when the namespace being closed is; obvious for any reason. For example, the outer-most namespace in a header file; is rarely a source of confusion. But namespaces both anonymous and named in; source files that are being closed half way through the file probably could use; clarification. .. _static:. Anonymous Namespaces; ^^^^^^^^^^^^^^^^^^^^. After talking about namespaces in general, you may be wondering about anonymous; namespaces in particular. Anony",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:58721,avoid,avoid,58721,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"ons happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2884,avoid,avoid,2884,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,2,['avoid'],['avoid']
Safety,"on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75297,detect,detector,75297,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detector']
Safety,"oop attributes the epilogue will have. The; epilogue is not vectorized and is executed when either the vectorized; loop is not known to preserve semantics (because e.g., it processes two; arrays that are found to alias by a runtime check) or for the last; iterations that do not fill a complete set of vector lanes. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.vectorize.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes in the metadata will be added to both the vectorized and; epilogue loop.; See :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll``'; ^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling; optimization hints such as the unroll factor. ``llvm.loop.unroll``; metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. The ``llvm.loop.unroll`` metadata are only; optimization hints and the unrolling will only be performed if the; optimizer believes it is safe to do so. '``llvm.loop.unroll.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an unroll factor to the loop unroller. The; first operand is the string ``llvm.loop.unroll.count`` and the second; operand is a positive integer specifying the unroll factor. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.count"", i32 4}. If the trip count of the loop is less than the unroll count the loop; will be partially unrolled. '``llvm.loop.unroll.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables loop unrolling. The metadata has a single operand; which is the string ``llvm.loop.unroll.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.unroll.disable""}. '``llvm.loop.unroll.runtime.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata disables runtime loop unrolling. The metadata has a single; operand which is the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:301078,safe,safe,301078,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"oop over all tutorials and define the corresponding test---------; foreach(t ${tutorials}); list(FIND returncode_1 ${t} index); if(index EQUAL -1); set(rc 0); else(); set(rc 255); endif(); string(REPLACE "".C"" """" tname ${t}); string(REPLACE ""/"" ""-"" tname ${tname}). set(labels tutorial); if(${t} IN_LIST long_running); list(APPEND labels longtest); endif(); if(${t} IN_LIST multithreaded); list(APPEND labels multithreaded); # If this is not a TMVA tutorial, we want to limit the size of the thread; # pool in case the tutorial invokes ROOT::EnableImplicitMT(), which by; # default creates a thread pool of the size of the total number of cores.; if(${t} IN_LIST multithreaded_all_cores); set(createThreadPool ""-e \""ROOT::EnableImplicitMT(${NProcessors})\""""); endif(); else(); unset(createThreadPool); endif(). if(${t} IN_LIST need_network); list(APPEND labels needs_network); endif(). # These tests on ARM64 need much more than 20 minutes - increase the timeout; if(ROOT_ARCHITECTURE MATCHES arm64 OR ROOT_ARCHITECTURE MATCHES ppc64); set(thisTestTimeout 3000) # 50m; else(); set(thisTestTimeout 1200) # 20m; endif(). ROOT_ADD_TEST(tutorial-${tname}; COMMAND ${ROOT_root_CMD} -b -l -q ${createThreadPool} ${CMAKE_CURRENT_SOURCE_DIR}/${t}${${tname}-aclic}; PASSRC ${rc} FAILREGEX ""Error in <"" "": error:"" ""segmentation violation"" ""FROM HESSE STATUS=FAILED"" ""warning: Failed to call""; LABELS ${labels}; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}). if(${t} IN_LIST multithreaded); # Makes sure that this doesn't run in parallel with other multithreaded tutorials, and that cmake doesn't start too; # many other tests. That we use 4 processors is actually a lie, because IMT takes whatever it finds.; # However, even this poor indication of MT behaviour is a good hint for cmake to reduce congestion.; set_tests_properties(tutorial-${tname} PROPERTIES RESOURCE_LOCK multithreaded PROCESSORS ${NProcessors}); endif(); endforeach(). #---Loop over al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:24089,timeout,timeout,24089,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['timeout'],['timeout']
Safety,"operand registers are available and resource requirements are; met. Multiple instructions can be issued in one cycle according to the value of; the ``IssueWidth`` parameter in LLVM's scheduling model. Once issued, an instruction is moved to ``IssuedInst`` set until it is ready to; retire. :program:`llvm-mca` ensures that writes are committed in-order. However,; an instruction is allowed to commit writes and retire out-of-order if; ``RetireOOO`` property is true for at least one of its writes. Custom Behaviour; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Due to certain instructions not being expressed perfectly within their; scheduling model, :program:`llvm-mca` isn't always able to simulate them; perfectly. Modifying the scheduling model isn't always a viable; option though (maybe because the instruction is modeled incorrectly on; purpose or the instruction's behaviour is quite complex). The; CustomBehaviour class can be used in these cases to enforce proper; instruction modeling (often by customizing data dependencies and detecting; hazards that :program:`llvm-mca` has no way of knowing about). :program:`llvm-mca` comes with one generic and multiple target specific; CustomBehaviour classes. The generic class will be used if the ``-disable-cb``; flag is used or if a target specific CustomBehaviour class doesn't exist for; that target. (The generic class does nothing.) Currently, the CustomBehaviour; class is only a part of the in-order pipeline, but there are plans to add it; to the out-of-order pipeline in the future. CustomBehaviour's main method is `checkCustomHazard()` which uses the; current instruction and a list of all instructions still executing within; the pipeline to determine if the current instruction should be dispatched.; As output, the method returns an integer representing the number of cycles; that the current instruction must stall for (this can be an underestimate; if you don't know the exact number and a value of 0 represents no stall). If you'd like ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:44393,detect,detecting,44393,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,2,"['detect', 'hazard']","['detecting', 'hazards']"
Safety,"operation; has been evaluated, the stack is therefore as it is left by the evaluation; of the operations of E. Since E is evaluated on the same stack as the call; operation, E can use, and/or remove entries already on the stack, and can; add new entries to the stack. *Values on the stack at the time of the call may be used as parameters by; the called expression and values left on the stack by the called expression; may be used as return values by prior agreement between the calling and; called expressions.*. * If D has a ``DW_AT_location`` attribute that is encoded as a ``loclist`` or; ``loclistsptr``, then the specified location list expression E is; evaluated. The evaluation of E uses the current context, except the result; kind is a location description, the compilation unit is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:76181,avoid,avoids,76181,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoids']
Safety,"opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76236,detect,detected,76236,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"or build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40074,redund,redundant,40074,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['redund'],['redundant']
Safety,"or gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ; Fix a problem in the assignment operator of the ROOT::Math::PxPyPzM4D class. Avoid having nan when converting for example from PxPyPzME4D to PxPyPzM4D when the mass is negative. ; Throw always exception in the non-supported setters (i.e. SetPt on a PxPyPzEVector) methods, which are generated only for the CINT dictionary. These methods flag a compiled-error when running in C++ mode. SMatrix. Change implementation of the SMatrix::Invert and SMatrix::Inverse methods. Now the optimized method based on the Cramer rule is used only for matrix up to sizes 2x2. The standard methods based on LU (for ordinary square matrix) or Bunch-Kaufman factorization (for square matrix) are used. The factorization method, although slower for small size matrices, they suffer much less from numerical precision problems.; New methods SMatrix::Invert and SMatrix::InverseFast are added for using the Cramer rule for up to matrix of sizes 5x5. This method",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:4541,avoid,avoid,4541,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['avoid'],['avoid']
Safety,"or, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2612,detect,detect,2612,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['detect'],['detect']
Safety,"or: Instruction Selector, Instruction; Scheduling, and Register Allocation. ``llvm/lib/MC/``. The libraries represent and process code at machine code level. Handles; assembly and object-file emission. ``llvm/lib/ExecutionEngine/``. Libraries for directly executing bitcode at runtime in interpreted and; JIT-compiled scenarios. ``llvm/lib/Support/``. Source code that corresponding to the header files in ``llvm/include/ADT/``; and ``llvm/include/Support/``. ``llvm/bindings``; ----------------------. Contains bindings for the LLVM compiler infrastructure to allow; programs written in languages other than C or C++ to take advantage of the LLVM; infrastructure.; LLVM project provides language bindings for OCaml and Python. ``llvm/projects``; -----------------. Projects not strictly part of LLVM but shipped with LLVM. This is also the; directory for creating your own LLVM-based projects which leverage the LLVM; build system. ``llvm/test``; -------------. Feature and regression tests and other sanity checks on LLVM infrastructure. These; are intended to run quickly and cover a lot of territory without being exhaustive. ``test-suite``; --------------. A comprehensive correctness, performance, and benchmarking test suite; for LLVM. This comes in a ``separate git repository; <https://github.com/llvm/llvm-test-suite>``, because it contains a; large amount of third-party code under a variety of licenses. For; details see the :doc:`Testing Guide <TestingGuide>` document. .. _tools:. ``llvm/tools``; --------------. Executables built out of the libraries; above, which form the main part of the user interface. You can always get help; for a tool by typing ``tool_name -help``. The following is a brief introduction; to the most important tools. More detailed information is in; the `Command Guide <CommandGuide/index.html>`_. ``bugpoint``. ``bugpoint`` is used to debug optimization passes or code generation backends; by narrowing down the given test case to the minimum number of passes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:38026,sanity check,sanity checks,38026,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['sanity check'],['sanity checks']
Safety,"or; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatically applied if ``-Xclang -fixit`` is passed to the; driver, they should only be used when it's very likely they match the user's; intent.; * Clang must recover from errors as if the fix-it had been applied.; * Fix-it hints on a warning must not change the meaning of the code.; However, a hint may clarify the meaning as intentional, for example by adding; parentheses when the precedence of operators isn't obvious. If a fix-it can't obey these rules, put the fix-it on a note. Fix-its on notes; are not applied automatically. All fix-it hints are described by the ``FixItHint`` class, instances of which; should be attached to the diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:19671,recover,recover,19671,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recover']
Safety,"or<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81772,unsafe,unsafe,81772,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['unsafe'],['unsafe']
Safety,"oreg, !5, !6. In this circumstance LLVM would leave the MIR as shown above. Were we to move; the DBG_VALUE of virtual register %7 upwards with the SUB32rr, we would re-order; assignments and introduce a new state of the program. Whereas with the solution; above, the debugger will see one fewer combination of variable values, because; ``!3`` and ``!5`` will change value at the same time. This is preferred over; misrepresenting the original program. In comparison, if one sunk the MOV32rm, LLVM would produce the following:. .. code-block:: text. DBG_VALUE $noreg, $noreg, !1, !2; %4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags; DBG_VALUE %4, $noreg, !3, !4; %7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags; DBG_VALUE %7, $noreg, !5, !6; %1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1); DBG_VALUE %1, $noreg, !1, !2. Here, to avoid presenting a state in which the first assignment to ``!1``; disappears, the DBG_VALUE at the top of the block assigns the variable the; undefined location, until its value is available at the end of the block where; an additional DBG_VALUE is added. Were any other DBG_VALUE for ``!1`` to occur; in the instructions that the MOV32rm was sunk past, the DBG_VALUE for ``%1``; would be dropped and the debugger would never observe it in the variable. This; accurately reflects that the value is not available during the corresponding; portion of the original program. Variable locations during Register Allocation; ---------------------------------------------. To avoid debug instructions interfering with the register allocator, the; LiveDebugVariables pass extracts variable locations from a MIR function and; deletes the corresponding DBG_VALUE instructions. Some localized copy; propagation is performed within blocks. After register allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:34985,avoid,avoid,34985,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"orithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and ren",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9373,safe,safe,9373,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['safe'],['safe']
Safety,"ormance Suite; ----------------------; https://github.com/LLNL/RAJAPerf. CORAL-2 Benchmarks; ------------------; https://asc.llnl.gov/coral-2-benchmarks/. Many of its programs have already been integrated in; MultiSource/Benchmarks/DOE-ProxyApps-C and; MultiSource/Benchmarks/DOE-ProxyApps-C++. * Nekbone; * QMCPack; * LAMMPS; * Kripke; * Quicksilver; * PENNANT; * Big Data Analytic Suite; * Deep Learning Suite; * Stream; * Stride; * ML/DL micro-benchmark; * Pynamic; * ACME; * VPIC; * Laghos; * Parallel Integer Sort; * Havoq. NWChem; ------; http://www.nwchem-sw.org/index.php/Benchmarks. TVM; ----; https://github.com/dmlc/tvm/tree/main/apps/benchmark. HydroBench; ----------; https://github.com/HydroBench/Hydro. ParRes; ------; https://github.com/ParRes/Kernels/tree/default/Cxx11. Applications/Libraries; ======================. GnuPG; -----; https://gnupg.org/. Blitz++; -------; https://sourceforge.net/projects/blitz/. FFmpeg; ------; https://ffmpeg.org/. FreePOOMA; ---------; http://www.nongnu.org/freepooma/. FTensors; --------; http://www.wlandry.net/Projects/FTensor. rawspeed; --------; https://github.com/darktable-org/rawspeed. Its test dataset is 756 MB in size, which is too large to be included; into the test-suite repository. C++ Performance Benchmarks; --------------------------; https://gitlab.com/chriscox/CppPerformanceBenchmarks. Generic Algorithms; ==================. Image processing; ----------------. Resampling; ``````````. * Bilinear; * Bicubic; * Lanczos. Dither; ``````. * Threshold; * Random; * Halftone; * Bayer; * Floyd-Steinberg; * Jarvis; * Stucki; * Burkes; * Sierra; * Atkinson; * Gradient-based. Feature detection; `````````````````. * Harris; * Histogram of Oriented Gradients. Color conversion; ````````````````. * RGB to grayscale; * HSL to RGB. Graph; -----. Search Algorithms; `````````````````. * Breadth-First-Search; * Depth-First-Search; * Dijkstra's algorithm; * A-Star. Spanning Tree; `````````````. * Kruskal's algorithm; * Prim's algorithm; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst:6057,detect,detection,6057,interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,1,['detect'],['detection']
Safety,"ormance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2356,safe,safe,2356,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"orpus.; ./a.out. You should get an error pretty quickly::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 ft: 5 corp: 4/6b exec/s: 0 rss: 25Mb L: 2 MS: 2 ShuffleBytes-ChangeBit-; #4167	NEW cov: 7 ft: 6 corp: 5/9b exec/s: 0 rss: 25Mb L: 3 MS: 1 InsertByte-; ==31511== ERROR: libFuzzer: deadly signal; ...; artifact_prefix='./'; Test unit written to ./crash-b13e8756b13a00cf168300179061fb4b91fefbed. More examples; -------------. Examples of real-life fuzz targets and the bugs they find can be found; at http://tutorial.libfuzzer.info. Among other things you can learn how; to detect Heartbleed_ in one second. Advanced features; =================; .. contents::; :local:; :depth: 1. Dictionaries; ------------; LibFuzzer supports user-supplied dictionaries with input language keywords; or other interesting byte sequences (e.g. multi-byte magic values).; Use ``-dict=DICTIONARY_FILE``. For some input languages using a dictionary; may significantly improve the search speed.; The dictionary syntax is similar to that used by AFL_ for its ``-x`` option::. # Lines starting with '#' and empty lines are ignored. # Adds ""blah"" (w/o quotes) to the dictionary.; kw1=""blah""; # Use \\ for backslash and \"" for quotes.; kw2=""\""ac\\dc\""""; # Use \xAB for hex values; kw3=""\xF7\xF8""; # the name of the keyword followed by '=' may be omitted:; ""foo\x0Abar"". Tracing CMP instructions; ------------------------. With an additional compiler flag ``-fsanitize-coverage=trace-cmp``; (on by default as part of ``-fsanitize=fuzzer``, see SanitizerCoverageTraceDataFlow_); libFuzzer will int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:19191,detect,detect,19191,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detect']
Safety,"orted on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can use the following suppression mechanism; to unblock yourself and continue on with the testing. This suppression; mechanism should only be used for suppressing issues in external code; it; does not work on code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:6668,detect,detection,6668,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detection']
Safety,"osed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the entire program is compiled; with ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the star",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:6254,avoid,avoid,6254,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoid']
Safety,"oss-compiler:. #. When you have extracted your cross-compiler from a zip file into; a directory, you have to use ``--sysroot=<path>``. The path is the; root directory where you have unpacked your file, and Clang will; look for the directories ``bin``, ``lib``, ``include`` in there. In this case, your setup should be pretty much done (if no; additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7448,safe,safer,7448,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['safe'],['safer']
Safety,"osure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * Andy Kaylor (Intel) [@andykaylor]; * Artur Pilipenko (Azul Systems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1893,avoid,avoid,1893,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['avoid'],['avoid']
Safety,"otFinder; and BrentMinimizer1D) by fixing a bug in the Brent method (see rev. 32544); and adding possibility to pass the tolerance and max number of; iterations; Change also the interface classes,; ROOT::Math::RootFinder and; ROOT::Math::IMinimizer1D to have methods consistent with; the other numerical algorithm classes (e.g. return bool and not; int from RootFinder::Solve and add a; RootFinder::Status() function. In addition, use the same default; tolerance for all the root finder algorithms.; ; The class ROOT::Math::Data::Range returns in the method; GetRange the values -inf and +inf when no range; is set; ; Use in TRandom::SetSeed(int seed) a value of; seed=0 as default argument. This is the same now in all the; derived classes.; Add new methods in ROOT::Fit::FitResult to have a more; consistent and expressive API:FitResult::Parameter(index),; FitResult::ParError(index) and; FitResult::ParName(index).; The method FitResult::ParError should be used instead of; FitResult::Error in the derived TFitResult; class to avoid a conflict with TObject::Error; (see bug 67671).; ; Fix a bug in Tmath::AreEqualRel to take into account; the case when the two arguments may be null.; Improve implementation of the F distribution for large N and; M. Use now the same implementation in ROOT::Math and TMath; Fix the returned value of the incomplete gamma functions for; a=0 or a is a negative integer number. Mathmore. Fix a bug in ROOT::Math::Random::Multinomial. ; Fix some bugs in GSLInterpolator; New mathematical special functions in the ROOT::Math namespace; implemented using GSL:; ; Airy functions:; ; double airy_Ai(double x);; double airy_Bi(double x);; double airy_Ai_deriv(double x);; double airy_Bi_deriv(double x);; double airy_zero_Ai(unsigned int s);; double airy_zero_Bi(unsigned int s);; double airy_zero_Ai_deriv(unsigned int s);; double airy_zero_Bi_deriv(unsigned int s);; ; Wigner coefficient functions:; ; double wigner_3j(int ja, int jb, int jc, int ma, int mb, int mc);; dou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:7231,avoid,avoid,7231,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,1,['avoid'],['avoid']
Safety,"oth its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the hea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:1379,redund,redundant,1379,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['redund'],['redundant']
Safety,"ouble`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query for this feature with ``__has_extension(enumerator_attributes)``. C++11 Attributes on using-declarations; ======================================. Clang allows C++-style ``[[]]`` attributes to be written on using-declarations.; For instance:. .. code-block:: c++. [",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:36205,unsafe,unsafe,36205,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"ountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:83688,safe,safe,83688,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"out needing to distinguish them from non-generic virtual registers. For simplicity, most generic instructions only accept virtual registers (both; generic and non-generic). There are some exceptions to this but in general:. * instead of immediates, they use a generic virtual register defined by an; instruction that materializes the immediate value (see; :ref:`irtranslator-constants`). Typically this is a G_CONSTANT or a; G_FCONSTANT. One example of an exception to this rule is G_SEXT_INREG where; having an immediate is mandatory.; * instead of physical register, they use a generic virtual register that is; either defined by a ``COPY`` from the physical register or used by a ``COPY``; that defines the physical register. .. admonition:: Historical Note. We started with an alternative representation, where MRI tracks a size for; each generic virtual register, and instructions have lists of types.; That had two flaws: the type and size are redundant, and there was no generic; way of getting a given operand's type (as there was no 1:1 mapping between; instruction types and operands).; We considered putting the type in some variant of MCInstrDesc instead:; See `PR26576 <https://llvm.org/PR26576>`_: [GlobalISel] Generic MachineInstrs; need a type but this increases the memory footprint of the related objects. .. _gmir-regbank:. Register Bank; -------------. A Register Bank is a set of register classes defined by the target. This; definition is rather loose so let's talk about what they can achieve. Suppose we have a processor that has two register files, A and B. These are; equal in every way and support the same instructions for the same cost. They're; just physically stored apart and each instruction can only access registers from; A or B but never a mix of the two. If we want to perform an operation on data; that's in split between the two register files, we must first copy all the data; into a single register file. Given a processor like this, we would benefit from clus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:2965,redund,redundant,2965,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['redund'],['redundant']
Safety,"out the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85723,recover,recovery,85723,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"overwrites the pointee on all paths; before returning. * Prove that the function reads the pointee only after overwriting it. * Prove that the function does not persist the pointer in a data structure; that is live after the function returns. There are also requirements that all usage sites of the candidate function must; satisfy, for example, that function arguments do not alias, that users are not; taking the address of the function, and so on. Let's consider verifying usage; site conditions to be a separate static analysis problem. ### Lattice design. To analyze the function body we can use a lattice which consists of normal; states and failure states. A normal state describes program points where we are; sure that no behaviors that block the refactoring have occurred. Normal states; keep track of all parameter's member fields that are known to be overwritten on; every path from function entry to the corresponding program point. Failure; states accumulate observed violations (unsafe reads and pointer escapes) that; block the refactoring. In the partial order of the lattice failure states compare greater than normal; states, which guarantees that they ""win"" when joined with normal states. Order; between failure states is determined by inclusion relation on the set of; accumulated violations (lattice's `⩽` is `⊆` on the set of violations). Order; between normal states is determined by reversed inclusion relation on the set of; overwritten parameter's member fields (lattice's `⩽` is `⊇` on the set of; overwritten fields). ![Lattice for data flow analysis that identifies output parameters](DataFlowAnalysisIntroImages/OutputParameterIdentificationLattice.svg). To determine whether a statement reads or writes a field we can implement; symbolic evaluation of `DeclRefExpr`s, `LValueToRValue` casts, pointer; dereference operator and `MemberExpr`s. ### Using data flow results to identify output parameters. Let's take a look at how we use data flow analysis to identify an ou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:17321,unsafe,unsafe,17321,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['unsafe'],['unsafe']
Safety,"overy AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87406,recover,recovery,87406,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"own *guarded* slot, which may consist of one or more accessible; pages. Each guarded slot is surrounded by two *guard* pages, which are mapped as; inaccessible. The collection of all guarded slots makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4309,detect,detection,4309,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"p) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:6337,redund,redundant,6337,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['redund'],['redundant']
Safety,"p. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1634,detect,detected,1634,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['detect'],['detected']
Safety,"p10 = getelementptr inbounds %struct.anon* %tmp3, i64 %idxprom7, i32 0; %tmp11 = load double* %tmp10, align 8, !tbaa !4; %cmp12 = fcmp ogt double %tmp5, %tmp11; br i1 %cmp12, label %if.then, label %for.inc. if.then: ; preds = %for.body; %i.017 = trunc i64 %indvar to i32; br label %for.inc. for.inc: ; preds = %for.body, %if.then; %i.01719 = phi i32 [ %i.01718, %for.body ], [ %i.017, %if.then ]; %indvar.next = add i64 %indvar, 1; %exitcond = icmp eq i64 %indvar.next, %tmp22; br i1 %exitcond, label %for.cond.for.end_crit_edge, label %for.body. It is good that we hoisted the reloads of numf2's, and Y out of the loop and; sunk the store to winner out. However, this is awful on several levels: the conditional truncate in the loop; (-indvars at fault? why can't we completely promote the IV to i64?). Beyond that, we have a partially redundant load in the loop: if ""winner"" (aka ; %i.01718) isn't updated, we reload Y[winner].y the next time through the loop.; Similarly, the addressing that feeds it (including the sext) is redundant. In; the end we get this generated assembly:. LBB0_2: ## %for.body; ## =>This Inner Loop Header: Depth=1; 	movsd	(%rdi), %xmm0; 	movslq	%edx, %r8; 	shlq	$4, %r8; 	ucomisd	(%rcx,%r8), %xmm0; 	jbe	LBB0_4; 	movl	%esi, %edx; LBB0_4: ## %for.inc; 	addq	$16, %rdi; 	incq	%rsi; 	cmpq	%rsi, %rax; 	jne	LBB0_2. All things considered this isn't too bad, but we shouldn't need the movslq or; the shlq instruction, or the load folded into ucomisd every time through the; loop. On an x86-specific topic, if the loop can't be restructure, the movl should be a; cmov. //===---------------------------------------------------------------------===//. [STORE SINKING]. GCC PR37810 is an interesting case where we should sink load/store reload; into the if block and outside the loop, so we don't reload/store it on the; non-call path. for () {; *P += 1;; if (); call();; else; ...; ->; tmp = *P; for () {; tmp += 1;; if () {; *P = tmp;; call();; tmp = *P;; } else ...; }; *P = tmp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:31375,redund,redundant,31375,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['redund'],['redundant']
Safety,p_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/li,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23971,safe,safestack,23971,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['safe'],['safestack']
Safety,"part.; Despite the typing of this as a generic token, *only* the value defined; by a ``gc.statepoint`` is legal here. Semantics:; """""""""""""""""""". The ``gc.result`` represents the return value of the call target of; the ``statepoint``. The type of the ``gc.result`` must exactly match; the type of the target. If the call target returns void, there will; be no ``gc.result``. A ``gc.result`` is modeled as a 'readnone' pure function. It has no; side effects since it is just a projection of the return value of the; previous call represented by the ``gc.statepoint``. '``llvm.experimental.gc.relocate``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <pointer type>; @llvm.experimental.gc.relocate(token %statepoint_token,; i32 %base_offset,; i32 %pointer_offset). Overview:; """""""""""""""""". A ``gc.relocate`` returns the potentially relocated value of a pointer; at the safepoint. Operands:; """""""""""""""""". The first argument is the ``gc.statepoint`` which starts the; safepoint sequence of which this ``gc.relocation`` is a part.; Despite the typing of this as a generic token, *only* the value defined; by a ``gc.statepoint`` is legal here. The second and third arguments are both indices into operands of the; corresponding statepoint's :ref:`gc-live <ob_gc_live>` operand bundle. The second argument is an index which specifies the allocation for the pointer; being relocated. The associated value must be within the object with which the; pointer being relocated is associated. The optimizer is free to change *which*; interior derived pointer is reported, provided that it does not replace an; actual base pointer with another interior derived pointer. Collectors are; allowed to rely on the base pointer operand remaining an actual base pointer if; so constructed. The third argument is an index which specify the (potentially) derived pointer; being relocated. It is legal for this index to be the same as the second; argument if-and-only-if a base pointer is being",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:505324,safe,safepoint,505324,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safepoint']
Safety,"pd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ""Run; in background"" has been added; to the dialog box. The behaviour of Ctrl-C has also been modified: the; user is prompted for a choice among continuing asynchronously, stopping; (terminating) or aborting the query.; Add the possibility to def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:2089,avoid,avoids,2089,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['avoid'],['avoids']
Safety,"pdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; sessions .; In TProofLite: fix problem with passing the 'varexp' and 'selection'; strings for processing, preventing correct usage of the operators '|'; and '||' in TTreeFormula.; In the TProofOutputFile constructor, remove the 'localroot' prefix; only if present in the path. Fixes possible truncation problems; occuring when the paths are not under the localroot scope.; In TXSocket and TXSlave: fix problem with the way collection over a; socket just marked as 'bad' was interrupted; the interrupt was de facto; ineffective, so that collection stayed always until the timeout expired; (default: 5 minutes). Should solve some of the cases were slow response; was experienced.; Fix a problem with log path transmission when the node dies early or; not even starts. The log path was empty and wrong was filled in when; retrieving the log buffers, disorienting debugging.; F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:6291,avoid,avoid,6291,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['avoid'],['avoid']
Safety,"pe (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3830,safe,safepoints,3830,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"pe=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. ==============; AMDGPU Support; ==============. Clang supports OpenCL, HIP and OpenMP on AMD GPU targets. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__AMDGPU__``; - Indicates that the code is being compiled for an AMD GPU.; * - ``__AMDGCN__``; - Defined if the GPU target is AMDGCN.; * - ``__R600__``; - Defined if the GPU target is R600.; * - ``__<ArchName>__``; - Defined with the name of the architecture (e.g., ``__gfx906__`` for the gfx906 architecture).; * - ``__<GFXN>__``; - Defines the GFX family (e.g., for gfx906, this macro would be ``__GFX9__``).; * - ``__amdgcn_processor__``; - Defined with the processor name as a string (e.g., ``""gfx906""``).; * - ``__amdgcn_target_id__``; - Defined with the target ID as a string.; * - ``__amdgcn_feature_<feature-name>__``; - Defined for each supported target feature. The value is 1 if the feature is enabled and 0 if it is disabled. Allowed feature names are sramecc and xnack.; * - ``__AMDGCN_CUMODE__``; - Defined as 1 if the CU mode is enabled and 0 if the WGP mode is enabled.; * - ``__AMDGCN_UNSAFE_FP_ATOMICS__``; - Defined if unsafe floating-point atomics are allowed.; * - ``__AMDGCN_WAVEFRONT_SIZE__``; - Defines the wavefront size. Allowed values are 32 and 64.; * - ``__AMDGCN_WAVEFRONT_SIZE``; - Alias to ``__AMDGCN_WAVEFRONT_SIZE__``. To be deprecated.; * - ``__HAS_FMAF__``; - Defined if FMAF instruction is available (deprecated).; * - ``__HAS_LDEXPF__``; - Defined if LDEXPF instruction is available (deprecated).; * - ``__HAS_FP64__``; - Defined if FP64 instruction is available (deprecated). Please note that the specific architecture and feature names will vary depending on the GPU. Also, some macros are deprecated and may be removed in future releases.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AMDGPUSupport.rst:1381,unsafe,unsafe,1381,interpreter/llvm-project/clang/docs/AMDGPUSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AMDGPUSupport.rst,1,['unsafe'],['unsafe']
Safety,"perator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77165,safe,safety,77165,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['safe'],['safety']
Safety,"performance; hit, the model puts some restrictions on how these pointers can be used.; ``__terminated_by`` pointers cannot be indexed and can only be incremented one; element at a time. To allow these operations, the pointers must be explicitly; converted to ``__indexable`` pointers using the intrinsic function; ``__unsafe_terminated_by_to_indexable(P, T)`` (or; ``__unsafe_null_terminated_to_indexable(P)``) which converts the; ``__terminated_by`` pointer ``P`` to an ``__indexable`` pointer. * ``__null_terminated`` : The pointer or array is terminated by ``NULL`` or; ``0``. Modifying the terminator or incrementing the pointer beyond it is; prevented at run time. * ``__terminated_by(T)`` : The pointer or array is terminated by ``T`` which is; a constant expression. Accessing or incrementing the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:19454,unsafe,unsafe,19454,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"placing the data into the folder structure and; calling `TTree::Fill`. ### Tree and TRef Objects. ``` {.cpp}; MyTree->BranchRef();; ```. This call requests the construction of an optional branch supporting; table of references (**`TRefTable`**). This branch (**`TBranchRef`**); will keep all the information needed to find the branches containing; referenced objects at each `Tree::Fill`, the branch numbers containing; the referenced objects are saved in the table of references. When the; Tree header is saved (via `TTree::Write` for example), the branch is; saved, keeping the information with the pointers to the branches having; referenced objects. Enabling this optional table, allow; `TTree::Draw` to automatically load the branches needed to; dereference a **`TRef`** (or **`TRefArray`**) object. ### Autosave. `Autosave` gives the option to save all branch buffers every `n` byte.; We recommend using `Autosave` for large acquisitions. If the acquisition; fails to complete, you can recover the file and all the contents since; the last `Autosave`. To set the number of bytes between `Autosave` you; can use the `TTree::SetAutosave()` method. You can also call; **`TTree::Autosave` in the acquisition loop every `n `entry.**. ### Trees with Circular Buffers. When a **`TTree`** is memory resident, you set it up so that it retains; retain only the last few entries. For example, this can be very useful; for monitoring purpose. ``` {.cpp}; void TTree::SetCircular(Long64_t maxEntries);; ```. where `maxEntries` is the maximum number of entries to be kept in the; buffers. When the number of entries exceeds this value, the first; entries in the **`Tree`** are deleted and the buffers used again. An; example of a script using a circular buffer is shown below:. ``` {.cpp}; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:13551,recover,recover,13551,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['recover'],['recover']
Safety,"ple:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstitution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ^^^^^^^^^^^^^^^^^^^^^^^^. Now that you've created the diagnostic in the ``Diagnostic*Kinds.td`` file, you; need to write the code that detects the condition in question and emits the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:15570,avoid,avoid,15570,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['avoid'],['avoid']
Safety,"pointers against scalar values.; Unsafe usage of dispatch_once_t predicates stored in Objective-C instance variables and other heap-allocated memory.; Issues resulting from self-assignment in C++.; Incorrect usage of MPI APIs in C and C++. This check can be enabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability checks:; ; Checker warning about uses of non-localized NSStrings passed to UI methods expecting localized strings.; Checker warning when the comment argument is missing from NSLocalizedString macros.; These can be enabled by passing the following command to scan-build:.   -enable-checker alpha.osx.cocoa.NonLocalizedStringChecker,alpha.osx.cocoa.EmptyLocalizationContext",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:1362,detect,detect,1362,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['detect'],['detect']
Safety,"pose. It; must be run before register allocation takes place. After its execution, the; resulting code may no longer be in SSA form. This happens, for instance, in; situations where an instruction such as ``%a = ADD %b %c`` is converted to two; instructions such as:. ::. %a = MOVE %b; %a = ADD %a %c. Notice that, internally, the second instruction is represented as ``ADD; %a[def/use] %c``. I.e., the register operand ``%a`` is both used and defined by; the instruction. The SSA deconstruction phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. An important transformation that happens during register allocation is called; the *SSA Deconstruction Phase*. The SSA form simplifies many analyses that are; performed on the control flow graph of programs. However, traditional; instruction sets do not implement PHI instructions. Thus, in order to generate; executable code, compilers must replace PHI instructions with other instructions; that preserve their semantics. There are many ways in which PHI instructions can safely be removed from the; target code. The most traditional PHI deconstruction algorithm replaces PHI; instructions with copy instructions. That is the strategy adopted by LLVM. The; SSA deconstruction algorithm is implemented in; ``lib/CodeGen/PHIElimination.cpp``. In order to invoke this pass, the identifier; ``PHIEliminationID`` must be marked as required in the code of the register; allocator. Instruction folding; ^^^^^^^^^^^^^^^^^^^. *Instruction folding* is an optimization performed during register allocation; that removes unnecessary copy instructions. For instance, a sequence of; instructions such as:. ::. %EBX = LOAD %mem_address; %EAX = COPY %EBX. can be safely substituted by the single instruction:. ::. %EAX = LOAD %mem_address. Instructions can be folded with the; ``TargetRegisterInfo::foldMemoryOperand(...)`` method. Care must be taken when; folding instructions; a folded instruction can be quite different from the; original instruction. See ``LiveIntervals::addInte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:68169,safe,safely,68169,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['safe'],['safely']
Safety,"ppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15210,recover,recover,15210,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,2,['recover'],"['recover', 'recoverable']"
Safety,"presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // dir is tainted if path was tainted; - Name: dirname; SrcArgs: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4007,avoid,avoiding,4007,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['avoid'],['avoiding']
Safety,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180149,detect,detection,180149,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detection']
Safety,"preted as describing a sequence of pointers and their corresponding; base pointers. If the Location is of size N x sizeof(pointer), then; there will be N records of one pointer each contained within the Location.; Both Locations in a pair can be assumed to be of the same size. Note that the Locations used in each section may describe the same; physical location. e.g. A stack slot may appear as a deopt location,; a gc base pointer, and a gc derived pointer. The LiveOut section of the StkMapRecord will be empty for a statepoint; record. Safepoint Semantics & Verification; ==================================. The fundamental correctness property for the compiled code's; correctness w.r.t. the garbage collector is a dynamic one. It must be; the case that there is no dynamic trace such that an operation; involving a potentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly establ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:23803,safe,safepoint,23803,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-7766).; * Change `TGraph::ComputeRange`: in case of log scale the minimum along X and; Y axis are now set to the lowest positive values of the graph. Previously a % of the; maximum was used which may hide some points like in the following example; ``` {.cpp}; {; TGraph * gr = new TGraph(10);; for (int i = 0;i<10;i++) gr->SetPoint(i,i,TMath::Exp(-10.0*i));; for (int i = 5;i<10;i++) gr->SetPoint(i,i,0.);; gr->Draw(""apl"");; gr->SetMarkerStyle(20);; gPad->SetLogy(true);; }; ```; The problem was reported [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20484). ### TGraph2D. Add a new implementation for Delauney interpolation using the triangle code from Jonathan Shewchuk, see [[ http://www.cs.cmu.edu/~quake/triangle.html ]]. ; A new class for Delauney triangulator and interpolation has been added in the MathCore library ( `ROOT::Math::Delauney2D` ). ### Fitting. * Improve thread safety of TH1::Fit by making static member of TVirtualFitter and TMinuitMinimizer thread local. This fixes [ROOT-7791].; * Fix some bugs in TF1NormSum (to fit normalized sum of functions) and in TF1Convolution; * Add a new histogram fitting option, `WIDTH` to fit directly density. The bin content in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:12824,safe,safety,12824,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['safe'],['safety']
Safety,"produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; compares. GCC produces multiple branches, which is much nicer:. compare:; subl $12, %esp; movl 20(%esp), %edx; movl 16(%esp), %eax; decl %edx; jle .L7; .L5:; addl $12, %esp; ret; .p2align 4,,7; .L7:; jl .L4; cmpl $0, %eax; .p2align 4,,8; ja .L5; .L4:; .p2align 4,,9; call abort. //===---------------------------------------------------------------------===//. Tail call optimization improvements: Tail call optimization currently; pushes all arguments on the top of the stack (their normal place for; non-tail call optimized calls) that source from the callers arguments; or that source from a virtual register (also possibly sourcing from; callers arguments).; This is done to prevent overwriting of parameters (see example; below) that might be used later. example: . int callee(int32, int64); ; int caller(int32 arg1, int32 arg2) { ; int64 local = arg2 * 2; ; return callee(arg2, (int64)local); ; }. [arg1] [!arg2 no longer valid since we moved local onto it]; [arg2] -> [(int64); [RETADDR] local ]. Moving arg1 onto the stack slot of callee function would overwrite; arg2 of the caller. Possible optimizations:. - Analyse the actual parameters of the callee to see which would; overwrite a caller parameter which is used by the callee and only; push them onto th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:17900,abort,abort,17900,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['abort'],['abort']
Safety,"program location is used to select the call; frame information entry, and further execution of the thread occurs.*. *A DWARF expression can be used to compute a location description for an object.; A subsequent DWARF expression evaluation can be given the object location; description as the object context or initial stack context to compute a; component of the object. The final result is undefined if the object location; description becomes invalid between the two expression evaluations.*. A change of a thread's program location may not make a location description; invalid, yet may still render it as no longer meaningful. Accessing such a; location description, or using it as the object context or initial stack context; of an expression evaluation, may produce an undefined result. *For example, a location description may specify a register that no longer holds; the intended program object after a program location change. One way to avoid; such problems is to recompute location descriptions associated with threads when; their program locations change.*. .. _amdgpu-dwarf-operation-expressions:. A.2.5.4 DWARF Operation Expressions; +++++++++++++++++++++++++++++++++++. An operation expression is comprised of a stream of operations, each consisting; of an opcode followed by zero or more operands. The number of operands is; implied by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:63860,avoid,avoid,63860,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoid']
Safety,"ption:`--select-types`). :program:`llvm-debuginfo-analyzer` can also compare a set of logical; views (:option:`--compare`), to find differences and identify possible; debug information syntax issues (:option:`--warning`) in any object file. OPTIONS; -------; :program:`llvm-debuginfo-analyzer` options are separated into several; categories, each tailored to a different purpose:. * :ref:`general_` - Standard LLVM options to display help, version, etc.; * :ref:`attributes_` - Describe how to include different details when; printing an element.; * :ref:`print_` - Specify which elements will be included when printing; the view.; * :ref:`output_` - Describe the supported formats when printing the view.; * :ref:`report_` - Describe the format layouts for view printing.; * :ref:`select_` - Allows to use specific criteria or conditions to; select which elements to print.; * :ref:`compare_` - Compare logical views and print missing and/or; added elements.; * :ref:`warning_` - Print the warnings detected during the creation; of the view.; * :ref:`internal_` - Internal analysis of the logical view. .. _general_:. GENERAL; ~~~~~~~; This section describes the standard help options, used to display the; usage, version, response files, etc. .. option:: -h, --help. Show help and usage for this command. (--help-hidden for more). .. option:: --help-list. Show help and usage for this command without grouping the options; into categories (--help-list-hidden for more). .. option:: --help-hidden. Display all available options. .. option:: --print-all-options. Print all option values after command line parsing. .. option:: --print-options. Print non-default options after command line parsing. .. option:: --version. Display the version of the tool. .. option:: @<FILE>. Read command-line options from `<FILE>`. If no input file is specified, :program:`llvm-debuginfo-analyzer`; defaults to read `a.out` and return an error when no input file is found. If `-` is used as the input file, :program:`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:3178,detect,detected,3178,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['detect'],['detected']
Safety,"ptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwise, conditionally thread safe. The read and write APIs provide templated, compile-time type-safe APIs,; APIs where the type at hand is passed as string and which are runtime type-safe,; and type-unsafe APIs using void pointers. On I/O errors and invalid input, RNTuple classes throw an `RException`. Walkthrough: Reading Data; -------------------------. ```c++; auto file = std::make_unique<TFile>(""data.root"");; auto ntuple = std::unique_ptr<RNTuple>(file->Get<RNTuple>(""ntpl""));. // Option 1: entire row; // The reader creates a page source; the page source creates a model from the on-disk information; auto reader = RNTupleReader::Open(ntuple);; // Populate the objects that are used in the model's default entry; reader->LoadEntry(0);; std::shared_ptr<float> pt = reader->GetDefaultEntry().GetPtr<float>(""pt"");. // Option 2: imposed model; auto model = RNTupleModel::Create();; auto pt = model->MakeField<float>(""pt"");; // The reader checks the passed model for compatibility; only the subset of fields defined in the model is read; auto reader = RNTupleReader::Open(std::move(model), ntuple);; reader->LoadEntry(0);. // Opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:2093,safe,safe,2093,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,3,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"put is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the computation of safety can always be forced:. ~~~{.cpp}; Double_t safety = gGeoManager->Safety();; ~~~. \anchor GP02gd; #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ~~~{.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ~~~. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; by a previous TGeoManager::FindNextBoundary() cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:80347,safe,safety,80347,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"putation functions for PDFs that enable significantly faster fittings._; #### Note: This library is still at an experimental stage. Tests are being conducted continuously to ensure correctness of the results, but the interfaces and the instructions on how to use might change. ### Purpose; While fitting, a significant amount of time and processing power is spent on computing the probability function for every event and PDF involved in the fitting model. To speed up this process, roofit can use the computation functions provided in this library. The functions provided here process whole data arrays (batches) instead of a single event at a time, as in the legacy evaluate() function in roofit. In addition, the code is written in a manner that allows for compiler optimizations, notably auto-vectorization. This library is compiled multiple times for different [vector instruction set architectures](https://en.wikipedia.org/wiki/SIMD) and the optimal code is executed during runtime, as a result of an automatic hardware detection mechanism that this library contains. **As a result, fits can benefit by a speedup of 3x-16x.**. As of ROOT v6.26, RooBatchComputes also provides multithread and [CUDA](https://en.wikipedia.org/wiki/CUDA) instances of the computation functions, resulting in even greater improvements for fitting times. ### How to use; This library is an internal component of RooFit, so users are not supposed to actively interact with it. Instead, they can benefit from significantly faster times for fitting by calling `fitTo()` and providing a `BatchMode(""cpu"")` or a `BatchMode(""cuda"")` option.; ``` {.cpp}; // fit using the most efficient library that the computer's CPU can support; RooMyPDF.fitTo(data, BatchMode(""cpu""));. // fit using the CUDA library along with the most efficient library that the computer's CPU can support; RooMyPDF.fitTo(data, BatchMode(""cuda""));; ```; **Note: In case the system does not support vector instructions, the `RooBatchCompute::Cpu` optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:1275,detect,detection,1275,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['detect'],['detection']
Safety,"qual to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53110,unsafe,unsafe,53110,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe']
Safety,"que_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:5795,recover,recoverable-errors,5795,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['recover'],['recoverable-errors']
Safety,"quences to the above ones. However, these are still very marginally; slower, as there are fewer ports able to dispatch shift instructions in most; modern x86 processors than there are for `or` instructions. Fast, single register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; shrxq %rax, %rsi, %rsi # Shift away bits if misspeculating.; movl (%rsi), %edi; ```. This will collapse the register to zero or one, and everything but the offset; in the addressing mode to be less than or equal to 9. This means the full; address can only be guaranteed to be less than `(1 << 31) + 9`. The OS may wish; to protect an extra page of the low address space to account for this. ##### Optimizations. A very large portion of the cost for this approach comes from checking loads in; this way, so it is important to work to optimize this. However, beyond making; the instruction sequences to *apply* the checks efficient (for example by; avoiding `pushfq` and `popfq` sequences), the only significant optimization is; to check fewer loads without introducing a vulnerability. We apply several; techniques to accomplish that. ###### Don't check loads from compile-time constant stack offsets. We implement this optimization on x86 by skipping the checking of loads which; use a fixed frame pointer offset. The result of this optimization is that patterns like reloading a spilled; register or accessing a global field don't get checked. This is a very; significant performance win. ###### Don't check dependent loads. A core part of why this mitigation strategy works is that it establishes a; data-flow check on the loaded address. However, this means that if the address; itself was already loaded using a checked load, there is no need to check a; dependent load provided it is within the same basic block as the checked load,; and therefore has no additional predicates guarding it. Consider code like the; following:; ```; ... .LBB0_4: # %danger; movq (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:34739,avoid,avoiding,34739,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['avoid'],['avoiding']
Safety,"r (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <select> with TGListBox/TGCombobox and emit InputSelected(const char *name, const char *val) when changing selection. TGHtmlBrowser. Added the possibility to save current html page in a local file. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:1832,avoid,avoid,1832,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,1,['avoid'],['avoid']
Safety,"r is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131821,detect,detected,131821,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detected']
Safety,"r new loop(s). This allows additional attributes; including followup-transformations to be specified. Specifying multiple; transformations in the same metadata node is possible for compatibility; reasons, but their execution order is undefined. For instance, when; ``llvm.loop.vectorize.enable`` and ``llvm.loop.unroll.enable`` are; specified at the same time, unrolling may occur either before or after; vectorization. As an example, the following instructs a loop to be vectorized and only; then unrolled. .. code-block:: llvm. !0 = distinct !{!0, !1, !2, !3}; !1 = !{!""llvm.loop.vectorize.enable"", i1 true}; !2 = !{!""llvm.loop.disable_nonforced""}; !3 = !{!""llvm.loop.vectorize.followup_vectorized"", !{""llvm.loop.unroll.enable""}}. If, and only if, no followup is specified, the pass may add attributes itself.; For instance, the vectorizer adds a ``llvm.loop.isvectorized`` attribute and; all attributes from the original loop excluding its loop vectorizer; attributes. To avoid this, an empty followup attribute can be used, e.g. .. code-block:: llvm. !3 = !{!""llvm.loop.vectorize.followup_vectorized""}. The followup attributes of a transformation that cannot be applied will; never be added to a loop and are therefore effectively ignored. This means; that any followup-transformation in such attributes requires that its; prior transformations are applied before the followup-transformation.; The user should receive a warning about the first transformation in the; transformation chain that could not be applied if it a forced; transformation. All following transformations are skipped. Pass-Specific Transformation Metadata; =====================================. Transformation options are specific to each transformation. In the; following, we present the model for each LLVM loop optimization pass and; the metadata to influence them. Loop Vectorization and Interleaving; -----------------------------------. Loop vectorization and interleaving is interpreted as a single; transformation. It",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:4666,avoid,avoid,4666,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoid']
Safety,"r shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These operations are required to be atomic in the sense that if you use; unordered loads and unordered stores, a load cannot see a value which was; never stored. A normal load or store instruction is usually sufficient, but; note that an unordered load or store cannot be split into multiple; instructions (or an instruction which does multiple memory operations, like; ``LDRD`` on ARM without LPAE, or not naturally-aligned ``LDRD`` on LPAE ARM). Monotonic; ---------. Monotonic is the weakest level of atomicity that can be used in synchronization; primitives, although it does not provide any general synchronization. It; essentially guarantees that if you take all the operations affecting a specific; address, a consistent ordering exists. Relevant standard; This corresponds to the C++/C ``memory_order_relaxed``; see those; standards for the exact definition. Notes for frontends; If",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:9422,safe,safe,9422,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['safe'],['safe']
Safety,"r that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereference (``*p``), array subscript (``p[i]``), member access (``p->``), and; pointer arithmetic, with some restrictions on bounds-unsafe uses. ``-fbounds-safety`` has a set of ""internal"" bounds annotations to turn pointers; into wide pointers. These are ``__bidi_indexable`` and ``__indexable``. When a; pointer has either of these annotations, the compiler changes the pointer to the; corresponding wide pointer. This means these annotations will break the ABI and; will not be compatible with plain C, and thus they should generally not be used; in ABI surfaces. * ``__bidi_indexable`` : A pointer with this annotation becomes a wide pointer; to carry the upper bound and the lower bound, the layout of which is; equivalent to ``struct { T *ptr; T *upper_bound; T *lower_bound; };``. As the; name indicates, pointers with this annotation are ""bidirectionally indexable"",; meaning that they can be indexed with either a negative or a positive offset; and the pointers can be incremented or decremented using pointer arithmetic. A; ``__bidi_indexable`` pointer is allowed to hold an out-of-bounds pointer; value. While creating an OOB pointer is undefined behavior in C,; ``-fbounds-safety`` m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:13821,safe,safety,13821,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"r to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::generateNonFatalErrorNode for emitting bug reports.; Most importantly, never emit report against CheckerContext::getPredecessor.; Prefer checkPreCall and checkPostCall to; checkPreStmt<CallExpr> and checkPostStmt<CallExpr>.; Use CallDescription to detect hardcoded API calls in the program.; Simplify C.getState()->getSVal(E, C.getLocationContext()) to C.getSVal(E). Common sources of crashes:. CallEvent::getOriginExpr is nullable - for example, it returns null for an; automatic destructor of a variable. The same applies to some values generated while the; call was modeled, eg. SymbolConjured::getStmt is nullable.; CallEvent::getDecl is nullable - for example, it returns null for a; call of symbolic function pointer.; addTransition, generateSink, generateNonFatalErrorNode,; generateErrorNode are nullable because you can transition to a node that you have already visited.; Methods of CallExpr/FunctionDecl/Ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:24060,safe,safe,24060,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['safe'],['safe']
Safety,"r) - tmp_ptr < tmp_count) trap();; sbuf->buf = tmp_ptr;; sbuf->count = tmp_count;; }. Whether the compiler can optimize such run-time checks depends on how the upper; bound of the pointer is derived. If the source pointer has ``__sized_by``,; ``__counted_by``, or a variant of such, the compiler assumes that the upper; bound calculation doesn't overflow, e.g., ``ptr + size`` (where the type of; ``ptr`` is ``void *__sized_by(size)``), because when the ``__sized_by`` pointer; is initialized, ``-fbounds-safety`` inserts run-time checks to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()``, the upper; bound of ``tmp_ptr`` is derived from ``void *__sized_by_or_null(size)``, which; is the return type of ``malloc()``. Hence, the pointer arithmetic doesn't; overflow or ``tmp_ptr`` is null. Therefore, if ``nelems`` was given as a; compile-time constant, the compiler could remove the checks. Cast rules; ----------. ``-fbounds-safety`` does not enforce overall type safety and bounds invariants; can still be violated by incorrect casts in some cases. That said,; ``-fbounds-safety`` prevents type conversions that change bounds attributes in a; way to violate the bounds invariant of the destination's pointer annotation.; Type conversions that change bounds attributes may be allowed if it does not; violate the invariant of the destination or that can be verified at run time.; Here are some of the important cast rules. Two pointers that hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:38492,safe,safety,38492,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"r) or 'random' (the 'broken' sort order prior to this release). IMPORTANT enhancement in TTree::Fill:; Slides from a recent seminar describing the main features of ROOT IO and Trees and the recent; improvements described below are available at; http://root.cern/files/brun_lcgapp09.pptx ; or; http://root.cern/files/brun_lcgapp09.pdf .; The baskets are flushed and the Tree header saved at regular intervals (See AutoFlush and OptimizeBaskets); When the amount of data written so far (fTotBytes) is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region.; When the first call to flush the baskets happens, we also take this opportunity to optimize the baskets buffers.; We also check if the number of bytes written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes.; Note that the user can also decide to call FlushBaskets and AutoSave in her event loop on the base of the number of events written instead of the number of bytes written.; New function TTree::OptimizeBaskets. void TTree::OptimizeBaskets(Int_t maxMemory, Float_t minComp, Option_t *option). This function may be called after having filled some entries in a Tree; using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed.; This function may also be called on an existing Tree to figure out the best values; given the information in the Tree header. TFile ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html:4051,recover,recoverable,4051,tree/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html,1,['recover'],['recoverable']
Safety,"r, and a gc derived pointer. The LiveOut section of the StkMapRecord will be empty for a statepoint; record. Safepoint Semantics & Verification; ==================================. The fundamental correctness property for the compiled code's; correctness w.r.t. the garbage collector is a dynamic one. It must be; the case that there is no dynamic trace such that an operation; involving a potentially relocated pointer is observably-after a; safepoint which could relocate it. 'observably-after' is this usage; means that an outside observer could observe this sequence of events; in a way which precludes the operation being performed before the; safepoint. To understand why this 'observable-after' property is required,; consider a null comparison performed on the original copy of a; relocated pointer. Assuming that control flow follows the safepoint,; there is no way to observe externally whether the null comparison is; performed before or after the safepoint. (Remember, the original; Value is unmodified by the safepoint.) The compiler is free to make; either scheduling choice. The actual correctness property implemented is slightly stronger than; this. We require that there be no *static path* on which a; potentially relocated pointer is 'observably-after' it may have been; relocated. This is slightly stronger than is strictly necessary (and; thus may disallow some otherwise valid programs), but greatly; simplifies reasoning about correctness of the compiled code. By construction, this property will be upheld by the optimizer if; correctly established in the source IR. This is a key invariant of; the design. The existing IR Verifier pass has been extended to check most of the; local restrictions on the intrinsics mentioned in their respective; documentation. The current implementation in LLVM does not check the; key relocation invariant, but this is ongoing work on developing such; a verifier. Please ask on llvm-dev if you're interested in; experimenting with the current",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:24176,safe,safepoint,24176,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"r.GetFile();; TNtuple ntrand(""ntrand"", ""Random Numbers"", ""r"");; fill(ntrand, nEventsPerWorker);; ntrand.Write();; f->Write();; };; ```. ## Language Bindings. - Add in PyROOT the converter for std::string_view; - Fix ROOT-8811: pickling of ROOT.Long now works; - Fix ROOT-8809: push_back on a vector of pointers; - Fix ROOT-8805: itemsize was not set on buffers returned by PyROOT functions. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - rlibmap has been removed; it was deprecated for three years.; - Added the CMake exported ROOT libraries into the ROOT:: namespace. In this way, projects based on CMake using ROOT can avoid; conflicts in library target names. As an example, this is the way to build a project consisting of one library and one; executable using ROOT.; ```; find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}). include_directories(${CMAKE_SOURCE_DIR} ${ROOT_INCLUDE_DIRS}); add_definitions(${ROOT_CXX_FLAGS}). ROOT_GENERATE_DICTIONARY(G__Event Event.h LINKDEF EventLinkDef.h). add_library(Event SHARED Event.cxx G__Event.cxx); target_link_libraries(Event ROOT::Hist ROOT::Tree). add_executable(Main MainEvent.cxx); target_link_libraries(Main Event); ```; - Added option `builtin_all` to enable all the built in options.; - For rootcling_stage1 (formerly known as rootcling_tmp), the package structure was changed to enable homogenous visibility; settings across object files. See core/README for an overview.; - Several non-public headers are not copied into include/ anymore; they reside in the PACKAGE/res/ subdirectory in the source tree.; - The IMT switch is set to on by default.; - A new library is now created, libImt. It contains all classes which depend on TBB. Those classes were previously part of libThread. As a consequence rootcling/genreflex do not depend anymore from TBB even in presence of imt builds.; - Refactoring of several math tests to avoid exact comparisons of floating point numbers; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:18948,avoid,avoid,18948,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['avoid'],['avoid']
Safety,"r: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from 4D-vectors based on mass to standard (x,y,z,t) vectors, when the mass is zero. In this case, a numerical error creates artificially small negative masses returned by the (x,y,z,t) vector. Eventually a protection could be added when calculating M2(), to avoid negative values due to numerical rounding.; ; Fix a problem in the assignment operator of the ROOT::Math::PxPyPzM4D class. Avoid having nan when converting for example from PxPyPzME4D to PxPyPzM4D when the mass is negative. ; Throw always exception in the no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:3817,avoid,avoid,3817,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['avoid'],['avoid']
Safety,"r=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77627,recover,recover,77627,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recover']
Safety,"r` option. The timing data is stored in the `test_exec_root` in a file named; `.lit_test_times.txt`. If this file does not exist, then `lit` checks the; `test_source_root` for the file to optionally accelerate clean builds. .. option:: --shuffle. Run the tests in a random order, not failing/slowest first. Deprecated,; use :option:`--order` instead. .. option:: --per-test-coverage. Emit the necessary test coverage data, divided per test case (involves; setting a unique value to LLVM_PROFILE_FILE for each RUN). The coverage; data files will be emitted in the directory specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --ru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:6554,timeout,timeout,6554,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['timeout'],['timeout']
Safety,"racts a constant `KahanSum` term after each likelihood evaluation), this can add up to significant numerical divergence. An improved algorithm was implemented, based on an algorithm for combining Kahan sums and carry terms (Tian et al. 2012). (PR #11940); - The auto-conversion to type `T` and implicit type `T` constructor in `KahanSum` made it hard to debug `KahanSum`, because it is easy to overlook implicit conversions in code, especially in lines where the type of the return value is `auto`. These auto-conversions were removed. Where necessary, they should be replaced with an explicit construction or explicit conversion to double via `Sum()`. (PR #11941); - Binary addition and subtraction operators were added, as well as a unary negation operator. (PR #11940); - Comparison operators `operator==` and `operator!=` were added. ### Foam. The usage of `TRef` in the `TFoamCell` class has ben replaced with array indices. This avoids, when generating a large number of toys requiring a re-initialization of `TFoam` an increase in the memory usage caused by `TRef`. ### RVec. - a number of new helper functions have been added to [RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): [Range](https://root.cern/doc/master/group__vecops.html#ga59cc6e477803f2bfd7dae29e56048cc1), [Product](https://root.cern/doc/master/group__vecops.html#ga25e4c2cf5c82fe56dd6bbc86b2386b69) and Enumerate; - the [Take](https://root.cern/doc/master/group__vecops.html#gac719439afb1ec9d32a28acdc7aee5948) helper function now allows passing a default value that will be used to fill the output array in case it's longer than the input. ## RooFit Libraries. ### Consistent definition of the default minimizer type for all of RooFit/RooStats. In previous releases, the default minimizer type that RooFit used was hardcoded to be the original `Minuit`, while RooStats used the default minimizer specified by `ROOT::Math::MinimizerOptions::DefaultMinimizerType()`. Now it is possible to centrally define ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:17989,avoid,avoids,17989,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoids']
Safety,"ragma clang arc_cf_code_audited begin; ...; #pragma clang arc_cf_code_audited end. All C functions declared within the extent of this pragma are treated as if; annotated with the ``cf_audited_transfer`` attribute unless they otherwise have; the ``cf_unknown_transfer`` attribute. The pragma is accepted in all language; modes. A program is ill-formed if it attempts to change files, whether by; including a file or ending the current file, within the extent of this pragma. It is possible to test for all the features in this section with; ``__has_feature(arc_cf_code_audited)``. .. admonition:: Rationale. A significant inconvenience in ARC programming is the necessity of; interacting with APIs based around C retainable pointers. These features are; designed to make it relatively easy for API authors to quickly review and; annotate their interfaces, in turn improving the fidelity of tools such as; the static analyzer and ARC. The single-file restriction on the pragma is; designed to eliminate the risk of accidentally annotating some other header's; interfaces. .. _arc.runtime:. Runtime support; ===============. This section describes the interaction between the ARC runtime and the code; generated by the ARC compiler. This is not part of the ARC language; specification; instead, it is effectively a language-specific ABI supplement,; akin to the ""Itanium"" generic ABI for C++. Ownership qualification does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:105136,risk,risk,105136,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['risk'],['risk']
Safety,"ral options when creating http server. They could be add as additional URL parameters to the constructor arguments like:. ```cpp; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; ```. Following URL parameters are supported:. | Name | Description |; | :-------------------- | :---------------- |; | thrds=N | number of threads used by the civetweb (default is 10) |; | top=name | configure top name, visible in the web browser |; | auth_file=filename | authentication file name, created with htdigets utility |; | auth_domain=domain | authentication domain |; | loopback | bind specified port to loopback 127.0.0.1 address |; | debug | enable debug mode, server returns html page with request info |; | websocket_timeout=tm | set web sockets timeout in seconds (default 300) |; | websocket_disable | disable web sockets handling (default enabled) |; | cors=domain | define value for CORS header ""Access-Control-Allow-Origin"" in server response |; | log=filename | configure civetweb log file |; | max_age=value | configures ""Cache-Control: max_age=value"" http header for all file-related requests, default 3600 |; | nocache | try to fully disable cache control for file requests |; | winsymlinks=no | do not resolve symbolic links on file system (Windows only), default true |; | dirlisting=no | enable/disable directory listing for browsing filesystem (default no) |. If necessary, one could bind http server to specific IP address like:. ```cpp; new THttpServer(""http:192.168.1.17:8080""); ```. One also can provide extra arguments for THttpServer itself:. | Name | Description |; | :------------- | :---------------- |; | readonly, ro | use server in read-only mode (default) |; | readwrite, rw | use server in read-write mode |; | global | let scan global directories for canvases and files (default) |; | noglobal | disable scan of global directories |; | basic_sniffer | use basic `TRootSniffer` without support of hist, gpad, graph, tree classes |. Example:. ```cpp; new THttpServer(""h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:2075,timeout,timeout,2075,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['timeout'],['timeout']
Safety,"rality) is that it is heavily; laden with target specific assumptions. As one simple example, the; preprocessor often destructively removes target-independence from the; code when it processes the input text:. .. code-block:: c. #ifdef __i386__; int X = 1;; #else; int X = 42;; #endif. While it is possible to engineer more and more complex solutions to; problems like this, it cannot be solved in full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requires a combination of language design, runtime; support, and often operating system support. It is certainly possible to implement a safe language in LLVM, but LLVM; IR does not itself guarantee safety. The LLVM IR allows unsafe pointer; casts, use after free bugs, buffer over-runs, and a variety of other; problems. Safety needs to be implemented as a layer on top of LLVM and,; conveniently, several groups have investigated this. Ask on the `LLVM; forums <https://discourse.llvm.org>`_ if you are interested in more details. Language-Specific Optimizations; -------------------------------. One thing about LLVM that turns off many people is that it does not; solve all the world's problems in one system. One specific; complaint is that people perceive LLVM as being incapable of performing; high-level language-specific optimization: LLVM ""loses too much; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:7924,safe,safe,7924,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['safe'],['safe']
Safety,"ram`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:345276,unsafe,unsafe,345276,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"raries in expressions. They now have a natural way of ending up nested; within each other and within function calls in order to build up aggregates; (such as option structs) from local variables. The historically common formatting of braced initialization of aggregate; variables does not mix cleanly with deep nesting, general expression contexts,; function arguments, and lambdas. We suggest new code use a simple rule for; formatting braced initialization lists: act as-if the braces were parentheses; in a function call. The formatting rules exactly match those already well; understood for formatting nested function calls. Examples:. .. code-block:: c++. foo({a, b, c}, {1, 2, 3});. llvm::Constant *Mask[] = {; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 0),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings are often useful and help improve the code. Those that are; not useful, can be often suppressed with a small code change. For example, an; assignment in the ``if`` condition is often a typo:. .. code-block:: c++. if (V = getValue()) {; ...; }. Several compilers will print a warning for the code above. It can be suppressed; by adding parentheses:. .. code-block:: c++. if ((V = getValue())) {; ...; }. Write Portable Code; ^^^^^^^^^^^^^^^^^^^. In almost all cases, it is possible to write completely portable code. When; you need to rely on non-portable code, put it behind a well-defined and; well-documented interface. Do not use RTTI or Exceptions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In an effort to reduce cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:21269,predict,predictable,21269,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['predict'],['predictable']
Safety,"ration, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the impleme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8000,safe,safe,8000,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['safe'],['safe']
Safety,"rbage collectors must be able to identify; any references to objects contained within executing code, and,; depending on the collector, potentially update them. The collector; does not need this information at all points in code - that would make; the problem much harder - but only at well-defined points in the; execution known as 'safepoints' For most collectors, it is sufficient; to track at least one copy of each unique pointer value. However, for; a collector which wishes to relocate objects directly reachable from; running code, a higher standard is required. One additional challenge is that the compiler may compute intermediate; results (""derived pointers"") which point outside of the allocation or; even into the middle of another allocation. The eventual use of this; intermediate value must yield an address within the bounds of the; allocation, but such ""exterior derived pointers"" may be visible to the; collector. Given this, a garbage collector can not safely rely on the; runtime value of an address to indicate the object it is associated; with. If the garbage collector wishes to move any object, the; compiler must provide a mapping, for each pointer, to an indication of; its allocation. To simplify the interaction between a collector and the compiled code,; most garbage collectors are organized in terms of three abstractions:; load barriers, store barriers, and safepoints. #. A load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:2144,safe,safely,2144,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safely']
Safety,"rce-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7250,detect,detected,7250,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detected']
Safety,"rdered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. .. _alpha-nondeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81431,unsafe,unsafe,81431,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['unsafe'],['unsafe']
Safety,"rdering operator<=>(const HasSpaceship&) const = default;; };. bool isLess(const HasSpaceship& a, const HasSpaceship& b) {; return a < b;; }. 1 match found. return a < b;; ^~~~~. No match found. Node Matchers. Node matchers are at the core of matcher expressions - they specify the type; of node that is expected. Every match expression starts with a node matcher,; which can then be further refined with a narrowing or traversal matcher. All; traversal matchers take node matchers as their arguments.; For convenience, all node matchers take an arbitrary number of arguments; and implicitly act as allOf matchers.; Node matchers are the only matchers that support the bind(""id"") call to; bind the matched node to the given string, to be later retrieved from the; match callback.; It is important to remember that the arguments to node matchers are; predicates on the same node, just with additional information about the type.; This is often useful to make matcher expression more readable by inlining bind; calls into redundant node matchers inside another node matcher:. // This binds the CXXRecordDecl to ""id"", as the decl() matcher will stay on; // the same node.; recordDecl(decl().bind(""id""), hasName(""::MyClass"")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:8436,redund,redundant,8436,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['redund'],['redundant']
Safety,"rds; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side chan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5114,avoid,avoids,5114,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['avoid'],['avoids']
Safety,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1724,recover,recovery,1724,interpreter/cling/www/old/contact.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html,3,['recover'],['recovery']
Safety,"re information. :program:`lit` parses options from the environment variable ``LIT_OPTS`` after; parsing options from the command line. ``LIT_OPTS`` is primarily useful for; supplementing or overriding the command-line options supplied to :program:`lit`; by ``check`` targets defined by a project's build system. :program:`lit` can also read options from response files which are specified as; inputs using the ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one per line and are treated as if they were in the same place as the; original file referencing argument on the command line. A response file can; reference other response files. Users interested in the :program:`lit` architecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:2541,detect,detected,2541,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['detect'],['detected']
Safety,"re the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the top level in a file, in which case they cover all subsequent function; bodies until they're turned off. Note that it is undefined behavior to enter; code that is *not* covered by one of these pragmas from code that *is* covered; by one of these pragmas unless the floating point environment has been restored; to its default state. See the C standard for more information about these pragmas. The command line option ``-frounding-math`` behaves as if the translation unit; began with ``#pragma STDC FENV_ROUND FE_DYNAMIC``. The command line option; ``-ffp-model=strict`` behaves as if the translation unit began with ``#pragma STDC FENV_ACCESS ON``. Code that just wants to use a specific rounding mode for specific floating point; operations can avoid most of the hazards of the dynamic floating point environment; by using ``#pragma STDC FENV_ROUND`` with a value other than ``FE_DYNAMIC``. .. _crtfastmath.o:. A note about ``crtfastmath.o``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ``-ffast-math`` and ``-funsafe-math-optimizations`` cause ``crtfastmath.o`` to be; automatically linked, which adds a static constructor that sets the FTZ/DAZ; bits in MXCSR, affecting not only the current compilation unit but all static; and shared libraries included in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:71432,avoid,avoid,71432,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,"['avoid', 'hazard']","['avoid', 'hazards']"
Safety,"re variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; linear problem into a nasty non-linear one, which is the reason why; limits should be avoided if not necessary. In addition, the; transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced; in the numerical calculation of the $\mbox{FCN}$ value. The effects; of non-linearity and numerical roundoff both become more important as; the external value gets closer to one of the limits (expressed as the; distance to nearest limit divided by distance between limits). The user; must therefore be aware of the fact that, for example, if they put limits; of $(0,10^{10})$ on a parameter, then the values $0.0$ and $1.0$ will be; indistinguishable to the accuracy of most machines. For this purpose single sided limits on parameters are provided by M ,; with their transformation being:. Lower bound $a$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:8846,avoid,avoided,8846,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoided']
Safety,"re). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned as its determinant shows. We construct a vector `b` by; summing the matrix rows. Therefore, the components of the solution; vector `x` should be exactly 1. Our rule of thumb to the 2.1012; condition number predicts that the solution accuracy should be around. `15 - 12 = 3`. digits. Indeed, the largest deviation is 0.00055 in component 6. ``` {.cpp}; TMatrixDSym H = THilbertMatrixDSym(10);; TVectorD rowsum(10);; for (Int_t irow = 0; irow < 10; irow++); for (Int_t icol = 0; icol < 10; icol++); rowsum(irow) += H(irow,icol);; TDecompLU lu(H);; Bool_t ok;; TVectorD x = lu.Solve(rowsum,ok);; Double_t d1,d2;; lu.Det(d1,d2);; cout << ""cond:"" << lu.Condition() << endl;; cout << ""det :"" << d1*TMath:Power(2.,d2) << endl;; cout << ""tol :"" << lu.GetTol() << endl;; x.Print();; cond:3.9569e+12; det :2.16439e-53; tol :2.22045e-16; Vector 10 is as follows; | 1 |; ------------------; 0 |1; 1 |1; 2 |0.999997; 3 |1.00003; 4 |0.999878; 5 |1.00033; 6 |0.999452; 7 |1.00053; 8 |0.999723; 9 |1.00006; ```. ### LU. Decompose an `nxn` matrix $A$. ``` {.cpp}; PA = LU; ```. *P* permutation matrix stored in the index array `fIndex`: `j=fIndex[i]`; indicates that row j and row` i `should be swapped. Sign of the; permutation, $-1^n$, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:42582,predict,predicts,42582,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['predict'],['predicts']
Safety,"re; can be multiple inner remainder loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307723,unsafe,unsafe,307723,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"re; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21338,safe,safety,21338,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['safe'],['safety']
Safety,"read from the place by the caller after this call; exits. .. code-block:: llvm. @glb = global ptr null; @glb2 = global ptr null; @glb3 = global ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured; store ptr null, ptr @glb3. %i = ptrtoint ptr %d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145344,safe,safely,145344,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"read lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intended to encompass the results; both of pointer transformations, such as casts and arithmetic, and of loading; from such derived pointers; furthermore, it applies whether or not such; derivations are applied directly in the calling code or by other utility code; (for example, the C library routine ``strchr``). However, the implementation; never need account for uses after a return from the code which calls the; method returning an interior pointer. As an exception, no extension is required if the receiver is loaded directly; from a ``__strong`` object with :ref:`precise lifetime semantics; <arc.optimization.precise>`. .. admonition:: Rationale. Implicit autoreleases carry the risk of significantly inflating memory use,; so it's important to provide users a way of avoiding these autoreleases.; Tying this to precise lifetime semantics is ideal, as for local variables; this requires a very explicit annotation, which allows ARC to trust the user; with good cheer. .. _arc.misc.c-retainable:. C retainable pointer types; --------------------------. A type is a :arc-term:`C retainable pointer type` if it is a pointer to; (possibly qualified) ``void`` or a pointer to a (possibly qualifier) ``struct``; or ``class`` type. .. admonition:: Rationale. ARC does not manage pointers of CoreFoundation type (or any of the related; families of retainable C pointers which interoperate with Objective-C for; retain/release operation). In fact, ARC does not even know how to; distinguish these types from arbitrary C pointer types. The intent of this; concept is to filter out some obviously non-object types while leaving a hook; for later tightening if a means of exhaustively marking CF types is made; available. .. _arc.mis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:101606,risk,risk,101606,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,"['avoid', 'risk']","['avoiding', 'risk']"
Safety,"red -Wl,-G""). # Also set the correct flags for building shared libraries.; string(APPEND CMAKE_SHARED_LINKER_FLAGS "" -shared""); endif(). # Build with _XOPEN_SOURCE on z/OS.; if (CMAKE_SYSTEM_NAME MATCHES ""OS390""); add_compile_definitions(_XOPEN_SOURCE=600); add_compile_definitions(_OPEN_SYS) # Needed for process information.; add_compile_definitions(_OPEN_SYS_FILE_EXT) # Needed for EBCDIC I/O.; add_compile_definitions(_EXT) # Needed for file data.; add_compile_definitions(_UNIX03_THREADS) # Multithreading support.; endif(). # Build with _FILE_OFFSET_BITS=64 on Solaris to match g++ >= 9.; if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""SunOS""); add_compile_definitions(_FILE_OFFSET_BITS=64); endif(). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories( ${LLVM_INCLUDE_DIR} ${LLVM_MAIN_INCLUDE_DIR}). # when crosscompiling import the executable targets from a file; if(LLVM_USE_HOST_TOOLS); include(CrossCompile); llvm_create_cross_target(LLVM NATIVE """" Release); endif(LLVM_USE_HOST_TOOLS); if(LLVM_TARGET_IS_CROSSCOMPILE_HOST); # Dummy use to avoid CMake Warning: Manually-specified variables were not used; # (this is a variable that CrossCompile sets on recursive invocations); endif(). if( ${CMAKE_SYSTEM_NAME} MATCHES SunOS ); # special hack for Solaris to handle crazy system sys/regset.h; include_directories(""${LLVM_MAIN_INCLUDE_DIR}/llvm/Support/Solaris""); endif( ${CMAKE_SYSTEM_NAME} MATCHES SunOS ). # Make sure we don't get -rdynamic in every binary. For those that need it,; # use export_executable_symbols(target).; set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS """"). include(AddLLVM); include(TableGen). include(LLVMDistributionSupport). if( MINGW AND NOT ""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang"" ); # People report that -O3 is unreliable on MinGW. The traditional; # build also uses -O2 for that reason:; llvm_replace_compiler_option(CMAKE_CXX_FLAGS_RELEASE ""-O3"" ""-O2""); endif(). if(LLVM_INCLUDE_TESTS); umbrella_lit_testsuite_begin(check-all); endif(). # Put this before tblgen. El",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:47862,avoid,avoid,47862,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['avoid'],['avoid']
Safety,"rent bounds annotations on their nested pointer; types are incompatible and cannot implicitly cast to each other. For example,; ``T *__single *__single`` cannot be converted to ``T *__bidi_indexable; *__single``. Such a conversion between incompatible nested bounds annotations; can be allowed using an explicit cast (e.g., C-style cast). Hereafter, the rules; only apply to the top pointer types. ``__unsafe_indexable`` cannot be converted; to any other safe pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, etc) using a cast. The extension provides builtins to force; this conversion, ``__unsafe_forge_bidi_indexable(type, pointer, char_count)`` to; convert pointer to a ``__bidi_indexable`` pointer of type with ``char_count``; bytes available and ``__unsafe_forge_single(type, pointer)`` to convert pointer; to a single pointer of type type. The following examples show the usage of these; functions. Function ``example_forge_bidi()`` gets an external buffer from an; unsafe library by calling ``get_buf()`` which returns ``void; *__unsafe_indexable.`` Under the type rules, this cannot be directly assigned to; ``void *buf`` (implicitly ``void *__bidi_indexable``). Thus,; ``__unsafe_forge_bidi_indexable`` is used to manually create a; ``__bidi_indexable`` from the unsafe buffer. .. code-block:: c. // unsafe_library.h; void *__unsafe_indexable get_buf(void);; size_t get_buf_size(void);. // my_source1.c (enables -fbounds-safety); #include ""unsafe_library.h""; void example_forge_bidi(void) {; void *buf =; __unsafe_forge_bidi_indexable(void *, get_buf(), get_buf_size());; // ...; }. // my_source2.c (enables -fbounds-safety); #include <stdio.h>; void example_forge_single(void) {; FILE *fp = __unsafe_forge_single(FILE *, fopen(""mypath"", ""rb""));; // ...; }. * Function ``example_forge_single`` takes a file handle by calling fopen defined; in system header ``stdio.h``. Assuming ``stdio.h`` did not adopt; ``-fbounds-safety``, the return type of ``fopen`` would implicit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:40452,unsafe,unsafe,40452,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['unsafe'],['unsafe']
Safety,"reported; return ret;; }. Additionally to the argument and return value conditions, this checker also adds; state of the value ``errno`` if applicable to the analysis. Many system; functions set the ``errno`` value only if an error occurs (together with a; specific return value of the function), otherwise it becomes undefined. This; checker changes the analysis state to contain such information. This data is; used by other checkers, for example :ref:`unix-Errno`. **Limitations**. The checker can not always provide notes about the values of the arguments.; Without this information it is hard to confirm if the constraint is indeed; violated. The argument values are shown if they are known constants or the value; is determined by previous (not too complicated) assumptions. The checker can produce false positives in cases such as if the program has; invariants not known to the analyzer engine or the bug report path contains; calls to unknown functions. In these cases the analyzer fails to detect the real; range of the argument. **Parameters**. The checker models functions (and emits diagnostics) from the C standard by; default. The ``ModelPOSIX`` option enables modeling (and emit diagnostics) of; additional functions that are defined in the POSIX standard. This option is; disabled by default. .. _osx-checkers:. osx; ^^^; macOS checkers. .. _osx-API:. osx.API (C); """"""""""""""""""""""; Check for proper uses of various Apple APIs. .. code-block:: objc. void test() {; dispatch_once_t pred = 0;; dispatch_once(&pred, ^(){}); // warn: dispatch_once uses local; }. .. _osx-NumberObjectConversion:. osx.NumberObjectConversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for erroneous conversions of objects representing numbers into numbers. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:34479,detect,detect,34479,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['detect'],['detect']
Safety,"resent, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section provides changes to existing call frame information and defines; instructions added by these extensions. Additional support is added for; address spaces. Register unwind DWARF expressions are generalized to allow any; location description, including those with composite and implicit location; descriptions. These changes would be incorporated into the DWARF Version 5 section 6.4. .. _amdgpu-dwarf-structure_of-call-frame-information:. A.6.4.1 Structure of Call Frame Information; +++++++++++++++++++++++++++++++++++++++++++. The register rules are:. *undefined*; A register that has this rule has no recoverable value in the previous frame.; The previous value of this register is the undefined location description (see; :ref:`amdgpu-dwarf-undefined-location-description-operations`). *By convention, the register is not preserved by a callee.*. *same value*; This register has not been modified from the previous caller frame. If the current frame is the top frame, then the previous value of this; register is the location description L that specifies one register location; description SL. SL specifies the register location storage that corresponds to; the register with a bit offset of 0 for the current thread. If the current frame is not the top frame, then the previous value of this; register is the location description obtained using the call frame information; for the callee frame and callee program location invoked by the current caller; frame for the same register. *By convention, the register is preserved by the callee, but the callee has; not modified it.*. *offset(N)*; N i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:190610,recover,recoverable,190610,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['recover'],['recoverable']
Safety,"ression:. * v5.34/38; * v6.08/06 [not yet released]; * v6.10/08; * v6.12/02. ## Removed interfaces. ## Core Libraries; - Optimize away redundant deserialization of template specializations. This reduces the memory footprint for hsimple by around 30% while improving the runtime performance for various cases by around 15%.; - When ROOT is signaled with a SIGUSR2 (i.e. on Linux and MacOS X) it will now print a backtrace.; - Move RStringView.h to ROOT/RStringView.hxx and always include ROOT/RStringView.hxx instead of RStringView.h for backward compatibility; - In `TClingCallFunc`, support r-value reference parameters. This paves the way for the corresponding support in PyROOT (implemented now in the latest Cppyy).; - Included the new TSequentialExecutor in ROOT, sharing the interfaces of TExecutor.This should improve code economy when providing a fallback for TThreadExecutor/TProcessExecutor. ### Thread safety; - Resolved several race conditions, dead-locks, performance and order of initialization/destruction issues still lingering because of or despite the new read-write lock mechanism. ## Interpreter. - Enabled use of multi-threaded code from the interpreter.; - Previouslyl multi-threaded code could be run from the interpreter as long as the call starting the threada was the same code that initialized the ROOT global lock, any other uses, including attempting to run the same code a second time in the same session would lead to a dead lock (if any other thread attempted to take on the ROOT lock).; - The interpreter now suspend the ROOT lock (which is taken to protect the interpreter global state) during user code execution. ## I/O Libraries; - LZ4 (with compression level 4) is now the default compression algorithm for new ROOT files (LZ4 is lossless data compression algorithm that is focused on compression and decompression speed, while in ROOT case providing benefit in faster decompression at the price of a bit worse compression ratio comparing to ZLIB); - If two or mo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:2533,safe,safety,2533,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['safe'],['safety']
Safety,"returns_twice``; This attribute indicates that this function can return twice. The C; ``setjmp`` is an example of such a function. The compiler disables; some optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks are; classified as ""Spectre variant #1"". Notably, this does not attempt to; mitigate against miss-speculation of branch target, classified as; ""Spectr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:100734,safe,safety,100734,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safety']
Safety,"riable correlations, classifier output.; * New classifier visualization for BDT, ANN and DNN.; * Interactive training for all methods. ## 2D Graphics Libraries. * In `TColor::SetPalette`, make sure the high quality palettes are defined; only once taking care of transparency. Also `CreateGradientColorTable` has been; simplified.; * New fast constructor for `TColor` avoiding to call `gROOT->GetColor()`. The; normal constructor generated a big slow down when creating a Palette with; `CreateGradientColorTable`.; * In `CreateGradientColorTable` we do not need anymore to compute the highest; color index.; * In `TGraphPainter`, when graphs are painted with lines, they are split into; chunks of length `fgMaxPointsPerLine`. This allows to paint line with an ""infinite""; number of points. In some case this ""chunks painting"" technic may create artefacts; at the chunk's boundaries. For instance when zooming deeply in a PDF file. To avoid; this effect it might be necessary to increase the chunks' size using the new function:; `TGraphPainter::SetMaxPointsPerLine(20000)`.; * When using line styles different from 1 (continuous line), the behavior of TArrow; was suboptimal. The problem was that the line style is also applied to the arrow; head, which is usually not what one wants.; The arrow tip is now drawn using a continuous line.; * It is now possible to select an histogram on a canvas by clicking on the vertical; lines of the bins boundaries.; This problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-6649).; * When using time format in axis, `TGaxis::PaintAxis()` may in some cases call; `strftime()` with invalid parameter causing a crash.; This problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-7689).; * Having ""X11.UseXft: yes"" activated in .rootrc file and running; [this](https://sft.its.cern.ch/jira/browse/ROOT-7985) little program,; resulted in a crash.; * Ease the setting of the appearance of joining lines for PostScript and PDF; output. `TPo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:14566,avoid,avoid,14566,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['avoid'],['avoid']
Safety,"ries of the ``xray_instr_map``, and; overwrite the instrumentation points at runtime. Using XRay; ==========. You can use XRay in a couple of ways:. - Instrumenting your C/C++/Objective-C/Objective-C++ application.; - Generating LLVM IR with the correct function attributes. The rest of this section covers these main ways and later on how to customize; what XRay does in an XRay-instrumented binary. Instrumenting your C/C++/Objective-C Application; ------------------------------------------------. The easiest way of getting XRay instrumentation for your application is by; enabling the ``-fxray-instrument`` flag in your clang invocation. For example:. ::. clang -fxray-instrument ... By default, functions that have at least 200 instructions (or contain a loop) will; get XRay instrumentation points. You can tweak that number through the; ``-fxray-instruction-threshold=`` flag:. ::. clang -fxray-instrument -fxray-instruction-threshold=1 ... The loop detection can be disabled with ``-fxray-ignore-loops`` to use only the; instruction threshold. You can also specifically instrument functions in your; binary to either always or never be instrumented using source-level attributes.; You can do it using the GCC-style attributes or C++11-style attributes. .. code-block:: c++. [[clang::xray_always_instrument]] void always_instrumented();. [[clang::xray_never_instrument]] void never_instrumented();. void alt_always_instrumented() __attribute__((xray_always_instrument));. void alt_never_instrumented() __attribute__((xray_never_instrument));. When linking a binary, you can either manually link in the `XRay Runtime; Library`_ or use ``clang`` to link it in automatically with the; ``-fxray-instrument`` flag. Alternatively, you can statically link-in the XRay; runtime library from compiler-rt -- those archive files will take the name of; `libclang_rt.xray-{arch}` where `{arch}` is the mnemonic supported by clang; (x86_64, arm7, etc.). LLVM Function Attribute; -----------------------. If",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:2160,detect,detection,2160,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['detect'],['detection']
Safety,"ries, so dsymutil knows where to look; for dSYM files with debug information about symbols present in those; libraries. .. option:: --fat64. Use a 64-bit header when emitting universal binaries. .. option:: --flat, -f. Produce a flat dSYM file. A ``.dwarf`` extension will be appended to the; executable name unless the output file is specified using the ``-o`` option. .. option:: --gen-reproducer. Generate a reproducer consisting of the input object files. Alias for; --reproducer=GenerateOnExit. .. option:: --help, -h. Print this help output. .. option:: --keep-function-for-static. Make a static variable keep the enclosing function even if it would have been; omitted otherwise. .. option:: --minimize, -z. When used when creating a dSYM file, this option will suppress the emission of; the .debug_inlines, .debug_pubnames, and .debug_pubtypes sections since; dsymutil currently has better equivalents: .apple_names and .apple_types. When; used in conjunction with ``--update`` option, this option will cause redundant; accelerator tables to be removed. .. option:: --no-odr. Do not use ODR (One Definition Rule) for uniquing C++ types. .. option:: --no-output. Do the link in memory, but do not emit the result file. .. option:: --no-swiftmodule-timestamp. Don't check the timestamp for swiftmodule files. .. option:: --num-threads <threads>, -j <threads>. Specifies the maximum number (``n``) of simultaneous threads to use when; linking multiple architectures. .. option:: --object-prefix-map <prefix=remapped>. Remap object file paths (but no source paths) before processing. Use; this for Clang objects where the module cache location was remapped using; ``-fdebug-prefix-map``; to help dsymutil find the Clang module cache. .. option:: --oso-prepend-path <path>. Specifies a ``path`` to prepend to all debug symbol object file paths. .. option:: --out <filename>, -o <filename>. Specifies an alternate ``path`` to place the dSYM bundle. The default dSYM; bundle path is created by append",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst:2873,redund,redundant,2873,interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,1,['redund'],['redundant']
Safety,"ring formats.; #if __has_include(""myinclude.h"") && __has_include(<stdint.h>); # include ""myinclude.h""; #endif. To test for this feature, use ``#if defined(__has_include)``:. .. code-block:: c++. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include); #if __has_include(""myinclude.h""); # include ""myinclude.h""; #endif; #endif. .. _langext-__has_include_next:. ``__has_include_next``; ----------------------. This function-like macro takes a single file name string argument that is the; name of an include file. It is like ``__has_include`` except that it looks for; the second instance of the given file found in the include paths. It evaluates; to 1 if the second instance of the file can be found using the include paths,; or 0 otherwise:. .. code-block:: c++. // Note the two possible file name string formats.; #if __has_include_next(""myinclude.h"") && __has_include_next(<stdint.h>); # include_next ""myinclude.h""; #endif. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include_next); #if __has_include_next(""myinclude.h""); # include_next ""myinclude.h""; #endif; #endif. Note that ``__has_include_next``, like the GNU extension ``#include_next``; directive, is intended for use in headers only, and will issue a warning if; used in the top-level compilation file. A warning will also be issued if an; absolute path is used in the file argument. ``__has_warning``; -----------------. This function-like macro takes a string literal that represents a command line; option for a warning and returns true if that is a valid warning option. .. code-block:: c++. #if __has_warning(""-Wformat""); ...; #endif. .. _languageextensions-builtin-macros:. Builtin Macros; ==============. ``__BASE_FILE__``; Defined to a string that contains the name of the main input file passed to; Clang. ``__FILE_NAME__``; Clang-specific extension that functions similar to ``__FILE__`` but only; renders the last path component (the filename) i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:11446,avoid,avoid,11446,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"ring>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities, while ``RELEASE`` implies that; a function releases all associated capabilities in whatever mode they're held. TRY_ACQUIRE(<bool>, ...), TRY_ACQUIRE_SHARED(<bool>, ...); ---------------------------------------------------------. *Previously:* ``EXCLUSIVE_TRYLOCK_FUNCTION``, ``SHARED_TRYLOCK_FUNCTION``. These are attributes on a function or method that tries to acquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the firs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13764,safe,safety,13764,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"rinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. // And for each live root...; for (GCFunctionInfo::live_iterator LI = MD.live_begin(PI),; LE = MD.live_end(PI);; LI != LE; ++LI) {; // Emit live root's offset within the stack frame.; OS.AddComment(""stack index (offset / wordsize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37926,safe,safe,37926,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ript update. Commit ``UM8``; updates a submodule of local project ``myproj``. The tool ``zip-downstream-fork.py`` at; https://github.com/greened/llvm-git-migration/tree/zip can be used to; convert the umbrella history into a monorepo-based history with; commits in the order implied by submodule updates::. U1 - U2 - U3 <- upstream/main; \ \ \; \ -----\--------------- local/zip--.; \ \ \ |; - Lllvm1 - Llld1 - UM3 - Lclang1 - Lclang2 - Lllvm2 - Llld2 - Lmyproj1 <-'. The ``U*`` commits represent upstream commits to the monorepo main; branch. Each submodule update in the local ``UM*`` commits brought in; a subproject tree at some local commit. The trees in the ``L*1``; commits represent merges from upstream. These result in edges from; the ``U*`` commits to their corresponding rewritten ``L*1`` commits.; The ``L*2`` commits did not do any merges from upstream. Note that the merge from ``U2`` to ``Lclang1`` appears redundant, but; if, say, ``U3`` changed some files in upstream clang, the ``Lclang1``; commit appearing after the ``Llld1`` commit would actually represent a; clang tree *earlier* in the upstream clang history. We want the; ``local/zip`` branch to accurately represent the state of our umbrella; history and so the edge ``U2 -> Lclang1`` is a visual reminder of what; clang's tree actually looks like in ``Lclang1``. Even so, the edge ``U3 -> Llld1`` could be problematic for future; merges from upstream. git will think that we've already merged from; ``U3``, and we have, except for the state of the clang tree. One; possible mitigation strategy is to manually diff clang between ``U2``; and ``U3`` and apply those updates to ``local/zip``. Another,; possibly simpler strategy is to freeze local work on downstream; branches and merge all submodules from the latest upstream before; running ``zip-downstream-fork.py``. If downstream merged each project; from upstream in lockstep without any intervening local commits, then; things should be fine without any special action. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:25705,redund,redundant,25705,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['redund'],['redundant']
Safety,"rison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:21592,redund,redundant,21592,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['redund'],['redundant']
Safety,"rker process has its; ``stdout``/``stderr`` redirected to ``fuzz-<JOB>.log``.; ``-workers``; Number of simultaneous worker processes to run the fuzzing jobs to completion; in. If 0 (the default), ``min(jobs, NumberOfCpuCores()/2)`` is used.; ``-dict``; Provide a dictionary of input keywords; see Dictionaries_.; ``-use_counters``; Use `coverage counters`_ to generate approximate counts of how often code; blocks are hit; defaults to 1.; ``-reduce_inputs``; Try to reduce the size of inputs while preserving their full feature sets;; defaults to 1.; ``-use_value_profile``; Use `value profile`_ to guide corpus expansion; defaults to 0.; ``-only_ascii``; If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0.; ``-artifact_prefix``; Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or; slow inputs) as ``$(artifact_prefix)file``. Defaults to empty.; ``-exact_artifact_path``; Ignored if empty (the default). If non-empty, write the single artifact on; failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides; ``-artifact_prefix`` and will not use checksum in the file name. Do not use; the same path for several parallel processes.; ``-print_pcs``; If 1, print out newly covered PCs. Defaults to 0.; ``-print_final_stats``; If 1, print statistics at exit. Defaults to 0.; ``-detect_leaks``; If 1 (default) and if LeakSanitizer is enabled; try to detect memory leaks during fuzzing (i.e. not only at shut down).; ``-close_fd_mask``; Indicate output streams to close at startup. Be careful, this will; remove diagnostic output from target code (e.g. messages on assert failure). - 0 (default): close neither ``stdout`` nor ``stderr``; - 1 : close ``stdout``; - 2 : close ``stderr``; - 3 : close both ``stdout`` and ``stderr``. For the full list of flags run the fuzzer binary with ``-help=1``. Output; ======. During operation the fuzzer prints information to ``stderr``, for example::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:13748,timeout,timeout,13748,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeout']
Safety,"rmine the current search direction, since this is; the optimal strategy for quadratic functions and ""physical"" functions; should be quadratic in the neighbourhood of the minimum at least. The; search directions determined by $\mbox{MIGRAD}$ are guaranteed to be; downhill only if the covariance matrix is positive–definite, so in case; this is not true, it makes a positive–definite approximation by adding; an appropriate constant along the diagonal as determined by the; eigenvalues of the matrix. Theoretically, the covariance matrix for a; ""physical"" function must be positive–definite at the minimum, although; it may not be so for all points far away from the minimum, even for a; well–determined physical problem. Therefore, if $\mbox{MIGRAD}$; reports that it has found a non-positive–definite covariance matrix,; this may be a sign of one or more of the following:. - **A non–physical region.** On its way to the minimum,; $\mbox{MIGRAD}$ may have traversed a region which has unphysical; behaviour, which is of course not a serious problem as long as it; recovers and leaves such a region. - **An underdetermined problem.** If the matrix is not; positive–definite even at the minimum, this may mean that the; solution is not well–defined, for example that there are more; unknowns than there are data points, or that the parametrization of; the fit contains a linear dependence. If this is the case, then M; (or any other program) cannot solve your problem uniquely, and the; error matrix will necessarily be largely meaningless, so the user; must remove the under-determinedness by reformulating the; parametrization. M cannot do this itself, but it can provide some; hints (contours, global correlation coefficients, eigenvalues) which; can help the clever user to find out what is wrong. - **Numerical inaccuracies.** It is possible that the apparent lack of; positive–definiteness is in fact only due to excessive roundoff; errors in numerical calculations, either in $\mbox{FCN}$ or in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:72195,recover,recovers,72195,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['recover'],['recovers']
Safety,"rom http://gcc.gnu.org/ml/gcc-patches/2004-09/msg01148.html,; but without the unnecessary and.); movl %ecx, %eax; shrl $5, %eax; movl %eax, %edx; xorl $1, %edx; sall %cl, %eax; sall %cl. %edx. 64-bit shifts (in general) expand to really bad code. Instead of using; cmovs, we should expand to a conditional branch like GCC produces. //===---------------------------------------------------------------------===//. Some isel ideas:. 1. Dynamic programming based approach when compile time is not an; issue.; 2. Code duplication (addressing mode) during isel.; 3. Other ideas from ""Register-Sensitive Selection, Duplication, and; Sequencing of Instructions"".; 4. Scheduling for reduced register pressure. E.g. ""Minimum Register; Instruction Sequence Problem: Revisiting Optimal Code Generation for DAGs""; and other related papers.; http://citeseer.ist.psu.edu/govindarajan01minimum.html. //===---------------------------------------------------------------------===//. Should we promote i16 to i32 to avoid partial register update stalls?. //===---------------------------------------------------------------------===//. Leave any_extend as pseudo instruction and hint to register; allocator. Delay codegen until post register allocation.; Note. any_extend is now turned into an INSERT_SUBREG. We still need to teach; the coalescer how to deal with it though. //===---------------------------------------------------------------------===//. It appears icc use push for parameter passing. Need to investigate. //===---------------------------------------------------------------------===//. The instruction selector sometimes misses folding a load into a compare. The; pattern is written as (cmp reg, (load p)). Because the compare isn't; commutative, it is not matched with the load on both sides. The dag combiner; should be made smart enough to canonicalize the load into the RHS of a compare; when it can invert the result of the compare for free. //===------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:2039,avoid,avoid,2039,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['avoid'],['avoid']
Safety,"roven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2704,safe,safety,2704,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"rpreter, this gives the name ""`UserFun`"" to the; thread. This name can be used to retrieve the thread later. However,; when called from compiled code, this method does not give any name to; the thread. So give a name to the thread in compiled use:. ``` {.cpp}; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; ```. You can pass arguments to the thread function using the; `UserArgs`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6415,safe,safe,6415,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"rror Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85339,recover,recovery,85339,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['recover'],['recovery']
Safety,"rrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified object at a time. To; do so, `TFile` keeps a list of **`TKeys`**, which is; essentially an index to the objects in the file. The **`TKey`** class;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15718,recover,recovery,15718,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['recover'],['recovery']
Safety,"rs (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:133786,safe,safety,133786,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"rs anywhere else in a declarator, it applies to; the type there. .. admonition:: Rationale. Ownership qualifiers are like ``const`` and ``volatile`` in the sense; that they may sensibly apply at multiple distinct positions within a; declarator. However, unlike those qualifiers, there are many; situations where they are not meaningful, and so we make an effort; to ""move"" the qualifier to a place where it will be meaningful. The; general goal is to allow the programmer to write, say, ``__strong``; before the entire declaration and have it apply in the leftmost; sensible place. .. _arc.ownership.spelling.property:. Property declarations; ^^^^^^^^^^^^^^^^^^^^^. A property of retainable object pointer type may have ownership. If the; property's type is ownership-qualified, then the property has that ownership.; If the property has one of the following modifiers, then the property has the; corresponding ownership. A property is ill-formed if it has conflicting; sources of ownership, or if it has redundant ownership modifiers, or if it has; ``__autoreleasing`` ownership. * ``assign`` implies ``__unsafe_unretained`` ownership.; * ``copy`` implies ``__strong`` ownership, as well as the usual behavior of; copy semantics on the setter.; * ``retain`` implies ``__strong`` ownership.; * ``strong`` implies ``__strong`` ownership.; * ``unsafe_unretained`` implies ``__unsafe_unretained`` ownership.; * ``weak`` implies ``__weak`` ownership. With the exception of ``weak``, these modifiers are available in non-ARC; modes. A property's specified ownership is preserved in its metadata, but otherwise; the meaning is purely conventional unless the property is synthesized. If a; property is synthesized, then the :arc-term:`associated instance variable` is; the instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:34591,redund,redundant,34591,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['redund'],['redundant']
Safety,"rs compilation of the symbol(s) searched for; (if they have not been compiled already), and (2) it provides the; synchronization mechanism for concurrent compilation. The pseudo-code for the; lookup process is:. .. code-block:: none. construct a query object from a query set and query handler; lock the session; lodge query against requested symbols, collect required materializers (if any); unlock the session; dispatch materializers (if any). In this context a materializer is something that provides a working definition; of a symbol upon request. Usually materializers are just wrappers for compilers,; but they may also wrap a jit-linker directly (if the program representation; backing the definitions is an object file), or may even be a class that writes; bits directly into memory (for example, if the definitions are; stubs). Materialization is the blanket term for any actions (compiling, linking,; splatting bits, registering with runtimes, etc.) that are required to generate a; symbol definition that is safe to call or access. As each materializer completes its work it notifies the JITDylib, which in turn; notifies any query objects that are waiting on the newly materialized; definitions. Each query object maintains a count of the number of symbols that; it is still waiting on, and once this count reaches zero the query object calls; the query handler with a *SymbolMap* (a map of symbol names to addresses); describing the result. If any symbol fails to materialize the query immediately; calls the query handler with an error. The collected materialization units are sent to the ExecutionSession to be; dispatched, and the dispatch behavior can be set by the client. By default each; materializer is run on the calling thread. Clients are free to create new; threads to run materializers, or to send the work to a work queue for a thread; pool (this is what LLJIT/LLLazyJIT do). Top Level APIs; ==============. Many of ORC's top-level APIs are visible in the example above:. -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:10359,safe,safe,10359,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['safe'],['safe']
Safety,"rs must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2059,predict,predict,2059,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['predict'],['predict']
Safety,"rt; i < end; ++i); A[i] *= B[i] + K;; }. Runtime Checks of Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. In the example below, if the pointers A and B point to consecutive addresses,; then it is illegal to vectorize the code because some elements of A will be; written before they are read from array B. Some programmers use the 'restrict' keyword to notify the compiler that the; pointers are disjointed, but in our example, the Loop Vectorizer has no way of; knowing that the pointers A and B are unique. The Loop Vectorizer handles this; loop by placing code that checks, at runtime, if the arrays A and B point to; disjointed memory locations. If arrays A and B overlap, then the scalar version; of the loop is executed. .. code-block:: c++. void bar(float *A, float* B, float K, int n) {; for (int i = 0; i < n; ++i); A[i] *= B[i] + K;; }. Reductions; ^^^^^^^^^^. In this example the ``sum`` variable is used by consecutive iterations of; the loop. Normally, this would prevent vectorization, but the vectorizer can; detect that 'sum' is a reduction variable. The variable 'sum' becomes a vector; of integers, and at the end of the loop the elements of the array are added; together to create the correct result. We support a number of different; reduction operations, such as addition, multiplication, XOR, AND and OR. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i] + 5;; return sum;; }. We support floating point reduction operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single stream of instructions. The Loop Vectorizer supports any; control flow in the innermost loop. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:5986,detect,detect,5986,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['detect'],['detect']
Safety,"rtual void Print(Option_t *wildcard, Option_t *option) const;; with; virtual void Print(Option_t *option="""") const;; virtual void Print(Option_t *option, Int_t recurse) const;; virtual void Print(Option_t *option, const char* wildcard,; Int_t recurse=1) const;; virtual void Print(Option_t *option, TPRegexp& regexp,; Int_t recurse=1) const;. Introduce three new protected methods used to print out collection details.; These are called from the Print() methods and make overriding of what; is printed for a collection / entries easier.; virtual void PrintCollectionHeader(Option_t* option) const;; virtual const char* GetCollectionEntryName(TObject* entry) const;; virtual void PrintCollectionEntry(TObject* entry, Option_t* option,; Int_t recurse) const;. Improve performance of reading TExMap object (50 times faster) using an updated,; slightly larger (16%) on file format for the TExMap object. ACLiC; Fix problem finding rootcint in the --prefix configuration.; Change the naming convention for the temporary files created by ACLiC, instead of randomly named ACLiC now uses:scriptname_scriptextension_ACLiC_function.extension; When ACLiC need to revert to the temp directory for storing the library, it now create the directory; structure under a directory named after the userid. Allow white space in the name of the directory where a script to be compiled by ACLiC resides.; Add optional 5th argument to CompileMacro to allow set the file bit; mode of the directory created.; Avoid looking for Microsoft's link.exe when we already have it (and hence avoid complaining about cygpath when cygwin is not even installed. Meta. Insure that the TClass list of methods is refreshed when new functions are added to the dictionary. TStyle. In TStyle::Reset, the Frame; Fill Color default value did not match the TFrame; Fill Color default value. TSystem. DirName now properly handle; repeated '/'; this allow mkdir(""a/b//c"",true); to succeed.; Extended the support for UNIX sockets on a generic path. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html:1734,avoid,avoid,1734,core/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html,1,['avoid'],['avoid']
Safety,"rtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:19800,abort,abort,19800,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['abort'],['abort']
Safety,"ructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear(""C""). with the simpler and more efficient:. for (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:2635,risk,risk,2635,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['risk'],['risk']
Safety,"rum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already on; - Decompress `TTreeCache` in parallel if IMT is on (upgrade of the `TTreeCacheUnzip` class).; - In `TTreeProcessorMT` delete friend chains after the main chain to avoid double deletes.; - If IMT is enabled, the multithreaded execution of the fit respects the number of threads IMT has been initialized with. ## Language Bindings. ### Notebook integration; - In the ROOT kernel, avoid import of unnecessary components.; - In the ROOT kernel, optimise regexes involved in tab-completion which could take up to minutes to be executed. ## JavaScript ROOT; ; Upgrade JSROOT to v5.4.1. Following new features implemented:. * New supported classes:; - TDiamond; - TArc; - TCurlyLine; - TCurlyArc; - TCrown; * New draw options:; - ""RX"" and ""RY"" for TGraph to reverse axis; - ""noopt"" for TGraph to disable drawing optimization; - ""CPN"" for TCanvas to create color palette from N last colors; - ""line"" for TGraph2D; * New features:; - support LZ4 compression; - tooltips and zooming in TGraphPolar drawings; - TPavesText with multiple underlying paves; - implement all fill styles; - draw borders for TWbox; - draw all objects from TList/TObjArray as they appear in list of primitives; - let enable/disable highlight of extra objects in geometry viewer; - draw axis labels on both sides when pad.fTick[x/y] > 1; - make drawing of TCanvas with many primitives smoother; - add fOptTitl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:15295,avoid,avoid,15295,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoid']
Safety,"runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize incremental scans in generational collectors. * Emission of read barriers when loading object references. These are useful; for interoperating with concurrent collectors. There are additional areas that LLVM does not directly address:. * Registration of global roots with the runtime. * Registration of stack map entries with the runtime. * The functions used by the program to allocate memory, trigger a collection,; etc. * Computation or compilation of type maps, or registration of them with the; runtime. These are used to crawl the heap for object references. In general, LLVM's support for GC does not include features which can be; adequately addressed with other features of the IR and does not specify a; particular binary interface. On the plus side, this means that you should be; able to integrate LLVM with an e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:6659,safe,safe,6659,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"rves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack maps. Direct Stack Map Entries; ^^^^^^^^^^^^^^^^^^^^^^^^. As shown in :ref:`stackmap-section`, a Direct stack map location; record",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:18352,unsafe,unsafe,18352,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['unsafe'],['unsafe']
Safety,"ry headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56959,detect,detection,56959,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['detect'],['detection']
Safety,"ry. Guarded Allocation Pool; -----------------------. The core of GWP-ASan is the guarded allocation pool. Each sampled allocation is; backed using its own *guarded* slot, which may consist of one or more accessible; pages. Each guarded slot is surrounded by two *guard* pages, which are mapped as; inaccessible. The collection of all guarded slots makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management librar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4156,detect,detection,4156,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['detect'],['detection']
Safety,"ry. Nodes have visualization attributes as the volume; has. When undefined by users, painting a node on a pad will take the; corresponding volume attributes. \anchor GP01b; ### Creating and Positioning Volumes. \anchor GP01ba; #### Making Volumes. As mentioned before, volumes are the basic objects used in building the; geometrical hierarchy. They represent objects that are not positioned,; but store all information about the placement of the other volumes they; may contain. Therefore a volume can be replicated several times in the; geometry. As it was explained, in order to create a volume, one has to; put together a shape and a medium, which are already defined. Volumes have to be named by users at creation time. Every different name; may represent a unique volume object, but may also represent more; general a family (class) of volume objects having the same shape type; and medium, but possibly different shape parameters. It is the user's; task to provide different names for different volume families in order; to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two; cases: when a parametric shape is used or when a division operation is; applied. Each volume in the geometry stores a unique ID corresponding to; its family. In order to ease-up their creation, the manager class is; providing an API that allows making a shape and a volume in a single; step. \anchor GP01bb; #### Example of Volume Creation. ~~~{.cpp}; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);. // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);. // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:24504,avoid,avoid,24504,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"ry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platfo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2788,detect,detect,2788,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['detect'],['detect']
Safety,"s (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can capture this.; Fixes (`#71976 <https://github.com/llvm/llvm-project/issues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified by `-fconstexpr-steps`.; (`#63562 <https://github.com/llvm/llvm-project/issues/63562>`_). - Fix a crash caused by some named unicode escape sequences designating; a Unicode character whose name contains a ``-``.; (Fixes `#64161 <https://github.com/llvm/llvm-project/issues/64161>`_). - Fix cases where we ignore ambiguous name lookup when looking up members.; (`#22413 <https://github.com/llvm/llvm-project/issues/22413>`_),; (`#29942 <https://github.com/llvm/llvm-project/issues/29942>`_),; (`#35574 <https://github.com/llvm/llvm-project/issues/35574>`_) and; (`#27224 <https://github.com/llvm/llvm-project/issues/27224>`_). - Clang emits an error on substitution failure within lambda body inside a; requires-expression. This fixes:; (`#64138 <https://github.com/llvm/llvm-project/issues/64138>`_) and; (`#71684 <https://github.com/llvm/llvm-project/issues/71684>`_). - Update ``FunctionDeclBitfields.NumFunctionDeclBi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:46490,avoid,avoid,46490,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['avoid'],['avoid']
Safety,"s a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = sub i32 4, %var ; yields i32:result = 4 - %var; <result> = sub i32 0, %val ; yields i32:result = -%var. .. _i_fsub:. '``fsub``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fsub [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fsub``' instruction returns the difference of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fsub``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point difference of the two operands.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`.; This instruction can also take any number of :ref:`fast-math; flags <fastmath>`, which are optimization hints to enable otherwise; unsafe floating-point optimizations:. Example:; """""""""""""""". .. code-block:: text. <result> = fsub float 4.0, %var ; yields float:result = 4.0 - %var; <result> = fsub float -0.0, %val ; yields float:result = -%var. .. _i_mul:. '``mul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = mul <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nsw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``mul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``mul``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:381687,unsafe,unsafe,381687,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"s a client of TGeoManager. The manager class also; controls the drawing/checking package (TGeoPainter client). This; is linked with %ROOT graphical libraries loaded on demand in order to; control visualization actions. \anchor GP02; ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or comput",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:61988,detect,detector,61988,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['detect'],['detector']
Safety,"s about the technology found [here](../../README.CXXMODULES.md).; - The `ACLiC` can be configured to pass options to the `rootcling` invocation by enabling in the `.rootrc` the `ACLiC.ExtraRootclingFlags [-opts]` line.; - A call to `ROOT::EnableThreadSafety` is not required before using `TThreadExecutor` or `TTreeProcessorMT` anymore; - `TTreeProcessorMT` does not silently activate implicit multi-threading features anymore. An explicit call to; `ROOT::EnableImplicitMT` is required instead; - `TTreeProcessorMT` now has a constructor argument to set the number of threads for its thread-pool. ## I/O Libraries. ## TTree Libraries. - A new status bit was added to `TTree`: `kEntriesReshuffled`, which indicates a `TTree` that is the output of the; processing of another tree during which its entry order has been changed (this can happen, for instance, when; processing a tree in a multi-thread application). To avoid silent entry number mismatches, trees with this bit set; cannot add friend trees nor can be added as friends, unless the friend `TTree` has an appropriate `TTreeIndex`. ## Histogram Libraries. ## Math Libraries. ## RooFit Libraries. ### RooWorkspace::Import() for Python; `RooWorkspace.import()` cannot be used in Python, since it is a reserved keyword. Users therefore had to resort; to; getattr(workspace, 'import')(...); Now,; workspace.Import(...); has been defined for the new PyROOT, which makes calling the function easier. ### Modernised category classes; RooFit's categories were modernised. Previously, the class RooCatType was used to store category states. It stores; two members, an integer for the category index, and up to 256 characters for a category name. Now, such states are; stored only using an integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:2384,avoid,avoid,2384,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['avoid'],['avoid']
Safety,"s and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26213,safe,safe,26213,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['safe'],['safe']
Safety,"s are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; knows to skip loading the object which contains the profiling runtime's; static initializer. * Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:15040,safe,safe,15040,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['safe'],['safe']
Safety,"s are not valid on ``load`` instructions.; Atomic loads produce :ref:`defined <memmodel>` results when they may see; multiple atomic stores. The type of the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:414255,safe,safe,414255,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"s can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:159819,avoid,avoid,159819,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['avoid'],['avoid']
Safety,"s compare greater than normal; states, which guarantees that they ""win"" when joined with normal states. Order; between failure states is determined by inclusion relation on the set of; accumulated violations (lattice's `⩽` is `⊆` on the set of violations). Order; between normal states is determined by reversed inclusion relation on the set of; overwritten parameter's member fields (lattice's `⩽` is `⊇` on the set of; overwritten fields). ![Lattice for data flow analysis that identifies output parameters](DataFlowAnalysisIntroImages/OutputParameterIdentificationLattice.svg). To determine whether a statement reads or writes a field we can implement; symbolic evaluation of `DeclRefExpr`s, `LValueToRValue` casts, pointer; dereference operator and `MemberExpr`s. ### Using data flow results to identify output parameters. Let's take a look at how we use data flow analysis to identify an output; parameter. The refactoring can be safely done when the data flow algorithm; computes a normal state with all of the fields proven to be overwritten in the; exit basic block of the function. ```c++; struct Customer {; int account_id;; std::string name;; };. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; c->name = ...; // Overwritten: {c->account_id, c->name}; } else {; c->name = ...; // Overwritten: {c->account_id, c->name}; }; // Overwritten: {c->account_id, c->name}; }; ```. When the data flow algorithm computes a normal state, but not all fields are; proven to be overwritten we can't perform the refactoring. ```c++; void target(bool b, Customer* c) {; // Overwritten: {}; if (b) {; c->account_id = 42; // Overwritten: {c->account_id}; } else {; c->name = ""Konrad""; // Overwritten: {c->name}; }; // Overwritten: {}; }; ```. Similarly, when the data flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:18368,safe,safely,18368,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['safe'],['safely']
Safety,"s determined when the ``typedef`` is used. The; following example shows that no pointer annotation is specified in the ``typedef; pint_t`` while each instance of ``typedef``'ed pointer gets its bounds; annotation based on the context in which the type is used. .. code-block:: c. typedef int * pint_t; // int *. pint_t glob; // int *__single glob;. void foo(void) {; pint_t local; // int *__bidi_indexable local;; }. Pointer types in a ``typedef`` can still have explicit annotations, e.g.,; ``typedef int *__single``, in which case the bounds annotation ``__single`` will; apply to every use of the ``typedef``. Array to pointer promotion to secure arrays (including VLAs); ------------------------------------------------------------. Arrays on function prototypes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, arrays on function prototypes are promoted (or ""decayed"") to a pointer to; its first element (e.g., ``&arr[0]``). In ``-fbounds-safety``, arrays are also; decayed to pointers, but with the addition of an implicit bounds annotation,; which includes variable-length arrays (VLAs). As shown in the following example,; arrays on function prototypes are decalyed to corresponding ``__counted_by``; pointers. .. code-block:: c. // Function prototype: void foo(int n, int *__counted_by(n) arr);; void foo(int n, int arr[n]);. // Function prototype: void bar(int *__counted_by(10) arr);; void bar(int arr[10]);. This means the array parameters are treated as `__counted_by` pointers within; the function and callers of the function also see them as the corresponding; `__counted_by` pointers. Incomplete arrays on function prototypes will cause a compiler error unless it; has ``__counted_by`` annotation in its bracket. .. code-block:: c. void f1(int n, int arr[]); // error. void f3(int n, int arr[__counted_by(n)]); // ok. void f2(int n, int arr[n]); // ok, decays to int *__counted_by(n). void f4(int n, int *__counted_by(n) arr); // ok. void f5(int n, int *arr); // ok, but decays to int *__single,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:32451,safe,safety,32451,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"s for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supported.; if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES ""AIX"")); # TODO: support other platforms and toolchains.; option(LLVM_BUILD_32_BITS ""Build 32 bits executables and libraries."" OFF); endif(). # Define the default arguments to use with 'lit', and an option for the user to; # override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC_IDE OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); if(LLVM_INDIVIDUAL_TEST_COVERAGE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:28520,recover,recover,28520,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['recover'],['recover']
Safety,"s need to know what object they are constructing.; Moreover, if the aggregate contains; references, lifetime extension needs to be properly modeled. One can start untangling this problem by trying to replace the; current ad-hoc ; ParentMap lookup in ; CXXConstructionKind::NonVirtualBase branch of; ExprEngine::VisitCXXConstructExpr(); with proper support for the feature.; (Difficulty: Medium) . Handle array constructors.; When an array of objects is allocated (say, using the; operator new[] or defining a stack array),; constructors for all elements of the array are called.; We should model (potentially some of) such evaluations,; and the same applies for destructors called from; operator delete[].; See tests cases in handle_constructors_with_new_array.cpp.; . Constructing an array requires invoking multiple (potentially unknown); amount of constructors with the same construct-expression.; Apart from the technical difficulties of juggling program points around; correctly to avoid accidentally merging paths together, we'll have to; be a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move construct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:3149,avoid,avoid,3149,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['avoid'],['avoid']
Safety,"s no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInterpreterMutex``` are deprecated and may be removed in future releases.; - Added ```TReadLockGuard```,```TWriteLockGuard```, ```R__READ_LOCKGUARD``` and```R__WRITE_LOCKGUARD``` to take advantage of the new lock. The legacy ```TLockGuard``` and ```R__LOCKGUARD``` use the write lock.; - Improved scaling of TROOT::RecursiveRemove in the case of large collection.; - Added a thread safe mode for the following ROOT collections: THashList, THashTable, TList and TObjArray. When ROOT's thread safe mode is enabled and the collection is set to use internal locks by calling:; ```; collection->UseRWLock();; ```; all operations on the collection will take the read or write lock when needed, currently they shared the global lock (ROOT::gCoreMutex). ### Interpreter. - cling's LLVM is upgraded to version 5.0; - All of cling's patches to llvm have been upstreamed.; - The interpreter-related lock is now locking only the compilation step, not the execution step. This reduces the scope for lock contention. Most significantly, it enables the use of concurrency on the prompt!. ## I/O Libraries. - Introduce TKey::ReadObject<typeName>. This is a user friendly wrapper around ReadObjectAny. For example; ```; auto h1 = key->ReadObject<TH1>; ```; after which h1 will either be null if the key contains something that is not a TH1 (or derived class); or will be set to the address of the histogram read from the file.; - Add the ability to store the 'same' object several time (assumingly with different data) in a single buffer. Instead of. ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:5779,safe,safe,5779,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['safe'],['safe']
Safety,"s not need to have special knowledge of the; operand bundle to not miscompile programs containing it. - The bundle operands for an unknown operand bundle escape in unknown; ways before control is transferred to the callee or invokee.; - Calls and invokes with operand bundles have unknown read / write; effect on the heap on entry and exit (even if the call target specifies; a ``memory`` attribute), unless they're overridden with; callsite specific attributes.; - An operand bundle at a call site cannot change the implementation; of the called function. Inter-procedural optimizations work as; usual as long as they take into account the first two properties. More specific types of operand bundles are described below. .. _deopt_opbundles:. Deoptimization Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Deoptimization operand bundles are characterized by the ``""deopt""``; operand bundle tag. These operand bundles represent an alternate; ""safe"" continuation for the call site they're attached to, and can be; used by a suitable runtime to deoptimize the compiled frame at the; specified call site. There can be at most one ``""deopt""`` operand; bundle attached to a call site. Exact details of deoptimization is; out of scope for the language reference, but it usually involves; rewriting a compiled frame into a set of interpreted frames. From the compiler's perspective, deoptimization operand bundles make; the call sites they're attached to at least ``readonly``. They read; through all of their pointer typed operands (even if they're not; otherwise escaped) and the entire visible heap. Deoptimization; operand bundles do not capture their operands except during; deoptimization, in which case control will not be returned to the; compiled frame. The inliner knows how to inline through calls that have deoptimization; operand bundles. Just like inlining through a normal call site; involves composing the normal and exceptional continuations, inlining; through a call site with a deoptimi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:119116,safe,safe,119116,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"s of LLVM. .. code-block:: llvm. load i64* %p. becomes. .. code-block:: llvm. load i64, ptr %p. Address spaces are still used to distinguish between different kinds of pointers; where the distinction is relevant for lowering (e.g. data vs function pointers; have different sizes on some architectures). Opaque pointers are not changing; anything related to address spaces and lowering. For more information, see; `DataLayout <LangRef.html#langref-datalayout>`_. Opaque pointers in non-default; address space are spelled ``ptr addrspace(N)``. This was proposed all the way back in; `2015 <https://lists.llvm.org/pipermail/llvm-dev/2015-February/081822.html>`_. Issues with explicit pointee types; ==================================. LLVM IR pointers can be cast back and forth between pointers with different; pointee types. The pointee type does not necessarily represent the actual; underlying type in memory. In other words, the pointee type carries no real; semantics. Historically LLVM was some sort of type-safe subset of C. Having pointee types; provided an extra layer of checks to make sure that the Clang frontend matched; its frontend values/operations with the corresponding LLVM IR. However, as other; languages like C++ adopted LLVM, the community realized that pointee types were; more of a hindrance for LLVM development and that the extra type checking with; some frontends wasn't worth it. LLVM's type system was `originally designed; <https://llvm.org/pubs/2003-05-01-GCCSummit2003.html>`_ to support high-level; optimization. However, years of LLVM implementation experience have demonstrated; that the pointee type system design does not effectively support; optimization. Memory optimization algorithms, such as SROA, GVN, and AA,; generally need to look through LLVM's struct types and reason about the; underlying memory offsets. The community realized that pointee types hinder LLVM; development, rather than helping it. Some of the initially proposed high-level; optimization",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:1939,safe,safe,1939,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['safe'],['safe']
Safety,"s option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); handleFunctionDecl(D); handleFunctionDecl(D);; } else if (isa<VarDecl>(D)) { else if (isa<VarDecl>(D)); handleVarDecl(D); handleVarDecl(D);; }. if (isa<VarDecl>(D)) { vs. if (isa<VarDecl>(D)) {; for (auto *A : D.attrs()) { for (auto *A : D.attrs()); if (shouldProcessAttr(A)) { if (shouldProcessAttr(A)); handleAttr(A); handleAttr(A);; } }; }; }. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()) { for (auto *A : D.attrs()); handleAttr(A); handleAttr(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:102640,redund,redundant,102640,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['redund'],['redundant']
Safety,"s r2, ha16(.CPI_X_2); lfd f1, lo16(.CPI_X_2)(r2); lis r2, ha16(.CPI_X_3); lfd f2, lo16(.CPI_X_3)(r2); fmadd f1, f0, f1, f2; blr. It would be better to materialize .CPI_X into a register, then use immediates; off of the register to avoid the lis's. This is even more important in PIC ; mode. Note that this (and the static variable version) is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. Here's another example (the sgn function):; double testf(double a) {; return a == 0.0 ? 0.0 : (a > 0.0 ? 1.0 : -1.0);; }. it produces a BB like this:; LBB1_1: ; cond_true; lis r2, ha16(LCPI1_0); lfs f0, lo16(LCPI1_0)(r2); lis r2, ha16(LCPI1_1); lis r3, ha16(LCPI1_2); lfs f2, lo16(LCPI1_2)(r3); lfs f3, lo16(LCPI1_1)(r2); fsub f0, f0, f1; fsel f1, f0, f2, f3; blr . ===-------------------------------------------------------------------------===. PIC Code Gen IPO optimization:. Squish small scalar globals together into a single global struct, allowing the ; address of the struct to be CSE'd, avoiding PIC accesses (also reduces the size; of the GOT on targets with one). Note that this is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. ===-------------------------------------------------------------------------===. Fold add and sub with constant into non-extern, non-weak addresses so this:. static int a;; void bar(int b) { a = b; }; void foo(unsigned char *c) {; *c = a;; }. So that . _foo:; lis r2, ha16(_a); la r2, lo16(_a)(r2); lbz r2, 3(r2); stb r2, 0(r3); blr. Becomes. _foo:; lis r2, ha16(_a+3); lbz r2, lo16(_a+3)(r2); stb r2, 0(r3); blr. ===-------------------------------------------------------------------------===. We should compile these two functions to the same thing:. #include <stdlib.h>; void f(int a, int b, int *P) {; *P = (a-b)>=0?(a-b):(b-a);; }; void g(int a, int b, int *P) {; *P = abs(a-b);; }. Further, they should compile to something better than:. _g:; subf r2, r4, r3; subfic r3, r2, 0; cmpwi cr0, r2, -1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:2631,avoid,avoiding,2631,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['avoid'],['avoiding']
Safety,"s source-language caller. '``llvm.swift.async.context.addr``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.swift.async.context.addr(). Overview:; """""""""""""""""". The '``llvm.swift.async.context.addr``' intrinsic returns a pointer to; the part of the extended frame record containing the asynchronous; context of a Swift execution. Semantics:; """""""""""""""""""". If the caller has a ``swiftasync`` parameter, that argument will initially; be stored at the returned address. If not, it will be initialized to null. '``llvm.localescape``' and '``llvm.localrecover``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.localescape(...); declare ptr @llvm.localrecover(ptr %func, ptr %fp, i32 %idx). Overview:; """""""""""""""""". The '``llvm.localescape``' intrinsic escapes offsets of a collection of static; allocas, and the '``llvm.localrecover``' intrinsic applies those offsets to a; live frame pointer to recover the address of the allocation. The offset is; computed during frame layout of the caller of ``llvm.localescape``. Arguments:; """""""""""""""""""". All arguments to '``llvm.localescape``' must be pointers to static allocas or; casts of static allocas. Each function can only call '``llvm.localescape``'; once, and it can only do so from the entry block. The ``func`` argument to '``llvm.localrecover``' must be a constant; bitcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:513642,recover,recover,513642,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['recover'],['recover']
Safety,"s the library under test starts; its own threads. However, it is possible to run multiple libFuzzer processes in; parallel with a shared corpus directory; this has the advantage that any new; inputs found by one fuzzer process will be available to the other fuzzer; processes (unless you disable this with the ``-reload=0`` option). This is primarily controlled by the ``-jobs=N`` option, which indicates that; that `N` fuzzing jobs should be run to completion (i.e. until a bug is found or; time/iteration limits are reached). These jobs will be run across a set of; worker processes, by default using half of the available CPU cores; the count of; worker processes can be overridden by the ``-workers=N`` option. For example,; running with ``-jobs=30`` on a 12-core machine would run 6 workers by default,; with each worker averaging 5 bugs by completion of the entire process. Fork mode; ---------. **Experimental** mode ``-fork=N`` (where ``N`` is the number of parallel jobs); enables oom-, timeout-, and crash-resistant; fuzzing with separate processes (using ``fork-exec``, not just ``fork``). The top libFuzzer process will not do any fuzzing itself, but will; spawn up to ``N`` concurrent child processes providing them; small random subsets of the corpus. After a child exits, the top process; merges the corpus generated by the child back to the main corpus. Related flags:. ``-ignore_ooms``; True by default. If an OOM happens during fuzzing in one of the child processes,; the reproducer is saved on disk, and fuzzing continues.; ``-ignore_timeouts``; True by default, same as ``-ignore_ooms``, but for timeouts.; ``-ignore_crashes``; False by default, same as ``-ignore_ooms``, but for all other crashes. The plan is to eventually replace ``-jobs=N`` and ``-workers=N`` with ``-fork=N``. Resuming merge; --------------. Merging large corpora may be time consuming, and it is often desirable to do it; on preemptable VMs, where the process may be killed at any time.; In order to seamless",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:7488,timeout,timeout,7488,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeout']
Safety,"s the unswizzled address; relative to the wave scratch base in the unswizzled private address space; of the lowest address stack allocated local variable. ``DW_AT_frame_base`` will be defined as the swizzled address in the; swizzled private address space by dividing the CFA by the wavefront size; (since CFA is always at least dword aligned which matches the scratch; swizzle element size). If no dynamic stack alignment was performed, the stack allocated arguments; are accessed as negative offsets relative to ``DW_AT_frame_base``, and the; local variables and register spill slots are accessed as positive offsets; relative to ``DW_AT_frame_base``. 5. Function argument passing is implemented by copying the input physical; registers to virtual registers on entry. The register allocator can spill if; necessary. These are copied back to physical registers at call sites. The; net effect is that each function call can have these values in entirely; distinct locations. The IPRA can help avoid shuffling argument registers.; 6. Call sites are implemented by setting up the arguments at positive offsets; from SP. Then SP is incremented to account for the known frame size before; the call and decremented after the call. .. note::. The CFI will reflect the changed calculation needed to compute the CFA; from SP. 7. 4 byte spill slots are used in the stack frame. One slot is allocated for an; emergency spill slot. Buffer instructions are used for stack accesses and; not the ``flat_scratch`` instruction. .. TODO::. Explain when the emergency spill slot is used. .. TODO::. Possible broken issues:. - Stack arguments must be aligned to required alignment.; - Stack is aligned to max(16, max formal argument alignment); - Direct argument < 64 bits should check register budget.; - Register budget calculation should respect ``inreg`` for SGPR.; - SGPR overflow is not handled.; - struct with 1 member unpeeling is not checking size of member.; - ``sret`` is after ``this`` pointer.; - Caller is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:399536,avoid,avoid,399536,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['avoid'],['avoid']
Safety,"s the writer to take a read lock. In other word, the lock is re-entrant for both reading and writing. The implementation tries to make faster the scenario when readers come and go but there is no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInterpreterMutex``` are deprecated and may be removed in future releases.; - Added ```TReadLockGuard```,```TWriteLockGuard```, ```R__READ_LOCKGUARD``` and```R__WRITE_LOCKGUARD``` to take advantage of the new lock. The legacy ```TLockGuard``` and ```R__LOCKGUARD``` use the write lock.; - Improved scaling of TROOT::RecursiveRemove in the case of large collection.; - Added a thread safe mode for the following ROOT collections: THashList, THashTable, TList and TObjArray. When ROOT's thread safe mode is enabled and the collection is set to use internal locks by calling:; ```; collection->UseRWLock();; ```; all operations on the collection will take the read or write lock when needed, currently they shared the global lock (ROOT::gCoreMutex). ### Interpreter. - cling's LLVM is upgraded to version 5.0; - All of cling's patches to llvm have been upstreamed.; - The interpreter-related lock is now locking only the compilation step, not the execution step. This reduces the scope for lock contention. Most significantly, it enables the use of concurrency on the prompt!. ## I/O Libraries. - Introduce TKey::ReadObject<typeName>. This is a user friendly wrapper around ReadObjectAny. For example; ```; auto h1 = key->ReadObject<TH1>; ```; after which h1 will either be null if the key contains something that is not a TH1 (or derived class); or will be set to the address of the histogram read from the file.; - Add ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:5670,safe,safe,5670,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['safe'],['safe']
Safety,"s()` from causing an autoparse on an abstract base class. ## Histogram Libraries. * TH2Poly has a functional Merge method.; * Implemented the `TGraphAsymmErrors` constructor directly from an ASCII file. ## Math Libraries. * New template class `TRandomGen<Engine>` which derives from `TRandom` and integrate new random generator engines as TRandom classes.; * New TRandom specific types have been defined for these following generators:; * `TRandomMixMax` - recommended MIXMAX generator with N=240; * `TRandomMixMax17` - MIXMAX generator with smaller state (N=17) and faster seeding time; * `TRandomMixMax256` - old version of MIXMAX generator (N=256); * `TRandomMT64` - 64 bit Mersenenne Twister generator from the standard library (based on `std::mt19937_64`). This generates 64 bit random numbers, while `TRandom3` generates only 32 bit random numbers.; * `TRandomRanlux48` - 48 bit Ranlux generator. Note that `TRandom1` is a 24 bit generator. ; * Improve thread safety of `TMinuit` constructor [ROOT-8217]; * Vc has ben removed from the ROOT sources. If the option 'vc' is enabled, the package will be searched (by default),; alternatively the source tarfile can be downloded and build with the option 'builtin_vc'. ## TMVA Libraries. * New `DataLoader` class that allows flexibility in variable and dataset selection. ; * New Deep Neural Network. Three different versions are available, which can be selected with the 'Architecture' option. See also the tutorial`tmva/TMVAClassification.C` for using the new DNN.; * `Architecture=STANDARD` to select the earlier version.; * `Architecture=CPU` to select the newer version for CPU, but designed also for GPU and optimized for speed and with multi-class support. ; * `Architecture=GPU` to select the newer GPU version. Requires configuration of ROOT with CUDA or OpenCL enabled. ; * Support for Cross Validation (see tutorial `tmva/TMVACrossValidation` as an example).; * Support for Hyper-Parameter tuning for BDT and SVM methods.; * New Variable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:12248,safe,safety,12248,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['safe'],['safety']
Safety,"s, by default using half of the available CPU cores; the count of; worker processes can be overridden by the ``-workers=N`` option. For example,; running with ``-jobs=30`` on a 12-core machine would run 6 workers by default,; with each worker averaging 5 bugs by completion of the entire process. Fork mode; ---------. **Experimental** mode ``-fork=N`` (where ``N`` is the number of parallel jobs); enables oom-, timeout-, and crash-resistant; fuzzing with separate processes (using ``fork-exec``, not just ``fork``). The top libFuzzer process will not do any fuzzing itself, but will; spawn up to ``N`` concurrent child processes providing them; small random subsets of the corpus. After a child exits, the top process; merges the corpus generated by the child back to the main corpus. Related flags:. ``-ignore_ooms``; True by default. If an OOM happens during fuzzing in one of the child processes,; the reproducer is saved on disk, and fuzzing continues.; ``-ignore_timeouts``; True by default, same as ``-ignore_ooms``, but for timeouts.; ``-ignore_crashes``; False by default, same as ``-ignore_ooms``, but for all other crashes. The plan is to eventually replace ``-jobs=N`` and ``-workers=N`` with ``-fork=N``. Resuming merge; --------------. Merging large corpora may be time consuming, and it is often desirable to do it; on preemptable VMs, where the process may be killed at any time.; In order to seamlessly resume the merge, use the ``-merge_control_file`` flag; and use ``killall -SIGUSR1 /path/to/fuzzer/binary`` to stop the merge gracefully. Example:. .. code-block:: console. % rm -f SomeLocalPath; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-INNER: using the control file 'SomeLocalPath'; ...; # While this is running, do `killall -SIGUSR1 my_fuzzer` in another console; ==9015== INFO: libFuzzer: exiting as requested. # This will leave the file SomeLocalPath with the partial state of the merge.; # Now, you can continue the merge by execu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:8108,timeout,timeouts,8108,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['timeout'],['timeouts']
Safety,"s, extend tooltip.htm example; 3. Implement workaround for standard THREE.SVGRenderer - no need for patched version; 4. When producing 3D graphical images in batch, use normal THREE.CanvasRenderer; 5. Use WebGL renderer in Chrome headless mode for 3D images generation; 6. Provide possibility to create SVG files for canvas or frame (#172); 7. Support text drawing with TH1 bar option; 8. Fix - when drawing text, reserve extra y range to show it correctly; 9. Migrate to Node.js 8, do not support older versions. ## Changes in 5.5.2; 1. Fix - draw TH2Poly bins outline when no content specified; 2. Fix - always set axis interactive handlers (#170); 3. Fix - take into account zaxis properties when drawing color palette (#171). ## Changes in 5.5.1; 1. Fix - adjust v7 part to new class naming convention, started with R; 2. Fix - show RCanvas title; 3. New - implement 'nocache' option for JSROOT scripts loading. When specified in URL with; JSRootCore.js script, tries to avoid scripts caching problem by adding stamp parameter to all URLs; 4. New - provide simple drawing for TObjString (#164). ## Changes in 5.5.0; 1. Introduce JSROOT.StoreJSON() function. It creates JSON code for the; TCanvas with all drawn objects inside. Allows to store current canvas state; 2. Support ""item=img:file.png"" parameter to insert images in existing layout (#151); 3. Support TTree drawing into TGraph (#153), thanks @cozzyd; 4. Let configure ""&toolbar=right"" in URL to change position of tool buttons; 5. Let configure ""&divsize=500x400"" in URL of size of main div element (default - full browser); 6. Implement ""optstat1001"" and ""optfit101"" draw options for histograms; 7. Remove ""autocol"" options - standard ""plc"" should be used instead; 8. Provide drawing of artificial ""$legend"" item - it creates TLegend for all primitives in pad; Can be used when several histograms or several graphs superimposed; 9. Let configure ""&toolbar=vert"" in URL to change orientation of tool buttons; 10. Improve markers and erro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:33318,avoid,avoid,33318,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['avoid'],['avoid']
Safety,"s, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``if``; would help to avoid running into a ""dangling else"" situation. .. code-block:: c++. // Omit the braces since the body is simple and clearly associated with the; // `if`.; if (isa<FunctionDecl>(D)); handleFunctionDecl(D);; else if (isa<VarDecl>(D)); handleVarDecl(D);. // Here we document the condition itself and not the body.; if (isa<VarDecl>(D)) {; // It is necessary that we explain the situation with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (shouldProcessAttr(A)); handleAttr(A);; }. // Use braces for the `if` block to keep it uniform with the `else` block.; if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D);; } else {; // In this `else` case, it is necessary that we explain the situation with; // this surprisingly long comment, so it would be unclear without the braces; // whether the following statement is in the scope of the `if`.; handleOtherDecl(D);; }. // This should also omit braces. The `for` loop contains only a single; // statement, so it shouldn't have braces. The `if` also only contains a; // single simple statement (the `for` loop), so it also should omit braces.; if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()); handleAttr(A);. // Use braces for a `do-while` loop and its enclosing statement.; if (Tok->is(tok::l_brace)) {; do {; Tok = Tok->Next;; } while (Tok);; }. // Use braces for the outer `if` since the nested `for` is braced.; if (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:63545,avoid,avoid,63545,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['avoid'],['avoid']
Safety,"s, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C`'; and `C`\"", having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation comes from the fact that any container is directly used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D`, `E`, and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class TGeoVolumeAssembly, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ""unnecessary"" volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:31946,avoid,avoid,31946,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"s. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesian vector. We then enforce the use; of transformations as rotations or translations (additions) for; modifying the vector contents. - The majority of the functionality, which is present in the CLHEP; package, involving operations on two vectors, is moved in separated; helper functions (see `ROOT::Math::VectorUtil`). This has the; advantage that the basic interface will remain more stable with time; while additional functions can be added easily. #### Naming Convention. As part of ROOT, the `GenVector` package adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74842,avoid,avoiding,74842,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoiding']
Safety,"s:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132151,avoid,avoid,132151,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoid']
Safety,"s://llvm.org/doxygen/Statistic_8h_source.html>`_ class is; designed to be an easy way to expose various success metrics from passes.; These statistics are printed at the end of a run, when the :option:`-stats`; command line option is enabled on the command line. See the :ref:`Statistics; section <Statistic>` in the Programmer's Manual for details. .. _writing-an-llvm-pass-passmanager:. What PassManager does; ---------------------. The `PassManager <https://llvm.org/doxygen/PassManager_8h_source.html>`_ `class; <https://llvm.org/doxygen/classllvm_1_1PassManager.html>`_ takes a list of; passes, ensures their :ref:`prerequisites <writing-an-llvm-pass-interaction>`; are set up correctly, and then schedules passes to run efficiently. All of the; LLVM tools that run passes use the PassManager for execution of these passes. The PassManager does two main things to try to reduce the execution time of a; series of passes:. #. **Share analysis results.** The ``PassManager`` attempts to avoid; recomputing analysis results as much as possible. This means keeping track; of which analyses are available already, which analyses get invalidated, and; which analyses are needed to be run for a pass. An important part of work; is that the ``PassManager`` tracks the exact lifetime of all analysis; results, allowing it to :ref:`free memory; <writing-an-llvm-pass-releaseMemory>` allocated to holding analysis results; as soon as they are no longer needed. #. **Pipeline the execution of passes on the program.** The ``PassManager``; attempts to get better cache and memory usage behavior out of a series of; passes by pipelining the passes together. This means that, given a series; of consecutive :ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>`, it; will execute all of the :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>` on the first function, then all of the; :ref:`FunctionPasses <writing-an-llvm-pass-FunctionPass>` on the second; function, etc... until the entire program has bee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:41258,avoid,avoid,41258,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['avoid'],['avoid']
Safety,"s; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has proper include protectors.; * Enable it in `rootcling` -- rootcling can produce a C++ Modules-aware; dictionary when it is invoked with `-cxxmodule` flag.; * Modularization of external dependencies -- if a header file is not explicitly; nominated as part of a module and it is transitively included in two modules,; both modules contain that header file content. In other words, the header is; duplicated. In turn, this leads to performance regressions. If a dictionary; depends on a header (directly or indirectly) from a external library (e.g.; libxml) it needs to be modularized. As part of our ongoing efforts to move; CMSSW to use C++ Modules [[6]] we have implemented a helper tool [[7]]. The; tool detects (based on the include paths of the compiler) dependencies and; tries to generate the relevant vfs file. ## State of the union. Preloading all modules at start up time turn our motivating example into:. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition. ```. becomes equivalent to. ```cpp; // ROOT prompt; root [] import ROOT.*;; root [] import Foo.*;; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition; ```. The implementation avoids recursive actions and relies on a well-defined (by; the C++ standard) behavior. Currently, this comes with a constant performance; overhead which we go in details bellow. ROOT uses the global module index (GMI) to av",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:15618,detect,detects,15618,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['detect'],['detects']
Safety,"s; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries. ## Database Libraries; - Fix issue related to time stamps manipulation done by `TPgSQLStatement` as suggested [here](https://root-forum.cern.ch/t/please-correct-bug-reading-date-time-from-postgresql-tpgsqlstatement). ## Networking Libraries; - New THttpWSHandler class should be used to work with websockets. It includes all necessary methods to handle multiple connections correctly. See in tutorials/http/ws.C how it can be used.; - Interface of THttpWSEngine class was changed, all its instances handled internally in THttpWSHandler. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - `TTree::GetEntry`: if IMT is enabled, run work in tasks if we have at least more than one top level branch.; - Make EnableImplicitMT no-op if IMT is already on; - Decompress `TTreeCache` in parallel if IMT is on (upgrade of the `TTreeCacheUnzip` class).; - In `TTreeProcessorMT` delete friend chains after the main chain to avoid double deletes.; - If IMT is enabled, the multithreaded execution of the fit respects the number of threads IMT has been initialized with. ## Language Bindings. ### Notebook integration; - In the ROOT kernel, avoid import of unnecessary components.; - In the ROOT kernel, optimise regexes involved in tab-completion which could take up to minutes to be executed. ## JavaScript ROOT; ; Upgrade JSROOT to v5.4.1. Following new features implemented:. * New supported classes:; - TDiamond; - TArc; - TCurlyLine; - TCurlyArc; - TCrown; * New draw options:; - ""RX"" and ""RY"" for TGraph to reverse axis; - ""noopt"" for TGraph to disable drawing optimization; - ""CPN"" for TCanvas to create color palette from N last colors; - ""line"" for TGraph2D; * New features:; - support LZ4 compression; - tooltips and zooming in TGraphPolar drawings; - TPavesText with multiple underlying paves; - implement all fill styles; - draw borders for TWbox; - draw all objects from TList/TObjArray ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:15080,avoid,avoid,15080,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['avoid'],['avoid']
Safety,"s; -----------------------------------------------. The ``ScalarEvolution`` analysis can be used to analyze and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Elimination; ------------------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inliner for ``always_inline`` functions; ----------------------------------------------------------. A custom inliner that handles only functions that are marked as ""always; inline"". ``argpromotion``: Promote 'by reference' arguments to scalars; -----------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:11385,safe,safety,11385,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['safe'],['safety']
Safety,"s; intrinsic is necessary because the `` llvm.va_start`` intrinsic may be; arbitrarily complex and require, for example, memory allocation. Accurate Garbage Collection Intrinsics; --------------------------------------. LLVM's support for `Accurate Garbage Collection <GarbageCollection.html>`_; (GC) requires the frontend to generate code containing appropriate intrinsic; calls and select an appropriate GC strategy which knows how to lower these; intrinsics in a manner which is appropriate for the target collector. These intrinsics allow identification of :ref:`GC roots on the; stack <int_gcroot>`, as well as garbage collector implementations that; require :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers.; Frontends for type-safe garbage collected languages should generate; these intrinsics to make use of the LLVM garbage collectors. For more; details, see `Garbage Collection with LLVM <GarbageCollection.html>`_. LLVM provides an second experimental set of intrinsics for describing garbage; collection safepoints in compiled code. These intrinsics are an alternative; to the ``llvm.gcroot`` intrinsics, but are compatible with the ones for; :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. The; differences in approach are covered in the `Garbage Collection with LLVM; <GarbageCollection.html>`_ documentation. The intrinsics themselves are; described in :doc:`Statepoints`. .. _int_gcroot:. '``llvm.gcroot``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.gcroot(ptr %ptrloc, ptr %metadata). Overview:; """""""""""""""""". The '``llvm.gcroot``' intrinsic declares the existence of a GC root to; the code generator, and allows some metadata to be associated with it. Arguments:; """""""""""""""""""". The first argument specifies the address of a stack object that contains; the root pointer. The second pointer (which must be either a constant or; a global value address) contains the meta-data to be associated with the; root. Semantics:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:496338,safe,safepoints,496338,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safepoints']
Safety,"s; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:123311,safe,safe,123311,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safe']
Safety,"s; the theoretical uniform distribution of resource pressure for every; instruction in sequence. .. option:: -bottleneck-analysis. Print information about bottlenecks that affect the throughput. This analysis; can be expensive, and it is disabled by default. Bottlenecks are highlighted; in the summary view. Bottleneck analysis is currently not supported for; processors with an in-order backend. .. option:: -json. Print the requested views in valid JSON format. The instructions and the; processor resources are printed as members of special top level JSON objects.; The individual views refer to them by index. However, not all views are; currently supported. For example, the report from the bottleneck analysis is; not printed out in JSON. All the default views are currently supported. .. option:: -disable-cb. Force usage of the generic CustomBehaviour and InstrPostProcess classes rather; than using the target specific implementation. The generic classes never; detect any custom hazards or make any post processing modifications to; instructions. .. option:: -disable-im. Force usage of the generic InstrumentManager rather than using the target; specific implementation. The generic class creates Instruments that provide; no extra information, and InstrumentManager never overrides the default; schedule class for a given instruction. EXIT STATUS; -----------. :program:`llvm-mca` returns 0 on success. Otherwise, an error message is printed; to standard error, and the tool returns 1. USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS; ---------------------------------------------; :program:`llvm-mca` allows for the optional usage of special code comments to; mark regions of the assembly code to be analyzed. A comment starting with; substring ``LLVM-MCA-BEGIN`` marks the beginning of an analysis region. A; comment starting with substring ``LLVM-MCA-END`` marks the end of a region.; For example:. .. code-block:: none. # LLVM-MCA-BEGIN; ...; # LLVM-MCA-END. If no user-defined region i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:7556,detect,detect,7556,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,2,"['detect', 'hazard']","['detect', 'hazards']"
Safety,"s`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6814,avoid,avoid,6814,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['avoid'],['avoid']
Safety,"safe=kFALSE);; ~~~. The meaning of the parameters here is the same as for FindNextBoundary,; but the safety value is triggered by an input flag. The output is the; node after the boundary crossing. \anchor GP02gc; #### Computing the Safe Radius. Other important navigation query for tracking is the computation of the; safe distance. This represents the `maximum` step that can be made from; the current point in `any direction` that assures that no boundary will; be crossed. Knowing this value gives additional freedom to the stepping; algorithm to propagate the current track on the corresponding range; `without checking` if the current state has changed. In other words, the; modeller insures that the current state does not change in any point; within the safety radius around the current point. The computation of the safe radius is `automatically` computed any time; when the next boundary is queried within a `limited step:`. ~~~{.cpp}; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. Otherwise, the computation of safety can always be forced:. ~~~{.cpp}; Double_t safety = gGeoManager->Safety();; ~~~. \anchor GP02gd; #### Making a Step. The modeller is able to make steps starting from the current point along; the current direction and having the current step length. The new point; and its corresponding state will be automatically computed:. ~~~{.cpp}; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; ~~~. We will explain the method above by its use cases. The input flag; `is_geom` allows specifying if the step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:80220,safe,safety,80220,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59217,unsafe,unsafe-math-optimizations,59217,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe-math-optimizations']
Safety,"scripts/asan_symbolize.py / < log | c++filt; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; ... Note that on macOS you may need to run ``dsymutil`` on your binary to have the; file\:line info in the AddressSanitizer reports. Additional Checks; =================. Initialization order checking; -----------------------------. AddressSanitizer can optionally detect dynamic initialization order problems,; when initialization of globals defined in one translation unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:5786,detect,detect,5786,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detect']
Safety,"se it runs over 38 passes. Next, ``bugpoint`` tries removing functions from the test program, to reduce its; size. Usually it is able to reduce a test program to a single function, when; debugging intraprocedural optimizations. Once the number of functions has been; reduced, it attempts to delete various edges in the control flow graph, to; reduce the size of the function as much as possible. Finally, ``bugpoint``; deletes any individual LLVM instructions whose absence does not eliminate the; failure. At the end, ``bugpoint`` should tell you what passes crash, give you a; bitcode file, and give you instructions on how to reproduce the failure with; ``opt`` or ``llc``. .. _code generator debugger:. Code generator debugger; -----------------------. The code generator debugger attempts to narrow down the amount of code that is; being miscompiled by the selected code generator. To do this, it takes the test; program and partitions it into two pieces: one piece which it compiles with the; ""safe"" backend (into a shared object), and one piece which it runs with either; the JIT or the static LLC compiler. It uses several techniques to reduce the; amount of code pushed through the LLVM code generator, to reduce the potential; scope of the problem. After it is finished, it emits two bitcode files (called; ""test"" [to be compiled with the code generator] and ""safe"" [to be compiled with; the ""safe"" backend], respectively), and instructions for reproducing the; problem. The code generator debugger assumes that the ""safe"" backend produces; good code. .. _miscompilation debugger:. Miscompilation debugger; -----------------------. The miscompilation debugger works similarly to the code generator debugger. It; works by splitting the test program into two pieces, running the optimizations; specified on one piece, linking the two pieces back together, and then executing; the result. It attempts to narrow down the list of passes to the one (or few); which are causing the miscompilation,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:4405,safe,safe,4405,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['safe'],['safe']
Safety,"se, we transition the; pointer to a `Conflicting` state, like in this example. ```c++; void ConflictingOwnership() {; int *pi; // pi is Compatible; pi = GetPtr(); // pi is Defined; Borrow(pi); // pi is Defined. pi = new int; // pi is Conflicting; Borrow(pi);; delete pi;; // pi is Conflicting; }; ```. We could still handle this case by finding a maximal range in the code where; `pi` could be in the Compatible state, and only refactoring that part. ```c++; void ConflictingOwnership() {; int *pi;; pi = GetPtr();; Borrow(pi);. std::unique_ptr<int> pi_unique = std::make_unique<int>();; Borrow(pi_unique.get());; }; ```. ## Example: finding redundant branch conditions. In the code below `b1` should not be checked in both the outer and inner ""if""; statements. It is likely there is a bug in this code. ```c++; int F(bool b1, bool b2) {; if (b1) {; f();; if (b1 && b2) { // Check `b1` again -- unnecessary!; g();; }; }; }; ```. A checker that finds this pattern syntactically is already implemented in; ClangTidy using AST matchers (`bugprone-redundant-branch-condition`). To implement it using the data flow analysis framework, we can produce a warning; if any part of the branch condition is implied by the flow condition. ```c++; int F(bool b1, bool b2) {; // Flow condition: true.; if (b1) {; // Flow condition: b1.; f();; if (b1 && b2) { // `b1` is implied by the flow condition.; g();; }; }; }; ```. One way to check this implication is to use a SAT solver. Without a SAT solver,; we could keep the flow condition in the CNF form and then it would be easy to; check the implication. ## Example: finding unchecked `std::optional` unwraps. Calling `optional::value()` is only valid if `optional::has_value()` is true. We; want to show that when `x.value()` is executed, the flow condition implies; `x.has_value()`. In the example below `x.value()` is accessed safely because it is guarded by the; `x.has_value()` check. ```c++; void Example(std::optional<int> &x) {; if (x.has_value()) {; use(x.v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:26227,redund,redundant-branch-condition,26227,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['redund'],['redundant-branch-condition']
Safety,"sed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:7284,predict,predictable,7284,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['predict'],['predictable']
Safety,"sed the following; undocumented convention to check whether a value `x` is in the range with; limits `a` and `b`: test if `[x - eps * x, x + eps * x]` overlaps with `[a, b]`, where the; parameter `eps` is defined as `max(epsRel * x, epsAbs)`. The values of the relative and absolute epsilons were inconsistent among the overloads:. * [RooAbsRealLValue::inRange(const char* rangeName)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#ab6050a0c3e5583b9d755a38fd7fb82f7): `epsRel = 1e-8, epsAbs = 0`; * [RooAbsRealLValue::inRange(double value, const char* rangeName, double* clippedValPtr)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#afc2a8818f433a9a4ec0c437cbdad4e8a): `epsRel = 0, epsAbs = 1e-6`; * [RooAbsRealLValue::inRange(std::span<const double> values, std::string const& rangeName, std::vector<bool>& out)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#af9217abd0afe34364562ad0c194f5d2c): `epsRel = 0, epsAbs = 1e-6`. With this release, the default absolute and relative epsilon is zero to avoid confusion.; You can change them with `RooNumber::setRangeEpsRel(epsRel)` and `RooNumber::setRangeEpsAbs(epsAbs)`. ## TMVA. ### SOFIE : Code generation for fast inference of Deep Learning models. A large number of new features have been added in the TMVA SOFIE library. The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. The interface of `RModel::Generate` has been changed to; ```; RModel::Generate(Options options = Options::kDefault, int batchsize = 1)`; ```; where `Options` is a new enumeration having 3 different values:; - `kDefault = 0x0` : default case, a session class is generated and the weights are stored in a separate `.dat` file (in text format).; - `kNoSession = 0x1` : no session class is generated and the internal intermediate tensors are declared in the global namespace `TMVA_SOFIE_$ModelName`.; - `kNoWeightFile = 0x2` the weight values are not written in a separate `.dat` file, but they a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:26124,avoid,avoid,26124,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoid']
Safety,"selective definition of env and rootrc; variables. Different values can be set for different users, groups, SVN; versions or ROOT versions.; Improve the diagnostic in case of exceptions. Information; about the event and file being processed at the moment the exception; was raised is sent to the client, e.g.;    0.5: caught exception triggered by signal '1' while; processing dset:'EventTree',; file:'http://root.cern.ch/files/data/event_3.root', event:1 - check; logs for possible stacktrace; The patch also fixes a problem with submergers observed when a worker; was stopped because above the memory limits: this worker was; established as merger but could not do the work, for obvious reasons,; freezing the session.; Add two new methods to TProof: ShowMissingFiles() to facilitate; the display of the list of missing files; and GetMissingFiles() to get; a TFileCollection (dataset) with the missing files for further; processing. Fixes. Fix a bug in error status transmission which avoid; session freezing in some cases; FIx; a few issues in libXrdProofd.so with handling of connection used for; admin operation: this should solve some cases where the daemon was not; responding. ; Fix a few memory leaks showing up when; running several queries in the same session; Fix a few issues affecting the new sub-merging option; Fix an issue preventing proper real-time notification; during VerifyDataSet; Fix an issue with TQueryResult ordering (was causing; random 'stressProof' failures); Fix; an issue with TProof::AskStatistics (fBytesRead, fRealTime and fCpuTime; were not correctly filled on the client; the values on the master,; displayed by TProof::Print were correct).; Fix several small issues affecting the handling of global; package directories; Fix an issue with socket handling in the main event-loop; while sendign or receiving files via TProofMgr.; Fix; a problem counting valid nodes in sequential or 'masteronly' mode,; generating the fake error message ""GoParallel: attaching to ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:9514,avoid,avoid,9514,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['avoid'],['avoid']
Safety,"sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been removed, for example). > This is important because the audiences for these two goals are very; > different. Architects and many compiler people care much more about; > the second question. The Java compiler and OS community care much more; > about the first one. 3. By focusing on a more low level virtual machine, we have much more room; for value add. The nice safe ""sandbox"" VM can be provided as a layer; on top of it. It also lets us focus on the more interesting compilers; related projects. > 2. Design issues to consider (an initial list that we should continue; > to modify). Note that I'm not trying to suggest actual solutions here,; > but just various directions we can pursue:. Understood. :). > a. A sing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:1663,safe,safe,1663,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['safe'],['safe']
Safety,"sertions are compiled out. Today, we have something much better: ``llvm_unreachable``:. .. code-block:: c++. llvm_unreachable(""Invalid radix for integer literal"");. When assertions are enabled, this will print the message if it's ever reached; and then exit the program. When assertions are disabled (i.e. in release; builds), ``llvm_unreachable`` becomes a hint to compilers to skip generating; code for this branch. If the compiler does not support this, it will fall back; to the ""abort"" implementation. Use ``llvm_unreachable`` to mark a specific point in code that should never be; reached. This is especially desirable for addressing warnings about unreachable; branches, etc., but can be used whenever reaching a particular code path is; unconditionally a bug (not originating from user input; see below) of some kind.; Use of ``assert`` should always include a testable predicate (as opposed to; ``assert(false)``). If the error condition can be triggered by user input then the; recoverable error mechanism described in :doc:`ProgrammersManual` should be; used instead. In cases where this is not practical, ``report_fatal_error`` may; be used. Another issue is that values used only by assertions will produce an ""unused; value"" warning when assertions are disabled. For example, this code will warn:. .. code-block:: c++. unsigned Size = V.size();; assert(Size > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value);; assert(NewToSet && ""The value shouldn't be in the set yet"");. These are two interesting different cases. In the first case, the call to; ``V.size()`` is only useful for the assert, and we don't want it executed when; assertions are disabled. Code like this should move the call into the assert; itself. In the second case, the side effects of the call must happen whether; the assert is enabled or not. In this case, the value should be cast to void to; disable the warning. To be specific, it is preferred to write the code like; this:. .. code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:47551,recover,recoverable,47551,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['recover'],['recoverable']
Safety,"set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can use the following suppression mechanism; to unblock yourself and continue on with the testing. This supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:6566,detect,detection,6566,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['detect'],['detection']
Safety,"sformation options are specific to each transformation. In the; following, we present the model for each LLVM loop optimization pass and; the metadata to influence them. Loop Vectorization and Interleaving; -----------------------------------. Loop vectorization and interleaving is interpreted as a single; transformation. It is interpreted as forced if; ``!{""llvm.loop.vectorize.enable"", i1 true}`` is set. Assuming the pre-vectorization loop is. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; Stmt(i);. then the code after vectorization will be approximately (assuming an; SIMD width of 4):. .. code-block:: c. int i = 0;; if (rtc) {; for (; i + 3 < n; i+=4) // vectorized/interleaved loop; Stmt(i:i+3);; }; for (; i < n; i+=1) // epilogue loop; Stmt(i);. where ``rtc`` is a generated runtime check. ``llvm.loop.vectorize.followup_vectorized`` will set the attributes for; the vectorized loop. If not specified, ``llvm.loop.isvectorized`` is; combined with the original loop's attributes to avoid it being; vectorized multiple times. ``llvm.loop.vectorize.followup_epilogue`` will set the attributes for; the remainder loop. If not specified, it will have the original loop's; attributes combined with ``llvm.loop.isvectorized`` and; ``llvm.loop.unroll.runtime.disable`` (unless the original loop already; has unroll metadata). The attributes specified by ``llvm.loop.vectorize.followup_all`` are; added to both loops. When using a follow-up attribute, it replaces any automatically deduced; attributes for the generated loop in question. Therefore it is; recommended to add ``llvm.loop.isvectorized`` to; ``llvm.loop.vectorize.followup_all`` which avoids that the loop; vectorizer tries to optimize the loops again. Loop Unrolling; --------------. Unrolling is interpreted as forced any ``!{!""llvm.loop.unroll.enable""}``; metadata or option (``llvm.loop.unroll.count``, ``llvm.loop.unroll.full``); is present. Unrolling can be full unrolling, partial unrolling of a loop; with c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:6379,avoid,avoid,6379,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['avoid'],['avoid']
Safety,"shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ``` {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ```. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and sha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:55951,detect,detector,55951,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ~~~ {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ~~~. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. \defgroup Tubes Tubes; \ingroup Shapes_classes; Tubes have Z as their symmetry axis. \defgroup Cones Cones; \ingroup Shapes_classes; Conical tube classes. \defgroup Trapezoids Trapezoids; \ingroup Shapes_classes; In general, we will c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:9721,detect,detector,9721,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['detect'],['detector']
Safety,"should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for eac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:532734,detect,detect,532734,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detect']
Safety,"sic unit system based; on millimeters, nanoseconds and MegaElectronVolts was better suited for the LHC; experiments. All LHC experiments use Geant4 and effectively adopted this; convention for all areas of data processing: simulation, reconstruction and; data analysis. Hence experiments using the %ROOT geometry toolkit to describe; the geometry had two different system of units in the application code. To allow users having the same system of units in the geometry description and the; application it is now possible to choose the system of units at startup of the; application:. ``` {.cpp}; TGeoManager::SetDefaultUnits(xx); xx = kG4Units, kRootUnits; ```. To ensure backwards compatibility %ROOT's default system of units is - as it was before -; based on centimeters, seconds and GigaElectronVolts, ie. the defaults are equivalent to:. ``` {.cpp}; TGeoManager::SetDefaultUnits(kRootUnits);; ```. To avoid confusion between materials described in %ROOT units and materials described; in Geant4 units, this switch should by all means be set once, before any element or; material is constructed. If for whatever reason it is necessary to change the; system of units later, this is feasible disabling the otherwise fatal exception:. ``` {.cpp}; TGeoManager::LockDefaultUnits(kFALSE);; ```. followed later by a corresponding call to again lock the system of units:. ``` {.cpp}; TGeoManager::LockDefaultUnits(kTRUE);; ```. \anchor GP01; ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:16518,avoid,avoid,16518,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['avoid'],['avoid']
Safety,"sics should be placed to represent the original variable; locations in this code? Unfortunately the second, third and fourth; dbg.values for ``!1`` in the source function have had their operands; (%tval, %fval, %merge) optimized out. Assuming we cannot recover them, we; might consider this placement of dbg.values:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. However, this will cause ``!3`` to have the return value of ``@gazonk()`` at; the same time as ``!1`` has the constant value zero -- a pair of assignments; that never occurred in the unoptimized program. To avoid this, we must terminate; the range that ``!1`` has the constant value assignment by inserting a poison; dbg.value before the dbg.value for ``!3``:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 poison, metadata !1, metadata !2); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. There are a few other dbg.value configurations that mean it terminates; dominating location definitions without adding a new location. The complete; list is:. * Any location operand is ``poison`` (or ``undef``).; * Any location operand is an empty metadata tuple (``!{}``) (which cannot; occur in a ``!DIArgList``).; * There are no location operands (empty ``DIArgList``) and the ``DIExpression``; is empty. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:22104,avoid,avoid,22104,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoid']
Safety,"side ``BLOCKINFO`` blocks, but; unlike their occurrence in normal blocks, the abbreviation is defined for blocks; matching the block ID we are describing, *not* the ``BLOCKINFO`` block; itself. The abbreviations defined in ``BLOCKINFO`` blocks receive abbreviation; IDs as described in `DEFINE_ABBREV`_. The ``BLOCKNAME`` record (code 2) can optionally occur in this block. The; elements of the record are the bytes of the string name of the block.; llvm-bcanalyzer can use this to dump out bitcode files symbolically. The ``SETRECORDNAME`` record (code 3) can also optionally occur in this block.; The first operand value is a record ID number, and the rest of the elements of; the record are the bytes for the string name of the record. llvm-bcanalyzer can; use this to dump out bitcode files symbolically. Note that although the data in ``BLOCKINFO`` blocks is described as ""metadata,""; the abbreviations they contain are essential for parsing records from the; corresponding blocks. It is not safe to skip them. .. _wrapper:. Bitcode Wrapper Format; ======================. Bitcode files for LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:17909,safe,safe,17909,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['safe'],['safe']
Safety,"signed int's are particularly common), but in this case, all; that will be added is an additional 'cast' instruction. I removed that; from the spec. > I agree with your comment that we don't need 'neg'. Removed. > There's a trade-off with the cast instruction:; > + it avoids having to define all the upcasts and downcasts that are; > valid for the operands of each instruction (you probably have; > thought of other benefits also); > - it could make the bytecode significantly larger because there could; > be a lot of cast operations. + You NEED casts to represent things like:; void foo(float);; ...; int x;; ...; foo(x);; in a language like C. Even in a Java like language, you need upcasts; and some way to implement dynamic downcasts.; + Not all forms of instructions take every type (for example you can't; shift by a floating point number of bits), thus SOME programs will need; implicit casts. To be efficient and to avoid your '-' point above, we just have to be; careful to specify that the instructions shall operate on all common; types, therefore casting should be relatively uncommon. For example all; of the arithmetic operations work on almost all data types. > Making the second arg. to 'shl' a ubyte seems good enough to me.; > 255 positions seems adequate for several generations of machines. Okay, that comment is removed. > and is more compact than uint. No, it isn't. Remember that the bytecode encoding saves value slots into; the bytecode instructions themselves, not constant values. This is; another case where we may introduce more cast instructions (but we will; also reduce the number of opcode variants that must be supported by a; virtual machine). Because most shifts are by constant values, I don't; think that we'll have to cast many shifts. :). > I still have some major concerns about including malloc and free in the; > language (either as builtin functions or instructions). Agreed. How about this proposal:. malloc/free are either built in functions or actual o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:3068,avoid,avoid,3068,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['avoid'],['avoid']
Safety,"signment in C++.; Incorrect usage of MPI APIs in C and C++. This check can be enabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability checks:; ; Checker warning about uses of non-localized NSStrings passed to UI methods expecting localized strings.; Checker warning when the comment argument is missing from NSLocalizedString macros.; These can be enabled by passing the following command to scan-build:.   -enable-checker alpha.osx.cocoa.NonLocalizedStringChecker,alpha.osx.cocoa.EmptyLocalizationContextChecker. New checks for _Nonnull type qualifiers. These can be enabled with:.   -enable-checker nullability.NullPassedToNonnull,nullability.NullReturnedFromNonnull; New checks for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:1533,detect,detect,1533,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['detect'],['detect']
Safety,"sing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20596,safe,safety,20596,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['safe'],['safety']
Safety,"sing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3517,recover,recovered,3517,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['recover'],['recovered']
Safety,"sion being browsed.; A set of scripts for quick interaction with a dataset; manager via PROOF are available under $ROOTSYS/etc/proof/utils/pq2 .; The scripts are prefixed; pq2 (proof; quick query - or; proof-dq2); and allow to {browse, register, remove, verify} datasets on a given; PROOF master. See $ROOTSYS/etc/proof/utils/pq2/README for more; information. Improvements. Enable by default schema evolution in TMessage; can be; disabled setting 'Proof.SchemaEvolution:; 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:5665,redund,redundant,5665,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['redund'],['redundant']
Safety,"sion of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpret roundoff noise as; significant and will usually either fail to find a minimum, or give; incorrect values for the parameter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26431,safe,safety,26431,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['safe'],['safety']
Safety,"size""`` attribute is inlined into; a function with another ``""stack-probe-size""`` attribute, the resulting; function has the ``""stack-probe-size""`` attribute that has the lower; numeric value. If a function that has a ``""stack-probe-size""`` attribute is; inlined into a function that has no ``""stack-probe-size""`` attribute; at all, the resulting function has the ``""stack-probe-size""`` attribute; of the callee.; ``""no-stack-arg-probe""``; This attribute disables ABI-required stack probes, if any.; ``returns_twice``; This attribute indicates that this function can return twice. The C; ``setjmp`` is an example of such a function. The compiler disables; some optimizations (like tail calls) in the caller of these; functions.; ``safestack``; This attribute indicates that; `SafeStack <https://clang.llvm.org/docs/SafeStack.html>`_; protection is enabled for this function. If a function that has a ``safestack`` attribute is inlined into a; function that doesn't have a ``safestack`` attribute or which has an; ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting; function will have a ``safestack`` attribute.; ``sanitize_address``; This attribute indicates that AddressSanitizer checks; (dynamic address safety analysis) are enabled for this function.; ``sanitize_memory``; This attribute indicates that MemorySanitizer checks (dynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:100111,safe,safestack,100111,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,3,['safe'],['safestack']
Safety,"sm that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4812,safe,safe,4812,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,['safe'],['safe']
Safety,"software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is incomplete and only catches a small and limited; subset of attackable patterns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear to be an adequate systematic mitigation. ## Performance Overhead. The performance overhead of this style of comprehensive mitigation is very; high. However, it compares very favorably with previously recommended; approaches such as the `lfence` instruction. Just as users can restrict the; scope of `lfence` to control its performance impact, this mitigation technique; could be restricted in scope as well. However, it is important to understand what",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45918,risk,risk,45918,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['risk'],['risk']
Safety,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1726,detect,detect,1726,interpreter/cling/www/contribute.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html,4,"['detect', 'recover']","['detect', 'recovery']"
Safety,"specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case, between points and vectors, modeling them with; different classes:. - `ROOT::Math::`**`DisplacementVector2D`** and; `ROOT::Math::`**`DisplacementVector3D`** template classes describing; 2 and 3 component direction and magnitude vectors, not rooted at any; particular point;. - `ROOT::Math::`**`PositionVector2D`** and; `ROOT::Math::`**`PositionVector3D`** template classes modeling the; points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them,; `ROOT::Math::`**`LorentzVector`**, since we have recognized a limited; need for modeling the functionality of a 4D po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:69337,avoid,avoid,69337,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['avoid'],['avoid']
Safety,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75779,avoid,avoid,75779,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['avoid'],['avoid']
Safety,"ss. #. Be wary of ordered and atomic memory operations. They are hard to optimize; and may not be well optimized by the current optimizer. Depending on your; source language, you may consider using fences instead. #. If calling a function which is known to throw an exception (unwind), use; an invoke with a normal destination which contains an unreachable; instruction. This form conveys to the optimizer that the call returns; abnormally. For an invoke which neither returns normally or requires unwind; code in the current function, you can use a noreturn call instruction if; desired. This is generally not required because the optimizer will convert; an invoke with an unreachable unwind destination to a call instruction. #. Use profile metadata to indicate statically known cold paths, even if; dynamic profiling information is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:7269,avoid,avoid,7269,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['avoid'],['avoid']
Safety,"ss; through transient states that violate the ""Should"" guidelines above, or would; otherwise make them unsuitable for direct inclusion in the monorepo (e.g.; dependencies that have not yet been factored appropriately, leveraging; experimental components or APIs that are not yet upstream, etc). When approved, the llvm-admin group can grant the new project:; * A new repository in the LLVM Github Organization - but not the LLVM monorepo.; * New mailing list, discourse forum, and/or discord chat hosted with other LLVM; forums.; * Other infrastructure integration can be discussed on a case-by-case basis. Graduation to the mono-repo would follow existing processes and standards for; becoming a first-class part of the monorepo. Similarly, an incubating project; may be eventually retired, but no process has been established for that yet. If; and when this comes up, please start an RFC discussion on the `LLVM Discourse forums`_. This process is very new - please expect the details to change, it is always; safe to ask on the `LLVM Discourse forums`_ about this. Suggested disclaimer for the project README and the main project web page:. ::. This project is participating in the LLVM Incubator process: as such, it is; not part of any official LLVM release. While incubation status is not; necessarily a reflection of the completeness or stability of the code, it; does indicate that the project is not yet endorsed as a component of LLVM. .. _copyright-license-patents:. Copyright, License, and Patents; ===============================. .. note::. This section deals with legal matters but does not provide legal advice. We; are not lawyers --- please seek legal counsel from a licensed attorney. This section addresses the issues of copyright, license and patents for the LLVM; project. The copyright for the code is held by the contributors of; the code. The code is licensed under permissive `open source licensing terms`_,; namely the Apache-2.0 with LLVM-exception license, which includes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:50085,safe,safe,50085,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['safe'],['safe']
Safety,"sses; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2066,detect,detect,2066,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['detect'],['detect']
Safety,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24626,safe,safe,24626,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['safe'],['safe']
Safety,"ssingDictionaries activate the search through the base classes.; - Added a TStatusBitsChecker to avoid Status Bits overlap in class hierarchy deriving from TObject (and resolved a handful of conflicts).; - Introduced support for type safe range-for-loop for ROOT collection. The typical use is:. ```; for(auto bcl : TRangeDynCast<TBaseClass>( * cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; ```; - ClassDefInline has been enhanced even for some compiled class (without a dictionary). ClassDefInline can still not be used for class template instance using Double32_t or Float16_t as a template parameter or for class or class template that do not have a public default constructor.; - ROOT's backport of `std::string_view` has been updated to follow what's available in C++17, notably its `to_string` member function has been removed. ### Thread safety. Resolved the race conditions inherent to the use of the RecursiveRemove mechanism. - Introduced ```ROOT::TReentrantRWLock```, an implementation of a reentrant read-write lock with a configurable internal mutex/lock and a condition variable to synchronize readers and writers when necessary. The implementation allows a single reader to take the write lock without releasing the reader lock. It also allows the writer to take a read lock. In other word, the lock is re-entrant for both reading and writing. The implementation tries to make faster the scenario when readers come and go but there is no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:4293,safe,safety,4293,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['safe'],['safety']
Safety,"ssors and; multiple successors. If one or more of the predecessors of the block can be; proven to always cause a jump to one of the successors, we forward the edge; from the predecessor to the successor by duplicating the contents of this; block. An example of when this can occur is code like this:. .. code-block:: c++. if () { ...; X = 4;; }; if (X < 3) {. In this case, the unconditional branch at the end of the first if can be; revectored to the false side of the second if. .. _passes-lcssa:. ``lcssa``: Loop-Closed SSA Form Pass; ------------------------------------. This pass transforms loops by placing phi nodes at the end of the loops for all; values that are live across the loop boundary. For example, it turns the left; into the right code:. .. code-block:: c++. for (...) for (...); if (c) if (c); X1 = ... X1 = ...; else else; X2 = ... X2 = ...; X3 = phi(X1, X2) X3 = phi(X1, X2); ... = X3 + 4 X4 = phi(X3); ... = X4 + 4. This is still valid LLVM; the extra phi nodes are purely redundant, and will be; trivially eliminated by ``InstCombine``. The major benefit of this; transformation is that it makes many other loop optimizations, such as; ``LoopUnswitch``\ ing, simpler. You can read more in the; :ref:`loop terminology section for the LCSSA form <loop-terminology-lcssa>`. .. _passes-licm:. ``licm``: Loop Invariant Code Motion; ------------------------------------. This pass performs loop invariant code motion, attempting to remove as much; code from the body of a loop as possible. It does this by either hoisting code; into the preheader block, or by sinking code to the exit blocks if it is safe.; This pass also promotes must-aliased memory locations in the loop to live in; registers, thus hoisting and sinking ""invariant"" loads and stores. Hoisting operations out of loops is a canonicalization transform. It enables; and simplifies subsequent optimizations in the middle-end. Rematerialization; of hoisted instructions to reduce register pressure is the responsibilit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:23098,redund,redundant,23098,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['redund'],['redundant']
Safety,"st a; review by 'ping'ing the GitHub PR with ""Ping"". The common courtesy 'ping' rate; is once a week. Please remember that you are asking for valuable time from other; professional developers. For more information on LLVM's code-review process, please see :doc:`CodeReview`. .. _commit_from_git:. For developers to commit changes from Git; -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your change before pushing; it to the repo. LLVM currently has a linear-history policy, which means that merge commits are; not allowed. The `llvm-project` repo on github is configured to reject pushes; that include merges, so the `git rebase` step above is required. Please ask for help if you're having trouble with your particular git workflow. .. _git_pre_push_hook:. Git pre-push hook; ^^^^^^^^^^^^^^^^^. We include an optional pre-push hook that run some sanity checks on the revisions; you are about to push and ask confirmation if you push multiple commits at once.; You can set it up (on Unix systems) by running from the repository root:. .. code-block:: console. % ln -sf ../../llvm/utils/git/pre-push.py .git/hooks/pre-push. Helpful Information About LLVM; ==============================; :doc:`LLVM's documentation <index>` provides a wealth of information about LLVM's internals as; well as various user guides. The pages listed below should provide a good overview; of LLVM's high-level design, as well as its internals:. :doc:`GettingStarted`; Discusses how to get up and running quickly with the LLVM infrastructure.; Everything from unpacking and compilation of the distribution to execution; of some tools. :doc:`LangRef`; Defines the LLVM intermediate representation. :doc:`ProgrammersManual`; Introduction to the general layout of the LLVM sourcebase, important classes; and APIs, and some tips & tricks. `LLVM for Grad Students`__; This is an introduction to the LLVM i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:5997,sanity check,sanity checks,5997,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['sanity check'],['sanity checks']
Safety,"stance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracket syntax in C mode. The argument; can either be a single identifier or a scoped identifier. If the attribute is; supported, a nonzero value is returned. If the attribute is not supported by the; current compilation target, this macro evaluates to 0. It can be used like this:. .. code-block:: c. #ifndef __has_c_attribute // Optional of course.; #define __has_c_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_c_attribute(fallthrough); #define FALLTHROUGH [[fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_attribute``; -------------------. This function-like macro takes a single identifier argument that is the name of; a GNU-style attribute. It evaluates to 1 if the attribute is supported by the; current compilation target, or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_attribute // Optional of course.; #define __has_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_attribute(always_inline); #define ALWAYS_INLINE __attribute__((always_inline)); #else; #define ALWAYS_INLINE; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__always_inline__`` can be used instead of ``always_inline``. ``__has_declspec_attribute``; ----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:7366,avoid,avoid,7366,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"sters. `TargetInstrInfo::isLoadFromStackSlotPostFE` and; `TargetInstrInfo::isStoreToStackSlotPostFE` are needed to identify spill and; restore instructions. Each should return the destination or source register; respectively. `LiveDebugValues` will track the movement of a value from / to; the stack slot. In addition, any instruction that writes to a stack spill; should have a `MachineMemoryOperand` attached, so that `LiveDebugValues` can; recognise that a slot has been clobbered. ## Target-specific optimisation instrumentation. Optimisations come in two flavours: those that mutate a `MachineInstr` to make; it do something different, and those that create a new instruction to replace; the operation of the old. The former _must_ be instrumented -- the relevant question is whether any; register def in any operand will produce a different value, as a result of the; mutation. If the answer is yes, then there is a risk that a `DBG_INSTR_REF`; instruction referring to that operand will end up assigning the different; value to a variable, presenting the debugging developer with an unexpected; variable value. In such scenarios, call `MachineInstr::dropDebugNumber()` on the; mutated instruction to erase its instruction number. Any `DBG_INSTR_REF`; referring to it will produce an empty variable location instead, that appears; as ""optimised out"" in the debugger. For the latter flavour of optimisation, to increase coverage you should record; an instruction number substitution: a mapping from the old instruction number /; operand pair to new instruction number / operand pair. Consider if we replace; a three-address add instruction with a two-address add:. ```text; %2:gr32 = ADD32rr %0, %1, debug-instr-number 1; ```. becomes. ```text; %2:gr32 = ADD32rr %0(tied-def 0), %1, debug-instr-number 2; ```. With a substitution from ""instruction number 1 operand 0"" to ""instruction number; 2 operand 0"" recorded in the `MachineFunction`. In `LiveDebugValues`,; `DBG_INSTR_REF`s will be mapped ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:6722,risk,risk,6722,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['risk'],['risk']
Safety,"still accessible. #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and speci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145502,detect,detector,145502,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"stly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3363,detect,detect,3363,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['detect'],['detect']
Safety,"sule**: Takes a cppyy bound C++ object and returns its address as; a PyCapsule object.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. * **ll.as_cobject**: Takes a cppyy bound C++ object and returns its address as; a PyCObject object for Python2 and a PyCapsule object for Python3.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. * **ll.as_ctypes**: Takes a cppyy bound C++ object and returns its address as; a ``ctypes.c_void_p`` object.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. `ctypes`; --------. The `ctypes module`_ has been part of Python since version 2.5 and provides a; Python-side foreign function interface.; It is clunky to use and has very bad performance, but it is guaranteed to be; available.; It does not have a public C interface, only the Python one, but its internals; have been stable since its introduction, making it safe to use for tight and; efficient integration at the C level (with a few Python helpers to assure; lazy lookup). Objects from ``ctypes`` can be passed through arguments of functions that; take a pointer to a single C++ builtin, and ``ctypes`` pointers can be passed ; when a pointer-to-pointer is expected, e.g. for array out-parameters.; This leads to the following set of possible mappings:. ======================================== ========================================; C++ ctypes; ======================================== ========================================; by value (ex.: ``int``) ``.value`` (ex.: ``c_int(0).value``); by const reference (ex.: ``const int&``) ``.value`` (ex.: ``c_int(0).value``); by reference (ex.: ``int&``) direct (ex.: ``c_int(0)``); by pointer (ex.: ``int*``) direct (ex.: ``c_int(0)``); by ptr-ref (ex.: ``int*&``) ``pointer`` (ex.: ``pointer(c_int(0))``); by ptr-ptr **in** (ex.: ``int**``) ``pointer`` (ex.: ``pointer(c_int(0))``); by ptr-ptr **out*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:7538,safe,safe,7538,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['safe'],['safe']
Safety,"symbol. Unlike regular reexports however, lookups of lazy reexports; do not trigger immediate materialization of the reexported symbol. Instead, they; only trigger materialization of a function stub. This function stub is; initialized to point at a *lazy call-through*, which provides reentry into the; JIT. If the stub is called at runtime then the lazy call-through will look up; the reexported symbol (triggering materialization for it if necessary), update; the stub (to call directly to the reexported symbol on subsequent calls), and; then return via the reexported symbol. By re-using the existing symbol lookup; mechanism, lazy reexports inherit the same concurrency guarantees: calls to lazy; reexports can be made from multiple threads concurrently, and the reexported; symbol can be any state of compilation (uncompiled, already in the process of; being compiled, or already compiled) and the call will succeed. This allows; laziness to be safely mixed with features like remote compilation, concurrent; compilation, concurrent JIT'd code, and speculative compilation. There is one other key difference between regular reexports and lazy reexports; that some clients must be aware of: The address of a lazy reexport will be; *different* from the address of the reexported symbol (whereas a regular; reexport is guaranteed to have the same address as the reexported symbol).; Clients who care about pointer equality will generally want to use the address; of the reexport as the canonical address of the reexported symbol. This will; allow the address to be taken without forcing materialization of the reexport. Usage example:. If JITDylib ``JD`` contains definitions for symbols ``foo_body`` and; ``bar_body``, we can create lazy entry points ``Foo`` and ``Bar`` in JITDylib; ``JD2`` by calling:. .. code-block:: c++. auto ReexportFlags = JITSymbolFlags::Exported | JITSymbolFlags::Callable;; JD2.define(; lazyReexports(CallThroughMgr, StubsMgr, JD,; SymbolAliasMap({; { Mangle(""foo""), { M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:17702,safe,safely,17702,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['safe'],['safely']
Safety,"symmetric errors, then becomes essentially meaningless. On the; other hand, the $\mbox{MINOS}$ analysis is still meaningful, at; least in principle, as long as $\mbox{MIGRAD}$ (which is called; internally by $\mbox{MINOS}$) does not get blocked at a limit.; Unfortunately, the user has no control over this aspect of the; $\mbox{MINOS}$ calculation, although it is possible to get enough; printout from the $\mbox{MINOS}$ result to be able to determine; whether the results are reliable or not. ## Fixing and releasing parameters ##. When M needs to be guided to the ""right"" minimum, often the best way to; do this is with the methods e.g. MnMigrad::fix(...) and; MnMigrad::release(...). That is, suppose you have a problem with ten; free parameters, and when you minimize with respect to all at once, M; goes to an unphysical solution characterized by an unphysical or; unwanted value of parameter number four. One way to avoid this is to fix; parameter four at a ""good"" value (not necessarily the best, since you; presumably don't know that yet), and minimize with respect to the; others. Then release parameter four and minimize again. If the problem; admits a ""good"" physical solution, you will normally find it this way.; If it doesn't work, you may see what is wrong by the following sequence; (where $\mbox{xxx}$ is the expected physical value for parameter; four):. MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);. where $\mbox{SCAN}$ gives you a picture of $\mbox{FCN}$ as a; function of parameter four alone, the others being fixed at their; current best values. If you suspect the difficulty is due to parameter; five, then add. MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);. to see a two-dimensional picture. ## Interpretation of parameter errors ##. There are two kinds of problems that can arise:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:66904,avoid,avoid,66904,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['avoid'],['avoid']
Safety,"t -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`. ``debugify`` in regression tests; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The output of the ``debugify`` pass must be stable enough to use in regression; tests. Changes to this pass are not allowed to break existing tests. .. note::. Regression tests must be robust. Avoid hardcoding line/variable numbers in; check lines. In cases where this can't be avoided (say, if a test wouldn't; be precise enough), moving the test to its own file is preferred. .. _MIRDebugify:. Test original debug info preservation in optimizations; ------------------------------------------------------. In addition to automatically generating debug info, the checks provided by; the ``debugify`` utility pass can also be used to test the preservation of; pre-existing debug info metadata. It could be run as follows:. .. code-block:: bash. # Run the pass by checking original Debug Info preservation.; $ opt -verify-debuginfo-preserve -pass-to-test sample.ll. # Check the preservation of original Debug Info after each pass.; $ opt -verify-each-debuginfo-preserve -O2 sample.ll. Limit number of observed functions to speed up the analysis:. .. code-block:: bash. # Test up to 100 functions (per compile unit) per pass.; $ opt -verify-each-debuginfo-preserve -O2 -debugify-func-limit=100 sample.ll. Please do note that running ``-verify-each-debuginfo-preserve`` on big projects; could be heavily time consumi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:13499,avoid,avoided,13499,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['avoid'],['avoided']
Safety,"t an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even if; the type of comparison is inverted, but GVN only runs late in the pipeline.; As a result, you may miss the opportunity to run other important; optimizations. #. Avoid using arithmetic intrinsics unless you are *required* by your source; language specification to emit a particular code sequence. The optimizer; is quite good at reasoning about general control flow and arithmetic, it is; not anywhere near as strong at reasoning about the various intrinsics. If; profitable for code generation purposes, the optimizer will likely form the; intrinsics itself late in the optimization pipeline. It is *very* rarely; profitable to emit these directly in the language frontend. This item; explicitly includes the use of the :ref:`overflow intrinsics <int_overflow>`. #. Avoid using the :ref:`assume intrinsic <int_assume>` until you've; established that a) there's no other way to express the given fact and b); that fact is critical for optimization purposes. Assumes are a great; prototyping mechanism, but the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:8571,redund,redundant,8571,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['redund'],['redundant']
Safety,"t and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76672,recover,recover,76672,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recover']
Safety,"t and; Nathaniel Smith. It is now matplotlib's current default color map. ![Viridis](palette_112.png). ### TMultiGraph. Ignore empty graphs when computing the multi-graph range at painting time. ### TASImage. A left click on a image produced a one pixel zoom. ### TCreatePrimitives. The ending of a polyline creation is based on the closeness of the two last; entered points. The previous algorithm was based on user coordinates. It is now; based on pixel to avoid the problem reported; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20343). ### TCanvas. When the first canvas created by ROOT was in batch mode, it was note possible to; come back in interactive mode for the next canvases. this problem was reported; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20354). ### Cocoa Backend. Sometimes the mouse cursor did not change back to the window manager arrow when; exiting a `TCanvas`. ### `freetype` library. Updates `builtin_freetype` to 2.6.1 (current upstream version), which can detect; `PPC64LE` machine. This was compiled and tested on `SLC6 + ICC + x86_64`,; `F21 + GCC + ppc64le`, `MacOSX 10.11.1 + Xcode 7.1` and `Windows (ROOT 5.34)`.; `$ROOTSYS/graf2d/freetype/src/README` was removed, because no issues were noticed; with `ICC` compiler and `-Wall -pedantic -ansi` flags.; Additionally `--with-png=no --with-bzip2=no` flags are passed to freetype; configuration script. Default values for these options are auto.; `freetype` finds `libpng` and `libbzip2` on the system and builds extra; modules. Then attempting to link against `freetype` one would need to link; `-lpng -lbzip2` explicitly otherwise linking will returns in undefined; references. Otherwise we would need to check for `libpng` and `libbzip2` on the system; and adjust `FREETYPE_LIBRARIES` to include `-lpng` and `-lbzip2`.; The current solution goes for the minimal configuration. The original request for; this update was posted [here](https://sft.its.cern.ch/jira/browse/ROOT-7631). ## 3D Graphic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:17614,detect,detect,17614,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['detect'],['detect']
Safety,"t areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18377,abort,abort,18377,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"t element) serving as the upper bound. This applies to all; types of arrays including constant-length arrays, variable-length arrays (VLAs),; and flexible array members annotated with `__counted_by`. In the following example, reference to ``vla`` promotes to ``int; *__bidi_indexable``, with ``&vla[n]`` as the upper bound and ``&vla[0]`` as the; lower bound. Then, it's copied to ``int *p``, which is implicitly ``int; *__bidi_indexable p``. Please note that value of ``n`` used to create the upper; bound is ``10``, not ``100``, in this case because ``10`` is the actual length; of ``vla``, the value of ``n`` at the time when the array is being allocated. .. code-block:: c. void foo(void) {; int n = 10;; int vla[n];; n = 100;; int *p = vla; // { .ptr: &vla[0], .upper: &vla[10], .lower: &vla[0] }; // it's `&vla[10]` because the value of `n` was 10 at the; // time when the array is actually allocated.; // ...; }. By promoting array references to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35051,safe,safety,35051,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"t from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; sessions .; In TProofLite: fix problem with passing the 'varexp' and 'selection'; strings for processing, preventing correct usage of the operators '|'; and '||' in TTreeFormula.; In the TProofOutputFile constructor, remove the 'localroot' prefix; only if present in the path. Fixes possible truncation problems; occuring when the paths are not under the localroot scope.; In TXSocket and TXSlave: fix problem with the way collection over a; socket just marked as 'bad' was interrupted; the interrupt was de facto; ineffective, so that collection stayed always until the timeout expired; (default: 5 minutes). Should solve some of the cases were slow response; was experienced.; Fix a problem with log path transmission when the node dies early or; not even starts. The log path was empty and wrong was filled in when; retrieving the log buffers, disorienting debugging.; Fix a bug checking the first event which rendered ineffective the; request for processing a subset of events in a given dataset or; chain.; In pq2-ana-dist, fix problem with the labels of the distribution; histo occuring when machines are represented by IPs instead of; names.; Add missing calls to closedir() and TSystem::FreeDirectory, cuasing a; large number of filedescriptors remaining opened after xproofd; initialization.; Fix a problem with the final update of the progress information; affecting occasionally cases with skipped events.; Fix merging of TproofOutputFile when using submergers (the; intermediate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:6982,timeout,timeout,6982,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['timeout'],['timeout']
Safety,"t is sensible to version this document by the releases of its sole; implementation (and its host project), clang. ""LLVM X.Y"" refers to an; open-source release of clang from the LLVM project. ""Apple X.Y"" refers to an; Apple-provided release of the Apple LLVM Compiler. Other organizations that; prepare their own, separately-versioned clang releases and wish to maintain; similar information in this document should send requests to cfe-dev. If a change decreases the expressiveness of the language, for example by; imposing a new restriction, this should be taken as an oversight in the; original specification and something to be avoided in all versions. Such; changes are generally to be avoided. .. _arc.general:. General; =======. Automatic Reference Counting implements automatic memory management for; Objective-C objects and blocks, freeing the programmer from the need to; explicitly insert retains and releases. It does not provide a cycle collector;; users must explicitly manage the lifetime of their objects, breaking cycles; manually or with weak or unsafe references. ARC may be explicitly enabled with the compiler flag ``-fobjc-arc``. It may; also be explicitly disabled with the compiler flag ``-fno-objc-arc``. The last; of these two flags appearing on the compile line ""wins"". If ARC is enabled, ``__has_feature(objc_arc)`` will expand to 1 in the; preprocessor. For more information about ``__has_feature``, see the; :ref:`language extensions <langext-__has_feature-__has_extension>` document. .. _arc.objects:. Retainable object pointers; ==========================. This section describes retainable object pointers, their basic operations, and; the restrictions imposed on their use under ARC. Note in particular that it; covers the rules for pointer *values* (patterns of bits indicating the location; of a pointed-to object), not pointer *objects* (locations in memory which store; pointer values). The rules for objects are covered in the next section. A :arc-term:`retainabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:9082,unsafe,unsafe,9082,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['unsafe'],['unsafe']
Safety,"t memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type conditional on `ROOFIT_MEMORY_SAFE_INTERFACES`.; If you are overriding such a function, you need to use the `RooFit::OwningPtr`; return type, which is an alias for `std::unique_ptr` in memory-safe mode or an; alias for a raw pointer otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatibl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:9592,safe,safe,9592,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['safe'],['safe']
Safety,"t method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at each poll site desired. While calls or invokes; inside this method are transformed to a ``gc.statepoints``, recursive poll; insertion is not performed. This pass is useful for any language frontend which only has to support; garbage collection semantics at safepoints. If you need other abstract; frame information at safepoints (e.g. for deoptimization or introspection),; you can insert safepoint polls in the frontend. If you have the later case,; please ask on llvm-dev for suggestions. There's been a good amount of work; done on making such a scheme work well in practice which is not yet documented; here. Supported Architectures; =======================. Support for statepoint generation requires some code for each backend.; Today, only Aarch64 and X86_64 are supported. .. _OpenWork:. Limitations and Half Baked Ideas; ================================. Mixing References and Raw Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Support for languages which allow unmanaged pointers to garbage collected; objects (i.e. pass a pointer to an object to a C routine) in the abstract; machine model. At the moment, the best idea on how to approach this; involves an intrinsic or opaque function which hides the connection between; the reference value and the raw pointer. The problem is that having a; ptrtoint or inttoptr cast (which is common for such use cases) breaks the; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:33582,safe,safepoint,33582,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"t of entries requested by the user if called; together with other operations ([PR](https://github.com/root-project/root/pull/11398)).; - Requesting variations for `Stats` results with `VariationsFor` is now supported.; - Factory functions for RDataFrames reading CSV files, RNTuples, Arrow tables, etc. have been renamed in order to; increase consistency, e.g. `MakeCsvDataFrame` is now `FromCSV`. The old wording is still available but deprecated.; - The precision of `Sum`s and `Mean`s of single-precision floating point values has been greatly improved by employing; Kahan summations.; - The content of [execution logs](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#rdf-logging) from RDataFrame; has been streamlined in order to make them more useful. ### Distributed RDataFrame. - Add support for systematic variations (e.g. `Vary` and `VariationsFor` operations) in distributed mode.; - If an instant action (e.g. `Snapshot`) is purposely made lazy by the user, distributed RDataFrame now respects this; and avoids triggering the computations right away.; - The algorithm for automatic splitting of the input dataset has been reworked, bringing the startup time cost of; distributed RDataFrame close to zero.; - A histogram model (name, title, binning) for the `Histo*D` actions is now required in distributed mode. See the; [relative PR](https://github.com/root-project/root/pull/10368) for more discussion.; - The performance of distributed RDataFrame for large computation graphs (>1000 operations) has been greatly improved.; - If the `npartitions` argument is not set by the user, the default number of tasks created by a distributed RDataFrame; is equal to the number of cores specified by the user when connecting to the cluster.; - C++ exceptions (i.e. instances of `std::exception` and derived) are now correctly propagated from the processes of the; computing nodes to the user side.; - The minimum `dask` version required to support distributed RDataFrame is 2022.8.1, sinc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:13255,avoid,avoids,13255,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['avoid'],['avoids']
Safety,"t offset from the coroutine frame. Note that there is also an ABI independent method:. .. parsed-literal::. print std::coroutine_handle<task::promise_type>::from_address((void*)0x416eb0).promise(). The functions `from_address(void*)` and `promise()` are often small enough to; be removed during optimization, so this method may not be possible. Print coroutine frames; ======================. LLVM generates the debug information for the coroutine frame in the LLVM middle; end, which permits printing of the coroutine frame in the debugger. Much like; the `promise_type`, when stopped at a breakpoint inside a coroutine we can; print the coroutine frame by:. .. parsed-literal::. print __coro_frame. Just as printing the `promise_type` is possible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_ty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5232,avoid,avoid,5232,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['avoid'],['avoid']
Safety,"t pattern or if there are multiple substitutions whose patterns; contain ``%{name}``. The substitution's current position in the substitution; list does not change so that expansion order relative to other existing; substitutions is preserved. The following properties apply to both the ``DEFINE:`` and ``REDEFINE:``; directives:. - **Substitution name**: In the directive, whitespace immediately before or; after ``%{name}`` is optional and discarded. ``%{name}`` must start with; ``%{``, it must end with ``}``, and the rest must start with a letter or; underscore and contain only alphanumeric characters, hyphens, underscores, and; colons. This syntax has a few advantages:. - It is impossible for ``%{name}`` to contain sequences that are special in; python's ``re.sub`` patterns. Otherwise, attempting to specify; ``%{name}`` as a substitution pattern in a lit configuration file could; produce confusing expansions.; - The braces help avoid the possibility that another substitution's pattern; will match part of ``%{name}`` or vice-versa, producing confusing; expansions. However, the patterns of substitutions defined by lit; configuration files and by lit itself are not restricted to this form, so; overlaps are still theoretically possible. - **Substitution value**: The value includes all text from the first; non-whitespace character after ``=`` to the last non-whitespace character. If; there is no non-whitespace character after ``=``, the value is the empty; string. Escape sequences that can appear in python ``re.sub`` replacement; strings are treated as plain text in the value.; - **Line continuations**: If the last non-whitespace character on the line after; ``:`` is ``\``, then the next directive must use the same directive keyword; (e.g., ``DEFINE:``) , and it is an error if there is no additional directive.; That directive serves as a continuation. That is, before following the rules; above to parse the text after ``:`` in either directive, lit joins that text; togethe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:34288,avoid,avoid,34288,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoid']
Safety,"t removing it; entirely, or you want to write comments that mention a directive by name. The; ""``COM:``"" directive makes it easy to do this. For example, you might have:. .. code-block:: llvm. ; X32: pinsrd_1:; ; X32: pinsrd $1, 4(%esp), %xmm0. ; COM: FIXME: X64 isn't working correctly yet for this part of codegen, but; ; COM: X64 will have something similar to X32:; ; COM:; ; COM: X64: pinsrd_1:; ; COM: X64: pinsrd $1, %edi, %xmm0. Without ""``COM:``"", you would need to use some combination of rewording and; directive syntax mangling to prevent FileCheck from recognizing the commented; occurrences of ""``X32:``"" and ""``X64:``"" above as directives. Moreover,; FileCheck diagnostics have been proposed that might complain about the above; occurrences of ""``X64``"" that don't have the trailing ""``:``"" because they look; like directive typos. Dodging all these problems can be tedious for a test; author, and directive syntax mangling can make the purpose of test code unclear.; ""``COM:``"" avoids all these problems. A few important usage notes:. * ""``COM:``"" within another directive's pattern does *not* comment out the; remainder of the pattern. For example:. .. code-block:: llvm. ; X32: pinsrd $1, 4(%esp), %xmm0 COM: This is part of the X32 pattern!. If you need to temporarily comment out part of a directive's pattern, move it; to another line. The reason is that FileCheck parses ""``COM:``"" in the same; manner as any other directive: only the first directive on the line is; recognized as a directive. * For the sake of LIT, FileCheck treats ""``RUN:``"" just like ""``COM:``"". If this; is not suitable for your test environment, see :option:`--comment-prefixes`. * FileCheck does not recognize ""``COM``"", ""``RUN``"", or any user-defined comment; prefix as a comment directive if it's combined with one of the usual check; directive suffixes, such as ""``-NEXT:``"" or ""``-NOT:``"", discussed below.; FileCheck treats such a combination as plain text instead. If it needs to act; as a comment d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:11851,avoid,avoids,11851,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['avoid'],['avoids']
Safety,"t stores `RA` in a dedicated register `R` before the `CALL` instruction.; `f()` does not spill `R` and does not use the `RET` instruction,; instead it uses the value in `R` to `JMP` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spill",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25687,abort,abort,25687,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['abort'],['abort']
Safety,"t to kUseGlobalSetting (0), the global variable; controls the algorithm for compression operations. This is the; default and the default value for the global variable is kZLIB. gDirectory; gDirectory is now a thread local!. The value of gDirectory and gFile are now all accessed via a static function of their respective class. The access is made transparent via a CPP macro. Note: Whenever a thread has an associated TThread object, the value of gDirectory is now thread local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed from a thread to another, the code must explicitly reset gDirectory to another value or there is a risk for this gDirectory to point to a stale pointer if the other thread deletes the TFile object. A TFile deletion will only affect the value of the local gDirectory and gFile. TMemFile; Introduce TMemFile and update TFileMerger to support incremental merges. Add new tutorials (net/treeClient.C + net/fastMergeServer.C); demonstrating how a TMemFile can be used to do parallel merge; from many clients. (TMemFile still needs to be better integrated; with TMessage and TSocket). The new TMemFile class support the TFile interface but only store; the information in memory. This version is limited to 32MB. TMessage mess;; ...; mess->ReadFastArray(scratch,length);; transient = new TMemFile(""hsimple.memroot"",scratch,length);. will copy the content of 'scratch' into the in-memory buffer; created by/for the TMemFile. TMemFile *file = new TMemFile(""hsimple.memroot"",""RECREATE"");. Will create an empty in-memory of (currently fixed) size 32MB. file->ResetAfterMerge(0);. Wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:3763,risk,risk,3763,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['risk'],['risk']
Safety,"t, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add; that to the redeclaration chain of the found node. This behaviour is essential; when we merge ASTs from different translation units which include the same; header file(s). For example, we want to have only one definition for the class; template ``std::vector``, even if we included ``<vector>`` in several; translation units. To find a structurally equivalent node we can use the regular C/C++ lookup; functions: ``DeclContext::noload_lookup()`` and; ``DeclContext::localUncachedLookup()``. These functions do respect the C/C++; name hiding rules, thus you cannot find certain declarations in a given; declaration context. For instance, unnamed declarations (anonymous structs),; non-first ``friend`` declarations and template specializations are hidden. This; is a problem, because if we use the regular C/C++ lookup then we create; redundant AST nodes during the merge! Also, having two instances of the same; node could result in false :ref:`structural in-equivalencies <structural-eq>`; of other nodes which depend on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (repr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:105705,redund,redundant,105705,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['redund'],['redundant']
Safety,"t: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1509,detect,detect,1509,interpreter/cling/www/old/contact.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html,1,['detect'],['detect']
Safety,"t; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unrea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16525,recover,recoverable,16525,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['recover'],['recoverable']
Safety,"tMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoManager::GetSafeDistance(): safe distance (in case it was computed). TGeoManager::IsOnBoundary(): the initial point `(x,y,z)` was (or was; not) on a boundary within TGeoShape::Tolerance(). The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:121993,safe,safety,121993,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"ta, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kernels), these approaches require manual and/or static analysis aided auditing; of code and explicit source changes to apply the mitigation. They are unlikely; to scale well to large applications. We are proposing a comprehensive; mitigation approach that would apply automatically across an entire program; rather than through manual changes to the code. While this is likely to have a; high performance cost, some applications may be in a good position to take this; performance / security tradeoff. The specific ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:2069,predict,predictor,2069,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,2,['predict'],"['predict', 'predictor']"
Safety,"ta>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307799,unsafe,unsafe,307799,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"tack, and other context elements corresponding to the source language; thread of execution upon which the user is focused, if any. The resulting; value V\ :sub:`3` is the value in L\ :sub:`2` at the time of the call made; by the call site. The result of these attributes is undefined if the current call frame is not; for the subprogram containing the ``DW_TAG_call_site_parameter`` debugger; information entry or the current program location is not for the call site; containing the ``DW_TAG_call_site_parameter`` debugger information entry in; the current call frame. *The consumer may have to virtually unwind to the call site (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) in order to evaluate these; attributes. This will ensure the source language thread of execution upon; which the user is focused corresponds to the call site needed to evaluate; the expression.*. If it is not possible to avoid the expressions of these attributes from; accessing registers or memory locations that might be clobbered by the; subprogram being called by the call site, then the associated attribute; should not be provided. *The reason for the restriction is that the parameter may need to be; accessed during the execution of the callee. The consumer may virtually; unwind from the called subprogram back to the caller and then evaluate the; attribute expressions. The call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) will not be able to restore; registers that have been clobbered, and clobbered memory will no longer have; the value at the time of the call.*. 3. Each call site parameter entry may also have a ``DW_AT_call_parameter``; attribute which contains a reference to a ``DW_TAG_formal_parameter`` entry,; ``DW_AT_type attribute`` referencing the type of the parameter or; ``DW_AT_name`` attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:170781,avoid,avoid,170781,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['avoid'],['avoid']
Safety,"tack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77060,recover,recovery,77060,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['recover'],['recovery']
Safety,"tants may also be represented as a double-quoted string using the ``c``; prefix. For example: ""``c""Hello World\0A\00""``"".; **Vector constants**; Vector constants are represented with notation similar to vector; type definitions (a comma separated list of elements, surrounded by; less-than/greater-than's (``<>``)). For example:; ""``< i32 42, i32 11, i32 74, i32 100 >``"". Vector constants; must have :ref:`vector type <t_vector>`, and the number and types of; elements must match those specified by the type. When creating a vector whose elements have the same constant value, the; preferred syntax is ``splat (<Ty> Val)``. For example: ""``splat (i32 11)``"".; These vector constants must have ::ref:`vector type <t_vector>` with an; element type that matches the ``splat`` operand.; **Zero initialization**; The string '``zeroinitializer``' can be used to zero initialize a; value to zero of *any* type, including scalar and; :ref:`aggregate <t_aggregate>` types. This is often used to avoid; having to print large zero initializers (e.g. for large arrays) and; is always exactly equivalent to using explicit zero initializers.; **Metadata node**; A metadata node is a constant tuple without types. For example:; ""``!{!0, !{!2, !0}, !""test""}``"". Metadata can reference constant values,; for example: ""``!{!0, i32 0, ptr @global, ptr @function, !""str""}``"".; Unlike other typed constants that are meant to be interpreted as part of; the instruction stream, metadata is a place to attach additional; information such as debug info. Global Variable and Function Addresses; --------------------------------------. The addresses of :ref:`global variables <globalvars>` and; :ref:`functions <functionstructure>` are always implicitly valid; (link-time) constants. These constants are explicitly referenced when; the :ref:`identifier for the global <identifiers>` is used and always have; :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM; file:. .. code-block:: llvm. @X = global i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:189612,avoid,avoid,189612,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"tation-based profile; the output format is the indexed binary format. .. option:: --extbinary. Emit the profile using an extensible binary encoding. This option can only; be used with sample-based profile. The extensible binary encoding can be; more compact with compression enabled and can be loaded faster than the; default binary encoding. .. option:: --text. Emit the profile in text mode. This option can also be used with both; sample-based and instrumentation-based profile. When this option is used; the profile will be dumped in the text format that is parsable by the profile; reader. .. option:: --gcc. Emit the profile using GCC's gcov format (Not yet supported). .. option:: --sparse[=true|false]. Do not emit function records with 0 execution count. Can only be used in; conjunction with -instr. Defaults to false, since it can inhibit compiler; optimization during PGO. .. option:: --num-threads=<N>, -j. Use N threads to perform profile merging. When N=0, llvm-profdata auto-detects; an appropriate number of threads to use. This is the default. .. option:: --failure-mode=[any|all]. Set the failure mode. There are two options: 'any' causes the merge command to; fail if any profiles are invalid, and 'all' causes the merge command to fail; only if all profiles are invalid. If 'all' is set, information from any; invalid profiles is excluded from the final merged product. The default; failure mode is 'any'. .. option:: --prof-sym-list=<path>. Specify a file which contains a list of symbols to generate profile symbol; list in the profile. This option can only be used with sample-based profile; in extbinary format. The entries in this file are newline-separated. .. option:: --compress-all-sections=[true|false]. Compress all sections when writing the profile. This option can only be used; with sample-based profile in extbinary format. .. option:: --use-md5=[true|false]. Use MD5 to represent string in name table when writing the profile.; This option can only be used with sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profdata.rst:3961,detect,detects,3961,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profdata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-profdata.rst,1,['detect'],['detects']
Safety,"tax:; """""""""""""". ::. declare i1 @llvm.type.test(ptr %ptr, metadata %type) nounwind memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer to be tested. The second argument is a; metadata object representing a :doc:`type identifier <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.test`` intrinsic tests whether the given pointer is associated; with the given type identifier. .. _type.checked.load:. '``llvm.type.checked.load``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare {ptr, i1} @llvm.type.checked.load(ptr %ptr, i32 %offset, metadata %type) nounwind memory(argmem: read). Arguments:; """""""""""""""""""". The first argument is a pointer from which to load a function pointer. The; second argument is the byte offset from which to load the function pointer. The; third argument is a metadata object representing a :doc:`type identifier; <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.checked.load`` intrinsic safely loads a function pointer from a; virtual table pointer using type metadata. This intrinsic is used to implement; control flow integrity in conjunction with virtual call optimization. The; virtual call optimization pass will optimize away ``llvm.type.checked.load``; intrinsics associated with devirtualized calls, thereby removing the type; check in cases where it is not needed to enforce the control flow integrity; constraint. If the given pointer is associated with a type metadata identifier, this; function returns true as the second element of its return value. (Note that; the function may also return true if the given pointer is not associated; with a type metadata identifier.) If the function's return value's second; element is true, the following rules apply to the first element:. - If the given pointer is associated with the given type metadata identifier,; it is the function pointer loaded from the given byte offset from the given; pointer. - If the given pointer is not associated with the given type meta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:938235,safe,safely,938235,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"te__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3819,unsafe,unsafe,3819,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['unsafe'],['unsafe']
Safety,"tead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAULT)). It is also possible to tune this 'cache-and-track' optimization to perform a more fine-grained caching; of components than Optimize(2) implements: to do so, call arg->setAttribute(""CacheAndTrack"") on each; pdf component that you'd like to be cache-and-tracked individually. New pdf/data attach mechanism in likelihood objects (RooAbsOptTestStatistic). The new mechanism only; reattaches the dataset branch buffers and not the RooRealVars representing the data. This new designs; allows for a much faster RooAbsTestStatistic::setData() implementation, which changes the dataset in; an existing likelihood object. This will speed up RooStats tools based on 'simple' likelihood models; substantially. Automatic detections of 'binned' pdfs and automatic generation of binned data in generate(). RooFit will; now automatically generate binned pdf shapes. Binned pdfs shapes are fundamentally RooHistPdf and RooHistFuncs; (with interpolation order set to zero). Products and sums of exclusively binned shapes are also recognized; as binned shapes. For such binned shapes generate() will now by default follow the 'binned' strategy ; -- that is, take the expectation value in each bin and sample a Poisson distribution from that -- rather; than follow the unbinned strategy. The rationale is that such datasets result in much faster likelihood; calculations (for nbin smaller than nevent). The optimization is also exact: the likelihood of a binned ; data using a binned pdf is identical to that of an unbinned dataset with a binned pdf. Nevertheless you can ; switch off this feature by passing AutoBinned(false) to RooAbsPdf::generate(). Mixed binned/unbinned generation from simultaneous pdf. For a RooSimultaneous consisting of exclusively; extend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:4394,detect,detections,4394,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['detect'],['detections']
Safety,"ted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are veri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68975,safe,safe,68975,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"tegy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. Debugging; =========. Internal bounds annotations; ---------------------------. Internal bounds annotation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7252,safe,safety,7252,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"ter and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution of a poll; under normal conditions. PlaceSafepoints does not attempt to ensure timely; execution of a poll under worst case conditions such as heavy system paging. The implementation of a safepoint poll action is specified by looking up a; function of the name ``gc.safepoint_poll`` in the containing Module. The body; of this function is inserted at",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:32210,safe,safepoint,32210,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"ter into a wide pointer. The debugger; needs to understand that wide pointers are essentially pointers with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to provide support that goes beyond showing the internal structure of; the wide pointer. There are no DWARF extensions needed to support wide pointers.; In our implementation, LLDB recognizes wide pointer types by name and; reconstructs them as wide pointer Clang AST types for use in the expression; evaluator. External bounds annotations; ---------------------------. Similar to internal bounds annotations, external bound annotations are described; as a typedef to their underlying pointer type in the debug info, and the bounds; are encoded as strings in the typedef’s name (e.g.,; ``__bounds_safety$counted_by:N``). Recognizing ``-fbounds-safety`` traps; -------------------------------------. Clang emits debug info for ``-fbounds-safety`` traps as inlined functions, where; the function name encodes the error message. LLDB implements a frame recognizer; to surface a human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:9306,safe,safety,9306,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"ter on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2846,safe,safely,2846,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safely']
Safety,"terType::get()`` and similar APIs are automatically converted into; opaque pointers. This simplifies migration and allows testing existing IR with; opaque pointers. .. code-block:: llvm. define i8* @test(i8* %p) {; %p2 = getelementptr i8, i8* %p, i64 1; ret i8* %p2; }. ; Is automatically converted into the following if -opaque-pointers; ; is enabled:. define ptr @test(ptr %p) {; %p2 = getelementptr i8, ptr %p, i64 1; ret ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * Use ``getLoadStoreType()`` to handle both of the above in one call.; * For getelementptr instructions, use ``getSourceElementType()``.; * For calls, use ``getFunctionType()``.; * For allocas, use ``getAllocatedType()``.; * For globals, use ``getValueType()``.; * For consistency assertions, use; ``PointerType::isOpaqueOrPointeeTypeEquals()``.; * To create a pointer type in a different address space, use; ``PointerType::getWithSamePointeeType()``.; * To check that two pointers have the same element type, use; ``PointerType::hasSameElementTypeAs()``.; * While it is preferred to write code in a way that accepts both typed and; opaque pointers, ``Type::isOpaquePointerTy()`` and; ``PointerType::isOpaque()`` can be used to handle opaque pointers specially.; ``PointerType::getNonOpaquePointerElementType()`` can be used as a marker in; code-paths where opaque pointers have b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:6782,avoid,avoid,6782,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['avoid'],['avoid']
Safety,"terating-over-def-use-use-def-chains>`_. **Reassociation**; Rearranging associative expressions to promote better redundancy elimination; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,; `derived pointers`_ must not be retained across safe points and `object; pointers`_ must be reloaded from stack roots. **SDISel**; Selection DAG Instruction Selection. **SCC**; Strongly Connected Component. **SCCP**; Sparse Conditional Constant Propagation. **SLP**; Superword-Level Parallelism, same as :ref:`Basic-Block Vectorization; <lexicon-bb-vectorization>`. **Splat**; Splat refers to a vector of identical scalar elements. The term is based on the PowerPC Altivec instructions that provided; this functionality in hardware. For example, ""vsplth"" and the corresponding; software intrinsic ""vec_splat()"". Examples of other hardware names for this; action include ""duplicate"" (ARM) and ""broadcast"" (x86). **SRoA**; Scalar Replacement of Aggregates. **SSA**; Static Single Assignment. **Stack Map**; In garbage collection, metadata emitted by the code generator which; identifies `roots`_ withi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:7785,safe,safe,7785,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['safe'],['safe']
Safety,"ters visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, such non-integral pointer type have no defined mapping to an; integer representation. This semantic quirk allows the runtime to pick a; integer mapping for each point in the program allowing relocations of objects; without visible effects. This high level abstract machine model is used for most of the optimizer. As; a result, transform passes do not need to be e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:4216,safe,safepoint,4216,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoint']
Safety,"tes, since we have not; deleted any objects. The last entry is the address of the last byte in; the file. ### File Recovery. A file may become corrupted or it may be impossible to write it to disk; and close it properly. For example if the file is too large and exceeds; the disk quota, or the job crashes or a batch job reaches its time limit; before the file can be closed. In these cases, it is imperative to; recover and retain as much information as possible. ROOT provides an; intelligent and elegant file recovery mechanism using the redundant; directory information in the record header. If a file that has been not properly closed is opened again, it is; scanned and rebuilt according to the information in the record header.; The recovery algorithm reads the file and creates the saved objects in; memory according to the header information. It then rebuilds the; directory and file structure. If the file is opened in write mode, the; recovery makes the correction on disk when the file is closed; however; if the file is opened in read mode, the correction can not be written to; disk. You can also explicitly invoke the recovery procedure by calling; the `TFile::Recover()` method. You can recover the directory structure,; but you cannot save what you recovered to the file on disk. In the; following example, we interrupted and aborted the previous ROOT session,; causing the file not to be closed. When we start a new session and; attempt to open the file, it gives us an explanation and status on the; recovery attempt. ``` {.cpp}; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; ```. ## The Logical ROOT File: TFile and TKey. We saw that the `TFile::Map()` method reads the file sequentially and; prints information about each record while scanning the file. It is not; feasible to support only sequential access and hence ROOT provides; random or direct access, i.e. reading a specified ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:15531,recover,recovery,15531,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['recover'],['recovery']
Safety,"tever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-block:: c++. std::string S;; // Simple formatting of basic types and implicit string conversion.; S = formatv(""{0} ({1:P})"", 7, 0.35); // S == ""7 (35.00%)"". // Out-of-order referencing and multi-referencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14688,detect,detected,14688,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['detect'],['detected']
Safety,"text will be updated; once the API churn dies down.**. Welcome to Chapter 3 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter discusses lazy JITing and shows you how to enable it by adding an ORC; CompileOnDemand layer the JIT from `Chapter 2 <BuildingAJIT2.html>`_. Lazy Compilation; ================. When we add a module to the KaleidoscopeJIT class from Chapter 2 it is; immediately optimized, compiled and linked for us by the IRTransformLayer,; IRCompileLayer and RTDyldObjectLinkingLayer respectively. This scheme, where all the; work to make a Module executable is done up front, is simple to understand and; its performance characteristics are easy to reason about. However, it will lead; to very high startup times if the amount of code to be compiled is large, and; may also do a lot of unnecessary compilation if only a few compiled functions; are ever called at runtime. A truly ""just-in-time"" compiler should allow us to; defer the compilation of any given function until the moment that function is; first called, improving launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each function in them to be compiled the; first time it is called. To do this, the CompileOnDemandLayer creates two small; utilities for each function that it scans: a *stub* and a *compile; callback*. The stub is a pair of a function pointer (which will be pointed at; the function's implementation once the function has been compiled) and an; indirect jump through the pointer. By fixing the address of the indirect jump; for the lifetime of the program we can give the function a permanent ""effective; address"", one that can be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:1612,redund,redundant,1612,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['redund'],['redundant']
Safety,"th :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46052,redund,redundant,46052,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['redund'],['redundant']
Safety,"th access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312782,safe,safe,312782,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safe']
Safety,"th are optional. The ""selection of target"" behavior is defined as follows:. (1) If the user does not specify -triple, we default to the host triple.; (2) If the user specifies a -arch, that overrides the arch in the host or; specified triple. //===---------------------------------------------------------------------===//. verifyInputConstraint and verifyOutputConstraint should not return bool. Instead we should return something like:. enum VerifyConstraintResult {; Valid,. // Output only; OutputOperandConstraintLacksEqualsCharacter,; MatchingConstraintNotValidInOutputOperand,. // Input only; InputOperandConstraintContainsEqualsCharacter,; MatchingConstraintReferencesInvalidOperandNumber,. // Both; PercentConstraintUsedWithLastOperand; };. //===---------------------------------------------------------------------===//. Blocks should not capture variables that are only used in dead code. The rule that we came up with is that blocks are required to capture; variables if they're referenced in evaluated code, even if that code; doesn't actually rely on the value of the captured variable. For example, this requires a capture:; (void) var;; But this does not:; if (false) puts(var);. Summary of <rdar://problem/9851835>: if we implement this, we should; warn about non-POD variables that are referenced but not captured, but; only if the non-reachability is not due to macro or template; metaprogramming. //===---------------------------------------------------------------------===//. We can still apply a modified version of the constructor/destructor; delegation optimization in cases of virtual inheritance where:; - there is no function-try-block,; - the constructor signature is not variadic, and; - the parameter variables can safely be copied and repassed; to the base constructor because either; - they have not had their addresses taken by the vbase initializers or; - they were passed indirectly. //===---------------------------------------------------------------------===//; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt:3744,safe,safely,3744,interpreter/llvm-project/clang/NOTES.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt,1,['safe'],['safely']
Safety,"th libc++; newer than 2016-11-16. ``<algorithm>``; ---------------. In C++14, many useful functions from ``<algorithm>`` (notably, ``std::min`` and; ``std::max``) become constexpr. You can therefore use these in device code,; when compiling with clang. Detecting clang vs NVCC from code; =================================. Although clang's CUDA implementation is largely compatible with NVCC's, you may; still want to detect when you're compiling CUDA code specifically with clang. This is tricky, because NVCC may invoke clang as part of its own compilation; process! For example, NVCC uses the host compiler's preprocessor when; compiling for device code, and that host compiler may in fact be clang. When clang is actually compiling CUDA code -- rather than being used as a; subtool of NVCC's -- it defines the ``__CUDA__`` macro. ``__CUDA_ARCH__`` is; defined only in device mode (but will be defined if NVCC is using clang as a; preprocessor). So you can use the following incantations to detect clang CUDA; compilation, in host and device modes:. .. code-block:: c++. #if defined(__clang__) && defined(__CUDA__) && !defined(__CUDA_ARCH__); // clang compiling CUDA code, host mode.; #endif. #if defined(__clang__) && defined(__CUDA__) && defined(__CUDA_ARCH__); // clang compiling CUDA code, device mode.; #endif. Both clang and nvcc define ``__CUDACC__`` during CUDA compilation. You can; detect NVCC specifically by looking for ``__NVCC__``. Dialect Differences Between clang and nvcc; ==========================================. There is no formal CUDA spec, and clang and nvcc speak slightly different; dialects of the language. Below, we describe some of the differences. This section is painful; hopefully you can skip this section and live your life; blissfully unaware. Compilation Models; ------------------. Most of the differences between clang and nvcc stem from the different; compilation models used by clang and nvcc. nvcc uses *split compilation*,; which works roughly as follows",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:8235,detect,detect,8235,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['detect'],['detect']
Safety,"that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC mode",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71578,unsafe,unsafe,71578,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"that we try to maintain some; backwards compatibility. The rules are intended as a balance between convenience; for llvm users and not imposing a big burden on llvm developers:. * The textual format is not backwards compatible. We don't change it too often,; but there are no specific promises. * Additions and changes to the IR should be reflected in; ``test/Bitcode/compatibility.ll``. * The current LLVM version supports loading any bitcode since version 3.0. * After each X.Y release, ``compatibility.ll`` must be copied to; ``compatibility-X.Y.ll``. The corresponding bitcode file should be assembled; using the X.Y build and committed as ``compatibility-X.Y.ll.bc``. * Newer releases can ignore features from older releases, but they cannot; miscompile them. For example, if nsw is ever replaced with something else,; dropping it would be a valid way to upgrade the IR. * Debug metadata is special in that it is currently dropped during upgrades. * Non-debug metadata is defined to be safe to drop, so a valid way to upgrade; it is to drop it. That is not very user friendly and a bit more effort is; expected, but no promises are made. C API Changes; -------------. * Stability Guarantees: The C API is, in general, a ""best effort"" for stability.; This means that we make every attempt to keep the C API stable, but that; stability will be limited by the abstractness of the interface and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:32397,safe,safe,32397,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['safe'],['safe']
Safety,"the ROOT file embedding (PR [#10558](https://github.com/root-project/root/pull/10558)). In particular, a `RNTupleReader` or `RDataFrame` object can be created from a `TFile` instance as follows; ```; auto f = TFile::Open(""data.root"");; auto ntpl = f->Get<ROOT::Experimental::RNTuple>(""Events"");. auto reader = ROOT::Experimental::RNTupleReader::Open(ntpl);; // or for RDataFrame; auto rdf = ROOT::Experimental::MakeNTupleDataFrame(ntpl);; ```. - If buffered write is enabled, vector writes are used where possible. In particular, this yields important improvements in storage backends leveraging parallel writes, e.g. in object storages. - Large read/write throughput improvements in the experimental Intel DAOS backend. - `RNTupleWriter::Fill()` now returns the number of uncompressed bytes written, which is align with TTree behavior. - Support for user-defined classes that behave as a collection via the `TVirtualCollectionProxy` interface.; Fields created via `RFieldBase::Create()` automatically detect the presence of a collection proxy at run-time. However, if `RField<T>` (`T` being a class) is used instead, the trait `IsCollectionProxy<T>` must be set for the given type (see PR [#11525](https://github.com/root-project/root/pull/11525) for details).; Note that associative collections are not yet supported. - Some internal support for per field post-read callbacks. This functionality will be presented in upcoming releases through custom I/O rules. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade in 2024. Thus, we appreciate feedback and suggestions for improvement. ## RDataFrame. ### New features. - Add [`GraphAsymmErrors`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#acea30792eef607489d498bf6547a00a6) action that fills a TGraphAsymmErrors object.; - Introduce [`RDatasetSpec`](https://root.cern/doc/master/classROOT_1_1RDF_1_1Experimental_1_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:9978,detect,detect,9978,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['detect'],['detect']
Safety,"the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));; ```. ### Deprecation of legacy iterators. The following methods related to the RooFit legacy iterators are deprecated an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10811,avoid,avoid,10811,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['avoid'],['avoid']
Safety,"the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:99338,predict,predictable,99338,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['predict'],['predictable']
Safety,"the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the; ``Use`` objects belonging to the same ``User`` form a contiguous array. We have 2 different layouts in the ``User`` (sub)classes:. * Layout a). The ``Use`` object(s) are inside (resp. at fixed offset) of the ``User``; object and there are a fixed number of them. * Layout b). The ``Use`` object(s) are referenced by a pointer to an array from the; ``User`` object and there may be a variable number of them. As of v2.4 each layout still possesses a direct pointer to the start of the; array of ``Use``\ s. Though not mandatory for layout a), we stick to this; redundancy for the sake of simplicity. The ``User`` object also stores the; number of ``Use`` objects it has. (Theoretically this information can also be; calculated given the scheme presented below.). Special forms of allocation operators (``operator new``) enforce the following; memory layouts:. * Layout a) is modelled by prepending the ``User`` object by the ``Use[]``; array. .. code-block:: none. ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:128049,redund,redundancy,128049,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['redund'],['redundancy']
Safety,"the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:192327,unsafe,unsafe,192327,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['unsafe'],['unsafe']
Safety,"the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161449,safe,safety,161449,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"the decomposed matrix is smaller than `fTol`. Here an; important point is raised. The `Decompose()` method is successful as; long no zero diagonal element is encountered. Therefore, the user could; perform decomposition and only after this step worry about the tolerance; number. If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices or vectors that are; invalid. If one would like to monitor the tolerance parameter but not; have the code stop in case of a number smaller than `fTol`, one could; proceed as follows:. ``` {.cpp}; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; ```. The observant reader will notice that by scaling the complete matrix by; some small number the decomposition will detect a singular matrix. In; this case, the user will have to reduce the tolerance number by this; factor. (For CPU time saving we decided not to make this an automatic procedure). ### Condition number. The numerical accuracy of the solution `x` in `Ax = b` can be accurately; estimated by calculating the condition number `k` of matrix $A$, which is defined as:. $k = ||A||_{1}||A^{-1}||_{1}$ where $||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)$. A good rule of thumb is that if the matrix condition number is 10n,; the accuracy in `x` is `15` - `n` digits for double precision. Hager devised an iterative method (W.W. Hager, Condition estimators,; SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to; determine $||A^{-1}||_{1}$ without actually having to; calculate $A^{-1}$. It is used when calling `Condition()`. A code example below shows the usage of the condition number. The matrix $A$; is a (10x10) *Hilbert* matrix that is badly; conditioned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:41420,detect,detect,41420,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['detect'],['detect']
Safety,"the generated compiler is to use LTO,; PGO, and statically link everything. This will result in an overall larger; distribution, and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving symbols; at process launch time, which can be very slow for C++ code. .. _shared_libs:. .. warning::; One very important note: Distributions should never be built using the; *BUILD_SHARED_LIBS* CMake option. That option exists for optimizing developer; workflow only. Due to design and implementation decisions, LLVM relies on; global data which can end up being duplicated across shared libraries; resulting in bugs. As such this is not a safe way to distribute LLVM or; LLVM-based tools. The simplest example of building a distribution with reasonable performance is; captured in the DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .. code-block:: console. $ cmake -G Ninja -C <path to clang>/cmake/caches/DistributionExample.cmake <path to LLVM source>; $ ninja stage2-distribution; $ ninja stage2-install-distribution. Difference between ``install`` and ``install-distribution``; -----------------------------------------------------------. One subtle but important thing to note is the difference between the ``install``; and ``install-distribution`` targets. The ``install`` target is expected to; install every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific part",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:2440,safe,safe,2440,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['safe'],['safe']
Safety,"the pointee must be an integer, pointer, or; floating-point type whose bit width is a power of two greater than or equal to; eight and less than or equal to a target-specific size limit. ``align`` must be; explicitly specified on atomic loads. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic loads. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single; metadata name ``<nontemp_node>`` corresponding to a metadata node with one; ``i32`` entry of value 1. The existence of the ``!nontemporal``; metadata on the instruction tells the optimizer and code generator; that this load is not expected to be reused in the cache. The code; generator may select special instructions to save cache bandwidth, such; as the ``MOVNT`` instruction on x86. The optional ``!invariant.load`` metadata must reference a single; metadata name ``<empty_node>`` co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:414423,safe,safely,414423,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['safe'],['safely']
Safety,"the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20206,avoid,avoid,20206,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,"['avoid', 'safe']","['avoid', 'safety']"
Safety,"the program, or inlined away; completely. The :doc:`LLVM test-suite <TestSuiteMakefileGuide>` provides a framework to; test the optimizer's handling of debugging information. It can be run like; this:. .. code-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=dbgopt. This will test impact of debugging information on optimization passes. If; debugging information influences optimization passes then it will be reported; as a failure. See :doc:`TestingGuide` for more information on LLVM test; infrastructure and how to run various tests. .. _format:. Debugging information format; ============================. LLVM debugging information has been carefully designed to make it possible for; the optimizer to optimize the program and debugging information without; necessarily having to know anything about debugging information. In; particular, the use of metadata avoids duplicated debugging information from; the beginning, and the global dead code elimination pass automatically deletes; debugging information for a function if it decides to delete the function. To do this, most of the debugging information (descriptors for types,; variables, functions, source files, etc) is inserted by the language front-end; in the form of LLVM metadata. Debug information is designed to be agnostic about the target debugger and; debugging information representation (e.g. DWARF/Stabs/etc). It uses a generic; pass to decode the information that represents variables, types, functions,; namespaces, etc: this allows for arbitrary source-language semantics and; type-systems to be used, as long as there is a module written for the target; debugger to interpret the information. To provide basic functionality, the LLVM debugger does have to make some; assumptions about the source-level language being debugged, though it keeps; these to a minimum. The only common features that the LLVM debugger assumes; exist are `source files <LangRef.html#difile>`_,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:6555,avoid,avoids,6555,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['avoid'],['avoids']
Safety,"the resulting object at all. It is just used; in the assembler to differentiate the sections. The 'o' flag is mapped to SHF_LINK_ORDER. If it is present, a symbol; must be given that identifies the section to be placed is the; .sh_link. .. code-block:: gas. .section .foo,""a"",@progbits; .Ltmp:; .section .bar,""ao"",@progbits,.Ltmp. which is equivalent to just. .. code-block:: gas. .section .foo,""a"",@progbits; .section .bar,""ao"",@progbits,.foo. ``.linker-options`` Section (linker options); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to support passing linker options from the frontend to the linker, a; special section of type ``SHT_LLVM_LINKER_OPTIONS`` (usually named; ``.linker-options`` though the name is not significant as it is identified by; the type). The contents of this section is a simple pair-wise encoding of; directives for consideration by the linker. The strings are encoded as standard; null-terminated UTF-8 strings. They are emitted inline to avoid having the; linker traverse the object file for retrieving the value. The linker is; permitted to not honour the option and instead provide a warning/error to the; user that the requested option was not honoured. The section has type ``SHT_LLVM_LINKER_OPTIONS`` and has the ``SHF_EXCLUDE``; flag to ensure that the section is treated as opaque by linkers which do not; support the feature and will not be emitted into the final linked binary. This would be equivalent to the follow raw assembly:. .. code-block:: gas. .section "".linker-options"",""e"",@llvm_linker_options; .asciz ""option 1""; .asciz ""value 1""; .asciz ""option 2""; .asciz ""value 2"". The following directives are specified:. - lib. The parameter identifies a library to be linked against. The library will; be looked up in the default and any specified library search paths; (specified to this point). - libpath. The parameter identifies an additional library search path to be considered; when looking up libraries after the inclusion of this option. ``SHT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst:6441,avoid,avoid,6441,interpreter/llvm-project/llvm/docs/Extensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst,1,['avoid'],['avoid']
Safety,"the; ``__terminated_by`` pointer ``P`` to an ``__indexable`` pointer. * ``__null_terminated`` : The pointer or array is terminated by ``NULL`` or; ``0``. Modifying the terminator or incrementing the pointer beyond it is; prevented at run time. * ``__terminated_by(T)`` : The pointer or array is terminated by ``T`` which is; a constant expression. Accessing or incrementing the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:19906,safe,safety,19906,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In this example the ``extra_sources`` variable is only defined if you're; targeting an Apple platform. For all other targets the ``extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). Lists of Lists; --------------. One of the more complicated patterns in CMake is lists of lists. Because a list; cannot contain an element with a semi-colon to construct a list of lists you; make a list of variable names that refer to other lists. For example:. .. code-block:: cmake. set(list_of_lists a b c); set(a 1 2 3); set(b 4 5 6); set(c 7 8 9). With this layout you can iterate through the list of lists printing each value; with the following code:. .. code-block:: cmake. foreach(list_name IN LISTS list_of_lists); foreach(value IN LISTS ${list_name}); message(${value}); endforeach(); endforeach(). You'll notice that the inner foreach loop's list is doubly dereferenced. This is; because the first dereferenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:4325,avoid,avoid,4325,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['avoid'],['avoid']
Safety,"the; profile. As you make changes to your code, clang may no longer be able to; use the profile data. It will warn you when this happens. Note that ``-fprofile-use`` option is semantically equivalent to; its GCC counterpart, it *does not* handle profile formats produced by GCC.; Both ``-fprofile-use`` and ``-fprofile-instr-use`` accept profiles in the; indexed format, regardeless whether it is produced by frontend or the IR pass. .. option:: -fprofile-generate[=<dirname>]. The ``-fprofile-generate`` and ``-fprofile-generate=`` flags will use; an alternative instrumentation method for profile generation. When; given a directory name, it generates the profile file; ``default_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-prof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:107885,risk,risk,107885,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['risk'],['risk']
Safety,"ther SIMD; operations are enabled or not. The default set of attributes is set by the; current CPU. For a list of available attributes, use:. .. code-block:: none. llvm-as < /dev/null | llc -march=xyz -mattr=help. .. option:: --frame-pointer. Specify effect of frame pointer elimination optimization (all,non-leaf,none). .. option:: --disable-excess-fp-precision. Disable optimizations that may produce excess precision for floating point.; Note that this option can dramatically slow down code on some systems; (e.g. X86). .. option:: --enable-no-infs-fp-math. Enable optimizations that assume no Inf values. .. option:: --enable-no-nans-fp-math. Enable optimizations that assume no NAN values. .. option:: --enable-no-signed-zeros-fp-math. Enable FP math optimizations that assume the sign of 0 is insignificant. .. option:: --enable-no-trapping-fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:3864,unsafe,unsafe,3864,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['unsafe'],['unsafe']
Safety,ther we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; },MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82509,safe,safe,82509,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['safe'],['safe']
Safety,"ther; `MyCondition.Signal()` is required, etc. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:9710,timeout,timeout,9710,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['timeout'],['timeout']
Safety,"therwise make it part of the module. **Example:** The C header ``assert.h`` is an excellent candidate for a textual header, because it is meant to be included multiple times (possibly with different ``NDEBUG`` settings). However, declarations within it should typically be split into a separate modular header. .. parsed-literal::. module std [system] {; textual header ""assert.h""; }. A given header shall not be referenced by more than one *header-declaration*. Two *header-declaration*\s, or a *header-declaration* and a ``#include``, are; considered to refer to the same file if the paths resolve to the same file; and the specified *header-attr*\s (if any) match the attributes of that file,; even if the file is named differently (for instance, by a relative path or; via symlinks). .. note::; The use of *header-attr*\s avoids the need for Clang to speculatively; ``stat`` every header referenced by a module map. It is recommended that; *header-attr*\s only be used in machine-generated module maps, to avoid; mismatches between attribute values and the corresponding files. Umbrella directory declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; An umbrella directory declaration specifies that all of the headers in the specified directory should be included within the module. .. parsed-literal::. *umbrella-dir-declaration*:; ``umbrella`` *string-literal*. The *string-literal* refers to a directory. When the module is built, all of the header files in that directory (and its subdirectories) are included in the module. An *umbrella-dir-declaration* shall not refer to the same directory as the location of an umbrella *header-declaration*. In other words, only a single kind of umbrella can be specified for a given directory. .. note::. Umbrella directories are useful for libraries that have a large number of headers but do not have an umbrella header. Submodule declaration; ~~~~~~~~~~~~~~~~~~~~~; Submodule declarations describe modules that are nested within their enclosing module. .. pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:38765,avoid,avoid,38765,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['avoid'],['avoid']
Safety,"thmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explicit cast or assignment. This is generally; much faster but can generate different results from strict operation-by-operation; emulation. Usually the results are more precise. This is permitted by the; C and C++ standards under the rules for excess precision in intermediate operands;; see the discussion of evaluation formats in the C standard and [expr.pre] in; the C++ standard. The use of excess precision can be independently controlled for these two; types with the ``-ffloat16-excess-precision=`` and; ``-fbfloat16-excess-precision=`` options. Valid values include:. * ``none``: meaning to perform strict operation-by-operation emulation; * ``standard``: meaning that excess precision is permitted under the rules; described in the standard, i.e. never across explicit casts or statements; * ``fast``: meaning that excess precision is permitted whenever the; optimizer sees an opportunity to avoid truncations; currently this has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:33668,avoid,avoid,33668,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['avoid'],['avoid']
Safety,"thout call Hash (and hence be linear rather than; logarithmic complexity). You will also see warnings like; ```; Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; ```; - When a container relies on TObject::Hash and RecursiveRemove, for example THashTable, the container uses ```TObject::CheckedHash()``` instead of ```TObject::Hash``` during insertion operation to record in the object whether the Hash/RecursiveRemove setup is done properly (as explain above). It this is not the case ```TObject::HasInconsistentHash()``` will return true. This can then be used to select, in RecursiveRemove, whether the call to Hash can be trusted or if one needs to do a linear search (as was done in v6.10 and earlier).; - In TClass::GetMissingDictionaries activate the search through the base classes.; - Added a TStatusBitsChecker to avoid Status Bits overlap in class hierarchy deriving from TObject (and resolved a handful of conflicts).; - Introduced support for type safe range-for-loop for ROOT collection. The typical use is:. ```; for(auto bcl : TRangeDynCast<TBaseClass>( * cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; ```; - ClassDefInline has been enhanced even for some compiled class (without a dictionary). ClassDefInline can still not be used for class template instance using Double32_t or Float16_t as a template parameter or for class or class template that do not have a public default constructor.; - ROOT's backport of `std::string_view` has been updated to follow what's available in C++17, notably its `to_string` member function has been removed. ### Thread safety. Resolved the race conditions inherent to the use of the RecursiveRemove mechanism. - Introduced ```ROOT::TReentrantRWLock`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:3387,avoid,avoid,3387,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['avoid'],['avoid']
Safety,"till 'no compression' but this will allow to study the; impact of compression. Add sort of 'progress' counter for merging is now shown; on the client:;  ;     root [n] p->Process(...);       ... ;       Mst-0: merging output objects ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full handshake.; In test/stressProof.cxx, avoid interferences between the; settings used for the PROOF tutorial and possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:8158,avoid,avoid,8158,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['avoid'],['avoid']
Safety,"till load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, these edges will need independent protection from; variant #1 style attacks. The analogous approach to that used for conditional; control flow should work:; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:8720,predict,prediction,8720,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['prediction']
Safety,"time) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75486,detect,detector,75486,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['detect'],['detector']
Safety,"ting an inlined function is a bit more work, fortunately broken up into; reasonable steps:. 1. The CoreEngine realizes we're at the end of an inlined call and generates a; CallExitBegin node. 2. ExprEngine takes over (in processCallExit) and finds the return value of the; function, if it has one. This is bound to the expression that triggered the; call. (In the case of calls without origin expressions, such as destructors,; this step is skipped.). 3. Dead symbols and bindings are cleaned out from the state, including any local; bindings. 4. A CallExitEnd node is generated, which marks the transition back to the; caller's LocationContext. 5. Custom post-call checks are processed and the final nodes are pushed back; onto the work list, so that evaluation of the caller can continue. Retry Without Inlining; ^^^^^^^^^^^^^^^^^^^^^^. In some cases, we would like to retry analysis without inlining a particular; call. Currently, we use this technique to recover coverage in case we stop; analyzing a path due to exceeding the maximum block count inside an inlined; function. When this situation is detected, we walk up the path to find the first node; before inlining was started and enqueue it on the WorkList with a special; ReplayWithoutInlining bit added to it (ExprEngine::replayWithoutInlining). The; path is then re-analyzed from that point without inlining that particular call. Deciding When to Inline; ^^^^^^^^^^^^^^^^^^^^^^^. In general, the analyzer attempts to inline as much as possible, since it; provides a better summary of what actually happens in the program. There are; some cases, however, where the analyzer chooses not to inline:. - If there is no definition available for the called function or method. In; this case, there is no opportunity to inline. - If the CFG cannot be constructed for a called function, or the liveness; cannot be computed. These are prerequisites for analyzing a function body,; with or without inlining. - If the LocationContext chain for a given",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:6514,recover,recover,6514,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['recover'],['recover']
Safety,"ting the limit higher than; 2 is thus harmless. To facilitate debugging, after reaching the limit, lit will make one extra pass; and report an error if the ``RUN:`` line changes again. In the above example,; setting the limit to 1 will thus cause lit to report an error instead of; producing incorrect output. Options; -------. The llvm lit configuration allows to customize some things with user options:. ``llc``, ``opt``, ...; Substitute the respective llvm tool name with a custom command line. This; allows to specify custom paths and default arguments for these tools.; Example:. % llvm-lit ""-Dllc=llc -verify-machineinstrs"". ``run_long_tests``; Enable the execution of long running tests. ``llvm_site_config``; Load the specified lit configuration instead of the default one. Other Features; --------------. To make RUN line writing easier, there are several helper programs. These; helpers are in the PATH when running tests, so you can just call them using; their name. For example:. ``not``; This program runs its arguments and then inverts the result code from it.; Zero result codes become 1. Non-zero result codes become 0. To make the output more useful, :program:`lit` will scan; the lines of the test case for ones that contain a pattern that matches; ``PR[0-9]+``. This is the syntax for specifying a PR (Problem Report) number; that is related to the test case. The number after ""PR"" specifies the; LLVM Bugzilla number. When a PR number is specified, it will be used in; the pass/fail reporting. This is useful to quickly get some context when; a test fails. Finally, any line that contains ""END."" will cause the special; interpretation of lines to terminate. This is generally done right after; the last RUN: line. This has two side effects:. (a) it prevents special interpretation of lines that are part of the test; program, not the instructions to the test case, and. (b) it speeds things up for really big test cases by avoiding; interpretation of the remainder of the file.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:39326,avoid,avoiding,39326,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['avoid'],['avoiding']
Safety,"ting-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contract=on``; (fused multiply add) is enabled. This pragma enables ``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; third argument, can only occur at file scope. .. code-block:: c++. for(...) {; // This block will be compiled with -fno-fast-math and -ffp-contract=on; #pragma float_control(precise, on); a = b[i] * c[i] + e;; }. Specifying an attribute",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:175895,unsafe,unsafe-floating,175895,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe-floating']
Safety,"tinual evolution, and this document must be updated as the; language progresses. If a change increases the expressiveness of the language, for example by; lifting a restriction or by adding new syntax, the change will be annotated; with a revision marker, like so:. ARC applies to Objective-C pointer types, block pointer types, and; :when-revised:`[beginning Apple 8.0, LLVM 3.8]` :revision:`BPTRs declared; within` ``extern ""BCPL""`` blocks. For now, it is sensible to version this document by the releases of its sole; implementation (and its host project), clang. ""LLVM X.Y"" refers to an; open-source release of clang from the LLVM project. ""Apple X.Y"" refers to an; Apple-provided release of the Apple LLVM Compiler. Other organizations that; prepare their own, separately-versioned clang releases and wish to maintain; similar information in this document should send requests to cfe-dev. If a change decreases the expressiveness of the language, for example by; imposing a new restriction, this should be taken as an oversight in the; original specification and something to be avoided in all versions. Such; changes are generally to be avoided. .. _arc.general:. General; =======. Automatic Reference Counting implements automatic memory management for; Objective-C objects and blocks, freeing the programmer from the need to; explicitly insert retains and releases. It does not provide a cycle collector;; users must explicitly manage the lifetime of their objects, breaking cycles; manually or with weak or unsafe references. ARC may be explicitly enabled with the compiler flag ``-fobjc-arc``. It may; also be explicitly disabled with the compiler flag ``-fno-objc-arc``. The last; of these two flags appearing on the compile line ""wins"". If ARC is enabled, ``__has_feature(objc_arc)`` will expand to 1 in the; preprocessor. For more information about ``__has_feature``, see the; :ref:`language extensions <langext-__has_feature-__has_extension>` document. .. _arc.objects:. Retainable objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:8650,avoid,avoided,8650,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['avoid'],['avoided']
Safety,"tinuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make sure the executable is in a path that; doesn't contain spaces. For example, you should install Python in a path like. ```sh; C:\Python27; ```; rather than. ```sh; C:\Program Files (x86)\Python 2.7; ```; * Path to all the required executables should be present in the Windows; **PATH** environment variable.; * In case of MSYS Git, choose the option ""Run Git from Windows; Command Prompt"" during installation. A good way to check if everything is detected properly by the script is to; run the following command:; ```sh; cd tools/packaging/; ./cpt.py --check-requirements; ```. #### Red Hat Linux (Fedora/Scientific Linux CERN); This section applies to all distros based on Red Hat Linux like Fedora, and; Scientific Linux CERN (SLC). Apparently, you can build RPM packages in any; distro regardless of the package manager it uses. This has been tested on; Fedora, SLC, Ubuntu, and CrunchBang. If you are interested, you can test it; on your favourite platform and email me the results. Depending on the package manager of your distro, you can install the; packages required by CPT to build RPM bundles. For a Red Hat based distro; (which uses ```yum``` package manager), you can use the following command; (also performed automatically by CPT):; ```sh; sudo yum update; sudo yum install git gcc gcc-c++ rpm-build python; ```. #### Mac OS X; Mac OS X provides a sane environement for CPT to build Apple Disk Images; (DMG Installers). On older versions of Mac OS, you need to u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:4644,detect,detected,4644,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['detect'],['detected']
Safety,"tion may include more detailed data than a logical; view created from a binary file with CodeView/COFF debug information. The following options describe the elements to compare. .. option:: --compare=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below elements. .. code-block:: text. =lines: Include lines.; =scopes: Include scopes.; =symbols: Include symbols.; =types: Include types. :program:`llvm-debuginfo-analyzer` takes the first binary file on the; command line as the **reference** and the second one as the **target**.; To get a more descriptive report, the comparison is done twice. The; reference and target views are swapped, in order to produce those; **missing** elements from the target view and those **added** elements; to the reference view. See :option:`--report` options on how to describe the comparison; reports. .. _warning_:. WARNING; ~~~~~~~; When reading the input object files, :program:`llvm-debuginfo-analyzer`; can detect issues in the raw debug information. These may not be; considered fatal to the purpose of printing a logical view but they can; give an indication about the quality and potentially expose issues with; the generated debug information. The following options describe the warnings to be recorded for later; printing, if they are requested by :option:`--print`. .. option:: --warning=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below warnings. The following options collect additional information during the creation; of the logical view, to include invalid coverage values and locations; for symbols; invalid code ranges; lines that are zero. .. code-block:: text. =coverages: Invalid symbol coverages values.; =lines: Debug lines that are zero.; =locations: Invalid symbol locations.; =ranges: Invalid code ranges. .. _internal_:. INTERNAL; ~~~~~~~~; For a better understanding of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:21366,detect,detect,21366,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['detect'],['detect']
Safety,"tion system is that it is; > VERY simple to use and understand (although it IS different than C, it is; > very simple and straightforward, which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the question is, what is more clear and concise?; The syntax programmers are used to out of years of experience or a new; syntax that they have never seen that has a more logical structure. I think; the answer is the former. Sometimes, you have to give up a better idea; because you can't overcome sociological barriers to it. Qwerty keyboards; and Windows are two classic examples of bad technology that are difficult to; root out. P.S. Also, while I agree that most your syntax is more logical, there is; one part that isn't:. Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. The arrays with size lists the dimensions and the type in a single list.; That is just too confusing:; [10, 40, int]; This seems to be a 3-D array where the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:1994,risk,risky,1994,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['risk'],['risky']
Safety,"tion that we can only; have one ""top level"" command at a time to reduce the number of; changes necessary. Here's the sample program we'll be compiling:. .. code-block:: python. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. fib(10). Why is this a hard problem?; ===========================. Debug information is a hard problem for a few different reasons - mostly; centered around optimized code. First, optimization makes keeping source; locations more difficult. In LLVM IR we keep the original source location; for each IR level instruction on the instruction. Optimization passes; should keep the source locations for newly created instructions, but merged; instructions only get to keep a single location - this can cause jumping; around when stepping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables, or difficult to track. For the purposes of this; tutorial we're going to avoid optimization (as you'll see with one of the; next sets of patches). Ahead-of-Time Compilation Mode; ==============================. To highlight only the aspects of adding debug information to a source; language without needing to worry about the complexities of JIT debugging; we're going to make a few changes to Kaleidoscope to support compiling; the IR emitted by the front end into a simple standalone program that; you can execute, debug, and see results. First we make our anonymous function that contains our top level; statement be our ""main"":. .. code-block:: udiff. - auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; + auto Proto = std::make_unique<PrototypeAST>(""main"", std::vector<std::string>());. just with the simple change of giving it a name. Then we're going to remove the command line code wherever it exists:. .. code-block:: udiff. @@ -1129,7 +1129,6 @@ static void HandleTopLevelExpression() {; /// top ::= definition | external | expression | ';'; stat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:2351,avoid,avoid,2351,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['avoid'],['avoid']
Safety,"tion-macros) (either in a single translation unit or in the build system), and creating a legacy iterator will trigger a compiler warning such as:; ```; <path>/RooChebychev.cxx:66:34: warning: 'createIterator' is deprecated: There is a superior alternative: begin(), end() and range-based for loops. [-Wdeprecated-declarations]; TIterator* coefIter = coefList.createIterator() ;; ^; 1 warning generated.; ```. ## TMVA. This release provides a consolidation and several fixes of the new machine learning tools provided in TMVA such as the Deep Learning module.; The method `TMVA::Types::kDL` should be used now for building Deep Learning architecture in TMVA, while `TMVA::Types::kDNN` is now deprecated. `TMVA::Types::kDL` provides all the functionality of `TMVA::Types::kDNN`, i.e building fully connected dense layer, but in addition supports building convolutional and recurrent neural network architectures.; These release contains improvements in the `MethodDL` such as:; - fix droput support for dense layer; - add protection to avoid returning NaN in the cross-entropy loss function. In addition we have :. - New `TMVA::Executor` class to control the multi-thread running of TMVA. By default now MT running will be enabled only when `ROOT::EnabledImplicitMT()` is called. But we can take the control of the threads by using `TMVA::gConfig().EnableMT(...)` and `TMVA::gConfig().DisableMT()`. ### PyMVA; - add support when using the Tensorflow backend in Keras to control the number of threads; - add possibility to control options for configuring GPU running. FOr example we can now set the mode to allocate memory only as needed. This is required when using the new RTX gaming cards from NVIDIA. ## 2D Graphics Libraries. - In the statistics painting for 2D histograms, the central cell of; the underflow/overflow grid was not properly rendered for very large contents.; This problem was reported [here](https://root-forum.cern.ch/t/stat-box-for-th2/).; - The automatic placement of legend now ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:17795,avoid,avoid,17795,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['avoid'],['avoid']
Safety,"tion. A; retainable object pointer type is **weak-unavailable** if; is a pointer to an (optionally protocol-qualified) Objective-C class ``T`` where; ``T`` or one of its superclasses has the ``objc_arc_weak_reference_unavailable``; attribute. A program is ill-formed if it applies the ``__weak`` ownership; qualifier to a weak-unavailable type or if the value operand of a weak; assignment operation has a weak-unavailable type. .. _arc.ownership.restrictions.autoreleasing:. Storage duration of ``__autoreleasing`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it declares an ``__autoreleasing`` object of; non-automatic storage duration. A program is ill-formed if it captures an; ``__autoreleasing`` object in a block or, unless by reference, in a C++11; lambda. .. admonition:: Rationale. Autorelease pools are tied to the current thread and scope by their nature.; While it is possible to have temporary objects whose instance variables are; filled with autoreleased objects, there is no way that ARC can provide any; sort of safety guarantee there. It is undefined behavior if a non-null pointer is assigned to an; ``__autoreleasing`` object while an autorelease pool is in scope and then that; object is read after the autorelease pool's scope is left. .. _arc.ownership.restrictions.conversion.indirect:. Conversion of pointers to ownership-qualified types; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if an expression of type ``T*`` is converted,; explicitly or implicitly, to the type ``U*``, where ``T`` and ``U`` have; different ownership qualification, unless:. * ``T`` is qualified with ``__strong``, ``__autoreleasing``, or; ``__unsafe_unretained``, and ``U`` is qualified with both ``const`` and; ``__unsafe_unretained``; or; * either ``T`` or ``U`` is ``cv void``, where ``cv`` is an optional sequence; of non-ownership qualifiers; or; * the conversion is requested with a ``reinterpret_cast`` in Objective-C++;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:43102,safe,safety,43102,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['safe'],['safety']
Safety,"tive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. \defgroup Tubes Tubes; \ingroup Shapes_classes; Tubes have Z as their symmetry axis. \defgroup Cones Cones; \ingroup Shapes_classes; Conical tube classes. \defgroup Trapezoids Trapezoids; \ingroup Shapes_classes; In general, we will call trapezoidal shapes having 8 vertices and up to; 6 trapezoid faces. Besides that, two of the opposite faces are parallel; to XY plane and are positioned at ` dZ`. Since general trapezoids are; seldom used in detector geometry descriptions, there are several; primitives implemented in the modeller for particular cases. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:10927,detect,detector,10927,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['detect'],['detector']
Safety,"tly call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: distance to next boundary. `TGeoManager::GetSafeDistance()`: safe distance (in case it was; computed). `TGeoManager::IsOnBoundary()`: the initial point `(x,y,z)` was (or was; not) on a boundary within `TGeoShape::Tolerance()`. The algorithm checks first if the computation of safety was required. If; this is the case and the global point coordinates did not change from; the last query, the last computed safety is taken. Otherwise, the method; **`TGeoManager`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape fr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:161566,safe,safety,161566,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,2,['safe'],"['safe', 'safety']"
Safety,"tness of bounds annotations; when the pointer and/or the related value containing the bounds information are; updated or passed as arguments. This is done by compile-time restrictions or; run-time checks (see `Maintaining correctness of bounds annotations`_; for more detail). For instance, initializing ``buf`` with ``null`` while; assigning non-zero value to ``count``, as shown in the following example, would; violate the ``__counted_by`` annotation because a null pointer does not point to; any valid memory location. To avoid this, the compiler produces either a; compile-time error or run-time trap. .. code-block:: c. void null_with_count_10(int *__counted_by(count) buf, unsigned count) {; buf = 0;; // This is not allowed as it creates a null pointer with non-zero length; count = 10;; }. However, there are use cases where a pointer is either a null pointer or is; pointing to memory of the specified size. To support this idiom,; ``-fbounds-safety`` provides ``*_or_null`` variants,; ``__counted_by_or_null(N)``, ``__sized_by_or_null(N)``, and; ``__ended_by_or_null(P)``. Accessing a pointer with any of these bounds; annotations will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:12478,safe,safety,12478,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"to TS3WebFile by allowing the security token to be given.; * Resolve an issue when space is freed in a large `ROOT` file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. - ##### TBufferJSON:; + support data members with `//[fN]` comment; + preliminary support of STL containers; + JSON data can be produced with `TObject::SaveAs()` method. ## TTree Libraries. * TChains can now be histogrammed without any C++ code, using the command line tool `rootdrawtree`. It is based on the new class `TSimpleAnalysis`.; * Do not automatically setup read cache during `TTree::Fill()`. This fixes [ROOT-8031].; * Make sure the option ""PARA"" in `TTree::Draw` is used with at least tow variables [ROOT-8196].; * The with `goff` option one can use as many variables as needed. There no more; limitation, like with the options `para`and `candle`.; * Fix detection of errors that appears in nested TTreeFormula [ROOT-8218]; * Better basket size optimization by taking into account meta data and rounding up to next 512 bytes, ensuring a complete cluster fits into a single basket. ### Fast Cloning. We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078]. It can be controlled from the `TTreeCloner`, `TTree::CopyEntries` or `hadd` interfaces. The new cache is enabled by default, to update the size of the cache or disable it from `TTreeCloner` use: `TTreeCloner::SetCacheSize`. To do the same from `TTree::CopyEntries` add to the option string ""cachesize=SIZE"". To update the size of the cache or disable it from `hadd`, use the command line option `-cachesize SIZE`. `SIZE` shouyld be given in number bytes and can be expressed in 'human readable form' (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. ### Other Changes. * Update `TChain::LoadTree` so that the user call back routine is actually call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:9238,detect,detection,9238,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['detect'],['detection']
Safety,"to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59803,unsafe,unsafe-math-optimizations,59803,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['unsafe'],['unsafe-math-optimizations']
Safety,"to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The ocaml frametable structure supports liveness information. It would be good; to support it. //===---------------------------------------------------------------------===//. The FIXME in ComputeCommonTailLength in BranchFolding.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the wrong thing. //===---------------------------------------------------------------------===//. It would be really nice to be able to write patterns in .td files for copies,; which would eliminate a bunch of explicit predicates on them (e.g. no side; effects). Once this is in place, it would be even better to have tblgen; synthesize the various copy insertion/inspection methods in TargetInstrInfo. //===---------------------------------------------------------------------===//. Stack coloring improvements:. 1. Do proper LiveStacks analysis on all stack objects including those which are; not spill slots.; 2. Reorder objects to fill in gaps between objects.; e.g. 4, 1, <gap>, 4, 1, 1, 1, <gap>, 4 => 4, 1, 1, 1, 1, 4, 4. //===---------------------------------------------------------------------===//. The scheduler should be able to sort nearby instructions by their address. For; example, in an expanded memset sequence it's not uncommon to see code like ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:4354,detect,detect,4354,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['detect'],['detect']
Safety,"to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()``, the upper; bound of ``tmp_ptr`` is derived from ``void *__sized_by_or_null(size)``, which; is the return type of ``malloc()``. Hence, the pointer arithmetic doesn't; overflow or ``tmp_ptr`` is null. Therefore, if ``nelems`` was given as a; compile-time constant, the compiler could remove the checks. Cast rules; ----------. ``-fbounds-safety`` does not enforce overall type safety and bounds invariants; can still be violated by incorrect casts in some cases. That said,; ``-fbounds-safety`` prevents type conversions that change bounds attributes in a; way to violate the bounds invariant of the destination's pointer annotation.; Type conversions that change bounds attributes may be allowed if it does not; violate the invariant of the destination or that can be verified at run time.; Here are some of the important cast rules. Two pointers that have different bounds annotations on their nested pointer; types are incompatible and cannot implicitly cast to each other. For example,; ``T *__single *__single`` cannot be converted to ``T *__bidi_indexable; *__single``. Such a conversion between incompatible nested bounds annotations; can be allowed using an explicit cast (e.g., C-style cast). Hereafter, the rules; only apply to the top pointer types. ``__unsafe_indexable`` cannot be converted; to any other safe pointer types (``__single``, ``__bidi_indexable``,; ``__counted_by``, e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:38934,safe,safety,38934,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['safe'],['safety']
Safety,"to replace; it with any other `i1` value. Any pass can; freely do it if it can benefit from non-default lowering. '``llvm.load.relative``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.load.relative.iN(ptr %ptr, iN %offset) nounwind memory(argmem: read). Overview:; """""""""""""""""". This intrinsic loads a 32-bit value from the address ``%ptr + %offset``,; adds ``%ptr`` to that value and returns it. The constant folder specifically; recognizes the form of this intrinsic and the constant initializers it may; load from; if a loaded constant initializer is known to have the form; ``i32 trunc(x - %ptr)``, the intrinsic call is folded to ``x``. LLVM provides that the calculation of such a constant initializer will; not overflow at link time under the medium code model if ``x`` is an; ``unnamed_addr`` function. However, it does not provide this guarantee for; a constant initializer folded into a function body. This intrinsic can be; used to avoid the possibility of overflows when loading from such a constant. .. _llvm_sideeffect:. '``llvm.sideeffect``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.sideeffect() inaccessiblememonly nounwind willreturn. Overview:; """""""""""""""""". The ``llvm.sideeffect`` intrinsic doesn't perform any operation. Optimizers; treat it as having side effects, so it can be inserted into a loop to; indicate that the loop shouldn't be assumed to terminate (which could; potentially lead to the loop being optimized away entirely), even if it's; an infinite loop with no other side effects. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic actually does nothing, but optimizers must assume that it; has externally observable side effects. '``llvm.is.constant.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.is.constant with any argument type. ::. declare i1 @llvm.is.constant.i32(i32 %operand) nounwind m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:951583,avoid,avoid,951583,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['avoid'],['avoid']
Safety,"to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:531072,detect,detect,531072,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['detect'],['detect']
Safety,"to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ``` {.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ```. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig `(default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag telling if the current track will enter inside some daughter of the; current volume or it will exit inside its container:. ``` {.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ```. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:117493,safe,safety,117493,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safety']
Safety,"to this value. If a boundary is found, a pointer; to the object (node) having it is returned; otherwise the method returns; `NULL`. The computed value for the computed distance can be subsequently; retrieved from the manager class:. ~~~{.cpp}; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; ~~~. According the step value, two use cases are possible:. - `step =` `TGeoShape::kBig ` (default behavior; `kBig = 1030`). In; this case, there is no limitation on the search algorithm, the first; crossed node is returned and the corresponding distance computed. If; the current point is outside geometry and the top node is not; crossed, the corresponding distance will be set to `kBig` and a; `NULL` pointer returned. No additional quantity will be computed.; - `step < kBig`. In this case, the progressive search starting from; the current point will be stopped after a distance equal with the; supplied step. In addition to the distance to the first crossed; boundary, the `safety radius` is also computed. Whenever the; information regarding the maximum required step is known it is; recommended to be provided as input parameter in order to speed-up; the search. In addition to the distance computation, the method sets an additional; flag telling if the current track will enter inside some daughter of the; current volume or it will exit inside its container:. ~~~{.cpp}; Bool_t TGeoManager::IsStepEntering() const;; ~~~. A combined task is to first find the distance to the next boundary and; then extrapolate the current point/direction with this distance making; sure that the boundary was crossed. Finally the goal would be to find; the next state after crossing the boundary. The problem can be solved in; principle using FindNextBoundary, but the boundary crossing can give; unpredictable results due to numerical roundings. The manager class; provides a method that allows this combined task and ensures boundary; crossing. This should be used in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:77941,safe,safety,77941,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['safe'],['safety']
Safety,"to zero out all of the loaded bits. Even; though this code pattern may still execute speculatively, *invalid* speculative; executions are prevented from leaking secret data from memory (but note that; this data might still be loaded in safe ways, and some regions of memory are; required to not hold secrets, see below for detailed limitations). This; approach only requires the underlying hardware have a way to implement a; branchless and unpredicted conditional update of a register's value. All modern; architectures have support for this, and in fact such support is necessary to; correctly implement constant time cryptographic primitives. Crucial properties of this approach:; * It is not preventing any particular side-channel from working. This is; important as there are an unknown number of potential side channels and we; expect to continue discovering more. Instead, it prevents the observation of; secret data in the first place.; * It accumulates the predicate state, protecting even in the face of nested; *correctly* predicted control flows.; * It passes this predicate state across function boundaries to provide; [interprocedural protection](#interprocedural-checking).; * When hardening the address of a load, it uses a *destructive* or; *non-reversible* modification of the address to prevent an attacker from; reversing the check using attacker-controlled inputs.; * It does not completely block speculative execution, and merely prevents; *mis*-speculated paths from leaking secrets from memory (and stalls; speculation until this can be determined).; * It is completely general and makes no fundamental assumptions about the; underlying architecture other than the ability to do branchless conditional; data updates and a lack of value prediction.; * It does not require programmers to identify all possible secret data using; static source code annotations or code vulnerable to a variant #1 style; attack. Limitations of this approach:; * It requires re-compiling source code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:5468,predict,predicted,5468,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['predict'],['predicted']
Safety,"to; ``3 * sizeof(int*)``). When ``sizeof()`` takes an expression, i.e., ``sizeof(expr``, it behaves as; ``sizeof(typeof(expr))``, except that ``sizeof(expr)`` does not report an error; with ``expr`` that has a type with an external bounds annotation dependent on; another declaration, whereas ``typeof()`` on the same expression would be an; error as described in :ref:`Default pointer types in typeof`.; The following example describes this behavior. .. code-block:: c. void foo(int *__counted_by(size) p, size_t size) {; // sizeof(p) == sizeof(int *__counted_by(size)) == sizeof(int *); // typeof(p): error; };. Default pointer types in ``alignof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``alignof()`` only takes a type name as the argument and it doesn't take an; expression. Similar to ``sizeof()`` and ``typeof``, the compiler doesn't apply; an implicit bounds annotation on the pointer types named inside ``alignof()``.; Therefore, ``alignof(T *)`` remains the same with or without; ``-fbounds-safety``, evaluating into the alignment of the raw pointer ``T *``.; The programmers can explicitly add a bounds annotation to the types, e.g.,; ``alignof(int *__bidi_indexable)``, which returns the alignment of ``int; *__bidi_indexable``. A bounds annotation including an internal bounds annotation; (i.e., ``__indexable`` and ``__bidi_indexable``) doesn't affect the alignment of; the original pointer. Therefore, ``alignof(int *__bidi_indexable)`` is equal to; ``alignof(int *)``. Default pointer types used in C-style casts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer type used in a C-style cast (e.g., ``(int *)src``) inherits the same; pointer attribute in the type of src. For instance, if the type of src is ``T; *__single`` (with ``T`` being an arbitrary C type), ``(int *)src`` will be ``int; *__single``. The reasoning behind this behavior is so that a C-style cast; doesn't introduce any unexpected side effects caused by an implicit cast of; bounds attribute. Pointer cas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:29575,safe,safety,29575,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['safe'],['safety']
Safety,"to; the LLVM infrastructure at all. It works with any and all LLVM passes and code; generators, and does not need to ""know"" how they work. Because of this, it may; appear to do stupid things or miss obvious simplifications. ``bugpoint`` is; also designed to trade off programmer time for computer time in the; compiler-debugging process; consequently, it may take a long period of; (unattended) time to reduce a test case, but we feel it is still worth it. Note; that ``bugpoint`` is generally very quick unless debugging a miscompilation; where each test of the program (which requires executing it) takes a long time. Automatic Debugger Selection; ----------------------------. ``bugpoint`` reads each ``.bc`` or ``.ll`` file specified on the command line; and links them together into a single module, called the test program. If any; LLVM passes are specified on the command line, it runs these passes on the test; program. If any of the passes crash, or if they produce malformed output (which; causes the verifier to abort), ``bugpoint`` starts the `crash debugger`_. Otherwise, if the ``-output`` option was not specified, ``bugpoint`` runs the; test program with the ""safe"" backend (which is assumed to generate good code) to; generate a reference output. Once ``bugpoint`` has a reference output for the; test program, it tries executing it with the selected code generator. If the; selected code generator crashes, ``bugpoint`` starts the `crash debugger`_ on; the code generator. Otherwise, if the resulting output differs from the; reference output, it assumes the difference resulted from a code generator; failure, and starts the `code generator debugger`_. Finally, if the output of the selected code generator matches the reference; output, ``bugpoint`` runs the test program after all of the LLVM passes have; been applied to it. If its output differs from the reference output, it assumes; the difference resulted from a failure in one of the LLVM passes, and enters the; `miscompil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:1961,abort,abort,1961,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['abort'],['abort']
Safety,"toc@ha; addis 4, 2, .LCPI0_1@toc@ha; addi 3, 3, .LCPI0_0@toc@l; addi 4, 4, .LCPI0_1@toc@l; lxvw4x 0, 0, 3; addi 3, 1, -16; lxvw4x 35, 0, 4; stxvw4x 0, 0, 3; ori 2, 2, 0; lxvw4x 34, 0, 3; addi 3, 1, -32; stxvw4x 35, 0, 3; vpmsumb 2, 2, 3; blr; .long 0; .quad 0. The two stxvw4x instructions are not needed.; With -mtriple=powerpc64le-unknown-linux-gnu, the associated permutes; are present too. //===----------------------------------------------------------------------===//. The following example is found in test/CodeGen/PowerPC/vec_add_sub_doubleword.ll:. define <2 x i64> @increment_by_val(<2 x i64> %x, i64 %val) nounwind {; %tmpvec = insertelement <2 x i64> <i64 0, i64 0>, i64 %val, i32 0; %tmpvec2 = insertelement <2 x i64> %tmpvec, i64 %val, i32 1; %result = add <2 x i64> %x, %tmpvec2; ret <2 x i64> %result. This will generate the following instruction sequence:; std 5, -8(1); std 5, -16(1); addi 3, 1, -16; ori 2, 2, 0; lxvd2x 35, 0, 3; vaddudm 2, 2, 3; blr. This will almost certainly cause a load-hit-store hazard. ; Since val is a value parameter, it should not need to be saved onto; the stack, unless it's being done set up the vector register. Instead,; it would be better to splat the value into a vector register, and then; remove the (dead) stores to the stack. //===----------------------------------------------------------------------===//. At the moment we always generate a lxsdx in preference to lfd, or stxsdx in; preference to stfd. When we have a reg-immediate addressing mode, this is a; poor choice, since we have to load the address into an index register. This; should be fixed for P7/P8. . //===----------------------------------------------------------------------===//. Right now, ShuffleKind 0 is supported only on BE, and ShuffleKind 2 only on LE.; However, we could actually support both kinds on either endianness, if we check; for the appropriate shufflevector pattern for each case ... this would cause; some additional shufflevectors to be recognized and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:7925,hazard,hazard,7925,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,1,['hazard'],['hazard']
Safety,"together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75175,avoid,avoids,75175,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['avoid'],['avoids']
Safety,"tom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _RawStringFormats:. **RawStringFormats** (``List of RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting supported languages code blocks in raw; strings. A raw string with a matching delimiter or a matching enclosing function; name will be reformatted assuming the specified language based on the; style for that language defined in the .clang-format file. If no style has; been defined in the .clang-format file for the specific language, a; predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not; found, the formatting is based on llvm style. A matching delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:98496,detect,detecting,98496,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['detect'],['detecting']
Safety,"tor operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annotations and the (late) parsing logic.; * Internal bounds annotations (wide pointers) and their parsing logic.; * Clang code generation for wide pointers with debug information.; * Pointer cast semantics involving bounds annotations (this could be divided; into multiple sub-PRs).; * CFG analysis for pairs of related pointer and count assignments and the likes.; * Bounds check expressions in AST and the Clang code generation (this could also; be divided into multiple sub-PRs). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:11339,safe,safety,11339,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['safe'],['safety']
Safety,"tra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56720,detect,detect,56720,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['detect'],['detect']
Safety,"trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3478,recover,recover,3478,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['recover'],['recover']
Safety,"truct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10211,recover,recover,10211,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['recover'],['recover']
Safety,"tructions at a maximum vector; length of 512 bits, which is a superset of instructions ``-mavx10.N`` enabled. Current binaries built with AVX512 features can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:159561,avoid,avoid,159561,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['avoid'],['avoid']
Safety,"try (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In **`TGeo`**, physical nodes are represented by; the class **`TGeoPhysicalNo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145687,detect,detector,145687,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detector']
Safety,"try block guarantees that the alloca is only; executed once, which makes analysis simpler.; #. mem2reg only promotes allocas whose uses are direct loads and stores.; If the address of the stack object is passed to a function, or if any; funny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that the ""sroa"" pass is; more powerful and can promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking is: should I bother with this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9000,avoid,avoiding,9000,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['avoid'],['avoiding']
Safety,"ts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3167,avoid,avoid,3167,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,1,['avoid'],['avoid']
Safety,"ts of how often code; blocks are hit; defaults to 1.; ``-reduce_inputs``; Try to reduce the size of inputs while preserving their full feature sets;; defaults to 1.; ``-use_value_profile``; Use `value profile`_ to guide corpus expansion; defaults to 0.; ``-only_ascii``; If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0.; ``-artifact_prefix``; Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or; slow inputs) as ``$(artifact_prefix)file``. Defaults to empty.; ``-exact_artifact_path``; Ignored if empty (the default). If non-empty, write the single artifact on; failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides; ``-artifact_prefix`` and will not use checksum in the file name. Do not use; the same path for several parallel processes.; ``-print_pcs``; If 1, print out newly covered PCs. Defaults to 0.; ``-print_final_stats``; If 1, print statistics at exit. Defaults to 0.; ``-detect_leaks``; If 1 (default) and if LeakSanitizer is enabled; try to detect memory leaks during fuzzing (i.e. not only at shut down).; ``-close_fd_mask``; Indicate output streams to close at startup. Be careful, this will; remove diagnostic output from target code (e.g. messages on assert failure). - 0 (default): close neither ``stdout`` nor ``stderr``; - 1 : close ``stdout``; - 2 : close ``stderr``; - 3 : close both ``stdout`` and ``stderr``. For the full list of flags run the fuzzer binary with ``-help=1``. Output; ======. During operation the fuzzer prints information to ``stderr``, for example::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:14141,detect,detect,14141,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['detect'],['detect']
Safety,"tself may be; annotated with ``__ended_by(Q)``. In this case, the end of the range extends; to the pointer ``Q``. This is used for ""iterator"" support in C where you're; iterating from one pointer value to another until a final pointer value is; reached (and the final pointer value is not dereferencable). Accessing a pointer outside the specified bounds causes a run-time trap or a; compile-time error. Also, the model maintains correctness of bounds annotations; when the pointer and/or the related value containing the bounds information are; updated or passed as arguments. This is done by compile-time restrictions or; run-time checks (see `Maintaining correctness of bounds annotations`_; for more detail). For instance, initializing ``buf`` with ``null`` while; assigning non-zero value to ``count``, as shown in the following example, would; violate the ``__counted_by`` annotation because a null pointer does not point to; any valid memory location. To avoid this, the compiler produces either a; compile-time error or run-time trap. .. code-block:: c. void null_with_count_10(int *__counted_by(count) buf, unsigned count) {; buf = 0;; // This is not allowed as it creates a null pointer with non-zero length; count = 10;; }. However, there are use cases where a pointer is either a null pointer or is; pointing to memory of the specified size. To support this idiom,; ``-fbounds-safety`` provides ``*_or_null`` variants,; ``__counted_by_or_null(N)``, ``__sized_by_or_null(N)``, and; ``__ended_by_or_null(P)``. Accessing a pointer with any of these bounds; annotations will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:12051,avoid,avoid,12051,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['avoid'],['avoid']
Safety,"ttern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobber each other, such clobbering can still; happen because of the ``pid`` re-use by the OS. Another side-effect of using; ``%p`` is that the storage requirement for raw profile data files is greatly; increased. To avoid issues like this, the ``%m`` specifier can used in the profile; name. When this specifier is used, the profiler runtime will substitute ``%m``; with a unique integer identifier associated with the instrumented binary. Additionally,; multiple raw profiles dumped from different processes that share a file system (can be; on different hosts) will be automatically merged by the profiler runtime during the; dumping. If the program links in multiple instrumented shared libraries, each library; will dump the profile data into its own profile data file (with its unique integer; id embedded in the profile name). Note that the merging enabled by ``%m`` is for raw; profile data generated by profiler runtime. The resulting merged ""raw"" profile data; file still needs to be converted to a different format expected by the compiler (; see step 3 below). .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%m.profraw"" ./code. See `this <SourceBasedCodeCoverage.html#running-the-instrumented-program>`_ section; about the ``%t``, and ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:105107,avoid,avoid,105107,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['avoid'],['avoid']
Safety,"tting it into another is not necessarily easier than re-doing it.; > Optimization code is usually heavily tied in to the specific IR they use. Understood. The only reason that I brought this up is because SGI's IR is; more similar to LLVM than it is different in many respects (SSA based,; relatively low level, etc), and could be easily adapted. Also their; optimizations are written in C++ and are actually somewhat; structured... of course it would be no walk in the park, but it would be; much less time consuming to adapt, say, SSA-PRE than to rewrite it. > But your larger point is valid that adding SSA based optimizations is; > feasible and should be fun. (Again, link time cost is the issue.). Assuming linktime cost wasn't an issue, the question is: ; Does using GCC's backend buy us anything?. > It also occurs to me that GCC is probably doing quite a bit of back-end; > optimization (step 16 in your list). Do you have a breakdown of that?. Not really. The irritating part of GCC is that it mixes it all up and; doesn't have a clean separation of concerns. A lot of the ""back end; optimization"" happens right along with other data optimizations (ie, CSE; of machine specific things). As far as REAL back end optimizations go, it looks something like this:. 1. Instruction combination: try to make CISCy instructions, if available; 2. Register movement: try to get registers in the right places for the; architecture to avoid register to register moves. For example, try to get; the first argument of a function to naturally land in %o0 for sparc.; 3. Instruction scheduling: 'nuff said :); 4. Register class preferencing: ??; 5. Local register allocation; 6. global register allocation; 7. Spilling; 8. Local regalloc; 9. Jump optimization; 10. Delay slot scheduling; 11. Branch shorting for CISC machines; 12. Instruction selection & peephole optimization; 13. Debug info output. But none of this would be usable for LLVM anyways, unless we were using; GCC as a static compiler. -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt:2426,avoid,avoid,2426,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,1,['avoid'],['avoid']
Safety,"tween. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6407,safe,safety,6407,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['safe'],['safety']
Safety,"ty of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for mi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1391,predict,predictable,1391,interpreter/llvm-project/clang/docs/MisExpect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst,1,['predict'],['predictable']
Safety,"type.; For instance, a `std::vector<Event>` can be projected onto a `std::vector<float>` for a float member of `Event`.; Projected fields are stored as header meta-data. Fields can be added to a model after the writing process has started (cf. `RNTupleWriter::CreateModelUpdater()`).; This is called _late model extension_.; Addition of fields invalidates previously created entries.; The values of deferred fields for the already written entries is set to the default constructed type of the field. ### REntry; The REntry represents a row/entry in an RNTuple.; It contains a list of `RValue` objects that correspond to the top-level fields of the originating model.; The entry gives access to the shared pointers corresponding to the top-level fields.; It also provides functionality to bind application-provided pointers. An REntry can be passed to `RNTupleWriter::Fill()` and `RNTupleReader::LoadEntry()`.; Otherwise, the reader/writer uses the default entry of its model. An entry can safely outlive its originating model.; New objects cannot anymore be created (`EmplaceNewValue` will throw an exception), but the entry is still properly destructed. ### RNTupleWriter, RNTupleParallelWriter; The RNTupleWriter is the primary interface to create an RNTuple.; The writer takes ownership of a given model.; The writer can either add an RNTuple to an existing ROOT file (`RNTupleWriter::Append()`) or create a new ROOT file with an RNTuple (`RNTupleWriter::Recreate()`).; Once created, entries are added to an RNTuple either serially (`RNTupleWriter::Fill()`) or in concurrently in multiple threads with the `RNTupleParallelWriter`.; Once committed (e.g. by releasing the RNTupleWriter), the RNTuple is immutable and cannot be amended.; An RNTuple that is currently being written cannot be read. ### RNTupleReader; The RNTupleReader is the primary interface to read and inspect an RNTuple.; An RNTupleReader owns a model: either a model created from the on-disk information or an imposed, user-provid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:11910,safe,safely,11910,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['safe'],['safely']
Safety,"types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from source files; Not resolved. 2728; open; Evaluation of conversions in a delete-expression; Not resolved. 2729; DRWP; Meaning of new-type-id; Unknown. 2730; open; Comparison templates on enumer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187787,redund,redundant,187787,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['redund'],['redundant']
Safety,"typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13959,redund,redundant,13959,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['redund'],['redundant']
Safety,"u=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will filter out all other architectures. Constraining test execution; ---------------------------. Some tests can be run only in specific configurations, such as; with debug builds or on particular platforms. Use ``REQUIRES``; and ``UNSUPPORTED`` to control when the test is enabled. Some tests are expected to fail. For example, there may be a known bug; that the test detect. Use ``XFAIL`` to mark a test as an expected failure.; An ``XFAIL`` test will be successful if its execution fails, and; will be a failure if its execution succeeds. .. code-block:: llvm. ; This test will be only enabled in the build with asserts.; ; REQUIRES: asserts; ; This test is disabled when running on Linux.; ; UNSUPPORTED: system-linux; ; This test is expected to fail when targeting PowerPC.; ; XFAIL: target=powerpc{{.*}}. ``REQUIRES`` and ``UNSUPPORTED`` and ``XFAIL`` all accept a comma-separated; list of boolean expressions. The values in each expression may be:. - Features added to ``config.available_features`` by configuration files such as ``lit.cfg``.; String comparison of features is case-sensitive. Furthermore, a boolean expression can; contain any Python regular expression enclosed in ``{{ }}``, in which case the boolean; expression is satisfied if any feature matches the regular expression. Regular; expressions can appear inside an identi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:19821,detect,detect,19821,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['detect'],['detect']
Safety,"ual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:35962,unsafe,unsafe,35962,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['unsafe'],['unsafe']
Safety,"uc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLVM a bit more. That might give us clues on how to; structure LLVM to support one or more language VMs. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:1162,safe,safety,1162,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,4,"['risk', 'safe']","['risk', 'safety']"
Safety,"uces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking Methods. ![Safety computation checking](pictures/030001E0.png). In order to check a given point, `CheckPoint(x,y,z)` method of; **`TGeoManager`** draws the daughters of the volume containing the point; one le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134615,detect,detected,134615,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['detect'],['detected']
Safety,"uction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, such non-integral pointer type have no defined mapping to an; integer representation. This semantic quirk allows the runtime to pick a; integer mapping for eac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3968,safe,safepoints,3968,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['safe'],['safepoints']
Safety,"ude ""llvm/IR/Function.h""; #include ""llvm/IR/DataLayout.h""; #include ""llvm/Target/TargetAsmInfo.h""; #include ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. // And for each live root...; for (GCFunctionInfo::liv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37774,safe,safe,37774,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ude ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in words; // int32_t StackArity;; // int32_t LiveCount;; // int32_t LiveOffsets[LiveCount];; // } __gcmap_<FUNCTIONNAME>;. // Align to address width.; AP.emitAlignment(IntPtrSize == 4 ? 2 : 3);. // Emit PointCount.; OS.AddComment(""safe point count"");; AP.emitInt32(MD.size());. // And each safe point...; for (GCFunctionInfo::iterator PI = MD.begin(),; PE = MD.end(); PI != PE; ++PI) {; // Emit the address of the safe point.; OS.AddComment(""safe point address"");; MCSymbol *Label = PI->Label;; AP.emitLabelPlusOffset(Label/*Hi*/, 0/*Offset*/, 4/*Size*/);; }. // Stack information never change in safe points! Only print info from the; // first call-site.; GCFunctionInfo::iterator PI = MD.begin();. // Emit the stack frame size.; OS.AddComment(""stack frame size (in words)"");; AP.emitInt32(MD.getFrameSize() / IntPtrSize);. // Emit stack arity, i.e. the number of stacked arguments.; unsigned RegisteredArgs = IntPtrSize == 4 ? 5 : 6;; unsigned StackArity = MD.getFunction().arg_size() > RegisteredArgs ?; MD.getFunction().arg_size() - RegisteredArgs : 0;; OS.AddComment(""stack arity"");; AP.emitInt32(StackArity);. // Emit the number of live roots in the function.; OS.AddComment(""live root count"");; AP.emitInt32(MD.live_size(PI));. // And for each live root...; for (GCFunctionInfo::live_iterator LI = MD.live_begin(PI),; LE = MD.live_end(PI);; LI != LE; ++LI) {; // Emit live root's offset",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:37898,safe,safe,37898,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['safe'],['safe']
Safety,"ueries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ``` {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51290,safe,safe,51290,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['safe'],['safe']
Safety,"ueries might be sometimes useful:. ~~~ {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ~~~. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ~~~ {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ~~~. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ~~~ {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ~~~. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ~~~ {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ~~~. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ~~~ {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:5006,safe,safe,5006,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['safe'],['safe']
Safety,"uffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, follo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23308,abort,abort,23308,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['abort'],['abort']
Safety,"uffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; }; // Complete kRaw tesselation section; if ((reqSections & TBuffer3D::kRaw) &&; buffer.SectionsValid(TBuffer3D::kRawSizes)) {; SetPoints(buffer.fPnts);; // Transform points to master frame if viewer requires it; // The fLocalFrame flag and translation matrix will have; // already been set in TGeoShape::FillBuffer3D() as required; if (!buffer.fLocalFrame); TransformPoints(buffer.fPnts, buffer.NbPnts());; SetSegsAndPols(buffer);; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; return buffer;; }; ```. Note:. - we use a static **`TBuffer3D`** derived object for efficiency - once; the object is added the buffer can be reused. - `kRawSize` (the calculation of tessellation sizing required in; buffer) and `kRaw` (the actual filling of tessellation) is split, as; the X3D viewer requires two publication passes - one to establish; the full tessellation capacity for all shapes, and another to; actually add them. Splitting avoids having to do the expensive; tessellation on the first pass. #### Shape Specific TBuffer3D Derived Classes. Currently we provide the following shape specific classes, which the GL; Viewer can take advantage of (see `TBuffer3D.h` and `TBuffer3DTypes.h`). - **`TBuffer3DSphere`** - solid, hollow and cut spheres (GL Viewer; only supports solid spheres at present - cut / hollow ones will be; requested as tessellated objects by client.). - **`TBuffer3DTube`** - basic tube with inner/outer radius and length. - **`TBuffer3DTubeSeg`** - angle tube segment. - **`TBuffer3DCutTube`** - angle tube segment with plane cut ends. See the above example from `TGeoSphere::GetBuffer3D` and also equivalent; functions in **`TGeoTube`**, **`TGeoTubeSeg`** and **`TGeoCtub`**.; Anyone is free to add new **`TBuffer3D`** classes, but it should be; clear that one or more viewers will require updating to be able to take; advantage of them. Hence we only provide classes which existing viewers; can benefit from. The number of native shape",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:131438,avoid,avoids,131438,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['avoid'],['avoids']
Safety,"uild your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Anot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3965,abort,aborting,3965,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,2,"['abort', 'recover']","['aborting', 'recover']"
