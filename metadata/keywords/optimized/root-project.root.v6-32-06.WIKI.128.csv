quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance," freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Tue Jun 2 15:27:42 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAddModel.html:53806,Cache,CacheElem,53806,root/html604/RooAddModel.html,https://root.cern,https://root.cern/root/html604/RooAddModel.html,1,['Cache'],['CacheElem']
Performance," freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::fBeepDurationInt_t fBeepDurationDefinition TSystem.h:288; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:172508,Load,LoadAllLibrariesvirtual,172508,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,3,['Load'],"['Load', 'LoadAllLibraries', 'LoadAllLibrariesvirtual']"
Performance," from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual IBaseFunctionOneDim * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; double DoEval (double x) const override;  Implement the ROOT::Math::IBaseFunctionOneDim interface DoEval(x) using the cached parameter values. ;  ; virtual double DoEvalPar (double x, const double *p) const =0;  Implementation of the evaluation function using the x value and the parameters. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricFunctionOneDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef IBaseFunctionOneDim ROOT::Math::IParametricFunctionOneDim::BaseFunc. Definition at line 166 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). double ROOT::Math::IParametricFunctionOneDim::DoEval ; (; double ; x); const. inlineoverrideprivatevirtual . Implement the ROOT::Math::IBaseFunctionOneDim interface DoEval(x) using the cached parameter values. ; Implements ROOT::Math::IBaseFunctionOneDim.; Reimplemented in ROOT::Math::WrappedTF1, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccurat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html:2137,cache,cached,2137,doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,1,['cache'],['cached']
Performance," from TNamed.; Definition at line 106 of file TPackMgr.h. ◆ IsEnabled(). Bool_t TPackMgr::IsEnabled ; (; const char * ; pack, . TPackMgr * ; packmgr = nullptr . ). static . Check if the package is enabled; priority is given to packmgr, if defined. ; Returns kTRUE if enabled ; Definition at line 961 of file TPackMgr.cxx. ◆ IsInDir(). Bool_t TPackMgr::IsInDir ; (; const char * ; path). Method to check if 'path' is in the managed directory Return kTRUE or kFALSE. ; Definition at line 478 of file TPackMgr.cxx. ◆ IsPackageEnabled(). Bool_t TPackMgr::IsPackageEnabled ; (; const char * ; pack). inline . Definition at line 82 of file TPackMgr.h. ◆ Load() [1/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . const char * ; opts . ). Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ; Definition at line 206 of file TPackMgr.cxx. ◆ Load() [2/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . TList * ; optls = 0 . ). Method to load a package taking an option list Return -1 on error, 0 otherwise. ; Definition at line 220 of file TPackMgr.cxx. ◆ Log(). void TPackMgr::Log ; (; const char * ; msg). private . Wrapper to notofuer / logger. ; Definition at line 73 of file TPackMgr.cxx. ◆ operator=(). TPackMgr & TPackMgr::operator= ; (; const TPackMgr & ; ). private . ◆ ReadMD5(). TMD5 * TPackMgr::ReadMD5 ; (; const char * ; pack). Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ; Returns a pointer to a TMD5 object, transferring ownership to the caller ; Definition at line 708 of file TPackMgr.cxx. ◆ RegisterGlobalPath(). Int_t TPackMgr::RegisterGlobalPath ; (; const char * ; paths). static . Parse one or more paths as possible sources of packages Returns number of paths added; or -1 in case of problems. ; Definition at line 872 of file TPackMgr.cxx. ◆ Remove(). Int_t TPackMgr::Remove ; (; const char * ; pack = 0, . Bool_t ; dolock = kTRUE . ). Remove package 'pack' If 'pack' is null or empty all packages are cleared. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:21499,load,load,21499,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['load'],['load']
Performance," from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; bool defineSetInternal (const char *name, const RooArgSet &aset);  . Private Attributes; RooArgSet _allOwnedNodes;  List of owned pdfs and components. ;  ; CodeRepo _classes;  ; RooLinkedList _dataList;  List of owned datasets. ;  ; WSDir * _dir = nullptr;  ! Transient ROOT directory representation of workspace ;  ; bool _doExport;  ! Export contents of workspace to CINT? ;  ; RooLinkedList _embeddedDataList;  List of owned datasets that are embedded in pdfs. ;  ; RooExpensiveObjectCache _eocache;  Cache for expensive objects. ;  ; std::string _exportNSName;  ! Name of CINT namespace to which contents are exported ;  ; std::unique_ptr< RooFactoryWSTool > _factory;  ! Factory tool associated with workspace ;  ; RooLinkedList _genObjects;  List of generic objects. ;  ; std::map< std::string, RooArgSet > _namedSets;  Map of named RooArgSets. ;  ; bool _openTrans = false;  ! Is there a transaction open? ;  ; RooArgSet _sandboxNodes;  ! Sandbox for incoming objects in a transaction ;  ; RooLinkedList _snapshots;  List of parameter snapshots. ;  ; RooLinkedList _studyMods;  List if StudyManager modules. ;  ; TUUID _uuid;  ; RooLinkedList _views;  List of model views. ;  . Static Private Attributes; static bool _autoClass = false;  ; static std::list< std::string > _classDeclDirList;  ; static std::string _classFileExportDir = "".wscode.%s.%s"";  ; static std::list< std::string > _classImplDirList;  . Friends; class CodeRepo;  ; class RooAbsArg;  ; class RooAbsPdf;  ; class RooConst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:20513,Cache,Cache,20513,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['Cache'],['Cache']
Performance, from a TTreeFriend.; ROOT::THnBaseBrowsable Browser-helper for THnBase; ROOT::TImpProxy<Long64_t> ; ROOT::TImpProxy<ULong64_t> ; ROOT::TImpProxy<bool> ; ROOT::TImpProxy<char> ; ROOT::TImpProxy<double> ; ROOT::TImpProxy<float> ; ROOT::TImpProxy<int> ; ROOT::TImpProxy<long> ; ROOT::TImpProxy<short> ; ROOT::TImpProxy<unsigned char> ; ROOT::TImpProxy<unsigned int> ; ROOT::TImpProxy<unsigned long> ; ROOT::TImpProxy<unsigned short> ; ROOT::TNamedBranchProxy branch proxy with a name; ROOT::TSchemaMatch ; ROOT::TSchemaRule ; ROOT::TSchemaRule::TSources ; ROOT::TSchemaRuleSet ; ROOT::TTreeReaderArrayBase ; ROOT::TTreeReaderValueBase ; Rectangle_t ; RedirectHandle_t ; Rgl ; Roo1DMomentMorphFunction Your description goes here...; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; Roo2DMomentMorphFunction ; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsMoment Abstract representation of moment in a RooAbsReal in a given RooRealVar; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOpt,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:24387,cache,cache,24387,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,3,['cache'],"['cache', 'cached']"
Performance," from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer; Actually skip only one node on current level of xml structure. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:32920,optimiz,optimize,32920,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,6,['optimiz'],['optimize']
Performance," from the p.d.f. that defines the observable obs. ; Reimplemented from RooAbsReal.; Definition at line 2106 of file RooProdPdf.cxx. ◆ printMetaArgs(). void RooProdPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 2189 of file RooProdPdf.cxx. ◆ processProductTerm(). std::vector< RooAbsReal * > RooProdPdf::processProductTerm ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset, . const char * ; isetRangeName, . const RooArgSet * ; term, . const RooArgSet & ; termNSet, . const RooArgSet & ; termISet, . bool & ; isOwned, . bool ; forceWrap = false . ); const. private . Calculate integrals of factorized product terms over observables iset while normalized to observables in nset. ; Definition at line 1382 of file RooProdPdf.cxx. ◆ rearrangeProduct(). void RooProdPdf::rearrangeProduct ; (; RooProdPdf::CacheElem & ; cache); const. private . Definition at line 989 of file RooProdPdf.cxx. ◆ redirectServersHook(). bool RooProdPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overridevirtual . Implement support for node removal. ; Reimplemented from RooAbsPdf.; Definition at line 2220 of file RooProdPdf.cxx. ◆ removePdfs(). void RooProdPdf::removePdfs ; (; RooAbsCollection const & ; pdfs). Remove some PDFs from the factors of this RooProdPdf. ; Definition at line 1898 of file RooProdPdf.cxx. ◆ selectNormalizationRange(). void RooProdPdf::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). overridevirtual . Interface function used by test statistics to freeze choice of range for interpretation of conditional product terms. ; Reimplemented from RooAbsReal.; Definition at line 2082 of file RooProdPdf.cxx. ◆ selfNormalized(). bool RooProdPdf::sel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:98891,Cache,CacheElem,98891,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,2,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance," from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormulaVar.html:32862,cache,cache,32862,root/html526/RooFormulaVar.html,https://root.cern,https://root.cern/root/html526/RooFormulaVar.html,2,['cache'],['cache']
Performance," from tree branches; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:37525,cache,cache,37525,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,4,['cache'],['cache']
Performance," from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooSetProxy_compSetDSet proxy for denominator components; RooSetProxy_compSetNSet proxy for numerator components; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:35537,cache,cache,35537,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance, fsync().; 4552 ; 4553Int_t TFile::SysSync(Int_t fd); 4554{; 4555 if (TestBit(kDevNull)) return 0;; 4556 ; 4557#ifndef WIN32; 4558 return ::fsync(fd);; 4559#else; 4560 return ::_commit(fd);; 4561#endif; 4562}; 4563 ; 4564////////////////////////////////////////////////////////////////////////////////; 4565/// Return the total number of bytes written so far to the file.; 4566 ; 4567Long64_t TFile::GetBytesWritten() const; 4568{; 4569 return fCacheWrite ? fCacheWrite->GetBytesInCache() + fBytesWrite : fBytesWrite;; 4570}; 4571 ; 4572////////////////////////////////////////////////////////////////////////////////; 4573/// Static function returning the total number of bytes read from all files.; 4574 ; 4575Long64_t TFile::GetFileBytesRead(); 4576{; 4577 return fgBytesRead;; 4578}; 4579 ; 4580////////////////////////////////////////////////////////////////////////////////; 4581/// Static function returning the total number of bytes written to all files.; 4582/// Does not take into account what might still be in the write caches.; 4583 ; 4584Long64_t TFile::GetFileBytesWritten(); 4585{; 4586 return fgBytesWrite;; 4587}; 4588 ; 4589////////////////////////////////////////////////////////////////////////////////; 4590/// Static function returning the total number of read calls from all files.; 4591 ; 4592Int_t TFile::GetFileReadCalls(); 4593{; 4594 return fgReadCalls;; 4595}; 4596 ; 4597////////////////////////////////////////////////////////////////////////////////; 4598/// Static function returning the readahead buffer size.; 4599 ; 4600Int_t TFile::GetReadaheadSize(); 4601{; 4602 return fgReadaheadSize;; 4603}; 4604 ; 4605//______________________________________________________________________________; 4606void TFile::SetReadaheadSize(Int_t bytes) { fgReadaheadSize = bytes; }; 4607 ; 4608//______________________________________________________________________________; 4609void TFile::SetFileBytesRead(Long64_t bytes) { fgBytesRead = bytes; }; 4610 ; 4611//_________________,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:167319,cache,caches,167319,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['caches']
Performance," funcFunction to be executed on the elements of the vector passed as second parameter. ; argsImmutable vector of elements passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func. Must return the same type as func. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 535 of file TThreadExecutor.hxx. ◆ MapReduce() [2/8]. template<class F , class T , class R , class Cond > . auto ROOT::TThreadExecutor::MapReduce ; (; F ; func, . const std::vector< T > & ; args, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F, T>. Execute a function in parallel over the elements of an immutable vector (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results.; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed assecond argument as a parameter. ; argsImmutable vector, whose elements are passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 557 of file TThreadExecutor.hxx. ◆ MapReduce() [3/8]. template<class F , class INTEGER , class R , class Cond > . auto ROOT::TThreadExecutor::MapReduce ; (; F ; func, . ROOT::TSeq< INTEGER > ; args, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F, INTEGER>. Execute a function in parallel over the elements of a vector (Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:25101,perform,performs,25101,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['perform'],['performs']
Performance," function calculates the background spectrum in this histogram. ;  ; Int_t ShowPeaks (Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) override;  Interface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this. ;  ; void Smooth (Int_t ntimes=1, Option_t *option="""") override;  Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH2. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:11357,Perform,Performs,11357,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['Perform'],['Performs']
Performance," function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinimizer. class RooMinimizer: public TObject. RooMinimizer is a wrapper class around ROOT::Fit:Fitter that; provides a seamless interface between the minimizer functionality; and the native RooFit interface.; ; By default the Minimizer is MINUIT.; ; RooMinimizer can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinimizer has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . Function Members (Methods); public:. RooMinimizer(RooAbsReal& function); virtual~RooMinimizer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinimizer.html:1211,optimiz,optimization,1211,root/html526/RooMinimizer.html,https://root.cern,https://root.cern/root/html526/RooMinimizer.html,4,['optimiz'],['optimization']
Performance," function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinimizer. class RooMinimizer: public TObject. RooMinimizer is a wrapper class around ROOT::Fit:Fitter that; provides a seamless interface between the minimizer functionality; and the native RooFit interface.; ; By default the Minimizer is MINUIT.; ; RooMinimizer can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinimizer has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . Function Members (Methods); public:. virtual~RooMinimizer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinimizer.html:1211,optimiz,optimization,1211,root/html602/RooMinimizer.html,https://root.cern,https://root.cern/root/html602/RooMinimizer.html,2,['optimiz'],['optimization']
Performance," function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinimizer. class RooMinimizer: public TObject. RooMinimizer is a wrapper class around ROOT::Fit:Fitter that; provides a seamless interface between the minimizer functionality; and the native RooFit interface.; ; By default the Minimizer is MINUIT.; ; RooMinimizer can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinimizer has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . This class is also known as (typedefs to this class)MINIMIZER. Function Members (Methods); public:. RooMinimizer(RooAbsReal& function); virtual~RooMinimizer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinimizer.html:1211,optimiz,optimization,1211,root/html534/RooMinimizer.html,https://root.cern,https://root.cern/root/html534/RooMinimizer.html,1,['optimiz'],['optimization']
Performance," function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for size points. ;  ; void CalcYErrorsSum () const;  Recalculates the summed y error arrays. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set Note: This function should be called only from the constructor since it does not delete previously existing arrays. ;  ; Bool_t DoMerge (const TGraph *tg) override;  Protected function to perform the merge operation of a graph with multiple asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:40559,perform,perform,40559,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['perform'],['perform']
Performance," function with mh==0; 506 if (!mh) {; 507 gLinkedDylibs = linkedDylibs;; 508 return;; 509 }; 510 ; 511 TString lib = _dyld_get_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15561,load,loaded,15561,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['load'],"['loaded', 'loading']"
Performance," functions for the net, i.e.Definition Functions.h:57; TMVA::DNN::TMVAInput_tstd::tuple< const std::vector< Event * > &, const DataSetInfo & > TMVAInput_tDefinition DataLoader.h:40; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::fetchValueTmpTString fetchValueTmp(const std::map< TString, TString > &keyValueMap, TString key)Definition MethodDL.cxx:75; TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMVA::TTrainingSettingsAll of the options that can be specified in the training string.Definition MethodDL.h:72; TMVA::TTrainingSettings::batchSizesize_t batchSizeDefinition MethodDL.h:73; TMVA::TTrainingSettings::optimizerParamsstd::map< TString, double > optimizerParamsDefinition MethodDL.h:84; TMVA::TTrainingSettings::optimizerNameTString optimizerNameDefinition MethodDL.h:79; TMVA::TTrainingSettings::optimizerDNN::EOptimizer optimizerDefinition MethodDL.h:78; TMVA::TTrainingSettings::maxEpochssize_t maxEpochsDefinition MethodDL.h:76; TMVA::TTrainingSettings::momentumDouble_t momentumDefinition MethodDL.h:81; TMVA::TTrainingSettings::weightDecayDouble_t weightDecayDefinition MethodDL.h:82; TMVA::TTrainingSettings::testIntervalsize_t testIntervalDefinition MethodDL.h:74; TMVA::TTrainingSettings::regularizationDNN::ERegularization regularizationDefinition MethodDL.h:77; TMVA::TTrainingSettings::convergenceStepssize_t convergenceStepsDefinition MethodDL.h:75; TMVA::TTrainingSettings::dropoutProbabilitiesstd::vector< Double_t > dropoutProbabilitiesDefinition MethodDL.h:83; TMVA::TTrainingSettings::learningRateDouble_t learningRateDefinition MethodDL.h:80; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; t1auto * t1Definition textangle.C:20; Functions.h; Types.h; outputstatic void output(). tmva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:121425,optimiz,optimizerNameTString,121425,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],"['optimizerNameDefinition', 'optimizerNameTString']"
Performance," functions named ""name"".; 1671 ; 1672TCollection *TROOT::GetListOfFunctionOverloads(const char* name) const; 1673{; 1674 return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Return pointer to global function by name.; 1679/// If params != 0 it will also resolve overloading other it returns the first; 1680/// name match.; 1681/// If params == 0 and load is true force reading of all currently defined; 1682/// global functions from Cling.; 1683/// The param string must be of the form: ""3189,\""aap\"",1.3"".; 1684 ; 1685TFunction *TROOT::GetGlobalFunction(const char *function, const char *params,; 1686 Bool_t load); 1687{; 1688 if (!params) {; 1689 R__LOCKGUARD(gROOTMutex);; 1690 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1691 } else {; 1692 if (!fInterpreter); 1693 Fatal(""GetGlobalFunction"", ""fInterpreter not initialized"");; 1694 ; 1695 R__LOCKGUARD(gROOTMutex);; 1696 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(nullptr,; 1697 function, params,; 1698 false);; 1699 ; 1700 if (!decl) return nullptr;; 1701 ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Return pointer to global function by name. If proto != 0; 1714/// it will also resolve overloading. If load is true force reading; 1715/// of all currently defined global functions from CINT (more expensive).; 1716/// The proto string must be of the form: ""int, char*, float"".; 1717 ; 1718TFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:65129,load,load,65129,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],['load']
Performance," gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; c#define c(i)Definition RSha256.hxx:101; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786. The option COL can be combined with the option POL:; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }. SinceROOT version 6.07/03:; A second rendering technique is also available with the COL2 and COLZ2 options.; These options provide potential performance improvements compared to the standard COL option. The performance comparison of the COL2 to the COL option depends on the histogram and the size of the rendering region in the current pad. In general, a small (approx. less than 100 bins per axis), sparsely populated TH2 will render faster with the COL option.; However, for larger histograms (approx. more than 100 bins per axis) that are not sparse, the COL2 option will provide up to 20 times performance improvements. For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude faster with the COL2 option.; The COL2 option will also scale its performance based on the size of the pixmap the histogram image is being rendered into. It also is much better optimized for sessions where the user is forwarding X11 windows through an ssh connection.; For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL and COLZ options. There is one major difference and that concerns the treatment of bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; COL2 option renders the histogram as a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:48027,perform,performance,48027,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['perform'],['performance']
Performance," gVirtualPS->SetName(psname);; 5140 gVirtualPS->Open(psname);; 5141 gVirtualPS->SetBit(kPrintingPS);; 5142 gVirtualPS->NewPage();; 5143 }; 5144 Paint();; 5145 if (noScreen); 5146 GetCanvas()->SetBatch(kFALSE);; 5147 ; 5148 if (!gSystem->AccessPathName(psname)); 5149 Info(""Print"", ""SVG file %s has been created"", psname.Data());; 5150 ; 5151 delete gVirtualPS;; 5152 gVirtualPS = nullptr;; 5153 ; 5154 return;; 5155 }; 5156 ; 5157 //==============Save pad/canvas as a TeX file================================; 5158 if (strstr(opt,""tex"") || strstr(opt,""Standalone"")) {; 5159 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5160 ; 5161 Bool_t noScreen = kFALSE;; 5162 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5163 noScreen = kTRUE;; 5164 GetCanvas()->SetBatch(kTRUE);; 5165 }; 5166 ; 5167 TContext ctxt(this, kTRUE);; 5168 ; 5169 if (!gVirtualPS) {; 5170 // Plugin Postscript/SVG driver; 5171 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPS"", ""tex"")) {; 5172 if (h->LoadPlugin() == -1); 5173 return;; 5174 h->ExecPlugin(0);; 5175 }; 5176 }; 5177 ; 5178 Bool_t standalone = kFALSE;; 5179 if (strstr(opt,""Standalone"")) standalone = kTRUE;; 5180 ; 5181 // Create a new TeX file; 5182 if (gVirtualPS) {; 5183 gVirtualPS->SetName(psname);; 5184 if (standalone) gVirtualPS->SetTitle(""Standalone"");; 5185 gVirtualPS->Open(psname);; 5186 gVirtualPS->SetBit(kPrintingPS);; 5187 gVirtualPS->NewPage();; 5188 }; 5189 Paint();; 5190 if (noScreen) GetCanvas()->SetBatch(kFALSE);; 5191 ; 5192 if (!gSystem->AccessPathName(psname)) {; 5193 if (standalone) {; 5194 Info(""Print"", ""Standalone TeX file %s has been created"", psname.Data());; 5195 } else{; 5196 Info(""Print"", ""TeX file %s has been created"", psname.Data());; 5197 }; 5198 }; 5199 ; 5200 delete gVirtualPS;; 5201 gVirtualPS = nullptr;; 5202 ; 5203 return;; 5204 }; 5205 ; 5206 //==============Save pad/canvas as a Postscript file=========================; 5207 ; 5208 // in case we read d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:166716,Load,LoadPlugin,166716,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance," gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+)metric:; s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therefore:; mag2 = v*v = t*t-x*x-y*y-z*z; If mag2 is negative: mag = -Sqrt(-mag*mag). The methods are:; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; Since in case of momentum and energy the magnitude has the meaning of invariant mass TLorentzVector provides the more meaningful aliases M2() and M(). The methods Beta() and Gamma() returns beta and gamma = 1/Sqrt(1-beta*beta).; 17.4.6 Lorentz Boost; A boost in a general direction can be parameterized with three parameters which can be taken as the components of a three vector b=(bx,by,bz). With x=(x,y,z) and gamma=1/Sqrt(1-beta*beta) (beta being the module of vector b), an arbitrary active Lorentz boost transformation (from the rod frame to the original frame) can be written as:; x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b; t = gamma(t'+ b*x'); The Boost() method performs a boost transformation from the rod frame to the original frame. BoostVector() returns a TVector3 of the spatial components divided by the time component:; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); 17.4.7 Rotations; There are four sets of functions to rotate the TVector3 component of a TLorentzVector:; Around Axes:; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; Around an arbitrary axis:; v.Rotate(TMath::Pi()/4., v1); // rotation around v1; Transformation from rotated frame:; v.RotateUz(direction); // direction must be a unit TVector3; Rotation by TRotation:; TRotation r;; v.Transform(r);//or v *= r; (v = r*v); 17.4.8 Miscellaneous; Angle between two vectors:; Double_t a = v1.Angle(v2);// get angle between v1 and v2; Methods Plus() and Minus() return the positive and negative light-cone components:; Double_t pcone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:870120,perform,performs,870120,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performs']
Performance," gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemented.. ; Definition at line 87 of file OptimizeConfigParameters.h. ◆ fFOMvsIter. std::vector<Float_t> TMVA::OptimizeConfigParameters::fFOMvsIter. private . graph showing the development of the Figure Of Merit values during the fit ; Definition at line 83 of file OptimizeConfigParameters.h. ◆ fLogger. MsgLogger* TMVA::OptimizeConfigParameters::fLogger. mutableprivate . ! message logger ; Definition at line 97 of file OptimizeConfigParameters.h. ◆ fMethod. MethodBase* const TMVA::OptimizeConfigParameters::fMethod. private . The MVA method to be evaluated. ; Definition at line 82 of file OptimizeConfigParameters.h. ◆ fMvaBkg. TH1D* TMVA::OptimizeConfigParameters::fMvaBkg. private . MVA distribution for bakgr. events, used for spline fit. ; Definition at line 90 of file OptimizeConfigParameters.h. ◆ fMvaBkgFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaBkgFineBin. private . MVA distribution for bakgr. events. ; Definition at line 93 of file OptimizeConfigParameters.h. ◆ fMvaSig. TH1D* TMVA::OptimizeConfigParameters::fMvaSig. private . MVA distribution for signal events, used for spline fit. ; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:10694,Optimiz,OptimizeConfigParameters,10694,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance," generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:44706,load,load,44706,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,4,['load'],['load']
Performance," generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:42361,load,load,42361,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['load'],['load']
Performance," generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gRO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270408,optimiz,optimization,270408,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance," geometry tree. To do that, the new point should not be introduced by using TGeoManager::SetCurrentPoint() method, but rather by calling the specific method:; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; TGeoManager::IsSameLocationBool_t IsSameLocation() constDefinition TGeoManager.h:393; In the prototype above, x, y and z are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of change:. change = kFALSE (default) - the modeller does not change the current state but just inform the caller about this change.; change = kTRUE - the modeller will actually perform a new ‘‘Where am I?’ `search after finding out that the location has changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. gGeoManager->FindNode(newX,newY,newZ)), users can always query if the previous state has changed by using a method having the same name but without parameters:; Bool_t TGeoManager::IsSameLocation();; Finding the Distance to the Next Boundary; All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:81920,perform,performing,81920,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performing']
Performance," getAnalyticalIntegral, except code zero. ; Reimplemented in RooNormalizedPdf, RooBinSamplingPdf, RooWrapperPdf, RooFixedProdPdf, ParamHistFunc, PiecewiseInterpolation, RooLagrangianMorphFunc, RooParamHistFunc, RooAbsAnaConvPdf, RooAbsCachedPdf, RooAbsCachedReal, RooAbsPdf, RooAddModel, RooAddPdf, RooExtendPdf, RooProdPdf, RooProjectedPdf, RooRealSumFunc, RooRealSumPdf, and RooSimultaneous.; Definition at line 378 of file RooAbsReal.cxx. ◆ asTF(). TF1 * RooAbsReal::asTF ; (; const RooArgList & ; obs, . const RooArgList & ; pars = RooArgList(), . const RooArgSet & ; nset = RooArgSet() . ); const. Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ; Definition at line 3987 of file RooAbsReal.cxx. ◆ attachToTree(). void RooAbsReal::attachToTree ; (; TTree & ; t, . Int_t ; bufSize = 32000 . ). overrideprotectedvirtual . Attach object to a branch of given TTree. ; By default it will register the internal value cache RooAbsReal::_value as branch buffer for a double tree branch with the same name as this object. If no double branch is found with the name of this object, this method looks for a Float_t Int_t, UChar_t and UInt_t, etc branch. If any of these are found, a TreeReadBuffer that branch is created, and saved in _treeReadBuffer. TreeReadBuffer::operator double() can be used to convert the values. This is used by copyCache(). ; Implements RooAbsArg.; Reimplemented in RooRealVar.; Definition at line 3113 of file RooAbsReal.cxx. ◆ attachToVStore(). void RooAbsReal::attachToVStore ; (; RooVectorDataStore & ; vstore). overrideprotectedvirtual . Implements RooAbsArg.; Reimplemented in RooRealVar.; Definition at line 3097 of file RooAbsReal.cxx. ◆ binBoundaries(). std::list< double > * RooAbsReal::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Retrieve bin boundaries if this distribution is binned in obs. ; Parameters. [in]obsObservable to retrieve boundaries for. ; [i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:65961,cache,cache,65961,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['cache']
Performance," getAnalyticalIntegral, except code zero. ; Reimplemented in RooNormalizedPdf, RooBinSamplingPdf, RooWrapperPdf, RooFixedProdPdf, ParamHistFunc, PiecewiseInterpolation, RooLagrangianMorphFunc, RooParamHistFunc, RooAbsAnaConvPdf, RooAbsCachedPdf, RooAbsCachedReal, RooAbsPdf, RooAddModel, RooAddPdf, RooExtendPdf, RooProdPdf, RooProjectedPdf, RooRealSumFunc, RooRealSumPdf, and RooSimultaneous.; Definition at line 380 of file RooAbsReal.cxx. ◆ asTF(). TF1 * RooAbsReal::asTF ; (; const RooArgList & ; obs, . const RooArgList & ; pars = RooArgList(), . const RooArgSet & ; nset = RooArgSet() . ); const. Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ; Definition at line 3911 of file RooAbsReal.cxx. ◆ attachToTree(). void RooAbsReal::attachToTree ; (; TTree & ; t, . Int_t ; bufSize = 32000 . ). overrideprotectedvirtual . Attach object to a branch of given TTree. ; By default it will register the internal value cache RooAbsReal::_value as branch buffer for a double tree branch with the same name as this object. If no double branch is found with the name of this object, this method looks for a Float_t Int_t, UChar_t and UInt_t, etc branch. If any of these are found, a TreeReadBuffer that branch is created, and saved in _treeReadBuffer. TreeReadBuffer::operator double() can be used to convert the values. This is used by copyCache(). ; Implements RooAbsArg.; Reimplemented in RooRealVar.; Definition at line 3028 of file RooAbsReal.cxx. ◆ attachToVStore(). void RooAbsReal::attachToVStore ; (; RooVectorDataStore & ; vstore). overrideprotectedvirtual . Implements RooAbsArg.; Reimplemented in RooRealVar.; Definition at line 3012 of file RooAbsReal.cxx. ◆ binBoundaries(). std::list< double > * RooAbsReal::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Retrieve bin boundaries if this distribution is binned in obs. ; Parameters. [in]obsObservable to retrieve boundaries for. ; [i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:64693,cache,cache,64693,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['cache'],['cache']
Performance, getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:37720,cache,cache,37720,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,2,"['Cache', 'cache']","['Cached', 'cache']"
Performance," giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, he can fix a parameter or put limits on another one before handing them over to Minit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply his own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:39070,perform,performed,39070,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['perform'],['performed']
Performance," global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:25001,load,load,25001,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance," global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:25537,load,load,25537,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance," grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined; as fixed or free. The constant parameters are not counted. Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:33898,Perform,Perform,33898,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,2,['Perform'],['Perform']
Performance," granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:42121,cache,cache,42121,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,14,['cache'],['cache']
Performance," grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:959052,perform,performance,959052,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," has already been done.; if (!useList) {; // Return as soon as a bad entry is detected; if (TMath::Abs(*fMd0_d-1.8646) >= 0.04) return kFALSE;; if (*fPtds_d <= 2.5) return kFALSE;; if (TMath::Abs(*fEtads_d) >= 1.5) return kFALSE;; (*fIk)--; //original fIk used f77 convention starting at 1; (*fIpi)--;; ; ; if (fNhitrp.At(*fIk)* fNhitrp.At(*fIpi) <= 1) return kFALSE;; ; ; if (fRend.At(*fIk) -fRstart.At(*fIk) <= 22) return kFALSE;; if (fRend.At(*fIpi)-fRstart.At(*fIpi) <= 22) return kFALSE;; if (fNlhk.At(*fIk) <= 0.1) return kFALSE;; if (fNlhpi.At(*fIpi) <= 0.1) return kFALSE;; (*fIpis)--; if (fNlhpi.At(*fIpis) <= 0.1) return kFALSE;; if (*fNjets < 1) return kFALSE;; }; // if option fillList, fill the entry list; if (fillList) elist->Enter(entry);; ; //fill some histograms; hdmd->Fill(*fDm_d);; h2->Fill(*fDm_d,*fRpd0_t/0.029979*1.8646/ *fPtd0_d);; ; return kTRUE;; }; ; void h1analysisTreeReader::Begin(TTree* /*myTree*/) {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; Reset();; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""Begin"", ""starting h1analysis with process option: %s"", option.Data());; ; delete gDirectory->GetList()->FindObject(""elist"");; ; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"", ""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; // We send a clone to avoid double deletes when importing the result; fInput->Add(elist);; // This is needed to avoid warnings from output-to-members mapping; elist = nullptr;; }; Info(""Begin"", ""creating an entry-list"");; }; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; // In PROOF option ""useList"" is pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:2597,perform,performs,2597,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['perform'],['performs']
Performance," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGClient.html:17838,queue,queue,17838,root/html528/TGClient.html,https://root.cern,https://root.cern/root/html528/TGClient.html,6,['queue'],['queue']
Performance," hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:65097,load,load,65097,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance," hashtables.; 1732 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1733 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1734 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1735 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1736 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1737 fgClassTypedefHash->Remove (htmp);; 1738 delete htmp;; 1739 break;; 1740 }; 1741 }; 1742 }; 1743 ; 1744 // Not owning lists, don't call Delete(); 1745 // But this still need to be done first because the TList destructor; 1746 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1747 delete fStreamer; fStreamer =nullptr;; 1748 delete fAllPubData; fAllPubData =nullptr;; 1749 delete fAllPubMethod; fAllPubMethod=nullptr;; 1750 ; 1751 delete fPersistentRef.load();; 1752 ; 1753 if (fBase.load()); 1754 (*fBase).Delete();; 1755 delete fBase.load(); fBase = nullptr;; 1756 ; 1757 if (fData.load()); 1758 (*fData).Delete();; 1759 delete fData.load(); fData = nullptr;; 1760 ; 1761 if (fUsingData.load()); 1762 (*fUsingData).Delete();; 1763 delete fUsingData.load(); fUsingData = nullptr;; 1764 ; 1765 if (fEnums.load()); 1766 (*fEnums).Delete();; 1767 delete fEnums.load(); fEnums = nullptr;; 1768 ; 1769 if (fFuncTemplate); 1770 fFuncTemplate->Delete();; 1771 delete fFuncTemplate; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuList; fClassMenuList=nullptr;; 1794 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:67848,load,load,67848,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance," have activated the following line in system.rootrc,; //it will appear in the GL viewer; //#Viewer3D.DefaultDrawOption: ogl; ; geom->SetVisLevel(4);; if (vis) top->Draw(""ogle"");; }; ; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; R; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; TGeoMaterialBase class describing materials.Definition TGeoMateri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootgeom_8C.html:6090,perform,performedDefinition,6090,doc/master/rootgeom_8C.html,https://root.cern,https://root.cern/doc/master/rootgeom_8C.html,1,['perform'],['performedDefinition']
Performance," have always a different order in the batches; 1437 size_t shuffleSeed = 0;; 1438 if (fRandomSeed != 0) shuffleSeed = fRandomSeed + trainingPhase;; 1439 RandomGenerator<TRandom3> rng(shuffleSeed);; 1440 ; 1441 // print weights before; 1442 if (fBuildNet && debug) {; 1443 Log() << ""Initial Deep Net Weights "" << Endl;; 1444 auto & weights_tensor = deepNet.GetLayerAt(0)->GetWeights();; 1445 for (size_t l = 0; l < weights_tensor.size(); ++l); 1446 weights_tensor[l].Print();; 1447 auto & bias_tensor = deepNet.GetLayerAt(0)->GetBiases();; 1448 bias_tensor[0].Print();; 1449 }; 1450 ; 1451 Log() << "" Start epoch iteration ..."" << Endl;; 1452 bool debugFirstEpoch = false;; 1453 bool computeLossInTraining = true; // compute loss in training or at test time; 1454 size_t nTrainEpochs = 0;; 1455 while (!converged) {; 1456 nTrainEpochs++;; 1457 trainingData.Shuffle(rng);; 1458 ; 1459 // execute all epochs; 1460 //for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1461 ; 1462 Double_t trainingError = 0;; 1463 for (size_t i = 0; i < batchesInEpoch; ++i ) {; 1464 // Clean and load new batches, one batch for one slave net; 1465 //batches.clear();; 1466 //batches.reserve(nThreads);; 1467 //for (size_t j = 0; j < nThreads; j++) {; 1468 // batches.push_back(trainingData.GetTensorBatch());; 1469 //}; 1470 if (debugFirstEpoch) std::cout << ""\n\n----- batch # "" << i << ""\n\n"";; 1471 ; 1472 auto my_batch = trainingData.GetTensorBatch();; 1473 ; 1474 if (debugFirstEpoch); 1475 std::cout << ""got batch data - doing forward \n"";; 1476 ; 1477#ifdef DEBUG; 1478 ; 1479 Architecture_t::PrintTensor(my_batch.GetInput(),""input tensor"",true);; 1480 typename Architecture_t::Tensor_t tOut(my_batch.GetOutput());; 1481 typename Architecture_t::Tensor_t tW(my_batch.GetWeights());; 1482 Architecture_t::PrintTensor(tOut,""label tensor"",true) ;; 1483 Architecture_t::PrintTensor(tW,""weight tensor"",true) ;; 1484#endif; 1485 ; 1486 deepNet.Forward(my_batch.GetInput(), true);; 1487 // compute also loss; 1488 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:58182,load,load,58182,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['load'],['load']
Performance," have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518532,load,loaded,518532,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance," have been in the areas of data analysis performance and programming model.; ; . Guilherme Amadio ; ; Guilherme has always been at the interface between physics and computer science. He started his undergraduate studies in computer science at the University of São Paulo (USP) campus in São Carlos in 2000, but later moved to the São Paulo campus for the course of molecular sciences, a special interdisciplinary program of the university aimed at preparing students for scientific research. In 2004, he moved to Japan for his master degree in nuclear physics at the University of Tokyo, where he studied the elastic and inelastic scattering of ⁷Be+p. He then moved on to obtain his PhD in aerospace engineering from the University of Illinois at Urbana-Champaign, USA. Guilherme then worked for two years at São Paulo State University (UNESP) in collaboration with CERN and Fermilab before joining the ROOT Team in April of 2017. His responsibilities in ROOT include working on the build system, performance analysis and optimization, and support for SIMD vectorization.;  ; ; . Jakob Blomer ; ; Jakob joined CERN for the first time as a summer student in 2007. He graduated from the University of Karlsruhe and obtained a PhD in computer science from the Technical University of Munich. Jakob works on distributed systems and storage software. He created the CernVM File System, which he evolves ever since. Jakob has been a Marie Curie fellow and a visiting scholar at the RAMCloud research group at Stanford University. In the ROOT team, Jakob works on the columnar data storage for event data, searching for ever faster and more robust ways to read and write hierarchically nested ntuples.; ; . Lorenzo Moneta ; ; Lorenzo started working in 1989 as an experimental physicist for the ALEPH experiment working for data analysis and software event reconstruction. He graduated in Pisa in 1990 and he received his Ph.D. in particle physics in 1994 at the University of Florence. Afterwards, since 199",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:5920,perform,performance,5920,d/team.html,https://root.cern,https://root.cern/d/team.html,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance," having an unique id.; 1304 ; 1305TGeoMaterial *; 1306TGeoManager::Mixture(const char *name, Double_t *a, Double_t *z, Double_t dens, Int_t nelem, Double_t *wmat, Int_t uid); 1307{; 1308 return TGeoBuilder::Instance(this)->Mixture(name, a, z, dens, nelem, wmat, uid);; 1309}; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Create tracking medium; 1313///; 1314/// - numed tracking medium number assigned; 1315/// - name tracking medium name; 1316/// - nmat material number; 1317/// - isvol sensitive volume flag; 1318/// - ifield magnetic field; 1319/// - fieldm max. field value (kilogauss); 1320/// - tmaxfd max. angle due to field (deg/step); 1321/// - stemax max. step allowed; 1322/// - deemax max. fraction of energy lost in a step; 1323/// - epsil tracking precision (cm); 1324/// - stmin min. step due to continuous processes (cm); 1325///; 1326/// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; 1327/// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; 1328/// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; 1329///; 1330 ; 1331TGeoMedium *TGeoManager::Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm,; 1332 Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); 1333{; 1334 return TGeoBuilder::Instance(this)->Medium(name, numed, nmat, isvol, ifield, fieldm, tmaxfd, stemax, deemax, epsil,; 1335 stmin);; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Create a node called `<name_nr>` pointing to the volume called `<name>`; 1340/// as daughter of the volume called `<mother>` (gspos). The relative matrix is; 1341/// made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`.; 1342/// In case npar>0, create the volume to be positioned in mother, according; 1343/// its actual parameters (gsposp).; 1344/// - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:48861,perform,performed,48861,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,3,['perform'],['performed']
Performance," hh_data_all = data.createHistogram(""hh_data_all"", x, Binning=8, YVar=dict(var=y, Binning=8)); hh_data_sel = data.createHistogram(""hh_data_sel"", x, Binning=8, YVar=dict(var=y, Binning=8), Cut=""cut==cut::accept""); hh_eff = effFunc.createHistogram(""hh_eff"", x, Binning=50, YVar=dict(var=y, Binning=50)); ; # Some adjustsment for good visualization; hh_data_all.SetMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:3696,perform,performing,3696,doc/master/rf702__efficiencyfit__2D_8py.html,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html,1,['perform'],['performing']
Performance," horizontal. ; Definition at line 154 of file TTF.cxx. ◆ GetTextExtent() [2/2]. void TTF::GetTextExtent ; (; UInt_t & ; w, . UInt_t & ; h, . wchar_t * ; text . ). static . Get width (w) and height (h) when text is horizontal. ; Definition at line 183 of file TTF.cxx. ◆ GetTrailingBlanksWidth(). Int_t TTF::GetTrailingBlanksWidth ; (; ). static . Definition at line 650 of file TTF.cxx. ◆ GetWidth(). Int_t TTF::GetWidth ; (; ). static . Definition at line 622 of file TTF.cxx. ◆ Init(). void TTF::Init ; (; ). static . Initialise the TrueType fonts interface. ; Definition at line 65 of file TTF.cxx. ◆ IsA(). virtual TClass * TTF::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 130 of file TTF.h. ◆ IsInitialized(). Bool_t TTF::IsInitialized ; (; ). static . Definition at line 615 of file TTF.cxx. ◆ LayoutGlyphs(). void TTF::LayoutGlyphs ; (; ). static . Compute the glyphs positions, fgAscent and fgWidth (needed for alignment). ; Perform the Glyphs transformation. Compute the string control box. If required take the ""kerning"" into account. SetRotation and PrepareString should have been called before. ; Definition at line 203 of file TTF.cxx. ◆ PrepareString() [1/2]. void TTF::PrepareString ; (; const char * ; string). static . Put the characters in ""string"" in the ""glyphs"" array. ; Definition at line 272 of file TTF.cxx. ◆ PrepareString() [2/2]. void TTF::PrepareString ; (; const wchar_t * ; string). static . Put the characters in ""string"" in the ""glyphs"" array. ; Definition at line 302 of file TTF.cxx. ◆ SetHinting(). void TTF::SetHinting ; (; Bool_t ; state). static . Set hinting flag. ; Definition at line 332 of file TTF.cxx. ◆ SetKerning(). void TTF::SetKerning ; (; Bool_t ; state). static . Set kerning flag. ; Definition at line 340 of file TTF.cxx. ◆ SetRotationMatrix(). void TTF::SetRotationMatrix ; (; Float_t ; angle). static . Set the rotation matrix used to rotate the font outlines. ; Definition at line 348 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTF.html:7942,Perform,Perform,7942,doc/master/classTTF.html,https://root.cern,https://root.cern/doc/master/classTTF.html,1,['Perform'],['Perform']
Performance, h length;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char ListFonts;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window LoadQueryFont;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Long_t;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize LowerWindow;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerSt,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:71556,Load,LoadQueryFont,71556,doc/master/TGWin32VirtualXProxy_8cxx.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html,2,['Load'],['LoadQueryFont']
Performance," i % 1000 == 0:; print(""Generating event ... %d"", i); ; for j in range(ntime):; h1 = v1[j]; h2 = v2[j]; h1.Reset(); h2.Reset(); ; f1.SetParameters(1, mean1[j], sigma1[j]); f2.SetParameters(1, mean2[j], sigma2[j]); ; h1.FillRandom(""f1"", 1000); h2.FillRandom(""f2"", 1000); ; for k in range(ntime):; # std::cout << j*10+k << "" "";; x1[j][k] = h1.GetBinContent(k + 1) + ROOT.gRandom.Gaus(0, 10); x2[j][k] = h2.GetBinContent(k + 1) + ROOT.gRandom.Gaus(0, 10); ; sgn.Fill(); bkg.Fill(); ; if n == 1:; c1 = ROOT.TCanvas(); c1.Divide(ntime, 2); for j in range(ntime):; c1.cd(j + 1); v1[j].Draw(); for j in range(ntime):; c1.cd(ntime + j + 1); v2[j].Draw(); ; ROOT.gPad.Update(); ; if n > 1:; sgn.Write(); bkg.Write(); sgn.Print(); bkg.Print(); f.Close(); ; ; ## macro for performing a classification using a Recurrent Neural Network; ## @param use_type; ## use_type = 0 use Simple RNN network; ## use_type = 1 use LSTM network; ## use_type = 2 use GRU; ## use_type = 3 build 3 different networks with RNN, LSTM and GRU; ; ; use_type = 1; ninput = 30; ntime = 10; batchSize = 100; maxepochs = 10; ; nTotEvts = 2000 # total events to be generated for signal or background; ; useKeras = True; ; useTMVA_RNN = True; useTMVA_DNN = True; useTMVA_BDT = False; ; tf_spec = importlib.util.find_spec(""tensorflow""); if tf_spec is None:; useKeras = False; ROOT.Warning(""TMVA_RNN_Classificaton"",""Skip using Keras since tensorflow is not installed""); ; ; rnn_types = [""RNN"", ""LSTM"", ""GRU""]; use_rnn_type = [1, 1, 1]; ; if 0 <= use_type < 3:; use_rnn_type = [0, 0, 0]; use_rnn_type[use_type] = 1; ; useGPU = True # use GPU for TMVA if available; ; useGPU = ""tmva-gpu"" in ROOT.gROOT.GetConfigFeatures(); useTMVA_RNN = (""tmva-cpu"" in ROOT.gROOT.GetConfigFeatures()) or useGPU; ; if useTMVA_RNN:; ROOT.Warning(; ""TMVA_RNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for RNN"",; ); ; archString = ""GPU"" if useGPU else ""CPU""; ; writeOutputFile = True; ; rnn_type = ""RNN"";",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:52136,perform,performing,52136,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performing']
Performance," i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87665,perform,perform,87665,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['perform'],['perform']
Performance," if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:6447,Load,Load,6447,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,2,['Load'],['Load']
Performance," if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[idx])) {; 1877 ++idx;; 1878 // No need to test for len here, at worse idx==len and lib[idx]=='\0'; 1879 if (libs[idx] == '.') {; 1880 ++idx;; 1881 }; 1882 }; 1883 while (idx < len && libs[idx] != '.') {; 1884 if (libs[idx] == ' ' || idx+1 == len) {; 1885 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Length()-1);; 1893 }; 1894 if (l.BeginsWith(""lib"")) {; 1895 l.Replace(0, 3, ""-l"");; 1896 for(idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1897 if ((idx == 0 || libs[idx-1] == ' ') &&; 1898 (libs[idx+l.Length()] == ' ' || libs[idx+l.Length()] == 0)) {; 1899 return 1;; 1900 }; 1901 }; 1902 }; 1903 ; 1904 char *path = DynamicPathName(module);; 1905 ; 1906 int ret = -1;; 1907 if (path) {; 1908 // load any dependent libraries; 1909 TString deplibs = gInterpreter->GetSharedLibDeps(path);; 1910 if (!deplibs.IsNull()) {; 1911 TString delim("" "");; 1912 TObjArray *tokens = deplibs.Tokenize(delim);; 1913 for (Int_t i = tokens->GetEntriesFast()-1; i > 0; i--) {; 1914 const char *deplib = ((TObjString*)tokens->At(i))->GetName();; 1915 if (strcmp(module,deplib)==0) {; 1916 continue;; 1917 }; 1918 if (gDebug > 0); 1919 Info(""Load"", ""loading dependent library %s for library %s"",; 1920 deplib, ((TObjString*)tokens->At(0))->GetName());; 1921 if ((ret = Load(deplib, """", system)) < 0) {; 1922 delete tokens;; 1923 delete [] path;; 1924 return ret;; 1925 }; 1926 }; 1927 delete tokens;; 1928 }; 1929 if (!system) {; 1930 // Mark the library in $ROOTSYS/lib as system.; 1931 TString dirname = GetDirName(path);; 1932 system = R__MatchFilename(TROOT::GetLibDir(), dirname.Data());; 1933 ; 1934 if (!system) {; 1935 system = R__MatchFilename(TROOT::GetBinDir(), dirname.Data());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:61544,load,load,61544,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['load']
Performance," if (ngood == 0 && nbad == 0) goto L700;; 5430 if (ngood > 0 && nbad == 0) fCstatu = ""SUCCESSFUL"";; 5431 if (ngood == 0 && nbad > 0) fCstatu = ""FAILURE "";; 5432 if (ngood > 0 && nbad > 0) fCstatu = ""PROBLEMS "";; 5433 if (fISW[4] >= 0) mnprin(4, fAmin);; 5434 if (fISW[4] >= 2) mnmatu(0);; 5435 return;; 5436// new minimum found; 5437L650:; 5438 fCfrom = ""MINOS "";; 5439 fNfcnfr = nfcnmi;; 5440 fCstatu = ""NEW MINIMU"";; 5441 if (fISW[4] >= 0) mnprin(4, fAmin);; 5442 Printf("" NEW MINIMUM FOUND. GO BACK TO MINIMIZATION STEP."");; 5443 Printf("" ================================================="");; 5444 Printf("" V"");; 5445 Printf("" V"");; 5446 Printf("" V"");; 5447 Printf("" VVVVVVV"");; 5448 Printf("" VVVVV"");; 5449 Printf("" VVV"");; 5450 Printf("" V\n"");; 5451 return;; 5452L700:; 5453 Printf("" THERE ARE NO MINOS ERRORS TO CALCULATE."");; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Performs a MINOS error analysis on one parameter; 5458///; 5459/// The parameter ILAX is varied, and the minimum of the; 5460/// function with respect to the other parameters is followed; 5461/// until it crosses the value FMIN+UP.; 5462 ; 5463void TMinuit::mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi); 5464{; 5465 /* System generated locals */; 5466 Int_t i__1;; 5467 ; 5468 /* Local variables */; 5469 Double_t delu, aopt, eros;; 5470 Double_t abest, xunit, dc, ut, sigsav, du1;; 5471 Double_t fac, sig, sav;; 5472 Int_t marc, isig, mpar, ndex, imax, indx, ierr, i, j;; 5473 Int_t iercr, it, istrav, nfmxin, nlimit, isw2, isw4;; 5474 TString csig;; 5475 ; 5476// save and prepare start vals; 5477 isw2 = fISW[1];; 5478 isw4 = fISW[3];; 5479 sigsav = fEDM;; 5480 istrav = fIstrat;; 5481 dc = fDcovar;; 5482 fLnewmn = kFALSE;; 5483 fApsi = fEpsi*.5;; 5484 abest = fAmin;; 5485 mpar = fNpar;; 5486 nfmxin = fNfcnmx;; 5487 for (i = 1; i <= mpar; ++i) { fXt[i-1] = fX[i-1]; }; 5488 i__1 = mpar*(mpar + 1) / 2;; 5489 for (j = 1; j <= i__1;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:178398,Perform,Performs,178398,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['Perform'],['Performs']
Performance," if (s.BeginsWith(""cpu MHz"")) {; 5121 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5122 sysinfo->fCpuSpeed = s.Atoi();; 5123 }; 5124 if (s.BeginsWith(""cache size"")) {; 5125 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5126 sysinfo->fL2Cache = s.Atoi();; 5127 }; 5128 if (s.BeginsWith(""processor"")) {; 5129 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5130 sysinfo->fCpus = s.Atoi();; 5131 sysinfo->fCpus++;; 5132 }; 5133 }; 5134 fclose(f);; 5135 }; 5136 ; 5137 f = fopen(""/proc/meminfo"", ""r"");; 5138 if (f) {; 5139 while (s.Gets(f)) {; 5140 if (s.BeginsWith(""MemTotal"")) {; 5141 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5142 sysinfo->fPhysRam = (s.Atoi() / 1024);; 5143 break;; 5144 }; 5145 }; 5146 fclose(f);; 5147 }; 5148 ; 5149 f = gSystem->OpenPipe(""uname -s -p"", ""r"");; 5150 if (f) {; 5151 s.Gets(f);; 5152 Ssiz_t from = 0;; 5153 s.Tokenize(sysinfo->fOS, from);; 5154 s.Tokenize(sysinfo->fCpuType, from);; 5155 gSystem->ClosePipe(f);; 5156 }; 5157}; 5158 ; 5159////////////////////////////////////////////////////////////////////////////////; 5160/// Get CPU load on Linux.; 5161 ; 5162static void ReadLinuxCpu(long *ticks); 5163{; 5164 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 5165 ; 5166 TString s;; 5167 FILE *f = fopen(""/proc/stat"", ""r"");; 5168 if (!f) return;; 5169 s.Gets(f);; 5170 // user, user nice, sys, idle; 5171 sscanf(s.Data(), ""%*s %ld %ld %ld %ld"", &ticks[0], &ticks[3], &ticks[1], &ticks[2]);; 5172 fclose(f);; 5173}; 5174 ; 5175////////////////////////////////////////////////////////////////////////////////; 5176/// Get CPU stat for Linux. Use sampleTime to set the interval over which; 5177/// the CPU load will be measured, in ms (default 1000).; 5178 ; 5179static void GetLinuxCpuInfo(CpuInfo_t *cpuinfo, Int_t sampleTime); 5180{; 5181 Double_t avg[3] = { -1., -1., -1. };; 5182#ifndef R__WINGCC; 5183 if (getloadavg(avg, sizeof(avg)) < 0) {; 5184 ::Error(""TUnixSystem::GetLinuxCpuInfo"", ""getloadavg failed"");; 5185 } else; 5186#endif; 5187 {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:166737,load,load,166737,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['load']
Performance," if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction2Binding_double_double_double_.html:33263,cache,cache,33263,root/html530/RooCFunction2Binding_double_double_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction2Binding_double_double_double_.html,1,['cache'],['cache']
Performance," if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList); Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:66481,perform,performed,66481,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['perform'],['performed']
Performance," if the iterator reached the end.; 1667/// If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 1668/// which case 'Next' will return the value of the pointer.; 1669 ; 1670TVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read); 1671{; 1672 if (read) {; 1673 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1674 if ( (fProperties & kIsAssociative) && read); 1675 return TGenCollectionProxy__StagingNext;; 1676 }; 1677 ; 1678 if ( fFunctionNextIterator ) return fFunctionNextIterator;; 1679 ; 1680 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1681 ; 1682 // TODO can we do better than the default for RVec?; 1683 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1684 return fFunctionNextIterator = TGenCollectionProxy__VectorNext;; 1685 else if ( (fProperties & kIsAssociative) && read); 1686 return TGenCollectionProxy__StagingNext;; 1687 else; 1688 return fFunctionNextIterator = TGenCollectionProxy__SlowNext;; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// See typedef void (*DeleteIterator_t)(void *iter);; 1693/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read); 1697{; 1698 if (read) {; 1699 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1700 if ( (fProperties & kIsAssociative) && read); 1701 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1702 }; 1703 ; 1704 if ( fFunctionDeleteIterator ) return fFunctionDeleteIterator;; 1705 ; 1706 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1707 ; 1708 // TODO can we do better than the default for RVec?; 1709 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:55693,load,load,55693,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance," if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:44795,cache,cached,44795,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,1,['cache'],['cached']
Performance," if(!fNotify->Notify()) return -6;; 6533 }; 6534 }; 6535 }; 6536 ; 6537 if ((fReadEntry >= fEntries) && !friendHasEntry) {; 6538 fReadEntry = -1;; 6539 return -2;; 6540 }; 6541 return fReadEntry;; 6542}; 6543 ; 6544////////////////////////////////////////////////////////////////////////////////; 6545/// Load entry on behalf of our master tree, we may use an index.; 6546///; 6547/// Called by LoadTree() when the masterTree looks for the entry; 6548/// number in a friend tree (us) corresponding to the passed entry; 6549/// number in the masterTree.; 6550///; 6551/// If we have no index, our entry number and the masterTree entry; 6552/// number are the same.; 6553///; 6554/// If we *do* have an index, we must find the (major, minor) value pair; 6555/// in masterTree to locate our corresponding entry.; 6556///; 6557 ; 6558Long64_t TTree::LoadTreeFriend(Long64_t entry, TTree* masterTree); 6559{; 6560 if (!fTreeIndex) {; 6561 return LoadTree(entry);; 6562 }; 6563 return LoadTree(fTreeIndex->GetEntryNumberFriend(masterTree));; 6564}; 6565 ; 6566////////////////////////////////////////////////////////////////////////////////; 6567/// Generate a skeleton analysis class for this tree.; 6568///; 6569/// The following files are produced: classname.h and classname.C.; 6570/// If classname is 0, classname will be called ""nameoftree"".; 6571///; 6572/// The generated code in classname.h includes the following:; 6573///; 6574/// - Identification of the original tree and the input file name.; 6575/// - Definition of an analysis class (data members and member functions).; 6576/// - The following member functions:; 6577/// - constructor (by default opening the tree file),; 6578/// - GetEntry(Long64_t entry),; 6579/// - Init(TTree* tree) to initialize a new TTree,; 6580/// - Show(Long64_t entry) to read and dump entry.; 6581///; 6582/// The generated code in classname.C includes only the main; 6583/// analysis function Loop.; 6584///; 6585/// To use this function:; 6586///; 6587/// - Ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:255813,Load,LoadTreeFriend,255813,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,3,['Load'],"['LoadTree', 'LoadTreeFriend']"
Performance," if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:343283,cache,cache,343283,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance," implements covariance matrix calculation will re-implement the method. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ivar) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. bool GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run; (This feature is not yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. bool Scan(unsigned int ivar, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj). find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:10697,perform,perform,10697,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,3,['perform'],['perform']
Performance," improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interlea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:53661,perform,performed,53661,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['perform'],['performed']
Performance," in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:50098,perform,performed,50098,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,3,['perform'],['performed']
Performance," in TBranchClones.; Definition at line 287 of file TBranch.h. ◆ SetupAddresses(). void TBranch::SetupAddresses ; (; ). virtual . If the branch address is not set, we set all addresses starting with the top level parent branch. ; Reimplemented in TBranchElement, and TBranchObject.; Definition at line 3294 of file TBranch.cxx. ◆ Streamer(). void TBranch::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TObject.; Reimplemented in THbookBranch, TBranchClones, TBranchElement, TBranchObject, TBranchRef, and TBranchSTL.; Definition at line 2956 of file TBranch.cxx. ◆ StreamerNVirtual(). void TBranch::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 295 of file TBranch.h. ◆ SupportsBulkRead(). bool TBranch::SupportsBulkRead ; (; ); const. Returns true if this branch supports bulk IO, false otherwise. ; This will return true if all the various preconditions necessary hold true to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may still fail, depending on the contents of the individual TBaskets loaded. ; Definition at line 1431 of file TBranch.cxx. ◆ UpdateAddress(). virtual void TBranch::UpdateAddress ; (; ). inlinevirtual . Reimplemented in TBranchObject.; Definition at line 290 of file TBranch.h. ◆ UpdateFile(). void TBranch::UpdateFile ; (; ). virtual . Refresh the value of fDirectory (i.e. ; where this branch writes/reads its buffers) with the current value of fTree->GetCurrentFile unless this branch has been redirected to a different file. Also update the sub-branches. ; Reimplemented in TBranchClones, and TBranchElement.; Definition at line 3304 of file TBranch.cxx. ◆ WriteBasket(). Int_t TBranch::WriteBasket ; (; TBasket * ; basket, . Int_t ; where . ). inlineprotected . Definition at line 175 of file TBranch.h. ◆ WriteBasketImpl(). Int_t TBranch::WriteBasketImpl ; (; TBasket * ; basket, . Int_t ; where, . ROOT::Internal::TBranchIMTHelper * ; imtHelper . ). private ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:68049,perform,perform,68049,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,2,"['load', 'perform']","['loaded', 'perform']"
Performance," in TUnixSystem, and TWinNTSystem.; Definition at line 453 of file TSystem.cxx. ◆ Select() [2/2]. Int_t TSystem::Select ; (; TList * ; active, . Long_t ; timeout . ). virtual . Select on active file descriptors (called by TMonitor). ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 445 of file TSystem.cxx. ◆ SendBuf(). int TSystem::SendBuf ; (; int ; sock, . const void * ; buffer, . int ; length . ). virtual . Send a buffer headed by a length indicator. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2427 of file TSystem.cxx. ◆ SendRaw(). int TSystem::SendRaw ; (; int ; sock, . const void * ; buffer, . int ; length, . int ; flag . ). virtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2409 of file TSystem.cxx. ◆ SetAclicMode(). void TSystem::SetAclicMode ; (; EAclicMode ; mode). virtual . AclicMode indicates whether the library should be built in debug mode or optimized. ; The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library . Definition at line 4077 of file TSystem.cxx. ◆ SetBuildDir(). void TSystem::SetBuildDir ; (; const char * ; build_dir, . Bool_t ; isflat = kFALSE . ). virtual . Set the location where ACLiC will create libraries and use as a scratch area. ; If unset, libraries will be created at the same location than the script.; Parameters. build_dirthe name of the build directory ; isflatIf false (default), then the libraries are actually stored in sub-directories of 'build_dir' including the full pathname of the script. If the script is located at /full/path/name/macro.C the library will be located at build_dir+/full/path/name/macro_C.so If 'isflat' is true, then no subdirectory is created and the library is created directly in the directory 'build_dir'. Note that in this mode there is a risk than 2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:82732,optimiz,optimized,82732,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimized']
Performance, in all the branches. ; Definition at line 365 of file TTreeCloner.cxx. ◆ CopyMemoryBaskets(). void TTreeCloner::CopyMemoryBaskets ; (; ). Transfer the basket from the input file to the output file. ; Definition at line 513 of file TTreeCloner.cxx. ◆ CopyProcessIds(). void TTreeCloner::CopyProcessIds ; (; ). Make sure that all the needed TStreamerInfo are present in the output file. ; Definition at line 543 of file TTreeCloner.cxx. ◆ CopyStreamerInfos(). void TTreeCloner::CopyStreamerInfos ; (; ). Make sure that all the needed TStreamerInfo are present in the output file. ; Definition at line 472 of file TTreeCloner.cxx. ◆ CreateCache(). void TTreeCloner::CreateCache ; (; ). private . Create a TFileCacheRead if it was requested. ; Definition at line 596 of file TTreeCloner.cxx. ◆ Exec(). bool TTreeCloner::Exec ; (; ). Execute the cloning. ; Definition at line 222 of file TTreeCloner.cxx. ◆ FillCache(). UInt_t TTreeCloner::FillCache ; (; UInt_t ; from). private . Fill the file cache with the next set of basket. ; Parameters. fromindex of the first lement of fFromBranches to start caching . ReturnsThe index of first element of fFromBranches that is not in the cache ; Definition at line 702 of file TTreeCloner.cxx. ◆ GetWarning(). const char * TTreeCloner::GetWarning ; (; ); const. inline . Definition at line 117 of file TTreeCloner.h. ◆ ImportClusterRanges(). void TTreeCloner::ImportClusterRanges ; (; ). private . Set the entries and import the cluster range of the. ; Definition at line 626 of file TTreeCloner.cxx. ◆ IsInPlace(). bool TTreeCloner::IsInPlace ; (; ); const. inline . Definition at line 118 of file TTreeCloner.h. ◆ IsValid(). bool TTreeCloner::IsValid ; (; ). inline . Definition at line 120 of file TTreeCloner.h. ◆ NeedConversion(). bool TTreeCloner::NeedConversion ; (; ). inline . Definition at line 121 of file TTreeCloner.h. ◆ operator=(). TTreeCloner & TTreeCloner::operator= ; (; const TTreeCloner & ; ). privatedelete . ◆ RestoreCache(). void TTreeClone,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:10203,cache,cache,10203,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['cache'],['cache']
Performance," in case of error and TSelector::GetStatus() in; in case of success. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); See TTree::SetDebug. void SetName(const char* name); See TTree::GetName. Long64_t GetEntries() const; Returns the total number of entries in the TProofChain, which is; the number of entries in the TDSet that it holds. Long64_t GetEntries(const char* sel); See TTree::GetEntries(const char *selection); Not implemented in TProofChain. Shouldn't be used. void Progress(Long64_t total, Long64_t processed); Changes the number of processed entries. Long64_t GetReadEntry() const; Returns the number of processed entries. void ReleaseProof(); Releases PROOF. Disconnect the ""progress"" signal. void ConnectProof(); Connects the proof ""Progress"" signal. TProofChain(). Int_t Debug() const; {return fDebug;}. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0). TList * GetListOfClones(); { return 0; }. TObjArray * GetListOfBranches(); {return (fTree ? fTree->GetListOfBranches() : (TObjArray *)0); }. TObjArray * GetListOfLeaves(); {return (fTree ? fTree->GetListOfLeaves() : (TObjArray *)0);}. TList * GetListOfFriends() const; {return 0;}. TList * GetListOfAliases() const; {return 0;}. Int_t GetMakeClass() const; GetMakeClass is left non-virtual for efficiency reason.; Making it virtual affects the performance of the I/O. {return fMakeClass;}. Bool_t HasTreeHeader() const; { return (fTree ? kTRUE : kFALSE); }. void SetEventList(TEventList* evlist); { fEventList = evlist; }. void SetEntryList(TEntryList* enlist, const Option_t* ); { fEntryList = enlist; }. » Author: G. Ganis Nov 2006 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-03 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofChain.html:33929,perform,performance,33929,root/html604/TProofChain.html,https://root.cern,https://root.cern/root/html604/TProofChain.html,1,['perform'],['performance']
Performance," in case of error and TSelector::GetStatus() in; in case of success. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); See TTree::SetDebug. void SetName(const char* name); See TTree::GetName. Long64_t GetEntries() const; Returns the total number of entries in the TProofChain, which is; the number of entries in the TDSet that it holds. Long64_t GetEntries(const char* sel); See TTree::GetEntries(const char *selection); Not implemented in TProofChain. Shouldn't be used. void Progress(Long64_t total, Long64_t processed); Changes the number of processed entries. Long64_t GetReadEntry() const; Returns the number of processed entries. void ReleaseProof(); Releases PROOF. Disconnect the ""progress"" signal. void ConnectProof(); Connects the proof ""Progress"" signal. TProofChain(). Int_t Debug() const; {return fDebug;}. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0). TList * GetListOfClones(); { return 0; }. TObjArray * GetListOfBranches(); {return (fTree ? fTree->GetListOfBranches() : (TObjArray *)0); }. TObjArray * GetListOfLeaves(); {return (fTree ? fTree->GetListOfLeaves() : (TObjArray *)0);}. TList * GetListOfFriends() const; {return 0;}. TList * GetListOfAliases() const; {return 0;}. Int_t GetMakeClass() const; GetMakeClass is left non-virtual for efficiency reason.; Making it virtual affects the performance of the I/O. {return fMakeClass;}. Bool_t HasTreeHeader() const; { return (fTree ? kTRUE : kFALSE); }. void SetEventList(TEventList* evlist); { fEventList = evlist; }. void SetEntryList(TEntryList* enlist, const Option_t* ); { fEntryList = enlist; }. » Author: G. Ganis Nov 2006 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofChain.html:33834,perform,performance,33834,root/html602/TProofChain.html,https://root.cern,https://root.cern/root/html602/TProofChain.html,1,['perform'],['performance']
Performance," in the BranchCount corresponding to that entry (can be obtained from branch->GetBranchCount()).; NoteThis interface is not meant to be exposed to end users, but rather it should be wrapped by higher-level interfaces. See TBranch::GetBulkEntries() for an alternative that also performs byte swapping. ; Definition at line 1586 of file TBranch.cxx. ◆ GetEntry(). Int_t TBranch::GetEntry ; (; Long64_t ; entry = 0, . Int_t ; getall = 0 . ). virtual . Read all leaves of entry and return total number of bytes read. ; The input argument ""entry"" is the entry number in the current tree. In case of a TChain, the entry number in the current Tree must be found before calling this function. For example:; TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::LoadTreeLong64_t LoadTree(Long64_t entry) overrideFind the tree which contains entry, and set it as the current tree.Definition TChain.cxx:1324; The function returns the number of bytes read from the input buffer. If entry does not exist, the function returns 0. If an I/O error occurs, the function returns -1.; See IMPORTANT REMARKS in TTree::GetEntry. ; Reimplemented in THbookBranch, TBranchClones, TBranchElement, TBranchObject, and TBranchSTL.; Definition at line 1706 of file TBranch.cxx. ◆ GetEntryExport(). Int_t TBranch::GetEntryExport ; (; Long64_t ; entry, . Int_t ; getall, . TClonesArray * ; li, . Int_t ; nentries . ). virtual . Read all leaves of an entry and export buffers to real objects in a TClonesArray list. ; Returns total number of bytes read. ; Definition at line 1762 of file TBranch.cxx. ◆ GetEntryNumber(). Long64_t TBranch::GetEntryNumber ; (; ); const. inline . Definition at line 242 of file TBranch.h. ◆ GetEntryOffsetLen(). Int_t TBranch::GetEntryOffsetLen ; (; ); const. inline . Definition at line 227 of file TBranc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:49208,Load,LoadTree,49208,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['Load'],['LoadTree']
Performance," in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function. Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (unique) shapes. Some viewers (OpenGL only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching with considerable performance gains in these cases.; For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. The viewer indicates this through the interface method PreferLocalFrame(); TVirtualViewer3D::PreferLocalFramevirtual Bool_t PreferLocalFrame() const =0; If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of logical object, with the fLocalMaster transform and the fColor and fTransparency attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master referenc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:7761,cache,cached,7761,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['cache'],['cached']
Performance," in the directory); par can be an URL for remote retrieval. ; If rmold is kTRUE an existing version of the package is removed if existing. Returns 0 on success, <0 otherwise ; Definition at line 766 of file TPackMgr.cxx. ◆ IsA(). TClass * TPackMgr::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 106 of file TPackMgr.h. ◆ IsEnabled(). Bool_t TPackMgr::IsEnabled ; (; const char * ; pack, . TPackMgr * ; packmgr = nullptr . ). static . Check if the package is enabled; priority is given to packmgr, if defined. ; Returns kTRUE if enabled ; Definition at line 961 of file TPackMgr.cxx. ◆ IsInDir(). Bool_t TPackMgr::IsInDir ; (; const char * ; path). Method to check if 'path' is in the managed directory Return kTRUE or kFALSE. ; Definition at line 478 of file TPackMgr.cxx. ◆ IsPackageEnabled(). Bool_t TPackMgr::IsPackageEnabled ; (; const char * ; pack). inline . Definition at line 82 of file TPackMgr.h. ◆ Load() [1/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . const char * ; opts . ). Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ; Definition at line 206 of file TPackMgr.cxx. ◆ Load() [2/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . TList * ; optls = 0 . ). Method to load a package taking an option list Return -1 on error, 0 otherwise. ; Definition at line 220 of file TPackMgr.cxx. ◆ Log(). void TPackMgr::Log ; (; const char * ; msg). private . Wrapper to notofuer / logger. ; Definition at line 73 of file TPackMgr.cxx. ◆ operator=(). TPackMgr & TPackMgr::operator= ; (; const TPackMgr & ; ). private . ◆ ReadMD5(). TMD5 * TPackMgr::ReadMD5 ; (; const char * ; pack). Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ; Returns a pointer to a TMD5 object, transferring ownership to the caller ; Definition at line 708 of file TPackMgr.cxx. ◆ RegisterGlobalPath(). Int_t TPackMgr::RegisterGlobalPath ; (; const char * ; paths). s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:21176,Load,Load,21176,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['Load'],['Load']
Performance," in the merged tree. ; Reimplemented in TChain.; Definition at line 6927 of file TTree.cxx. ◆ MergeTrees(). TTree * TTree::MergeTrees ; (; TList * ; li, . Option_t * ; options = """" . ). static . Static function merging the trees in the TList into a new tree. ; Trees in the list can be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). ; Definition at line 6851 of file TTree.cxx. ◆ MoveReadCache(). void TTree::MoveReadCache ; (; TFile * ; src, . TDirectory * ; dir . ). protected . Move a cache from a file to the current file in dir. ; if src is null no operation is done, if dir is null or there is no current file the cache is deleted. ; Definition at line 6983 of file TTree.cxx. ◆ Notify(). bool TTree::Notify ; (; ). overridevirtual . Function called when loading a new class library. ; Reimplemented from TObject.; Definition at line 7033 of file TTree.cxx. ◆ operator=(). TTree & TTree::operator= ; (; const TTree & ; tt). delete . ◆ OptimizeBaskets(). void TTree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.; if option =""d"" an analysis report is printed. ; Definition at line 7057 of file TTree.cxx. ◆ Principal(). TPrincipal * TTree::Principal ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = ""np"", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). Interface to the Principal Components Analysis class. ; Create an insta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:185257,Optimiz,OptimizeBaskets,185257,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['Optimiz'],['OptimizeBaskets']
Performance," in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; 281 ; 282 // Event loop; 283 ; 284 // Prepare the event tree; 285 // - Here the variable names have to corresponds to your tree; 286 // - You can use the same variables as above which is slightly faster,; 287 // but of course you can use different ones and copy the values inside the event loop; 288 //; 289 std::cout << ""--- Select signal sample"" << std::endl;; 290 TTree* theTree = (TTree*)input->Get(""TreeS"");; 291 Float_t userVar1, userVar2;; 292 theTree->SetBranchAddress( ""var1"", &userVar1 );; 293 theTree->SetBranchAddress( ""var2"", &userVar2 );; 294 theTree->SetBranchAddress( ""var3"", &var3 );; 295 theTree->SetBranchAddress( ""var4"", &var4 );; 296 ; 297 // Efficiency calculator for cut method; 298 Int_t nSelCutsGA = 0;; 299 Double_t effS = 0.7;; 300 ; 301 std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; 302 ; 303 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 304 TStopwatch sw;; 305 sw.Start();; 306 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 307 ; 308 if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 309 ; 310 theTree->GetEntry(ievt);; 311 ; 312 var1 = userVar1 + userVar2;; 313 var2 = userVar1 - userVar2;; 314 ; 315 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:11855,CACHE,CACHEREAD,11855,doc/master/TMVAClassificationApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html,1,['CACHE'],['CACHEREAD']
Performance," in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nentries /* = -1 */, Option_t* option /* = """" */); 3141{; 3142 // Options; 3143 bool fastClone = false;; 3144 ; 3145 TString opt = option;; 3146 opt.ToLower();; 3147 if (opt.Contains(""fast"")) {; 3148 fastClone = true;; 3149 }; 3150 ; 3151 // If we are a chain, switch to the first tree.; 3152 if ((fEntries > 0) && (LoadTree(0) < 0)) {; 3153 // FIXME: We need an error message here.; 3154 return nullptr;; 3155 }; 3156 ; 3157 // Note: For a tree we get the this pointer, for; 3158 // a chain we get the chain's current tree.; 3159 TTree* thistree = GetTree();; 3160 ; 3161 // We will use this to override the IO features on the cloned branches.; 3162 ROOT::TIOFeatures features = this->GetIOFeatures();; 3163 ;; 3164 ; 3165 // Note: For a chain, the returned clone will be; 3166 // a clone of the chain's first tree.; 3167 TTree* newtree = (TTree*) thistree->Clone();; 3168 if (!newtree) {; 3169 return nullptr;; 3170 }; 3171 ; 3172 // The clone should not delete any objects allocated by SetAddress().; 3173 TObjArray* branches = newtree->GetListOfBranches();; 3174 Int_t nb = branches->GetEntriesFast();; 3175 for (Int_t i = 0; i < nb; ++i) {; 3176 TBranch* br = (TBranch*) branches->UncheckedAt(i);; 3177 if (br->InheritsFrom(TBranchElement::Class())) {; 3178 ((TBranchElement*) br)->ResetDeleteObject();; 3179 }; 3180 }; 3181 ; 31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:126246,Load,LoadTree,126246,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['LoadTree']
Performance," including dimensions, if any; Note that this function stores the name into a static array.; You should copy the result. void GetSequenceType(TString& type) const; Fill type with the string representation of sequence; information including 'cached','repeat','write' or; 'nodelete'. Int_t GetSize() const; Returns size of this element in bytes. TMemberStreamer * GetStreamer() const; Return the local streamer object. const char * GetTypeNameBasic() const; Return type name of this element; in case the type name is not a standard basic type, return; the basic type name known to CINT. void Init(TObject* obj = 0); Initliaze the element. Bool_t IsOldFormat(const char* newTypeName); The early 3.00/00 and 3.01/01 versions used to store; dm->GetTypeName instead of dm->GetFullTypename; if this case is detected, the element type name is modified. Bool_t IsBase() const; Return kTRUE if the element represent a base class. Bool_t IsTransient() const; Return kTRUE if the element represent an entity that is not written; to the disk (transient members, cache allocator/deallocator, etc.). void ls(Option_t* option = """") const; Print the content of the element. void SetArrayDim(Int_t dim); Set number of array dimensions. void SetMaxIndex(Int_t dim, Int_t max); set maximum index for array with dimension dim. void SetStreamer(TMemberStreamer* streamer); set pointer to Streamer function for this element. void Streamer(TBuffer& ); Stream an object of class TStreamerElement. void Update(const TClass* oldClass, TClass* newClass); function called by the TClass constructor when replacing an emulated class; by the real class. TStreamerElement(const TStreamerElement& ). TStreamerElement& operator=(const TStreamerElement& ). Int_t GetArrayDim() const; {return fArrayDim;}. Int_t GetArrayLength() const; {return fArrayLength;}. TClass * GetClass() const; {return GetClassPointer();}. const char * GetInclude() const; {return """";}. Int_t GetMaxIndex(Int_t i) const; {return fMaxIndex[i];}. ULong_t GetMethod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerElement.html:11109,cache,cache,11109,root/html602/TStreamerElement.html,https://root.cern,https://root.cern/root/html602/TStreamerElement.html,2,['cache'],['cache']
Performance," incremental changes to a RNTupleModel More...;  ; class  RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  RNTupleWriteOptionsManip;  ; class  ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  RPageRef;  Reference to a page stored in the page pool. More...;  ; class  RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  RPageSourceDaos;  Storage provider that reads ntuple pages from a DAOS container. More...;  ; class  RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; class  RPageSourceFriends;  Virtual storage that combines several other sources horizontally. More...;  ; class  RPageStorage;  Common functionality of an ntuple storage for both reading and writing. More...;  ; class  RProjectedFields; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:8170,cache,cache,8170,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,2,"['cache', 'load']","['cache', 'loaded']"
Performance," inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Events}"", 30, -0.5, 0.5}, ""y"");; };; ; auto sig = make_histo(""TreeS"");; auto bkg = make_histo(""TreeB"");; ; // Make plot; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; ; sig->SetLineColor(kRed);; bkg->SetLineColor(kBlue);; sig->SetLineWidth(2);; bkg->SetLineWidth(2);; bkg->Draw(""HIST"");; sig->Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""TreeS"", ""Signal"", ""l"");; legend.AddEntry(""TreeB"", ""Background"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:2942,perform,performed,2942,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,3,"['Perform', 'perform']","['Perform', 'performed', 'performs']"
Performance," information to process sub-seeds; 2411 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2412 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2413 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2414 delete sresults;; 2415 delete seedloader;; 2416 this->DeleteAllMethods();; 2417 fMethodsMap.clear();; 2418 ; 2419 // removing global result because it is requiring a lot of RAM for all seeds; 2420 ; 2421 for (uint32_t i = 0; i < VIBITS; ++i) {; 2422 if (x & (1 << i)) {; 2423 y = x & ~(uint64_t(1) << i);; 2424 std::bitset<VIBITS> ybitset(y);; 2425 // need at least one variable; 2426 // NOTE: if sub-seed is zero then is the special case; 2427 // that count in xbitset is 1; 2428 uint32_t ny = static_cast<uint32_t>(log(x - y) / 0.693147);; 2429 if (y == 0) {; 2430 importances[ny] = SROC - 0.5;; 2431 continue;; 2432 }; 2433 ; 2434 // creating loader for sub-seed; 2435 TMVA::DataLoader *subseedloader = new TMVA::DataLoader(ybitset.to_string());; 2436 // adding variables from sub-seed; 2437 for (int index = 0; index < nbits; index++) {; 2438 if (ybitset[index]); 2439 subseedloader->AddVariable(varNames[index], 'F');; 2440 }; 2441 ; 2442 // Loading Dataset; 2443 DataLoaderCopy(subseedloader, loader);; 2444 ; 2445 // Booking SubSeed; 2446 BookMethod(subseedloader, theMethod, methodTitle, theOption);; 2447 ; 2448 // Train/Test/Evaluation; 2449 TrainAllMethods();; 2450 TestAllMethods();; 2451 EvaluateAllMethods();; 2452 ; 2453 // getting ROC; 2454 SSROC = GetROCIntegral(ybitset.to_string(), methodTitle);; 2455 importances[ny] += SROC - SSROC;; 2456 ; 2457 // cleaning information; 2458 TMVA::MethodBase *ssmethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[ybitset.to_string().c_str()][0][0]);; 2459 TMVA::ResultsClassification *ssresults = (TMVA::ResultsClassification *)ssmethod->Data()->GetResults(; 2460 ssmethod->GetMethodName(), Types::kTesting,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:101336,load,loader,101336,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance," information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:9396,cache,cache,9396,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,6,['cache'],['cache']
Performance," information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(void* object, char** retText); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, char** retText); Execute the method for the specified object and argument values. void SetParamPtrs(voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodCall.html:12587,cache,cached,12587,root/html602/TMethodCall.html,https://root.cern,https://root.cern/root/html602/TMethodCall.html,2,['cache'],['cached']
Performance," inittime=0., Float_t proctime=0.);  Set processing info. ;  ; void SetRecvTime (Float_t recvtime);  ; void SetTermTime (Float_t termtime);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool fArchived;  whether the query has been archived ;  ; Long64_t fBytes;  number of bytes processed ;  ; bool fDraw;  true if draw action query ;  ; TDatime fEnd;  time when processing ended ;  ; Long64_t fEntries;  number of entries processed ;  ; bool fFinalized;  whether Terminate has been run ;  ; Long64_t fFirst;  first entry processed ;  ; Float_t fInitTime;  Initialization time (seconds) (millisec precision) ;  ; TList * fInputList;  input list; contains also data sets, entry list, ... ;  ; TString fLibList;  blank-separated list of libs loaded at fStart ;  ; TMacro * fLogFile;  file with log messages from the query ;  ; Float_t fMergeTime;  Merging time (seconds) (millisec precision) ;  ; Int_t fNumMergers;  Number of submergers. ;  ; Int_t fNumWrks;  Number of workers at start. ;  ; TString fOptions;  processing options + aclic mode (< opt >#< aclic_mode >) ;  ; TList * fOutputList;  output list ;  ; TString fParList;  colon-separated list of PAR loaded at fStart ;  ; Float_t fPrepTime;  Prepare time (seconds) (millisec precision) ;  ; Float_t fProcTime;  Processing time (seconds) (millisec precision) ;  ; Float_t fRecvTime;  Transfer-to-client time (seconds) (millisec precision) ;  ; TString fResultFile;  URL of the file where results have been archived. ;  ; TMacro * fSelecHdr;  selector header file ;  ; TMacro * fSelecImp;  selector implementation file ;  ; Int_t fSeqNum;  query unique sequential number ;  ; TDatime fStart;  time when processing started ;  ; EQueryStatus fStatus;  query status ;  ; Float_t fTermTime;  Terminate time (seconds) (millisec precision) ;  ; Float_t fUsedCP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQueryResult.html:13990,load,loaded,13990,doc/master/classTQueryResult.html,https://root.cern,https://root.cern/doc/master/classTQueryResult.html,1,['load'],['loaded']
Performance," inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 286 of file TPluginManager.h. ◆ DeclFileName(). static const char * TPluginManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 286 of file TPluginManager.h. ◆ FindHandler(). TPluginHandler * TPluginManager::FindHandler ; (; const char * ; base, . const char * ; uri = nullptr . ). Returns the handler if there exists a handler for the specified URI. ; The uri can be 0 in which case the first matching plugin handler will be returned. Returns 0 in case handler is not found. ; Definition at line 608 of file TPluginManager.cxx. ◆ IsA(). TClass * TPluginManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 286 of file TPluginManager.h. ◆ LoadHandlerMacros(). void TPluginManager::LoadHandlerMacros ; (; const char * ; path). private . Load all plugin macros from the specified path/base directory. ; Definition at line 431 of file TPluginManager.cxx. ◆ LoadHandlersFromEnv(). void TPluginManager::LoadHandlersFromEnv ; (; TEnv * ; env). Load plugin handlers specified in config file, like: ; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). ; Definition at line 391 of file TPluginManager.cxx. ◆ LoadHandlersFromPluginDirs(). void TPluginManager::LoadHandlersFromPluginDirs ; (; const char * ; base = nullptr). Load plugin handlers specified via macros in a list of plugin directories. ; The $ROOTSYS/etc/plugins is the default top plugin directory specified in $ROOTSYS/etc/system.rootrc. The macros must have names like <BaseClass>/PX0_<PluginClass>.C, e.g. //TSQLServer/P20_TMySQLServer.C, to allow easy sorting and grouping. If the BaseClass is in a namespace the directory must have the name NameSpace@Bas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginManager.html:17515,Load,Load,17515,doc/master/classTPluginManager.html,https://root.cern,https://root.cern/doc/master/classTPluginManager.html,1,['Load'],['Load']
Performance," inlinevirtual . Definition at line 242 of file TFile.h. ◆ GetBytesToPrefetch(). Int_t TFile::GetBytesToPrefetch ; (; ); const. virtual . Max number of bytes to prefetch. ; By default this is 75% of the read cache size. But specific TFile implementations may need to change it ; Reimplemented in TXNetFile.; Definition at line 5222 of file TFile.cxx. ◆ GetBytesWritten(). Long64_t TFile::GetBytesWritten ; (; ); const. virtual . Return the total number of bytes written so far to the file. ; Definition at line 4566 of file TFile.cxx. ◆ GetCacheFileDir(). const char * TFile::GetCacheFileDir ; (; ). static . Get the directory where to locally stage/cache remote files. ; Definition at line 4654 of file TFile.cxx. ◆ GetCacheRead(). TFileCacheRead * TFile::GetCacheRead ; (; const TObject * ; tree = nullptr); const. Return a pointer to the current read cache. ; Definition at line 1262 of file TFile.cxx. ◆ GetCacheWrite(). TFileCacheWrite * TFile::GetCacheWrite ; (; ); const. Return a pointer to the current write cache. ; Definition at line 1279 of file TFile.cxx. ◆ GetClassIndex(). TArrayC * TFile::GetClassIndex ; (; ); const. inline . Definition at line 226 of file TFile.h. ◆ GetCompressionAlgorithm(). Int_t TFile::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 385 of file TFile.h. ◆ GetCompressionFactor(). Float_t TFile::GetCompressionFactor ; (; ). Return the file compression factor. ; Add total number of compressed/uncompressed bytes for each key. Returns the ratio of the two. ; Definition at line 1202 of file TFile.cxx. ◆ GetCompressionLevel(). Int_t TFile::GetCompressionLevel ; (; ); const. inline . Definition at line 391 of file TFile.h. ◆ GetCompressionSettings(). Int_t TFile::GetCompressionSettings ; (; ); const. inline . Definition at line 397 of file TFile.h. ◆ GetEND(). virtual Long64_t TFile::GetEND ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 231 of file TFile.h. ◆ GetEndpointUrl() [1/2]. virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:63599,cache,cache,63599,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['cache'],['cache']
Performance," input data (events), test output data (labels). ;  ; template<typename Data_t , typename Net_t > ; auto TrainMomentum (const Data_t &trainingData, size_t nTrainingSamples, const Data_t &testData, size_t nTestSamples, Net_t &net, Scalar_t momentum, size_t nThreads) -> Scalar_t;  ; template<typename Data_t , typename Net_t > ; Scalar_t TrainMomentum (const Data_t &TrainingDataIn, size_t nTrainingSamples, const Data_t &TestDataIn, size_t nTestSamples, Net_t &net, Scalar_t momentum, size_t nThreads=1);  Same as Train(...) but uses the given momentum. ;  . Private Attributes; size_t fBatchSize;  Batch size to use for the training. ;  ; size_t fConvergenceCount;  Current number of training epochs without. ;  ; size_t fConvergenceSteps;  Number of training epochs without considerable. ;  ; Scalar_t fLearningRate;  Learning rate \(\alpha\). ;  ; Scalar_t fMinimumError;  The minimum loss achieved on the training set during the current training session. ;  ; size_t fStepCount;  Number of steps performed in the current training session. ;  ; Scalar_t fTestError;  Holds the most recently computed test loss. ;  ; size_t fTestInterval;  Interval for the computation of the test error. ;  ; Scalar_t fTrainingError;  Holds the most recently computed training loss. ;  . #include <TMVA/DNN/Minimizers.h>; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t > . using TMVA::DNN::TGradientDescent< Architecture_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 59 of file Minimizers.h. ◆ Scalar_t. template<typename Architecture_t > . using TMVA::DNN::TGradientDescent< Architecture_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 58 of file Minimizers.h. Constructor & Destructor Documentation. ◆ TGradientDescent() [1/2]. template<typename Architecture_t > . TMVA::DNN::TGradientDescent< Architecture_t >::TGradientDescent. Definition at line 175 of file Minimizers.h. ◆ TGradientDescent() [2/2]. template<typename Architecture_t > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:4835,perform,performed,4835,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,1,['perform'],['performed']
Performance," input; 3180 // to check for the presence of the TTree inside. But at this moment the; 3181 // filename we are using here corresponds to a file which does not exist yet,; 3182 // i.e. the output file of the Snapshot call. Thus, checkFile=false will; 3183 // prevent the function from trying to open a non-existent file.; 3184 auto newRDF = std::make_shared<RInterface<RLoopManager>>(ROOT::Detail::RDF::CreateLMFromTTree(; 3185 fullTreeName, filename, /*defaultColumns=*/columnListWithoutSizeColumns, /*checkFile=*/false));; 3186 ; 3187 // The Snapshot helper will use validCols (with aliases resolved) as input columns, and; 3188 // columnListWithoutSizeColumns (still with aliases in it, passed through snapHelperArgs) as output column names.; 3189 auto resPtr = CreateAction<RDFInternal::ActionTags::Snapshot, ColumnTypes...>(validCols, newRDF, snapHelperArgs,; 3190 fProxiedPtr);; 3191 ; 3192 if (!options.fLazy); 3193 *resPtr;; 3194 return resPtr;; 3195 }; 3196 ; 3197 ////////////////////////////////////////////////////////////////////////////; 3198 /// \brief Implementation of cache.; 3199 template <typename... ColTypes, std::size_t... S>; 3200 RInterface<RLoopManager> CacheImpl(const ColumnNames_t &columnList, std::index_sequence<S...>); 3201 {; 3202 const auto columnListWithoutSizeColumns = RDFInternal::FilterArraySizeColNames(columnList, ""Snapshot"");; 3203 ; 3204 // Check at compile time that the columns types are copy constructible; 3205 constexpr bool areCopyConstructible =; 3206 RDFInternal::TEvalAnd<std::is_copy_constructible<ColTypes>::value...>::value;; 3207 static_assert(areCopyConstructible, ""Columns of a type which is not copy constructible cannot be cached yet."");; 3208 ; 3209 RDFInternal::CheckTypesAndPars(sizeof...(ColTypes), columnListWithoutSizeColumns.size());; 3210 ; 3211 auto colHolders = std::make_tuple(Take<ColTypes>(columnListWithoutSizeColumns[S])...);; 3212 auto ds = std::make_unique<RLazyDS<ColTypes...>>(; 3213 std::make_pair(columnListWithoutSizeCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:182063,cache,cache,182063,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cache']
Performance," instead only for Minuit (and Minuit2).; The class supports also setting global default values for the options, by using the static functions MinimizerOptions::SetDefault... (for example MinimizerOptions::SetDefaultPrintLevel(int )). The static functions can be also used to set the minimizer options when using TH1::Fit or TGraph::Fit. The list of the current option values can be inspected by using MinimizerOptions::Print.; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; In addition it is possible to provide extra options which might apply for a particular minimizer MinimizerOptions::SetExtraOptions(const IOptions & ). See the documentation of the particular minimizer to use for the list of possible additional options available.; 5.7.5 Performing the Fit; Here we have now all the required input ingredients for the fit, the data and the function to fit. Depending on these we have now several different way to perform the fit, using the corresponding methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit:::PoissonLikelihoodFCN.; Un-Binned likelihood fit: Fitter::LikelihoodFit(const UnBindata &). The user needs to pass an UnBinData object. By default th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:206622,perform,perform,206622,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance," int > _gcIndex;  Index value corresponding to component. ;  ; std::vector< std::unique_ptr< RooAbsGenContext > > _gcList;  List of component generator contexts. ;  ; bool _haveIdxProto {false};  Flag set if generation of index is requested. ;  ; RooAbsCategoryLValue * _idxCat {nullptr};  Clone of index category. ;  ; TString _idxCatName {};  Name of index category. ;  ; std::unique_ptr< RooArgSet > _idxCatSet;  Owner of index category components. ;  ; Int_t _numPdf {0};  Number of generated PDFs. ;  ; const RooSimultaneous * _pdf {nullptr};  Original PDF. ;  ; std::unique_ptr< RooDataSet > _protoData;  ! Prototype dataset ;  ; const RooDataSet * _prototype {nullptr};  Prototype data set. ;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimGenContext.html:16280,load,load,16280,doc/master/classRooSimGenContext.html,https://root.cern,https://root.cern/doc/master/classRooSimGenContext.html,1,['load'],['load']
Performance," int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:42287,load,loaded,42287,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['load'],['loaded']
Performance," int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:41523,load,loaded,41523,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['load'],['loaded']
Performance," int l1, int m1, int l2, int m2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:24055,cache,cache,24055,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,4,['cache'],['cache']
Performance," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26239,cache,cacheParams,26239,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,7,['cache'],"['cacheParams', 'cachedIntegral']"
Performance," integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; virtual void printTree (std::ostream &os, TString indent="""") const;  Interface for tree structure printing of object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooDirItem;  RooDirItem ();  ;  RooDirItem (const RooDirItem &);  ; virtual ~RooDirItem ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooFitResult * lastMinuitFit (const RooArgList &varList=RooArgList());  Import the results of the last fit performed by gMinuit, interpreting the fit parameters as the given varList of parameters. ;  ; static RooFitResult * prefitResult (const RooArgList &paramList);  Import the results of the last fit performed by gMinuit, interpreting the fit parameters as the given varList of parameters. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:16463,perform,performed,16463,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['perform'],['performed']
Performance," integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFunctor1DPdfBinding.html:39158,cache,cache,39158,root/html526/RooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/root/html526/RooFunctor1DPdfBinding.html,2,['cache'],['cache']
Performance," integral. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return the expected number of events associated with the extendable input PDF in the product. ;  ; ExtendMode extendMode () const override;  If this product contains exactly one extendable p.d.f return the extension abilities of that p.d.f, otherwise return CanNotBeExtended. ;  ; RooArgSet * findPdfNSet (RooAbsPdf const &pdf) const;  Look up user specified normalization set for given input PDF component. ;  ; void fixRefRange (const char *rangeName);  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all observables for internal integration. ;  ; void generateEvent (Int_t code) override;  Generate a single event with configuration specified by 'code' Defer internal generation to components as encoded in the _genCode registry for given generator code. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Determine which part (if any) of given integral can be performed analytically. ;  ; RooArgSet * getConnectedParameters (const RooArgSet &observables) const;  Return all parameter constraint p.d.f.s on parameters listed in constrainedParams. ;  ; RooArgSet * getConstraints (const RooArgSet &observables, RooArgSet const &constrainedParams, RooArgSet &pdfParams) const override;  Return all parameter constraint p.d.f.s on parameters listed in constrainedParams. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Query internal generation capabilities of component p.d.f.s and aggregate capabilities into master configuration passed to the generator context. ;  ; void initGenerator (Int_t code) override;  Forward one-time initialization call to component generation initialization methods. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:5120,perform,performed,5120,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['perform'],['performed']
Performance," into an eve-window ;  CTEveWindowManagerManager for EVE windows ;  CTEveWindowPackEncapsulates TGPack into an eve-window ;  CTEveWindowSlotDescription of TEveWindowSlot ;  CTEveWindowTabEncapsulates TGTab into an eve-window ;  CTExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad ;  ►CTExMapThis class stores a (key,value) pair using an external hash ;  CAssoc_t;  CTExMapIter;  CTF11-Dim function class ;  CTF12A projection of a TF2 along X or Y ;  CTF1ConvolutionClass wrapping convolution of two functions ;  CTF1Editor;  CTF1NormSumClass adding two functions: c1*f1+c2*f2 ;  CTF1ParametersTF1 Parameters class ;  CTF2A 2-Dim function with parameters ;  CTF2GLGL renderer for TF2 ;  CTF3A 3-Dim function with parameters ;  CTFastCgi;  CTFeldmanCousins;  CTFFTComplex;  CTFFTComplexReal;  CTFFTReal;  CTFFTRealComplex;  CTFileA ROOT file is a suite of consecutive data records (TKey instances) with a well defined format ;  CTFileCacheReadA cache when reading files over the network ;  CTFileCacheWriteA cache when writing files over the network ;  CTFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries ;  CTFileDrawMapThis class is automatically called by TFile::DrawMap ;  CTFileHandler;  CTFileInfoClass describing a generic file including meta information ;  CTFileInfoMeta;  CTFileIter;  CTFileMergeInfo;  CTFileMergerThis class provides file copy and merging services ;  CTFileOpenHandleClass holding info about the file being opened ;  CTFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries ;  CTFileSet;  CTFileStager;  ►CTFitEditor;  CFuncParamData_tTF1Convolution object ;  CTFitParametersDialog;  CTFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O ;  CTFitResultPtrProvides an indirection to the TFitResult class and with a semantics iden",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:112305,cache,cache,112305,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['cache'],['cache']
Performance," int ; lvl = 3). inline . Configures maximal visible level. ; Definition at line 79 of file RGeomViewer.hxx. ◆ Show(). void RGeomViewer::Show ; (; const RWebDisplayArgs & ; args = """", . bool ; always_start_new_browser = false . ). Show or update geometry in web window If web browser already started - just refresh drawing like ""reload"" button does If no web window exists or. ; Parameters. always_start_new_browserconfigured, starts new window ; argsarguments to display . Definition at line 109 of file RGeomViewer.cxx. ◆ Update(). void RGeomViewer::Update ; (; ). Update geometry drawings in all web displays. ; Definition at line 150 of file RGeomViewer.cxx. ◆ WebWindowCallback(). void RGeomViewer::WebWindowCallback ; (; unsigned ; connid, . const std::string & ; arg . ). protected . Process data from client. ; Definition at line 260 of file RGeomViewer.cxx. ◆ WebWindowDisconnect(). void RGeomViewer::WebWindowDisconnect ; (; unsigned ; connid). protected . Process disconnect event Clear cache data and dependent connections. ; Definition at line 353 of file RGeomViewer.cxx. Member Data Documentation. ◆ fDesc. RGeomDescription ROOT::RGeomViewer::fDesc. protected . ! geometry description, send to the client as first message ; Definition at line 33 of file RGeomViewer.hxx. ◆ fGeoManager. TGeoManager* ROOT::RGeomViewer::fGeoManager {nullptr}. protected . ! geometry to show ; Definition at line 31 of file RGeomViewer.hxx. ◆ fInfoActive. bool ROOT::RGeomViewer::fInfoActive {false}. protected . ! true when info page active and node info need to be provided ; Definition at line 37 of file RGeomViewer.hxx. ◆ fSelectedVolume. std::string ROOT::RGeomViewer::fSelectedVolume. protected . ! name of selected volume ; Definition at line 32 of file RGeomViewer.hxx. ◆ fShowColumns. bool ROOT::RGeomViewer::fShowColumns {true}. protected . ! show columns in hierarchy ; Definition at line 35 of file RGeomViewer.hxx. ◆ fShowHierarchy. bool ROOT::RGeomViewer::fShowHierarchy {true}. protected . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomViewer.html:10083,cache,cache,10083,doc/v632/classROOT_1_1RGeomViewer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomViewer.html,1,['cache'],['cache']
Performance," int ; lvl = 3). inline . Configures maximal visible level. ; Definition at line 79 of file RGeomViewer.hxx. ◆ Show(). void RGeomViewer::Show ; (; const RWebDisplayArgs & ; args = """", . bool ; always_start_new_browser = false . ). Show or update geometry in web window If web browser already started - just refresh drawing like ""reload"" button does If no web window exists or. ; Parameters. always_start_new_browserconfigured, starts new window ; argsarguments to display . Definition at line 117 of file RGeomViewer.cxx. ◆ Update(). void RGeomViewer::Update ; (; ). Update geometry drawings in all web displays. ; Definition at line 158 of file RGeomViewer.cxx. ◆ WebWindowCallback(). void RGeomViewer::WebWindowCallback ; (; unsigned ; connid, . const std::string & ; arg . ). protected . Process data from client. ; Definition at line 268 of file RGeomViewer.cxx. ◆ WebWindowDisconnect(). void RGeomViewer::WebWindowDisconnect ; (; unsigned ; connid). protected . Process disconnect event Clear cache data and dependent connections. ; Definition at line 361 of file RGeomViewer.cxx. Member Data Documentation. ◆ fDesc. RGeomDescription ROOT::RGeomViewer::fDesc. protected . ! geometry description, send to the client as first message ; Definition at line 33 of file RGeomViewer.hxx. ◆ fGeoManager. TGeoManager* ROOT::RGeomViewer::fGeoManager {nullptr}. protected . ! geometry to show ; Definition at line 31 of file RGeomViewer.hxx. ◆ fInfoActive. bool ROOT::RGeomViewer::fInfoActive {false}. protected . ! true when info page active and node info need to be provided ; Definition at line 37 of file RGeomViewer.hxx. ◆ fSelectedVolume. std::string ROOT::RGeomViewer::fSelectedVolume. protected . ! name of selected volume ; Definition at line 32 of file RGeomViewer.hxx. ◆ fShowColumns. bool ROOT::RGeomViewer::fShowColumns {true}. protected . ! show columns in hierarchy ; Definition at line 35 of file RGeomViewer.hxx. ◆ fShowHierarchy. bool ROOT::RGeomViewer::fShowHierarchy {true}. protected . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RGeomViewer.html:10130,cache,cache,10130,doc/master/classROOT_1_1RGeomViewer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RGeomViewer.html,1,['cache'],['cache']
Performance," int Order () const;  Order of Polynomial. ;  ;  Public Member Functions inherited from ROOT::Math::ParamFunction< IParamGradFunction >;  ParamFunction (unsigned int npar=0);  Construct a parameteric function with npar parameters. ;  ; virtual ~ParamFunction ();  ; unsigned int NPar () const;  Return the number of parameters. ;  ; virtual const double * Parameters () const;  Access the parameter values. ;  ; virtual void SetParameters (const double *p);  Set the parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionOneDim;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; virtual void ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html:3897,cache,cached,3897,doc/master/classROOT_1_1Math_1_1Polynomial.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html,1,['cache'],['cached']
Performance," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:23158,cache,cache,23158,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,6,['cache'],['cache']
Performance," is != 0, the full path to the file is returned in *fullpath, which must be deleted by the caller. ; Definition at line 966 of file TSystem.cxx. ◆ IsPathLocal(). Bool_t TSystem::IsPathLocal ; (; const char * ; path). virtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented in TDavixSystem, TUnixSystem, TWinNTSystem, and TNetXNGSystem.; Definition at line 1305 of file TSystem.cxx. ◆ Link(). int TSystem::Link ; (; const char * ; from, . const char * ; to . ). virtual . Create a link from file1 to file2. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1359 of file TSystem.cxx. ◆ ListLibraries(). void TSystem::ListLibraries ; (; const char * ; regexp = """"). virtual . List the loaded shared libraries. ; regexp is a regular expression allowing to filter the list.; Examples:; The following line lists all the libraries currently loaded: gSystem->ListLibraries(); TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; The following line lists all the libraries currently loaded having ""RIO"" in their names: gSystem->ListLibraries("".*RIO.*""). Reimplemented in TUnixSystem.; Definition at line 2085 of file TSystem.cxx. ◆ ListSymbols(). void TSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). virtual . List symbols in a shared library. ; Reimplemented in TUnixSystem.; Definition at line 2064 of file TSystem.cxx. ◆ Load(). int TSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). virtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded, -1 in case lib does not exist or in case of error and -2 in case of version mismatch. When entry is specified the loaded lib is searched for this entry point (return -1 when entry does not exist, 0 otherwise). When the system f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:72362,load,loaded,72362,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,['load'],['loaded']
Performance," is actually saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory *motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBasket.html:9513,Load,LoadBasketBuffers,9513,root/html526/TBasket.html,https://root.cern,https://root.cern/root/html526/TBasket.html,2,['Load'],"['Load', 'LoadBasketBuffers']"
Performance," is actually saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBasket.html:9730,Load,LoadBasketBuffers,9730,root/html528/TBasket.html,https://root.cern,https://root.cern/root/html528/TBasket.html,2,['Load'],"['Load', 'LoadBasketBuffers']"
Performance," is actually saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBasket.html:10004,Load,LoadBasketBuffers,10004,root/html530/TBasket.html,https://root.cern,https://root.cern/root/html530/TBasket.html,2,['Load'],"['Load', 'LoadBasketBuffers']"
Performance," is actually saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBasket.html:10004,Load,LoadBasketBuffers,10004,root/html532/TBasket.html,https://root.cern,https://root.cern/root/html532/TBasket.html,2,['Load'],"['Load', 'LoadBasketBuffers']"
Performance," is defined for a given dataset.; 585 ; 586Bool_t TMVA::Factory::HasMethod(const TString &datasetname, const TString &methodTitle) const; 587{; 588 if (fMethodsMap.find(datasetname) == fMethodsMap.end()); 589 return 0;; 590 ; 591 std::string methodName = methodTitle.Data();; 592 auto isEqualToMethodName = [&methodName](TMVA::IMethod *m) { return (0 == methodName.compare(m->GetName())); };; 593 ; 594 TMVA::Factory::MVector *methods = this->fMethodsMap.at(datasetname);; 595 Bool_t isMethodNameExisting = std::any_of(methods->begin(), methods->end(), isEqualToMethodName);; 596 ; 597 return isMethodNameExisting;; 598}; 599 ; 600////////////////////////////////////////////////////////////////////////////////; 601 ; 602void TMVA::Factory::WriteDataInformation(DataSetInfo &fDataSetInfo); 603{; 604 RootBaseDir()->cd();; 605 ; 606 if (!RootBaseDir()->GetDirectory(fDataSetInfo.GetName())); 607 RootBaseDir()->mkdir(fDataSetInfo.GetName());; 608 else; 609 return; // loader is now in the output file, we dont need to save again; 610 ; 611 RootBaseDir()->cd(fDataSetInfo.GetName());; 612 fDataSetInfo.GetDataSet(); // builds dataset (including calculation of correlation matrix); 613 ; 614 // correlation matrix of the default DS; 615 const TMatrixD *m(0);; 616 const TH2 *h(0);; 617 ; 618 if (fAnalysisType == Types::kMulticlass) {; 619 for (UInt_t cls = 0; cls < fDataSetInfo.GetNClasses(); cls++) {; 620 m = fDataSetInfo.CorrelationMatrix(fDataSetInfo.GetClassInfo(cls)->GetName());; 621 h = fDataSetInfo.CreateCorrelationMatrixHist(; 622 m, TString(""CorrelationMatrix"") + fDataSetInfo.GetClassInfo(cls)->GetName(),; 623 TString(""Correlation Matrix ("") + fDataSetInfo.GetClassInfo(cls)->GetName() + TString("")""));; 624 if (h != 0) {; 625 h->Write();; 626 delete h;; 627 }; 628 }; 629 } else {; 630 m = fDataSetInfo.CorrelationMatrix(""Signal"");; 631 h = fDataSetInfo.CreateCorrelationMatrixHist(m, ""CorrelationMatrixS"", ""Correlation Matrix (signal)"");; 632 if (h != 0) {; 633 h->Write();; 634 delete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:24599,load,loader,24599,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance," is extend. If one of the input p.d.f.s is a RooAddPdf, it is configured so that the interpretation; range of the fraction coefficients is kept at the nominal convolutions observable range (instead of interpreting coefficients; in the widened range including the buffer). void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. void calcParams(); (Re)calculate effective parameters of this p.d.f. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); calcParams() ;. RooFFTConvPdf(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooFFTConvPdf(*this,newname); }. void setShift(Double_t val1, Double_t val2); { _shift1 = val1 ; _shift2 = val2 ; }. void setCacheObservables(const RooArgSet& obs); { _cacheObs.removeAll() ; _cacheObs.add(obs) ; }. const RooArgSet& cacheObservables() const; { return _cacheObs ; }. Double_t bufferFraction() const; Return value of buffer fraction applied in FFT calculation array beyond either; end of the observable domain to reduce cyclical effects. BufStrat bufferStrategy() const; Return the strategy currently used to fill the buffer:; 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range; 'Flat' means that the buffer is filled with the p.d.f. value at the boundary of the observable range; 'Mirror' means that the buffer is filled with a mirror image of the p.d.f. around the convolution observable boundary. Int_t getMaxVal(const RooArgSet& vars) const; Propagate maximum value estimate of pdf1 as convolution can only result in lower max values. { return _pdf1.arg().getMaxVal(vars) ; }. Double_t maxVal(Int_t code) const; { return _pdf1.arg().maxVal(code) ; }. Double_t evaluate() const; { RooArgSet dummy(_x.arg()) ; return getVal(&dummy) ; }. PdfCacheElem* createCache(const RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFFTConvPdf.html:52171,cache,cacheObservables,52171,root/html528/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html528/RooFFTConvPdf.html,6,['cache'],['cacheObservables']
Performance," is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Private Member Functions; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void initialize ();  . Private Attributes; std::unique_ptr< RooProdPdf::CacheElem > _cache;  ; RooArgSet _normSet;  ; std::unique_ptr< RooProdPdf > _prodPdf;  ; RooSetProxy _servers;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:56116,Cache,CacheMode,56116,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['Cache'],['CacheMode']
Performance," is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:6714,cache,cache,6714,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,['cache'],['cache']
Performance," is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:24233,cache,cache,24233,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,4,['cache'],['cache']
Performance," is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:23218,cache,cache,23218,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['cache'],['cache']
Performance," is merged with RooMCStudy::fitParDataSet() by RooMCStudy. ;  ; bool initializeInstance () override;  Initialize module after attachment to RooMCStudy object. ;  ; bool initializeRun (Int_t) override;  Initialize module at beginning of RooCMStudy run. ;  ; TClass * IsA () const override;  ; bool processBetweenGenAndFit (Int_t) override;  Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsMCStudyModule;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy constructor. ;  ; bool doInitializeInstance (RooMCStudy &);  Initializer method called upon attachment to given RooMCStudy object. ;  ; virtual bool processAfterFit (Int_t);  Method called after fit has been performed. ;  ; virtual bool processBeforeGen (Int_t);  Method called after resetting of generator parameters to initial values and before call to generator context Any modifications to generator parameters will affect next generation operation (only) ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html:1899,perform,performed,1899,doc/master/classRooStats_1_1UpperLimitMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html,1,['perform'],['performed']
Performance," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:1853,perform,perform,1853,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,12,['perform'],['perform']
Performance," is necessary for those classes that need a customized Streamer method. #pragma link C++ class SClass-; // no streamer. ! : tells rootcling not to generate the operator>>(TBuffer &b,MyClass *&obj) method for this class. This is necessary to be able to write pointers to objects of classes not inheriting from TObject. #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator. + : in ROOT version 1 and 2 tells rootcling to generate a Streamer with extra byte count information. This adds an integer to each object in the output buffer, but it allows for powerful error correction in case a Streamer method is out of sync with data in the file. The + option is mutual exclusive with both the - and ! options. IMPORTANT NOTE: In ROOT Version 3 and later, a “+” after the class name tells rootcling to use the new I/O system. The byte count check is always added. The new I/O system has many advantages including support automatic schema evolution, full support for STL collections and better run-time performance. We strongly recommend using it.; #pragma link C++ class SClass+; // add byte count; For information on Streamers see “Input/Output”. To get help on rootcling type on the UNIX command line: rootcling -h; 15.5.1.1 The Order Matters; When using template classes, the order of the pragma statements matters. For example, here is a template class Tmpl and a normal class Norm, which holds a specialized instance of a Tmpl:; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; Then in Linkdef.h, the pragma statements must be ordered by listing all specializations before any classes that need them:; // Correct Linkdef.h ordering; ...; #pragma link C++ class Tmpl<int>;; #pragma link C++ class Norm;; ...; And not vice versa:; // Bad Linkdef.h ordering; ...; #pragma link C++ class Norm;; #pragma link C++ class Tmpl<int>;; ...; In this case, rootcling generates Norm::Streamer() that makes reference to Tmpl<int>::St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:825802,perform,performance,825802,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," is now fixed. See http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18883; Improve the square-root drawing in case it is small.; Better adjustment of the tilde accent position in case of Cocoa backend. TMathText. \mu is now working for Postscript output.; \splitline is now implemented. Cocoa backend. Line width and line style were not applied on boxes. 3D Graphics Libraries; GL Viewer. New option “Rotate scene” in the “Extras” tab of the GL Viewer. It allows to do a real rotation instead of a wobbling when the “Auto Rotator” is launched.; New methods from Jeremi Niedziela jeremi.niedziela at cern dot ch to return the image in memory. Tutorials. New tutorial textviewostream.C showing how to use the TGTextViewostream widget. Build, Configuration and Testing Infrastructure. Backport Python3 compatibility of build scripts. New functionalities. Support ARM 64 bits architecture.; Partial support for PPC 64 bits Little Endian architecture.; Add “Optimized” CMAKE_BUILD_TYPE: allow highest level of optimisation of the GCC and Clang compilers (-Ofast).; Support ccache activation with cmake configuration switch.; Support link to jemalloc and tcmalloc allocators.; Careful suppression of known and understood warnings, e.g. coming from external packages. Patch Releases; Release 6.04/02; Platform Support. Added support for Intel icc 15. Build System. Define ROOT_XXX_FLAGS in ROOTConfig.cmake for use by client packages ROOT-7401; Enabled c++14 in CLING when compiling ROOT with c++14 enabled (CMake: -Dcxx14=ON, classic: –enable-cxx14). Dictionary Generation. Uniform style of warnings, use standard ROOT logging facilities rather than cout/cerr.; Do not add as autoparse keys stl classes, stl (nested) containers templated with plain old data or integers. Core. Fixed support for dictionary for class with inlined namespace.; Do not treat Mac OSX’s “cl_kernels” dylinker entry as a library ROOT-7436. TDirectory::TContext. Fixed a thread safety issue in TMVA by updating TDirectory::TContext.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:24989,Optimiz,Optimized,24989,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['Optimiz'],['Optimized']
Performance," is numeric and not requires quotes when writing ; Definition at line 729 of file TSQLStructure.cxx. ◆ LocateElementColumn(). Int_t TSQLStructure::LocateElementColumn ; (; TSQLFile * ; f, . TBufferSQL2 * ; buf, . TSQLObjectData * ; data . ). find column in TSQLObjectData object, which correspond to current element ; Definition at line 2107 of file TSQLStructure.cxx. ◆ MakeArrayIndex(). TString TSQLStructure::MakeArrayIndex ; (; TStreamerElement * ; elem, . Int_t ; n . ). static . produce string with complete index like [1][2][0] ; Definition at line 1493 of file TSQLStructure.cxx. ◆ NumChilds(). Int_t TSQLStructure::NumChilds ; (; ); const. number of child structures ; Definition at line 345 of file TSQLStructure.cxx. ◆ PerformConversion(). void TSQLStructure::PerformConversion ; (; TSqlRegistry * ; reg, . TSqlRawBuffer * ; blobs, . const char * ; topname, . Bool_t ; useblob = kFALSE . ). protected . perform conversion of structure to sql statements first tries convert it to normal form if fails, produces data for raw table ; Definition at line 1216 of file TSQLStructure.cxx. ◆ Print(). void TSQLStructure::Print ; (; Option_t * ; option = """"); const. overridevirtual . print content of complete structure ; Reimplemented from TObject.; Definition at line 667 of file TSQLStructure.cxx. ◆ PrintLevel(). void TSQLStructure::PrintLevel ; (; Int_t ; level); const. print content of current structure ; Definition at line 675 of file TSQLStructure.cxx. ◆ RecognizeTString(). Bool_t TSQLStructure::RecognizeTString ; (; const char *& ; value). protected . prove that structure contains TString data ; Definition at line 1870 of file TSQLStructure.cxx. ◆ SetArray(). void TSQLStructure::SetArray ; (; Int_t ; sz = -1). Set structure as array element. ; Definition at line 478 of file TSQLStructure.cxx. ◆ SetArrayIndex(). void TSQLStructure::SetArrayIndex ; (; Int_t ; indx, . Int_t ; cnt = 1 . ). set array index for this structure ; Definition at line 458 of file TSQLStructure.cxx. ◆ Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLStructure.html:26563,perform,perform,26563,doc/master/classTSQLStructure.html,https://root.cern,https://root.cern/doc/master/classTSQLStructure.html,1,['perform'],['perform']
Performance," is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:. ""GLISO"" : TH3 is drawn using iso-surfaces. TH3 as color boxes - (TGLVoxelPainter); The supported option is:. ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes. See $ROOTSYS/tutorials/gl/glvox1.C. TF3 (implicit function) - (TGLTF3Painter); The supported option is:. ""GLTF3"" : Draw a TF3. Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and visualize the surface. Interaction with the plots; General information.; All the interactions are implemented via standard methods DistancetoPrimitive and ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad occupied by gl-produced picture). If the mouse cursor is not above gl-picture, the standard pad interaction is performed.; Selectable parts.; Different parts of the plot can be selected:. xoz, yoz, xoy back planes: When such a plane selected, it's highlighted in green if the dynamic slicing by this plane is supported, and it's highlighted in red, if the dynamic slicing is not supported. -*The plot itself*: On surfaces, the selected surface is outlined in red. (TF3 and ISO are not outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:. When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:. Mouse wheel or ‘'j’,'J','k','K'` keys.; Panning.; The selected plot can be moved in a pad's area by pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLHistPainter.html:2996,perform,performed,2996,doc/master/classTGLHistPainter.html,https://root.cern,https://root.cern/doc/master/classTGLHistPainter.html,1,['perform'],['performed']
Performance," is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 47 of file RooMomentMorph.h. ◆ setMode(). void RooMomentMorph::setMode ; (; const Setting & ; setting). inline . Definition at line 43 of file RooMomentMorph.h. ◆ Streamer(). void RooMomentMorph::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooMomentMorph::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 98 of file RooMomentMorph.h. ◆ sumPdf(). RooAbsPdf * RooMomentMorph::sumPdf ; (; const RooArgSet * ; nset). Definition at line 330 of file RooMomentMorph.cxx. ◆ useHorizontalMorphing(). void RooMomentMorph::useHorizontalMorphing ; (; bool ; val). inline . Definition at line 45 of file RooMomentMorph.h. Friends And Related Symbol Documentation. ◆ CacheElem. friend class CacheElem. friend . Current normalization set. ; Definition at line 76 of file RooMomentMorph.h. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooMomentMorph::_cacheMgr. mutableprotected . Definition at line 73 of file RooMomentMorph.h. ◆ _curNormSet. RooArgSet* RooMomentMorph::_curNormSet = nullptr. mutableprotected . The cache manager. ; Definition at line 74 of file RooMomentMorph.h. ◆ _M. TMatrixD* RooMomentMorph::_M = nullptr. mutableprotected . Definition at line 92 of file RooMomentMorph.h. ◆ _mref. TVectorD* RooMomentMorph::_mref = nullptr. mutableprotected . Definition at line 90 of file RooMomentMorph.h. ◆ _pdfList. RooListProxy RooMomentMorph::_pdfList. protected . Definition at line 89 of file RooMomentMorph.h. ◆ _setting. Setting RooMomentMorph::_setting. protected . Definition at line 94 of file RooMomentMorph.h. ◆ _useHorizMorph. bool RooMomentMorph::_useHorizMorph = true. protected . Definition at line 96 of file RooMomentMorph.h. ◆ _var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorph.html:79204,Cache,CacheElem,79204,doc/master/classRooMomentMorph.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorph.html,1,['Cache'],['CacheElem']
Performance," is set, the automatically generated Streamer can call directly TClass::WriteBuffer. ; Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However there is a drawback: When a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfo of the class in the array being optimized, one cannot use later the TClonesArray with split>0. For example, there is a problem with the following scenario:; A class Foo has a TClonesArray of Bar objects; The Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance.; In a new program, T1 is read and a new Tree T2 is created with the object Foo in split>1; When the T2 branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfo had been generated in optimized mode or not. . Definition at line 321 of file TClonesArray.cxx. ◆ CanBypassStreamer(). Bool_t TClonesArray::CanBypassStreamer ; (; ); const. inline . Definition at line 64 of file TClonesArray.h. ◆ Class(). static TClass * TClonesArray::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TClonesArray::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TClonesArray::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 83 of file TClonesArray.h. ◆ Clear(). void TClonesArray::Clea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:32048,optimiz,optimized,32048,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['optimiz'],['optimized']
Performance," is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. If recurseInNewSet is true, the recursion algorithm also recursion into; expression trees under the arguments in the new servers (i.e. those in newset). void registerProxy(RooArgProxy& proxy); Register an RooArgProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:26471,cache,cached,26471,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,7,['cache'],['cached']
Performance," is to be called many times, it is more efficient to divide the histogram into a large number cells. However, if the histogram is to be filled only a few times, it is better to divide into a small number of cells. ; Definition at line 66 of file TH2Poly.h. Public Member Functions;  TH2Poly ();  Default Constructor. No boundaries specified. ;  ;  TH2Poly (const char *name, const char *title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup);  Constructor with specified name and boundaries, but no partition cell number. ;  ;  TH2Poly (const char *name, const char *title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup);  Constructor with specified name and boundaries and partition cell number. ;  ;  TH2Poly (const TH2Poly &rhs);  Copy constructor. ;  ;  ~TH2Poly () override;  Destructor. ;  ; Bool_t Add (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1) override;  NOT IMPLEMENTED for TH2Poly. ;  ; Bool_t Add (const TH1 *h1, Double_t c1) override;  Performs the operation: this = this + c1*h1. ;  ; Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""") override;  NOT IMPLEMENTED for TH2Poly. ;  ; Int_t AddBin (Double_t x1, Double_t y1, Double_t x2, Double_t y2);  Add a new bin to the histogram. ;  ; Int_t AddBin (Int_t n, const Double_t *x, const Double_t *y);  Adds a new bin to the histogram. ;  ; virtual Int_t AddBin (TObject *poly);  Adds a new bin to the histogram. ;  ; void ChangePartition (Int_t n, Int_t m);  Changes the number of partition cells in the histogram. ;  ; void ClearBinContents ();  Clears the contents of all bins in the histogram. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; Double_t ComputeIntegral (Bool_t) override;  NOT IMPLEMENTED for TH2Poly. ;  ; void Copy (TObject &newth2p) const override;  Copy function for TH2Poly. ;  ; virtual TH2PolyBin * CreateBin (TObject *poly);  Create appropriate histogram bin. ;  ; Bool_t Divide (TF1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:6877,Perform,Performs,6877,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['Perform'],['Performs']
Performance," is too dark to be easily distinguished from black. ; Definition at line 1678 of file TGHtml.cxx. ◆ IsLightColor(). int TGHtml::IsLightColor ; (; ColorStruct_t * ; p). protected . Check to see if the given color is too light to be easily distinguished from white. ; Definition at line 1725 of file TGHtml.cxx. ◆ IsVisited(). virtual int TGHtml::IsVisited ; (; const char * ; ). inlinevirtual . Definition at line 924 of file TGHtml.h. ◆ ItemLayout(). Bool_t TGHtml::ItemLayout ; (; ). overridevirtual . Layout html widget. ; Reimplemented from TGView.; Definition at line 834 of file TGHtml.cxx. ◆ LayoutDoc(). void TGHtml::LayoutDoc ; (; ). protected . Advance the layout as far as possible. ; Definition at line 1178 of file TGHtmlLayout.cxx. ◆ ListTokens(). TGString * TGHtml::ListTokens ; (; TGHtmlElement * ; p, . TGHtmlElement * ; pEnd . ). Return all tokens between the two elements as a string list. ; Definition at line 1454 of file TGHtmlParse.cxx. ◆ LoadImage(). TImage * TGHtml::LoadImage ; (; const char * ; url, . int ; w = 0, . int ; h = 0 . ). virtual . This is the default LoadImage() procedure. ; It just tries to load the image from a file in the local filesystem. ; Definition at line 292 of file TGHtmlImage.cxx. ◆ LostSelection(). void TGHtml::LostSelection ; (; ). protected . Clear selection. ; Definition at line 2027 of file TGHtml.cxx. ◆ MakeInvisible(). void TGHtml::MakeInvisible ; (; TGHtmlElement * ; p_first, . TGHtmlElement * ; p_last . ). protected . Add the STY_Invisible style to every token between p_first and p_last. ; Definition at line 144 of file TGHtmlSizer.cxx. ◆ MakeMarkupEntry(). TGHtmlMarkupElement * TGHtml::MakeMarkupEntry ; (; int ; objType, . int ; type, . int ; argc, . int ; arglen[], . char * ; argv[] . ). protected . Make one markup entry. ; Definition at line 1006 of file TGHtmlParse.cxx. ◆ MapControls(). int TGHtml::MapControls ; (; ). protected . Map any control that should be visible according to the current scroll position. ; At the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:76289,Load,LoadImage,76289,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['Load'],['LoadImage']
Performance," is why we never needed to specify the column types for all actions in the above snippets.; When the column type is not a common one such as int, double, char or float it is nonetheless good practice to specify it as a template parameter to the action itself, like this: df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing x = 0 rather than x == 0:; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");. User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; Implementing custom actions with Book(); Through the Book() method, users can implement a custom action and have access to the same features that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; #include <ROOT/RDataFrame.hxx>; #include <memory>; ; class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;; ; public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;; ; MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; ; // Called before the event loop to retrieve the address of the result t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:65000,perform,performed,65000,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['perform'],['performed']
Performance," isTransient)=0;  ; TClass * IsA () const override;  ; virtual Bool_t IsAutoParsingSuspended () const =0;  ; virtual Bool_t IsErrorMessagesEnabled () const =0;  ; virtual Bool_t IsFloatingType (const void *) const;  ; virtual Bool_t IsIntegerType (const void *) const;  ; virtual Bool_t IsLibraryLoaded (const char *libname) const =0;  ; virtual Bool_t IsLoaded (const char *filename) const =0;  ; virtual Bool_t IsPointerType (const void *) const;  ; virtual Bool_t IsProcessLineLocked () const =0;  ; virtual Bool_t IsSameType (const void *, const void *) const;  ; virtual Bool_t IsSignedIntegerType (const void *) const;  ; virtual Bool_t IsUnsignedIntegerType (const void *) const;  ; virtual Bool_t IsVoidPointerType (const void *) const;  ; virtual Int_t Load (const char *filenam, Bool_t system=kFALSE)=0;  ; virtual void LoadEnums (TListOfEnums &cl) const =0;  ; virtual int LoadFile (const char *) const;  ; virtual void LoadFunctionTemplates (TClass *cl) const =0;  ; virtual Int_t LoadLibraryMap (const char *rootmapfile=nullptr)=0;  ; virtual void LoadMacro (const char *filename, EErrorCode *error=nullptr)=0;  ; virtual Bool_t LoadText (const char *) const;  ; virtual std::unique_ptr< TInterpreterValue > MakeInterpreterValue () const;  ; virtual const char * MapCppName (const char *) const;  ; virtual const char * MethodArgInfo_DefaultValue (MethodArgInfo_t *) const;  ; virtual void MethodArgInfo_Delete (MethodArgInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory () const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory (MethodInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_FactoryCopy (MethodArgInfo_t *) const;  ; virtual Bool_t MethodArgInfo_IsValid (MethodArgInfo_t *) const;  ; virtual const char * MethodArgInfo_Name (MethodArgInfo_t *) const;  ; virtual int MethodArgInfo_Next (MethodArgInfo_t *) const;  ; virtual Long_t MethodArgInfo_Property (MethodArgInfo_t *) const;  ; virtual TypeInfo_t * MethodArgInfo_TypeInfo (MethodArgInfo_t *)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:18354,Load,LoadLibraryMap,18354,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['LoadLibraryMap']
Performance," it's fOffsetfBucketSize, or if fOffsetfBucketSize==0, it's also fBucketSize. ;  ; Int_t GetOffset ();  cross node ;  ; Int_t GetParent (Int_t inode) const;  ; Index * GetPointsIndexes (Int_t node) const;  return the indices of the points in that terminal node for all the nodes except last, the size is fBucketSize for the last node it's fOffsetfBucketSize ;  ; Int_t GetRight (Int_t inode) const;  ; Int_t GetRowT0 ();  ; Int_t GetTotalNodes () const;  ; TClass * IsA () const override;  ; Int_t IsOwner ();  ; Bool_t IsTerminal (Index inode) const;  ; Value KOrdStat (Index ntotal, Value *a, Index k, Index *index) const;  copy of the TMath::KOrdStat because I need an Index work array ;  ; void MakeBoundaries (Value *range=nullptr);  Build boundaries for each node. ;  ; void MakeBoundariesExact ();  Build boundaries for each node. ;  ; Int_t SetData (Index idim, Value *data);  Set the coordinate #ndim of all points (the column #ndim of the data matrix) After setting all the data columns, proceed by calling Build() function Note, that calling this function after Build() is not possible Note also, that no checks on the array sizes is performed anywhere. ;  ; void SetData (Index npoints, Index ndim, UInt_t bsize, Value **data);  Set the data array. See the constructor function comments for details. ;  ; void SetOwner (Int_t owner);  ; void Spread (Index ntotal, Value *a, Index *index, Value &min, Value &max) const;  Calculate spread of the array a. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:16840,perform,performed,16840,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['perform'],['performed']
Performance," its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on a data set which is stored on the master with name 'dsetname'. ;  ; virtual Int_t Echo (const char *str);  Sends a string to master and workers and expect them to echo it back to the client via a message. ;  ; virtual Int_t Echo (const TObject *obj);  Sends an object to master and workers and expect them to send back a message with the output of its TObject::Print(). ;  ; Int_t EnablePackage (const char *package, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, const char *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, TList *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t Exec (const char *cmd, Bool_t plusMaster=kFALSE);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t Exec (const char *cmd, const char *ord, Bool_t logtomacro=kFALSE);  Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ;  ; void Feedback (TList *objs);  Get list of feedback objects. ;  ; Long64_t Finalize (const char *queryref, Bool_t force=kFALSE);  Finalize query with reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:9516,load,loadopts,9516,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['load'],['loadopts']
Performance," k in range(nh):; for l in range(nw):; m = k * nw + l; # add some noise in each bin; x1[m] = h1.GetBinContent(k + 1, l + 1) + ROOT.gRandom.Gaus(0, pixelNoise); x2[m] = h2.GetBinContent(k + 1, l + 1) + ROOT.gRandom.Gaus(0, pixelNoise); ; sgn.Fill(); bkg.Fill(); ; sgn.Write(); bkg.Write(); ; print(""Signal and background tree with images data written to the file %s"", f.GetName()); sgn.Print(); bkg.Print(); f.Close(); ; hasGPU = ""tmva-gpu"" in ROOT.gROOT.GetConfigFeatures(); hasCPU = ""tmva-cpu"" in ROOT.gROOT.GetConfigFeatures(); ; nevt = 1000 # use a larger value to get better results; ; if (not hasCPU and not hasGPU) :; ROOT.Warning(""TMVA_CNN_Classificaton"",""ROOT is not supporting tmva-cpu and tmva-gpu skip using TMVA-DNN and TMVA-CNN""); useTMVACNN = False; useTMVADNN = False; ; if not ""tmva-pymva"" in ROOT.gROOT.GetConfigFeatures():; useKerasCNN = False; usePyTorchCNN = False; else:; TMVA.PyMethodBase.PyInitialize(); ; if not useTMVACNN:; ROOT.Warning(; ""TMVA_CNN_Classificaton"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for CNN"",; ); ; writeOutputFile = True; ; num_threads = 4 # use max 4 threads; max_epochs = 10 # maximum number of epochs used for training; ; ; # do enable MT running; if ""imt"" in ROOT.gROOT.GetConfigFeatures():; ROOT.EnableImplicitMT(num_threads); ROOT.gSystem.Setenv(""OMP_NUM_THREADS"", ""1"") # switch OFF MT in OpenBLAS; print(""Running with nthreads = {}"".format(ROOT.GetThreadPoolSize())); else:; print(""Running in serial mode since ROOT does not support MT""); ; ; ; ; outputFile = None; if writeOutputFile:; outputFile = TFile.Open(""TMVA_CNN_ClassificationOutput.root"", ""RECREATE""); ; ; ## Create TMVA Factory; ; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; ; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; # - The first argument is the base of the name of all the output; # weight fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:4445,multi-thread,multi-thread,4445,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['multi-thread'],['multi-thread']
Performance," kBuildRunning; };; enum EReadWrite { kBase; kOffsetL; kOffsetP; kCounter; kCharStar; kChar; kShort; kInt; kLong; kFloat; kDouble; kDouble32; kUChar; kUShort; kUInt; kULong; kBits; kLong64; kULong64; kBool; kFloat16; kObject; kAny; kObjectp; kObjectP; kTString; kTObject; kTNamed; kAnyp; kAnyP; kAnyPnoVT; kSTLp; kSkip; kSkipL; kSkipP; kConv; kConvL; kConvP; kSTL; kSTLstring; kStreamer; kStreamLoop; kCache; kArtificial; kCacheNew; kCacheDelete; kMissing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfIsCompiled! true if the StreamerInfo has been compiled (i.e. fully built, ready to use for streaming).; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*fgInfoFactory; static Bool_tfgOptimizeTrue if optimization on; static Bool_tfgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualStreamerInfo& operator=(const TVirtualStreamerInfo& ); assignment operator. ~TVirtualStreamerInfo(); Destructor. Bool_t CanDelete(); static function returning true if ReadBuffer can delete object. Bool_t CanOptimize(); static function returning true if optimization can be on. TStreamerBasicType * GetElementCounter(const char* countName, TClass* cl); Get pointer to a TStreamerBasicType in TClass *cl; static function. Bool_t GetStreamMemberWise(); Return whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing. A collection can be saved member wise when it contain is guaranteed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualStreamerInfo.html:9079,optimiz,optimization,9079,root/html534/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TVirtualStreamerInfo.html,1,['optimiz'],['optimization']
Performance," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsDataStore.html:8550,load,loaded,8550,root/html526/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html526/RooAbsDataStore.html,3,['load'],['loaded']
Performance," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const char* newname = 0) const. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsDataStore.html:9064,load,loaded,9064,root/html532/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html532/RooAbsDataStore.html,2,['load'],['loaded']
Performance," kFALSE on failure. ;  ;  Static Public Member Functions inherited from TFile; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static TFile *& CurrentFile ();  Return the current ROOT file if any. ;  ; static const char * DeclFileName ();  ; static EAsyncOpenStatus GetAsyncOpenStatus (const char *name);  Get status of the async open request related to 'name'. ;  ; static EAsyncOpenStatus GetAsyncOpenStatus (TFileOpenHandle *handle);  Get status of the async open request related to 'handle'. ;  ; static const char * GetCacheFileDir ();  Get the directory where to locally stage/cache remote files. ;  ; static const TUrl * GetEndpointUrl (const char *name);  Get final URL for file being opened asynchronously. ;  ; static Long64_t GetFileBytesRead ();  Static function returning the total number of bytes read from all files. ;  ; static Long64_t GetFileBytesWritten ();  Static function returning the total number of bytes written to all files. ;  ; static Long64_t GetFileCounter ();  ; static Int_t GetFileReadCalls ();  Static function returning the total number of read calls from all files. ;  ; static Bool_t GetOnlyStaged ();  Returns staged only flag. ;  ; static UInt_t GetOpenTimeout ();  Returns open timeout (in ms). ;  ; static Int_t GetReadaheadSize ();  Static function returning the readahead buffer size. ;  ; static Bool_t GetReadStreamerInfo ();  If the streamerinfos are to be read at file opening. ;  ; static EFileType GetType (const char *name, Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:28237,cache,cache,28237,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['cache'],['cache']
Performance," kFALSE); TStringcurrentLabel() const; const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMultiCategory.html:17530,optimiz,optimizeDirtyHook,17530,root/html530/RooMultiCategory.html,https://root.cern,https://root.cern/root/html530/RooMultiCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance," kFALSE, . Int_t * ; error = nullptr . ). overridevirtual . Parse a single command line and forward the request to the remote server where it will be processed. ; The line is either a C++ statement or an interpreter command starting with a ""."". Return the return value of the command casted to a long. ; Reimplemented from TApplication.; Definition at line 886 of file TApplicationRemote.cxx. ◆ RecvLogFile(). void TApplicationRemote::RecvLogFile ; (; Int_t ; size). private . Receive the log file from the server. ; Definition at line 602 of file TApplicationRemote.cxx. ◆ SendFile(). Int_t TApplicationRemote::SendFile ; (; const char * ; file, . Int_t ; opt = kAscii, . const char * ; rfile = nullptr . ). Send a file to the server. ; Return 0 on success, -1 in case of error. If defined, the full path of the remote path will be rfile. The mask 'opt' is an or of ESendFileOpt: kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run). Definition at line 762 of file TApplicationRemote.cxx. ◆ SendObject(). Int_t TApplicationRemote::SendObject ; (; const TObject * ; obj). Send object to server. ; Return 0 on success, -1 in case of error. ; Definition at line 652 of file TApplicationRemote.cxx. ◆ SetPortParam(). void TApplicationRemote::SetPortParam ; (; Int_t ; lower = -1, . Int_t ; upper = -1, . Int_t ; attempts = -1 . ). static . Set port parameters for tunnelling. A value of -1 means unchanged. ; Definition at line 867 of file TApplicationRemote.cxx. ◆ Streamer(). void TApplicationRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TApplication. ◆ StreamerNVirtual(). void TApplicationRemote::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 117 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:30068,cache,cache,30068,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['cache'],['cache']
Performance," kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TCanvas.h; TColor.h; TExec.h; TF2.h; TStyle.h; colorsColor * colorsDefinition X3DBuffer.c:21; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; bool; c3return c3Definition legend3.C:15; . Since6.26: The function TColor::CreateColorTableFromFile(""filename.txt"") allows you to create a color palette based on an input ASCII file. In contrast to TColor::CreateGradientColorTable(), here the length (spacing) is constant and can not be tuned. There is no gradient being interpolated between adjacent colors. The palette will contain the exact colors stored in the file, that comprises one line per color in the format ""r g b"" as floats. High quality predefined palettes; Since6.04: 63 high quality palettes are predefined with 255 colors each.; These palettes can be accessed ""by name"" with gStyle->SetPalette(num). num can be taken within the following enum:; kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; kBird=57, kCubehelix=58, kGreenRedViolet=59,; kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; kAlpine=63, kAquamarine=64, kArmy=65,; kAtlantic=66, kAurora=67, kAvocado=68,; kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; kBrownCyan=72, kCMYK=73, kCandy=74,; kCherry=75, kCoffee=76, kDarkRainBow=77,; kDarkTerrain=78, kFall=79, kFruitPunch=80,; kFuchsia=81, kGreyYellow=82, kGreenBrownTerrain=83,; kGreenPi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:13433,tune,tuned,13433,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['tune'],['tuned']
Performance," kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual void AddBinContent (Int_t bin);  Increment bin content by 1. ;  ; virtual void AddBinContent (Int_t bin, Double_t w);  Increment bin content by a weight w. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Int_t BufferEmpty (Int_t action=0);  Fill histogram with all entries in the buffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:24855,Perform,Performs,24855,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['Perform'],['Performs']
Performance," kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:12925,cache,cache,12925,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance, kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; TStringTWebFile::fBasicUrlbasic url without authentication and options; TStringTWebFile::fBasicUrlOrgsave original url in case of temp redirection; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tTWebFile::fHTTP11true if server support HTTP/1.1; Bool_tTWebFile::fHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initial,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:21620,cache,cache,21620,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['cache'],['cache']
Performance," kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TCondor (const char *pool="""");  Create Condor interface object. ;  ;  ~TCondor () override;  Cleanup Condor interface. ;  ; TCondorSlave * Claim (const char *vmname, const char *cmd);  Claim virtual machine with name vmname This function does not figure out the image and performance index before returning the condor slave. ;  ; TList * Claim (Int_t n, const char *cmd);  Claim n virtual machines This function figures out the image and performance index before returning the list of condor slaves. ;  ; TString GetImage (const char *host) const;  Get image of the worker. ;  ; EState GetState () const;  ; TList * GetVirtualMachines () const;  Get the names of the virtual machines in the pool. ;  ; Bool_t GetVmInfo (const char *vm, TString &image, Int_t &perfidx) const;  Get info about worker status. ;  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  ; void Print (Option_t *option="""") const override;  Print master status. ;  ; Bool_t Release ();  Release worker. ;  ; Bool_t Resume ();  Resume worker. ;  ; Bool_t SetState (EState state);  Set the state of workers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t Suspend ();  Suspend worker. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCondor.html:1525,perform,performance,1525,doc/master/classTCondor.html,https://root.cern,https://root.cern/doc/master/classTCondor.html,1,['perform'],['performance']
Performance," kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooRealIntegral*_acceptRejectFuncProjection function to be passed to accept/reject sampler; Double_t_area; RooArgSet*_cloneSetClone of all nodes of input p.d.f; Int_t_codeInternal generation code; RooArgSet_directVars; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooAbsNumGenerator*_generatorMC sampling generation engine; Bool_tRooAbsGenContext::_isValidIs context in valid state?; Double_t_maxProb; RooRealVar*_maxVarVariable holding maximum value of p.d.f; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; Double_t_normMaximum probability, p.d.f area and normalization; RooArgSet_otherVarsList of observables generated internally, randomly, and by accept/reject sampling; RooAbsPdf*_pdfCloneClone of input p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenContext.html:8362,load,load,8362,root/html526/RooGenContext.html,https://root.cern,https://root.cern/root/html526/RooGenContext.html,1,['load'],['load']
Performance," kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooRealIntegral*_acceptRejectFuncProjection function to be passed to accept/reject sampler; Double_t_area; RooArgSet*_cloneSetClone of all nodes of input p.d.f; Int_t_codeInternal generation code; RooArgSet_directVars; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooAbsNumGenerator*_generatorMC sampling generation engine; Bool_tRooAbsGenContext::_isValidIs context in valid state?; Double_t_maxProb; RooRealVar*_maxVarVariable holding maximum value of p.d.f; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; Double_t_normMaximum probability, p.d.f area and normalization; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet_otherVarsList of observables generated internally, randomly, and by accept/reject sampling; RooAbsPdf*_pdfCloneClone of input p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenContext.html:8348,load,load,8348,root/html528/RooGenContext.html,https://root.cern,https://root.cern/root/html528/RooGenContext.html,4,['load'],['load']
Performance," kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThresh[_numPdf] Fraction threshold array; TList_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_haveIdxProtoFlag set if generation of index is requested; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*_prototypePrototype data set; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimGenContext.html:8071,load,load,8071,root/html526/RooSimGenContext.html,https://root.cern,https://root.cern/root/html526/RooSimGenContext.html,1,['load'],['load']
Performance," kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. string_addCoefRangeNameName of reference to be used for RooAddPdf components; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:32459,cache,cache,32459,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,5,['cache'],"['cache', 'caches']"
Performance," kStandard; kAnnihilate; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tfAutoRangeset eta phi limits on DataChanged(); Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tfBarrelRadiusbarrel raidus in cm; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tfCellIdCacheOKdata cell ids cache state; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tfEndCapPosBbackward end cap z coordinate in cm (should be < 0); Float_tfEndCapPosFforward end cap z coordinate in cm; Double_tfEtaMax; Double_tfEtaMin; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Float_tfMaxT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCaloViz.html:20286,cache,cache,20286,root/html534/TEveCaloViz.html,https://root.cern,https://root.cern/root/html534/TEveCaloViz.html,1,['cache'],['cache']
Performance," kStandard; kAnnihilate; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tfAutoRangeset eta phi limits on DataChanged(); Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tfBarrelRadiusbarrel raidus in cm; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tfCellIdCacheOKdata cell ids cache state; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tfEndCapPosend cap z coordinate in cm; Double_tfEtaMax; Double_tfEtaMin; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Float_tfMaxTowerHbounding box z dimesion; Float_tfMaxValAbs; TStringTNamed::fNameobject iden",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloViz.html:19835,cache,cache,19835,root/html528/TEveCaloViz.html,https://root.cern,https://root.cern/root/html528/TEveCaloViz.html,3,['cache'],['cache']
Performance," kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooThresholdCategory.html:20659,cache,cache,20659,root/html534/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html,4,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance," kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:26408,cache,cache,26408,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,1,['cache'],['cache']
Performance," kTRUE . ). inline . Definition at line 159 of file TBuffer.h. ◆ WriteObject() [2/3]. virtual void TBuffer::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse . ). virtual . Implements TBuffer. ◆ WriteObject() [3/3]. void TBufferIO::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; Implements TBuffer.; Definition at line 530 of file TBufferIO.cxx. ◆ WriteObjectAny(). Int_t TBufferIO::WriteObjectAny ; (; const void * ; obj, . const TClass * ; ptrClass, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; This function assumes that the value in 'obj' is the value stored in a pointer to a ""ptrClass"". The actual type of the object pointed to can be any class derived from ""ptrClass"". Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). If 'cacheReuse' is true (default) upon seeing an object address a second time, we record the offset where its was written the first time rather than streaming the object a second time. If 'cacheReuse' is false, we always stream the object. This allows the (re)use of temporary object to store different data in the same buffer. ; Implements TBuffer.; Definition at line 492 of file TBufferIO.cxx. ◆ WriteObjectClass(). virtual void TBufferIO::WriteObjectClass ; (; const void * ; actualObjStart, . const TClass * ; actualClass, . Bool_t ; cacheReuse . ). protectedpure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ WriteProcessID(). UShort_t TBufferIO::WriteProcessID ; (; TProcessID * ; pid). overridevirtual . Check if the ProcessID pid is already in the file. ; If not, add it and return the index number in the local file list. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 456 of file TBufferIO.cxx. Member Data Documentation. ◆ fClassMap. TExMap* TBufferIO::fClassMap {nullptr}. protected . Map containing object,class pairs f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:43227,cache,cacheReuse,43227,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cacheReuse']
Performance," kTanh = 3,; 37 kSymmRelu = 4,; 38 kSoftSign = 5,; 39 kGauss = 6,; 40 kFastTanh = 7; 41 ; 42};; 43 ; 44/*! Enum that represents output functions */; 45enum class EOutputFunction; 46{; 47 kIdentity = 'I',; 48 kSigmoid = 'S',; 49 kSoftmax = 'M'; 50};; 51 ; 52/*! Enum that represents objective functions for the net, i.e. functions; 53* that take the output from the last layer in the net together with the; 54* truths and return the objective function values that is to be minimized; 55* in the training process. */; 56enum class ELossFunction; 57{; 58 kCrossEntropy = 'C',; 59 kMeanSquaredError = 'R',; 60 kSoftmaxCrossEntropy = 'S'; 61};; 62 ; 63/*! Enum representing the regularization type applied for a given layer */; 64enum class ERegularization; 65{; 66 kNone = '0',; 67 kL1 = '1',; 68 kL2 = '2'; 69 };; 70 ; 71/* Enum representing the initialization method used for this layer. */; 72enum class EInitialization {; 73 kGauss = 'G',; 74 kUniform = 'U',; 75 kIdentity = 'I',; 76 kZero = 'Z',; 77 kGlorotNormal = 'X',; 78 kGlorotUniform = 'F',; 79};; 80 ; 81/// Enum representing the optimizer used for training.; 82enum class EOptimizer {; 83 kSGD = 0,; 84 kAdam = 1,; 85 kAdagrad = 2,; 86 kRMSProp = 3,; 87 kAdadelta = 4,; 88};; 89 ; 90//______________________________________________________________________________; 91//; 92// Activation Functions; 93//______________________________________________________________________________; 94 ; 95/*! Apply the given activation function to each value in the given; 96* tensor A. */; 97template<typename Architecture_t>; 98inline void evaluate(typename Architecture_t::Tensor_t &A,; 99 EActivationFunction f); 100{; 101 switch(f); 102 {; 103 case EActivationFunction::kIdentity : break;; 104 case EActivationFunction::kRelu : Architecture_t::Relu(A);; 105 break;; 106 case EActivationFunction::kSigmoid : Architecture_t::Sigmoid(A);; 107 break;; 108 case EActivationFunction::kTanh : Architecture_t::Tanh(A);; 109 break;; 110 case EActivationFunction:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2DNN_2Functions_8h_source.html:2521,optimiz,optimizer,2521,doc/master/tmva_2tmva_2inc_2TMVA_2DNN_2Functions_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2DNN_2Functions_8h_source.html,1,['optimiz'],['optimizer']
Performance," kWriteDelete; };. protected:. UShort_tfCurrent! to fasten Contains() in list mode; UShort_t*fIndices[fN]; Int_tfLastIndexQueried! to optimize GetEntry() in a loop; Int_tfLastIndexReturned! to optimize GetEntry() in a loop; Int_tfNsize of fIndices for I/O =fNPassed for list, fBlockSize for bits; Int_tfNPassednumber of entries in the entry list (if fPassing=0 - number of entries; Bool_tfPassing1 - stores entries that belong to the list; Int_tfType0 - bits, 1 - list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryListBlock(); default c-tor. TEntryListBlock(const TEntryListBlock& eblock); copy c-tor. ~TEntryListBlock(); destructor. Bool_t Enter(Int_t entry); If the block has already been optimized and the entries; are stored as a list and not as bits, trying to enter a new entry; will make the block switch to bits representation. Bool_t Remove(Int_t entry); Remove entry #entry; If the block has already been optimized and the entries; are stored as a list and not as bits, trying to remove a new entry; will make the block switch to bits representation. Int_t Contains(Int_t entry); true if the block contains entry #entry. Int_t Merge(TEntryListBlock* block); Merge with the other block; Returns the resulting number of entries in the block. Int_t GetNPassed(); Returns the number of entries, passing the selection.; In case, when the block stores entries that pass (fPassing=1) returns fNPassed. Int_t GetEntry(Int_t entry); Return entry #entry; See also Next(). Int_t Next(); Return the next non-zero entry; Faster than GetEntry() function. void Print(Option_t* option = """") const; Print the entries in this block. void PrintWithShift(Int_t shift) const; print the indices of this block + shift (used from TEntryList::Print()) to; print the corrent values. void OptimizeStorage(); if there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. void Transform(Bool_t dir, UShort_t* indexnew); Transform the existin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListBlock.html:15390,optimiz,optimized,15390,root/html528/TEntryListBlock.html,https://root.cern,https://root.cern/root/html528/TEntryListBlock.html,3,['optimiz'],['optimized']
Performance," kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_actual! Set of actual dependents; Bool_t_compiledFlag set if formula is compiled; Bool_t_isOKIs internal state OK?; RooLinkedList_labelListList of label names for category objects ; static Int_tRooPrintable::_nameLength; RooArgSet*_nset; RooLinkedList_origList! Original list of dependents; vector<Bool_t>_useIsCat! Is given slot in _useList a category?; RooLinkedList_useList! List of actual dependents ; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayTFormula::fFunctionsArray of function calls to make; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFormula.html:12616,cache,cache,12616,root/html532/RooFormula.html,https://root.cern,https://root.cern/root/html532/RooFormula.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance," keep as is; 24#include ""RConfigure.h""; 25 ; 26#include ""cuda.h""; 27#include ""cuda_runtime.h""; 28#include ""cublas_v2.h""; 29#include ""curand_kernel.h""; 30 ; 31#include ""TMatrixT.h""; 32#include ""CudaBuffers.h""; 33 ; 34#define CUDACHECK(ans) {cudaError((ans), __FILE__, __LINE__); }; 35 ; 36namespace TMVA {; 37namespace DNN {; 38 ; 39/** Function to check cuda return code. Taken from; 40 * http://stackoverflow.com/questions/14038589/; 41 */; 42inline void cudaError(cudaError_t code, const char *file, int line, bool abort=true);; 43 ; 44//____________________________________________________________________________; 45//; 46// Cuda Device Reference; 47//____________________________________________________________________________; 48 ; 49/** TCudaDeviceReference; 50 *; 51 * Helper class emulating lvalue references for AFloat values that are; 52 * physically on the device. Allows for example to assign to matrix elements.; 53 * Note that device access through CudaDeviceReferences enforces synchronization; 54 * with all streams and thus qualifies as performance killer. Only used for; 55 * testing.; 56 */; 57template<typename AFloat>; 58class TCudaDeviceReference; 59{; 60private:; 61 ; 62 AFloat * fDevicePointer;; 63 ; 64public:; 65 ; 66 TCudaDeviceReference(AFloat * devicePointer);; 67 ; 68 operator AFloat();; 69 ; 70 void operator=(const TCudaDeviceReference &other);; 71 void operator=(AFloat value);; 72 void operator+=(AFloat value);; 73 void operator-=(AFloat value);; 74};; 75 ; 76//____________________________________________________________________________; 77//; 78// Cuda Matrix; 79//____________________________________________________________________________; 80 ; 81/** TCudaMatrix Class; 82 *; 83 * The TCudaMatrix class represents matrices on a CUDA device. The elements; 84 * of the matrix are stored in a TCudaDeviceBuffer object which takes care of; 85 * the allocation and freeing of the device memory. TCudaMatrices are lightweight; 86 * object, that means on assignme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:2335,perform,performance,2335,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,1,['perform'],['performance']
Performance," kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:4469,optimiz,optimization,4469,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance," key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); voidstandby(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:27105,cache,cache,27105,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['cache'],['cache']
Performance," keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset cache; TList*fOpenPhases!Time info about open phases; TStringfOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:20493,cache,cache,20493,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['cache'],['cache']
Performance," label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooErrorVar(const char* name, const char* title, const RooRealVar& input); Construct an lvalue variable representing the error of R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:40910,cache,cache,40910,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,4,['cache'],['cache']
Performance," label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooListProxy_olist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooListProxy_plist; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTFnBinding(const char* name, const char* title, TF1* func, const RooArgList& list). RooTFnBinding(const char* name, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTFnBinding.html:34545,cache,cache,34545,root/html534/RooTFnBinding.html,https://root.cern,https://root.cern/root/html534/RooTFnBinding.html,2,['cache'],['cache']
Performance," label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf.html:41826,cache,cache,41826,root/html530/RooAbsPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html,1,['cache'],['cache']
Performance," latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:1706,Cache,Cache,1706,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['Cache'],['Cache']
Performance, layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogAxislogarithmic check box; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; TGCheckButton*fMoreLogmore logarithmic labels check box; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGCheckButton*fNoExponentcheck box for No exponent choice; TGCheckButton*fOptimizetick optimization check box; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; TGCheckButton*fRotatedcheck button for rotated title; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGNumberEntry*fTickLengthtick length number entry; TGCheckButton*fTicksBothcheck box setting ticks on both axis sides; Int_tfTicksFlagpositive/negative ticks' flag; TGTextEntry*fTitleaxis title input field; TGColorSelect*fTitleColorcolor selection widget; TGFontTypeComboBox*fTitleFonttitle font combo box; TGNumberEntry*fTitleOffsettitle offset number entry; Int_tfTitlePrecfont precision level; TGNumberEntry*fTitleSizetitle size number entry; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTG,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAxisEditor.html:21299,optimiz,optimization,21299,root/html602/TAxisEditor.html,https://root.cern,https://root.cern/root/html602/TAxisEditor.html,2,['optimiz'],['optimization']
Performance," leaf = nullptr;; 7038 while ((leaf = (TLeaf*) next())) {; 7039 leaf->Notify();; 7040 leaf->GetBranch()->Notify();; 7041 }; 7042 return true;; 7043}; 7044 ; 7045////////////////////////////////////////////////////////////////////////////////; 7046/// This function may be called after having filled some entries in a Tree.; 7047/// Using the information in the existing branch buffers, it will reassign; 7048/// new branch buffer sizes to optimize time and memory.; 7049///; 7050/// The function computes the best values for branch buffer sizes such that; 7051/// the total buffer sizes is less than maxMemory and nearby entries written; 7052/// at the same time.; 7053/// In case the branch compression factor for the data written so far is less; 7054/// than compMin, the compression is disabled.; 7055///; 7056/// if option =""d"" an analysis report is printed.; 7057 ; 7058void TTree::OptimizeBaskets(ULong64_t maxMemory, Float_t minComp, Option_t *option); 7059{; 7060 //Flush existing baskets if the file is writable; 7061 if (this->GetDirectory()->IsWritable()) this->FlushBasketsImpl();; 7062 ; 7063 TString opt( option );; 7064 opt.ToLower();; 7065 bool pDebug = opt.Contains(""d"");; 7066 TObjArray *leaves = this->GetListOfLeaves();; 7067 Int_t nleaves = leaves->GetEntries();; 7068 Double_t treeSize = (Double_t)this->GetTotBytes();; 7069 ; 7070 if (nleaves == 0 || treeSize == 0) {; 7071 // We're being called too early, we really have nothing to do ...; 7072 return;; 7073 }; 7074 Double_t aveSize = treeSize/nleaves;; 7075 UInt_t bmin = 512;; 7076 UInt_t bmax = 256000;; 7077 Double_t memFactor = 1;; 7078 Int_t i, oldMemsize,newMemsize,oldBaskets,newBaskets;; 7079 i = oldMemsize = newMemsize = oldBaskets = newBaskets = 0;; 7080 ; 7081 //we make two passes; 7082 //one pass to compute the relative branch buffer sizes; 7083 //a second pass to compute the absolute values; 7084 for (Int_t pass =0;pass<2;pass++) {; 7085 oldMemsize = 0; //to count size of baskets in memory with old buffer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:276081,Optimiz,OptimizeBaskets,276081,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Optimiz'],['OptimizeBaskets']
Performance," learn more about the interpretation of fits with squared weights). ; [in]doOffsetSee RooAbsPdf::extendedTerm(double, RooArgSet const*, double, bool) const. . Definition at line 793 of file RooAbsPdf.cxx. ◆ extendMode(). virtual ExtendMode RooAbsPdf::extendMode ; (; ); const. inlinevirtual . Returns ability of PDF to provide extended likelihood terms. ; Possible answers are in the enumerator RooAbsPdf::ExtendMode. This default implementation always returns CanNotBeExtended. ; Reimplemented in RooAddModel, RooAddPdf, RooBinSamplingPdf, RooExtendedTerm, RooExtendPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooSimultaneous, RooNormalizedPdf, RooFixedProdPdf, and xRooProjectedPdf.; Definition at line 216 of file RooAbsPdf.h. ◆ fitTo(). template<typename... CmdArgs_t> . RooAbsPdf::fitTo ; (; RooAbsData & ; data, . CmdArgs_t const &... ; cmdArgs . ). inline . Fit PDF to given dataset. ; If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; Parameters. dataReference to a RooAbsData object representing the dataset. ; cmdArgsVariadic template arguments representing optional command arguments. You can pass either an arbitrary number of RooCmdArg instances or a single RooLinkedList that points to the RooCmdArg objects. . ReturnsAn owning pointer to the created RooAbsReal NLL object. . RooFitResult with fit status and parameters if option Save() is used, nullptr otherwise. The user takes ownership of the fit result.; Template Parameters. CmdArgs_tTemplate types for optional command arguments. Can either be an arbitrary number of RooCmdArg or a single RooLinkedList. NoteThis front-end function should not be re-implemented in derived PDF types. If you mean to customize the likelihood fitting routine, you need to override the virtual RooAbsPdf::fitToImpl() method.; The following named arguments are supported",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:104127,perform,performed,104127,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['perform'],['performed']
Performance," legend->AddEntry(h1,""All nations"",""f"");; legend->AddEntry(h2,""French only"",""f"");; legend->Draw();. c1->cd();; delete f;; }; To control the bar width (default is the bin width) TH1::SetBarWidth(); should be used. To control the bar offset (default is 0) TH1::SetBarOffset() should; be used. These two parameters are useful when several histograms are plotted using; the option SAME. They allow to plot the histograms next to each other.; The SCATter plot option (default for 2D histograms); For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above; kNMAX contents are normalized to kNMAX (kNMAX=2000).; If option is of the form ""scat=ff"", (eg scat=1.8,; scat=1e-3), then ff is used as a scale factor to compute the; number of dots. ""scat=1"" is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the TAttMarker; documentation). To change the marker size, a scalable marker type should be; used. For instance a circle (marker style 20). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5"");; return c1;; }; The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; return c1;; }; The BOX option; For each cell (i,j) a box is drawn. The size (surface) of the box is; proportional to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:26253,scalab,scalable,26253,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,1,['scalab'],['scalable']
Performance," length of ; this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle). Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2. Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle. between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction). In case isn't defined, an alternative method of; performing this second test is used: The ; function. is accepted if (refer also to equation (13)). (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user). >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting. as shown below. Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as. (15). where. (16). Consequently, ; is an upper tri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:8150,perform,performing,8150,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,3,['perform'],['performing']
Performance, level in geometry. ; Definition at line 53 of file TGeoManager.h. ◆ fgMaxLevel. Int_t TGeoManager::fgMaxLevel = 1. staticprotected . Verbosity level for Info messages (no IO). ; Definition at line 52 of file TGeoManager.h. ◆ fgMaxXtruVert. Int_t TGeoManager::fgMaxXtruVert = 1. staticprotected . Maximum number of daughters. ; Definition at line 54 of file TGeoManager.h. ◆ fgMutex. std::mutex TGeoManager::fgMutex. staticprotected . Definition at line 49 of file TGeoManager.h. ◆ fgNumThreads. Int_t TGeoManager::fgNumThreads = 0. staticprivate . Thread id's map. ; Definition at line 121 of file TGeoManager.h. ◆ fGShapes. TObjArray* TGeoManager::fGShapes. private . Definition at line 97 of file TGeoManager.h. ◆ fgThreadId. TGeoManager::ThreadsMap_t * TGeoManager::fgThreadId = nullptr. staticprivate . Map between thread id's and navigator arrays. ; Definition at line 120 of file TGeoManager.h. ◆ fgVerboseLevel. Int_t TGeoManager::fgVerboseLevel = 1. staticprotected . Lock preventing a second geometry to be loaded. ; Definition at line 51 of file TGeoManager.h. ◆ fGVolumes. TObjArray* TGeoManager::fGVolumes. private . list of runtime shapes ; Definition at line 98 of file TGeoManager.h. ◆ fHashGVolumes. THashList* TGeoManager::fHashGVolumes. private . hash list of volumes providing fast search ; Definition at line 137 of file TGeoManager.h. ◆ fHashPNE. THashList* TGeoManager::fHashPNE. private . hash list of group volumes providing fast search ; Definition at line 138 of file TGeoManager.h. ◆ fHashVolumes. THashList* TGeoManager::fHashVolumes. private . Definition at line 136 of file TGeoManager.h. ◆ fIsGeomCleaning. Bool_t TGeoManager::fIsGeomCleaning. private . flag set when reading geometry ; Definition at line 83 of file TGeoManager.h. ◆ fIsGeomReading. Bool_t TGeoManager::fIsGeomReading. private . Definition at line 82 of file TGeoManager.h. ◆ fIsNodeSelectable. Bool_t TGeoManager::fIsNodeSelectable. private . switch ON/OFF volume activity (default OFF - all volumes ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:148456,load,loaded,148456,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['load'],['loaded']
Performance," libraries the first one depends on. Returns 0 in case the library is not found. ; Definition at line 3623 of file TClass.cxx. ◆ GetShowMembersWrapper(). ShowMembersFunc_t TClass::GetShowMembersWrapper ; (; ); const. inline . Definition at line 487 of file TClass.h. ◆ GetState(). EState TClass::GetState ; (; ); const. inline . Definition at line 488 of file TClass.h. ◆ GetStreamer(). TClassStreamer * TClass::GetStreamer ; (; ); const. Return the Streamer Class allowing streaming (if any). ; Definition at line 2914 of file TClass.cxx. ◆ GetStreamerFunc(). ClassStreamerFunc_t TClass::GetStreamerFunc ; (; ); const. Get a wrapper/accessor function around this class custom streamer (member function). ; Definition at line 2939 of file TClass.cxx. ◆ GetStreamerInfo(). TVirtualStreamerInfo * TClass::GetStreamerInfo ; (; Int_t ; version = 0, . Bool_t ; isTransient = kFALSE . ); const. returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4599 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:91655,load,loaded,91655,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loaded']
Performance," libraries the first one depends on. Returns 0 in case the library is not found. ; Definition at line 3690 of file TClass.cxx. ◆ GetShowMembersWrapper(). ShowMembersFunc_t TClass::GetShowMembersWrapper ; (; ); const. inline . Definition at line 487 of file TClass.h. ◆ GetState(). EState TClass::GetState ; (; ); const. inline . Definition at line 488 of file TClass.h. ◆ GetStreamer(). TClassStreamer * TClass::GetStreamer ; (; ); const. Return the Streamer Class allowing streaming (if any). ; Definition at line 2981 of file TClass.cxx. ◆ GetStreamerFunc(). ClassStreamerFunc_t TClass::GetStreamerFunc ; (; ); const. Get a wrapper/accessor function around this class custom streamer (member function). ; Definition at line 3006 of file TClass.cxx. ◆ GetStreamerInfo(). TVirtualStreamerInfo * TClass::GetStreamerInfo ; (; Int_t ; version = 0, . Bool_t ; isTransient = kFALSE . ); const. returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4666 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:91656,load,loaded,91656,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loaded']
Performance," library provides protection against multiple threads trying to modify static and global data used within a library. The developer must explicitly lock access to objects shared between threads. No other thread can write to a locked object unless it is unlocked. The developer needs to lock local objects. The spirit, if not the letter of this definition, requires the user of the library only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within the library. The preferred way of providing this protection is to use mutex locks. The library also locks an object before writing to it. The developer is not required to explicitly lock or unlock a class object (static, global or local) to perform a single operation on the object. Note that even multithread safe level II hardly relieves the user of the library from the burden of locking. A thread suffers from deadlock if it is blocked waiting for a condition that will never occur. Typically, this occurs when one thread needs to access a resource that is already locked by another thread, and that other thread is trying to access a resource that has already been locked by the first thread. In this situation, neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1124197,perform,perform,1124197,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnixSystem.html:43547,load,load,43547,root/html532/TUnixSystem.html,https://root.cern,https://root.cern/root/html532/TUnixSystem.html,3,['load'],['load']
Performance," line 100 of file RMethodBase.h. ◆ GetMvaValue(). virtual Double_t TMVA::RMethodBase::GetMvaValue ; (; Double_t * ; errLower = nullptr, . Double_t * ; errUpper = nullptr . ). pure virtual . Implements TMVA::MethodBase.; Implemented in TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, and TMVA::MethodRXGB. ◆ HasAnalysisType(). Bool_t TMVA::RMethodBase::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ; numberTargets . ). pure virtual . Implements TMVA::IMethod.; Implemented in TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, and TMVA::MethodRXGB. ◆ Init(). virtual void TMVA::RMethodBase::Init ; (; ). pure virtual . Implements TMVA::MethodBase.; Implemented in TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, and TMVA::MethodRXGB. ◆ IsA(). virtual TClass * TMVA::RMethodBase::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::MethodBase.; Definition at line 100 of file RMethodBase.h. ◆ LoadData(). void RMethodBase::LoadData ; (; ). protected . Definition at line 43 of file RMethodBase.cxx. ◆ ProcessOptions(). virtual void TMVA::RMethodBase::ProcessOptions ; (; ). pure virtual . Implements TMVA::MethodBase.; Implemented in TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, and TMVA::MethodRXGB. ◆ ReadWeightsFromStream() [1/2]. virtual void TMVA::RMethodBase::ReadWeightsFromStream ; (; std::istream & ; ). protectedpure virtual . Implements TMVA::MethodBase.; Implemented in TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, TMVA::MethodRXGB, TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, and TMVA::MethodRXGB. ◆ ReadWeightsFromStream() [2/2]. virtual void TMVA::RMethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlineprotectedvirtual . Reimplemented from TMVA::MethodBase.; Reimplemented in TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, and TMVA::MethodRXGB.; Definition at line 86 of file RMethodBase.h. ◆ ReadWeightsFromXML(). virtual void TMVA::RMethodB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RMethodBase.html:30851,Load,LoadData,30851,doc/master/classTMVA_1_1RMethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RMethodBase.html,1,['Load'],['LoadData']
Performance, line 113 of file TFitEditor.h. ◆ fDrawAdvanced. TGTextButton* TFitEditor::fDrawAdvanced. protected . opens a dialog for advanced draw options ; Definition at line 94 of file TFitEditor.h. ◆ fDrawSame. TGCheckButton* TFitEditor::fDrawSame. protected . switch on/off fit function drawing ; Definition at line 93 of file TFitEditor.h. ◆ fEmptyBinsWghts1. TGCheckButton* TFitEditor::fEmptyBinsWghts1. protected . switch on/off option 'include empry bins' ; Definition at line 87 of file TFitEditor.h. ◆ fEnableRobust. TGCheckButton* TFitEditor::fEnableRobust. protected . switch on/off robust option ; Definition at line 105 of file TFitEditor.h. ◆ fEnteredFunc. TGTextEntry* TFitEditor::fEnteredFunc. protected . contains user function file name ; Definition at line 69 of file TFitEditor.h. ◆ fErrorScale. TGNumberEntryField* TFitEditor::fErrorScale. protected . Definition at line 139 of file TFitEditor.h. ◆ fFitButton. TGTextButton* TFitEditor::fFitButton. protected . performs fitting ; Definition at line 62 of file TFitEditor.h. ◆ fFitObject. TObject* TFitEditor::fFitObject. protected . selected object to fit ; Definition at line 111 of file TFitEditor.h. ◆ fFuncList. TGComboBox* TFitEditor::fFuncList. protected . contains function list ; Definition at line 68 of file TFitEditor.h. ◆ fFuncPars. std::vector<FuncParamData_t> TFitEditor::fFuncPars. protected . Definition at line 128 of file TFitEditor.h. ◆ fGeneral. TGCompositeFrame* TFitEditor::fGeneral. protected . general tab ; Definition at line 59 of file TFitEditor.h. ◆ fgFitDialog. TFitEditor * TFitEditor::fgFitDialog = 0. staticprotected . Definition at line 147 of file TFitEditor.h. ◆ fImproveResults. TGCheckButton* TFitEditor::fImproveResults. protected . switch on/off option 'improve fit results' ; Definition at line 86 of file TFitEditor.h. ◆ fIntegral. TGCheckButton* TFitEditor::fIntegral. protected . switch on/off option 'integral' ; Definition at line 80 of file TFitEditor.h. ◆ fIterations. TGNumberEntryField* TFitE,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:64080,perform,performs,64080,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['perform'],['performs']
Performance," line 1303 of file TProofBench.cxx. ◆ RemoveDataSet(). Int_t TProofBench::RemoveDataSet ; (; const char * ; dset). Physically remove the dataset 'dset', i.e. ; remove the dataset and the files it describes Return 0 on success, -1 on error ; Definition at line 1315 of file TProofBench.cxx. ◆ RunCPU(). Int_t TProofBench::RunCPU ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1, . Int_t ; step = -1 . ). Perform the CPU run Return 0 on success, -1 on error. ; Definition at line 336 of file TProofBench.cxx. ◆ RunCPUx(). Int_t TProofBench::RunCPUx ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1 . ). Perform the CPU run scanning over the number of workers per node Return 0 on success, -1 on error. ; Definition at line 365 of file TProofBench.cxx. ◆ RunDataSet(). Int_t TProofBench::RunDataSet ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1, . Int_t ; step = 1 . ). Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ; Definition at line 897 of file TProofBench.cxx. ◆ RunDataSetx(). Int_t TProofBench::RunDataSetx ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1 . ). Perform a test using dataset 'dset' scanning over the number of workers per node. ; Return 0 on success, -1 on error Open the file for the results ; Definition at line 932 of file TProofBench.cxx. ◆ SetCPUPar(). void TProofBench::SetCPUPar ; (; const char * ; par). inline . Definition at line 121 of file TProofBench.h. ◆ SetCPUSel(). void TProofBench::SetCPUSel ; (; const char * ; sel). inline . Definition at line 120 of file TProofBench.h. ◆ SetDataGenPar(). void TProofBench::SetDataGenPar ; (; const char * ; par). inline . Definition at line 125 of file TProofBench.h. ◆ SetDataGenSel(). void TProofBench::SetDataGenSel ; (; const char * ; sel). inline . Definition at line 124 of file TProofBench.h. ◆ SetDataPar(). void TProofBench::SetDataPar ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:21784,Perform,Perform,21784,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['Perform'],['Perform']
Performance," line 353 of file RPageStorage.cxx. ◆ LoadPageImpl(). virtual RPageRef ROOT::Experimental::Internal::RPageSource::LoadPageImpl ; (; ColumnHandle_t ; columnHandle, . const RClusterInfo & ; clusterInfo, . ClusterSize_t::ValueType ; idxInCluster . ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceDaos, ROOT::Experimental::Internal::RPageSourceFile, and ROOT::Experimental::Internal::RPageSourceFriends. ◆ LoadSealedPage(). virtual void ROOT::Experimental::Internal::RPageSource::LoadSealedPage ; (; DescriptorId_t ; physicalColumnId, . RClusterIndex ; clusterIndex, . RSealedPage & ; sealedPage . ). pure virtual . Read the packed and compressed bytes of a page into the memory buffer provided by sealedPage. ; The sealed page can be used subsequently in a call to RPageSink::CommitSealedPage. The fSize and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enough buffer and call LoadSealedPage again. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadStructure(). void ROOT::Experimental::Internal::RPageSource::LoadStructure ; (; ). Loads header and footer without decompressing or deserializing them. ; This can be used to asynchronously open a file in the background. The method is idempotent and it is called as a first step in Attach(). Pages sources may or may not make use of splitting loading and processing meta-data. Therefore, LoadStructure() may do nothing and defer loading the meta-data to Attach(). ; Definition at line 188 of file RPageStorage.cxx. ◆ LoadStructureImpl(). virtual void ROOT::Experimental::Internal::RPageSource::LoadStructureImpl ; (; ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:16860,Load,LoadSealedPage,16860,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadSealedPage']
Performance," line 3607 of file TClass.cxx. ◆ GetHeapInstanceCount(). UInt_t TClass::GetHeapInstanceCount ; (; ); const. inline . Definition at line 467 of file TClass.h. ◆ GetIdMap(). IdMap_t * TClass::GetIdMap ; (; ). staticprivate . Definition at line 469 of file TClass.cxx. ◆ GetImplFileLine(). Short_t TClass::GetImplFileLine ; (; ); const. inline . Definition at line 457 of file TClass.h. ◆ GetImplFileName(). const char * TClass::GetImplFileName ; (; ); const. inline . Definition at line 456 of file TClass.h. ◆ GetInstanceCount(). UInt_t TClass::GetInstanceCount ; (; ); const. inline . Definition at line 466 of file TClass.h. ◆ GetIsAProxy(). TVirtualIsAProxy * TClass::GetIsAProxy ; (; ); const. Return the proxy implementing the IsA functionality. ; Definition at line 2955 of file TClass.cxx. ◆ GetLastReadInfo(). TVirtualStreamerInfo * TClass::GetLastReadInfo ; (; ); const. inline . Definition at line 444 of file TClass.h. ◆ GetListOfAllPublicDataMembers(). TList * TClass::GetListOfAllPublicDataMembers ; (; Bool_t ; load = kTRUE). Returns a list of all public data members of this class and its base classes. ; Refers to a subset of the data members in GetListOfDatamembers() so don't do GetListOfAllPublicDataMembers()->Delete(). ; Definition at line 3862 of file TClass.cxx. ◆ GetListOfAllPublicMethods(). const TList * TClass::GetListOfAllPublicMethods ; (; Bool_t ; load = kTRUE). Returns a list of all public methods of this class and its base classes. ; Refers to a subset of the methods in GetListOfMethods() so don't do GetListOfAllPublicMethods()->Delete(). Algorithm used to get the list is:; put all methods of the class in the list (also protected and private ones).; loop over all base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3845 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:81018,load,load,81018,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance," line 3674 of file TClass.cxx. ◆ GetHeapInstanceCount(). UInt_t TClass::GetHeapInstanceCount ; (; ); const. inline . Definition at line 467 of file TClass.h. ◆ GetIdMap(). IdMap_t * TClass::GetIdMap ; (; ). staticprivate . Definition at line 469 of file TClass.cxx. ◆ GetImplFileLine(). Short_t TClass::GetImplFileLine ; (; ); const. inline . Definition at line 457 of file TClass.h. ◆ GetImplFileName(). const char * TClass::GetImplFileName ; (; ); const. inline . Definition at line 456 of file TClass.h. ◆ GetInstanceCount(). UInt_t TClass::GetInstanceCount ; (; ); const. inline . Definition at line 466 of file TClass.h. ◆ GetIsAProxy(). TVirtualIsAProxy * TClass::GetIsAProxy ; (; ); const. Return the proxy implementing the IsA functionality. ; Definition at line 3022 of file TClass.cxx. ◆ GetLastReadInfo(). TVirtualStreamerInfo * TClass::GetLastReadInfo ; (; ); const. inline . Definition at line 444 of file TClass.h. ◆ GetListOfAllPublicDataMembers(). TList * TClass::GetListOfAllPublicDataMembers ; (; Bool_t ; load = kTRUE). Returns a list of all public data members of this class and its base classes. ; Refers to a subset of the data members in GetListOfDatamembers() so don't do GetListOfAllPublicDataMembers()->Delete(). ; Definition at line 3929 of file TClass.cxx. ◆ GetListOfAllPublicMethods(). const TList * TClass::GetListOfAllPublicMethods ; (; Bool_t ; load = kTRUE). Returns a list of all public methods of this class and its base classes. ; Refers to a subset of the methods in GetListOfMethods() so don't do GetListOfAllPublicMethods()->Delete(). Algorithm used to get the list is:; put all methods of the class in the list (also protected and private ones).; loop over all base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3912 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:81019,load,load,81019,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance," line 51 of file RooCachedPdf.h. ◆ clone(). TObject * RooCachedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooCachedPdf.h. ◆ DeclFileName(). static const char * RooCachedPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 51 of file RooCachedPdf.h. ◆ evaluate(). double RooCachedPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 39 of file RooCachedPdf.h. ◆ fillCacheObject(). void RooCachedPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input p.d.f. ; Note that the cache is filled with normalized p.d.f values so that the RooHistPdf that represents the cache contents can be explicitly declared as self normalized eliminating the need for superfluous numeric calculations of unit normalization.s ; Implements RooAbsCachedPdf.; Definition at line 92 of file RooCachedPdf.cxx. ◆ inputBaseName(). const char * RooCachedPdf::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return the base name for cache objects, in this case the name of the cached p.d.f. ; Implements RooAbsCachedPdf.; Definition at line 33 of file RooCachedPdf.h. ◆ IsA(). TClass * RooCachedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 51 of file RooCachedPdf.h. ◆ payloadUniqueSuffix(). const char * RooCachedPdf::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedPdf.; Definition at line 44 of file RooCachedPdf.h. ◆ preferredObservableScanOrder(). void RooCachedPdf::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:81304,cache,cache,81304,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance," line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfCustomizedflag for customized canvas implimentation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQApplication(); Used by Dictionary(). TQApplication(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0); Create the root application and load the graphic libraries. ~TQApplication(); Delete ROOT application environment. void LoadGraphicsLibs(); Here we overload the LoadGraphicsLibs() function.; This function now just instantiates a QRootGuiFactory; object and redirect the global pointer gGuiFactory to point; to it. void SetCustomized(); Set the custom flag. » Author: Denis Bertini, M. Al-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQApplication.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQApplication.html:12471,load,load,12471,root/html528/TQApplication.html,https://root.cern,https://root.cern/root/html528/TQApplication.html,3,"['Load', 'load']","['LoadGraphicsLibs', 'load']"
Performance," line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfCustomizedflag for customized canvas implimentation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQApplication(); Used by Dictionary(). TQApplication(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0); Create the root application and load the graphic libraries. ~TQApplication(); Delete ROOT application environment. void LoadGraphicsLibs(); Here we overload the LoadGraphicsLibs() function.; This function now just instantiates a QRootGuiFactory; object and redirect the global pointer gGuiFactory to point; to it. void SetCustomized(); Set the custom flag. » Author: Denis Bertini, M. Al-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQApplication.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQApplication.html:12622,load,load,12622,root/html532/TQApplication.html,https://root.cern,https://root.cern/root/html532/TQApplication.html,3,"['Load', 'load']","['LoadGraphicsLibs', 'load']"
Performance," lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMacro.html:9168,load,loading,9168,root/html602/TMacro.html,https://root.cern,https://root.cern/root/html602/TMacro.html,2,['load'],['loading']
Performance," linked in library. This fixes ROOT-8019. Dictionaries. Fix ROOT-7879: Prevent LinkDef files to be listed in a rootmap file and use (as the user actually expects) the header files #included in the linkdef file, if any, as the top level headers. Interpreter. Ignore access check when evaluating ROOT-7426. Meta Library; Add a new mode for TClass::SetCanSplit (2) which indicates that this class and any derived class should not be split. This included a rework the mechanism checking the base classes. Instead of using InheritsFrom, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit. This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes ROOT-7972.; TTree. Do not automatically setup read cache during TTree::Fill(). This fixes ROOT-8031.; Fast Cloning We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address ROOT-5078. It can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces. The new cache is enabled by default, to update the size of the cache or disable it from TTreeCloner use: TTreeCloner::SetCacheSize. To do the same from TTree::CopyEntries add to the option string “cachesize=SIZE”. To update the size of the cache or disable it from hadd, use the command line option -cachesize SIZE. SIZE shouyld be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Histogram Libraries. Protect access to TROOT::GetListOfGlobalFunctions in TFormula. Math. Update MixMax random number generator for 32 bit architectures. TColor. Import TColor from maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:25461,cache,cache,25461,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['cache'],['cache']
Performance," list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:38797,load,load,38797,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance, list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes providing fast search; THashList*fHashPNE-> hash list of phisical node entries; THashList*fHashVolumes! hash list of volumes providing fast search; Bool_tfIsGeomCleaning! flag to notify that the manager is being destructed; Bool_tfIsGeomReading! flag set when reading geometry; Bool_tfIsNodeSelectable! flag that nodes are the selected objects in pad rather than volumes; Int_t*fKeyPNEId[fSizePNEId] array of uid values for PN entries; Bool_tfLoopVolumes! flag volume lists loop; TGeoVolume*fMasterVolumemaster volume; TList*fMaterials-> list of materials; TObjArray*fMatrices-> list of local transformations; Bool_tfMatrixReflection! flag for GL reflections; Bool_tfMatrixTransform! flag for using GL matrix; Int_tfMaxThreads! Max number of threads; Int_tfMaxVisNodesmaximum number of visible nodes; TList*fMedia-> list of tracking media; Bool_tfMultiThread! Flag for multi-threading; Int_tfNLevelmaximum accepted level in geometry; Int_tfNNodestotal number of physical nodes; Int_tfNPNEIdnumber of PN entries having a unique ID; TGeoManager::NavigatorsMap_tfNavigators! Map between thread id's and navigator arrays; Int_t*fNodeIdArray! array of node id's; TObjArray*fNodes-> current branch of nodes; Int_tfNpdgnumber of different pdg's stored; Int_tfNsegmentsnumber of segments to approximate circles; Int_tfNtracksnumber of tracks; TObjArray*fOverlaps-> list of geometrical overlaps; TGeoVolume*fPaintVolume! volume currently painted; TVirtualGeoPainter*fPainter! current painter; TGeoParallelWorld*fParallelWorldParallel world; TStringfParticleName! particles to be drawn; TStringfPath! path to current node; Int_tfPdgId[1024]pdg conversion table; TObjArray*fPdgNames-> list of pdg names for tracks; Bool_tfPhiCutflag for phi cuts; Double_tfPhimax! highest range for phi cut; Double_tfPhimin! lowest range for phi cut; TObjArray*fPhysicalNodes-> list of physical nodes; TOb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoManager.html:35408,multi-thread,multi-threading,35408,root/html602/TGeoManager.html,https://root.cern,https://root.cern/root/html602/TGeoManager.html,2,['multi-thread'],['multi-threading']
Performance," list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes providing fast search; THashList*fHashPNE-> hash list of phisical node entries; THashList*fHashVolumes! hash list of volumes providing fast search; Bool_tfIsGeomCleaning! flag to notify that the manager is being destructed; Bool_tfIsGeomReading! flag set when reading geometry; Bool_tfIsNodeSelectable! flag that nodes are the selected objects in pad rather than volumes; Int_t*fKeyPNEId[fSizePNEId] array of uid values for PN entries; Bool_tfLoopVolumes! flag volume lists loop; TGeoVolume*fMasterVolumemaster volume; TList*fMaterials-> list of materials; TObjArray*fMatrices-> list of local transformations; Bool_tfMatrixReflection! flag for GL reflections; Bool_tfMatrixTransform! flag for using GL matrix; Int_tfMaxThreads! Max number of threads; Int_tfMaxVisNodesmaximum number of visible nodes; TList*fMedia-> list of tracking media; Bool_tfMultiThread! Flag for multi-threading; Int_tfNLevelmaximum accepted level in geometry; Int_tfNNodestotal number of physical nodes; Int_tfNPNEIdnumber of PN entries having a unique ID; map<long,TGeoNavigatorArray*>fNavigators! Map between thread id's and navigator arrays; Int_t*fNodeIdArray! array of node id's; TObjArray*fNodes-> current branch of nodes; Int_tfNpdgnumber of different pdg's stored; Int_tfNsegmentsnumber of segments to approximate circles; Int_tfNtracksnumber of tracks; TObjArray*fOverlaps-> list of geometrical overlaps; TGeoVolume*fPaintVolume! volume currently painted; TVirtualGeoPainter*fPainter! current painter; TGeoParallelWorld*fParallelWorldParallel world; TStringfParticleName! particles to be drawn; TStringfPath! path to current node; Int_tfPdgId[1024]pdg conversion table; TObjArray*fPdgNames-> list of pdg names for tracks; Bool_tfPhiCutflag for phi cuts; Double_tfPhimax! highest range for phi cut; Double_tfPhimin! lowest range for phi cut; TObjArray*fPhysicalNodes-> list of physical nodes; TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:34897,multi-thread,multi-threading,34897,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,1,['multi-thread'],['multi-threading']
Performance," list of the streamer infos in this file; Bool_tfInitDone!True if the file has been initialized; Bool_tfIsArchive!True if this is a pure archive file; Bool_tfIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset cache; TList*fOpenPhases!Time info about open phases; TStringfOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:20238,cache,cache,20238,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,4,['cache'],['cache']
Performance," list of user objects associated to this Tree; Double_tfWeightTree weight (see TTree::SetWeight); Long64_tfZipBytesTotal number of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any varia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:33318,cache,cache,33318,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['cache'],['cache']
Performance," list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script] | [host] -close; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:15924,Load,LoadGraphicsLibs,15924,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,12,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance," list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name.; If params != 0 it will also resolve overloading other it returns the first; name match.; If params == 0 and load is true force reading of all currently defined; global functions from Cling.; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfEnums(Bool_t load = kFALSE). TCollection * GetListOfFunctionTemplates(). TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return a dynamic list giving access to all TDataTypes (typedefs); currently def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:28151,load,load,28151,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance," lnk; lnk = lnk->Next()) {; 1282 TTree* clone = (TTree*) lnk->GetObject();; 1283 AddClone(clone);; 1284 }; 1285 }; 1286 fTreeNumber = -1;; 1287 fTree = nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Dummy function.; 1292/// It could be implemented and load all baskets of all trees in the chain.; 1293/// For the time being use TChain::Merge and TTree::LoadBasket; 1294/// on the resulting tree.; 1295 ; 1296Int_t TChain::LoadBaskets(Long64_t /*maxmemory*/); 1297{; 1298 Error(""LoadBaskets"", ""Function not yet implemented for TChain."");; 1299 return 0;; 1300}; 1301 ; 1302////////////////////////////////////////////////////////////////////////////////; 1303/// Find the tree which contains entry, and set it as the current tree.; 1304///; 1305/// Returns the entry number in that tree.; 1306///; 1307/// The input argument entry is the entry serial number in the whole chain.; 1308///; 1309/// In case of error, LoadTree returns a negative number:; 1310/// * -1: The chain is empty.; 1311/// * -2: The requested entry number is less than zero or too large for the chain.; 1312/// * -3: The file corresponding to the entry could not be correctly open; 1313/// * -4: The TChainElement corresponding to the entry is missing or; 1314/// the TTree is missing from the file.; 1315/// * -5: Internal error, please report the circumstance when this happen; 1316/// as a ROOT issue.; 1317/// * -6: An error occurred within the notify callback.; 1318///; 1319/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; 1320/// See TNotifyLink for more information on the notification mechanism.; 1321///; 1322/// \note This is the only routine which sets the value of fTree to a non-zero pointer.; 1323///; 1324Long64_t TChain::LoadTree(Long64_t entry); 1325{; 1326 // We already have been visited while recursively looking; 1327 // through the friends tree, let's return.; 1328 if (kLoadTree & fF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:47651,Load,LoadTree,47651,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance," loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/// If filename is of the form file.C++, the file file.C will be compiled; 7402/// and dynamically loaded.; 7403///; 7404/// If filename is of the form file.C+, the file file.C will be compiled; 7405/// and dynamically loaded. At next call, if file.C is older than file.o; 7406/// and file.so, the file.C is not compiled, only file.so is loaded.; 7407///; 7408/// ## NOTE1; 7409///; 7410/// It may be more interesting to invoke directly the other Process function; 7411/// accepting a TSelector* as argument.eg; 7412/// ~~~ {.cpp}; 7413/// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; 7414/// selector->CallSomeFunction(..);; 7415/// mytree.Process(selector,..);; 7416/// ~~~; 7417/// ## NOTE2; 7418//; 7419/// One should not call this function twice with the same selector file; 7420/// in the same script. If this is required, proceed as indicated in NOTE1,; 7421/// by getting a pointer to the corresponding TSelector,eg; 7422///; 7423/// ### Workaround 1; 7424///; 7425/// ~~~ {.cpp}; 7426/// void stubs1() {; 7427/// TSelector *selector = TSelector::GetSelector(""h1test.C"");; 7428/// TFile *f1 = new TFile(""stubs_nood_le1.root"");; 7429/// TTree *h1 = (TTree*)f1->Get(""h1"");; 7430/// h1->Process(selector);; 7431/// TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; 7432/// TTree *h2 = (TTree*)f2->Get(""h1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:291359,load,loaded,291359,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loaded']
Performance," loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be asso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46620,concurren,concurrently,46620,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrently']
Performance," make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:13165,optimiz,optimized,13165,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,7,['optimiz'],['optimized']
Performance," make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 49 of file TPServerSocket.cxx. ◆ TPServerSocket() [3/3]. TPServerSocket::TPServerSocket ; (; const char * ; service, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a parallel server socket object for a named service. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 76 of file TPServerSocket.cxx. ◆ ~TPServerSocket(). virtual TPServerSocket::~TPServerSocket ; (; ). inlinevirtual . Definition at line 47 of file TPServerSocket.h. Member Function Documentation. ◆ Accept(). TPSocket * TPServerSocket::Accept ; (; UChar_t ; Opt = kSrvNoAuth). override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPServerSocket.html:21229,queue,queue,21229,doc/master/classTPServerSocket.html,https://root.cern,https://root.cern/doc/master/classTPServerSocket.html,1,['queue'],['queue']
Performance," manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyc; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyp.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:42598,cache,cache,42598,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,1,['cache'],['cache']
Performance," manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:44822,cache,cache,44822,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,1,['cache'],['cache']
Performance," manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigmaL; RooRealProxysigmaR; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBifurGauss.html:44209,cache,cache,44209,root/html602/RooBifurGauss.html,https://root.cern,https://root.cern/root/html602/RooBifurGauss.html,2,['cache'],['cache']
Performance," marker style with line width 1 for the given style. ;  . Protected Attributes; THbookFile * fFile;  ; Int_t fID;  ; Bool_t fInit;  ; Int_t fType;  ; char * fX;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache is prefetching whole clusters ;  ; Long64_t fCacheSize;  ! Maximum size of file buffers ;  ; bool fCacheUserSet;  ! true if the cache setting was explicitly given by user ;  ; Long64_t fChainOffset;  ! Offset of 1st entry of this Tree in a TChain ;  ; TList * fClones;  ! List of cloned trees which share our addresses ;  ; Long64_t * fClusterRangeEnd;  [fNClusterRange] Last entry of a cluster range. ;  ; Long64_t * fClusterSize;  [fNClusterRange] Number of entries in each cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:39694,cache,cache,39694,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,3,['cache'],['cache']
Performance," matrix (stored as cov[ i * dim + j]; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver; doublefLSToleranceLine Search Tolerance; unsigned intfNFreedimension of the internal function to be minimized; vector<ROOT::Math::LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLNLSMinimizer.html:7995,perform,perform,7995,root/html602/ROOT__Math__GSLNLSMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLNLSMinimizer.html,2,['perform'],['perform']
Performance," maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:49437,Optimiz,OptimizeVoxels,49437,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['Optimiz'],['OptimizeVoxels']
Performance," may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:38414,cache,cache,38414,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cache']
Performance," measurement, RooAbsReal& truth); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:24337,cache,cache,24337,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,2,['cache'],['cache']
Performance," members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:1211,perform,performed,1211,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,5,['perform'],['performed']
Performance," menu; Better support of touch devices; Provide simple layout, making it default; Allow to open ROOT files in online session (via url parameter); One could monitor simultaneously objects from server and root files; Implement ‘autocol’ draw option - when superimposing histograms, their line colors will be automatically assigned; Implement ‘nostat’ draw option - disabled stat drawing; Using ‘same’ identifier in item name, one can easily draw or superimpose similar items from different files. Could be used in URL like: ...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_] ...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_ Main limitation - file names should have similar length.; When ‘autozoom’ specified in draw options, histogram zoomed into non-empty content. Same command available via context menu.; Item of ‘Text’ kind can be created. It is displayed as lain text in the browser. If property ‘mathjax’ specified, MathJax.js library will be loaded and used for rendering. See tutorials/http/httpcontrol.C macro for example.; When using foreignObject, provide workaround for absolute positioning problem in Chrome/Safari, see http://bit.ly/1wjqCQ9; Support usage of minimized versions of .js and .css files. Minimized scripts used by default on web servers.; Implement JSROOT.extend instead of jQuery.extend, reduce usage of jquery.js in core JSROOT classes; Implement main graphics without jquery at all, such mode used in nobrowser mode.; Provide optional latex drawing with MathJax SVG. TMathText always drawn with MathJax, other classes require mathjax option in URL; Improve drawing of different text classes, correctly handle their alignment and scaling, special handling for IE. TTree Libraries; TTree Behavior change.; Merging.; Added fast cloning support to TTree::MergeTrees and TTree::Merge(TCollection,Option_t).; TTreeCache; The TTreeCache is now enabled by default. The default size of the TTreeCache is the estimated size of a cluste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:10912,load,loaded,10912,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['load'],['loaded']
Performance," method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Refresh the list of shared libraries and return it. const char * GetClassSharedLibs(const char* cls); Get the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:28767,Load,Load,28767,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,1,['Load'],['Load']
Performance," method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCint.html:29243,Load,Load,29243,root/html528/TCint.html,https://root.cern,https://root.cern/root/html528/TCint.html,3,['Load'],['Load']
Performance," method indicated in method.; The value of the parameter 'method' determines in which order the branches' baskets are written to the output file.; When a TTree is filled the data is stored in the individual branches' basket. Each basket is written individually to the disk as soon as it is full. In consequence the baskets of branches that contain 'large' data chunk are written to the disk more often.; There is currently 3 supported sorting order: SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry; When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the basket are sorted on their offset in the original file; Usually this also means that the baskets are sorted on the index/number of the last entry they contain); When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted on the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially. ; Definition at line 104 of file TTreeCloner.cxx. ◆ TTreeCloner() [4/4]. TTreeCloner::TTreeCloner ; (; TTree * ; from, . TDirectory * ; newdirectory, . Option_t * ; method, . UInt_t ; options = kNone . ). Constructor. In place cloning. ; This object would transfer the data from 'from' the original location to 'newdirectory' the new directory using the sorting method indicated in method. It updates the 'from' TTree with the new information. See TTreeCloner::TTreeCloner(TTree *from, TTree *to, Option_t *method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:6526,optimiz,optimize,6526,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['optimiz'],['optimize']
Performance," method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; Bool_tfNotDoneYetflat to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html:3112,Optimiz,OptimizeConfigParameters,3112,root/html602/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html,4,['Optimiz'],['OptimizeConfigParameters']
Performance," method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:1553,Cache,CacheModeRooAbsArg,1553,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['Cache'],['CacheModeRooAbsArg']
Performance," method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodCFMlpANNMethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodCFMlpANNMethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTMVA::MethodBase::Reset(); voidTObject::ResetBit(UInt_t f)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:10066,Optimiz,OptimizeTuningParameters,10066,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance," method, const char* msgfmt) const; static RooAbsReal::EvalErrorIterevalErrorIter(); static Bool_tevalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tfindRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidfixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidfixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidforceNumInt(Bool_t flag = kTRUE); RooFunctor*functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:10113,cache,cacheList,10113,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['cache'],['cacheList']
Performance," method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static TThread::VoidRtnFunc_tThreadProc(void*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TThread*fConsumerconsumer thread; TFile*fFilereference to the file; TMutex*fMutexPendingListmutex for the pending list; TMutex*fMutexReadListmutex for the list of read blocks; TCondition*fNewBlockAddedcondition used to signal the addition of a new pending block; TStringfPathCachepath to the cache directory; TList*fPendingBlockslist of pending block to be read; TCondition*fReadBlockAddedcondition usd to signal the addition of a new red block; TList*fReadBlockslist of block read; TSemaphore*fSemsemaphore used to kill the consumer thread; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFilePrefetch.html:6069,cache,cache,6069,root/html530/TFilePrefetch.html,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html,1,['cache'],['cache']
Performance," method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtuple&operator=(const TNtuple&); TNtuple(const TNtuple&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtuple.html:21457,cache,cacheSize,21457,root/html602/TNtuple.html,https://root.cern,https://root.cern/root/html602/TNtuple.html,1,['cache'],['cacheSize']
Performance," method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtuple(const TNtuple&); TNtuple&operator=(const TNtuple&). Data Members; public:. enum TTree::ELockStatusBits { kFindBranch; kFindLeaf; kGetAlias; kGetBranch; kGetEntry; kGetEntryWithIndex; kGetFriend; kGetFriendA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNtuple.html:21293,cache,cacheSize,21293,root/html534/TNtuple.html,https://root.cern,https://root.cern/root/html534/TNtuple.html,1,['cache'],['cacheSize']
Performance," method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtupleD&operator=(const TNtupleD&); TNtupleD(const TNtupleD&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtupleD.html:21443,cache,cacheSize,21443,root/html602/TNtupleD.html,https://root.cern,https://root.cern/root/html602/TNtupleD.html,1,['cache'],['cacheSize']
Performance," method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtupleD(const TNtupleD&); TNtupleD&operator=(const TNtupleD&). Data Members; public:. enum TTree::ELockStatusBits { kFindBranch; kFindLeaf; kGetAlias; kGetBranch; kGetEntry; kGetEntryWithIndex; kGetFriend; kGetFri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNtupleD.html:21279,cache,cacheSize,21279,root/html534/TNtupleD.html,https://root.cern,https://root.cern/root/html534/TNtupleD.html,1,['cache'],['cacheSize']
Performance," method-specific help message]; : InputLayout: ""1|16|16"" [The Layout of the input]; : Layout: ""CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (None, 256) 576256 ; ; dense_1 (Dense) (None, 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:7207,perform,performance,7207,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performance']
Performance," mg_connection fc;; 16855 if (!dom_ctx) {; 16856 dom_ctx = &(phys_ctx->dd);; 16857 }; 16858 path = dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 16859 if ((path != NULL); 16860 && !mg_stat(fake_connection(&fc, phys_ctx), path, &file.stat)) {; 16861 mg_cry_ctx_internal(phys_ctx,; 16862 ""Cannot open %s: %s"",; 16863 path,; 16864 strerror(ERRNO));; 16865 return 0;; 16866 }; 16867 return 1;; 16868 }; 16869 return 0;; 16870}; 16871#endif /* NO_FILESYSTEMS */; 16872 ; 16873 ; 16874static int; 16875set_acl_option(struct mg_context *phys_ctx); 16876{; 16877 union usa sa;; 16878 memset(&sa, 0, sizeof(sa));; 16879#if defined(USE_IPV6); 16880 sa.sin6.sin6_family = AF_INET6;; 16881#else; 16882 sa.sin.sin_family = AF_INET;; 16883#endif; 16884 return check_acl(phys_ctx, &sa) != -1;; 16885}; 16886 ; 16887 ; 16888static void; 16889reset_per_request_attributes(struct mg_connection *conn); 16890{; 16891 if (!conn) {; 16892 return;; 16893 }; 16894 ; 16895 conn->num_bytes_sent = conn->consumed_content = 0;; 16896 ; 16897 conn->path_info = NULL;; 16898 conn->status_code = -1;; 16899 conn->content_len = -1;; 16900 conn->is_chunked = 0;; 16901 conn->must_close = 0;; 16902 conn->request_len = 0;; 16903 conn->request_state = 0;; 16904 conn->throttle = 0;; 16905 conn->accept_gzip = 0;; 16906 ; 16907 conn->response_info.content_length = conn->request_info.content_length = -1;; 16908 conn->response_info.http_version = conn->request_info.http_version = NULL;; 16909 conn->response_info.num_headers = conn->request_info.num_headers = 0;; 16910 conn->response_info.status_text = NULL;; 16911 conn->response_info.status_code = 0;; 16912 ; 16913 conn->request_info.remote_user = NULL;; 16914 conn->request_info.request_method = NULL;; 16915 conn->request_info.request_uri = NULL;; 16916 ; 16917 /* Free cleaned local URI (if any) */; 16918 if (conn->request_info.local_uri != conn->request_info.local_uri_raw) {; 16919 mg_free((void *)conn->request_info.local_uri);; 16920 conn->request_info.local_uri = NULL;; 16921",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:501747,throttle,throttle,501747,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance," mg_connection fc;; 16856 if (!dom_ctx) {; 16857 dom_ctx = &(phys_ctx->dd);; 16858 }; 16859 path = dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 16860 if ((path != NULL); 16861 && !mg_stat(fake_connection(&fc, phys_ctx), path, &file.stat)) {; 16862 mg_cry_ctx_internal(phys_ctx,; 16863 ""Cannot open %s: %s"",; 16864 path,; 16865 strerror(ERRNO));; 16866 return 0;; 16867 }; 16868 return 1;; 16869 }; 16870 return 0;; 16871}; 16872#endif /* NO_FILESYSTEMS */; 16873 ; 16874 ; 16875static int; 16876set_acl_option(struct mg_context *phys_ctx); 16877{; 16878 union usa sa;; 16879 memset(&sa, 0, sizeof(sa));; 16880#if defined(USE_IPV6); 16881 sa.sin6.sin6_family = AF_INET6;; 16882#else; 16883 sa.sin.sin_family = AF_INET;; 16884#endif; 16885 return check_acl(phys_ctx, &sa) != -1;; 16886}; 16887 ; 16888 ; 16889static void; 16890reset_per_request_attributes(struct mg_connection *conn); 16891{; 16892 if (!conn) {; 16893 return;; 16894 }; 16895 ; 16896 conn->num_bytes_sent = conn->consumed_content = 0;; 16897 ; 16898 conn->path_info = NULL;; 16899 conn->status_code = -1;; 16900 conn->content_len = -1;; 16901 conn->is_chunked = 0;; 16902 conn->must_close = 0;; 16903 conn->request_len = 0;; 16904 conn->request_state = 0;; 16905 conn->throttle = 0;; 16906 conn->accept_gzip = 0;; 16907 ; 16908 conn->response_info.content_length = conn->request_info.content_length = -1;; 16909 conn->response_info.http_version = conn->request_info.http_version = NULL;; 16910 conn->response_info.num_headers = conn->request_info.num_headers = 0;; 16911 conn->response_info.status_text = NULL;; 16912 conn->response_info.status_code = 0;; 16913 ; 16914 conn->request_info.remote_user = NULL;; 16915 conn->request_info.request_method = NULL;; 16916 conn->request_info.request_uri = NULL;; 16917 ; 16918 /* Free cleaned local URI (if any) */; 16919 if (conn->request_info.local_uri != conn->request_info.local_uri_raw) {; 16920 mg_free((void *)conn->request_info.local_uri);; 16921 conn->request_info.local_uri = NULL;; 16922",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:501780,throttle,throttle,501780,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance," minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  ROOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__MultiMin.html:2353,perform,performing,2353,doc/master/group__MultiMin.html,https://root.cern,https://root.cern/doc/master/group__MultiMin.html,1,['perform'],['performing']
Performance," minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits. . Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions. ; Fumili: library providing the implementation of the original Fumili fitting algorithm. Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:. Matrix: general matrix package providing matrix TMatrix and vector TVector classes and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/MATH_Index.html:2953,optimiz,optimization,2953,root/html526/MATH_Index.html,https://root.cern,https://root.cern/root/html526/MATH_Index.html,5,['optimiz'],['optimization']
Performance," minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:13800,queue,queue,13800,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,3,['queue'],['queue']
Performance," mntiny(Double_t epsp1, Double_t &epsbak)To find the machine precision.Definition TMinuit.cxx:7661; TMinuit::mninexvirtual void mninex(Double_t *pint)Transforms from internal coordinates (PINT) to external (U)Definition TMinuit.cxx:4506; TMinuit::fCtitlTString fCtitlDefinition TMinuit.h:168; TMinuit::mnpintvirtual void mnpint(Double_t &pexti, Int_t i, Double_t &pinti)Calculates the internal parameter value PINTI.Definition TMinuit.cxx:6017; TMinuit::fCONTwDouble_t * fCONTwDefinition TMinuit.h:101; TMinuit::fNfcwarInt_t fNfcwar[20]Definition TMinuit.h:152; TMinuit::fMIGRvgDouble_t * fMIGRvgDefinition TMinuit.h:111; TMinuit::mnfixpvirtual void mnfixp(Int_t iint, Int_t &ierr)Removes parameter IINT from the internal parameter list.Definition TMinuit.cxx:3169; TMinuit::fIstkrdInt_t fIstkrd[10]Definition TMinuit.h:137; TMinuit::fIsyswrInt_t fIsyswrDefinition TMinuit.h:132; TMinuit::fG2Double_t * fG2Definition TMinuit.h:82; TMinuit::mnmnotvirtual void mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi)Performs a MINOS error analysis on one parameter.Definition TMinuit.cxx:5463; TMinuit::fNpaglnInt_t fNpaglnDefinition TMinuit.h:135; TMinuit::fMNOTxdevDouble_t * fMNOTxdevDefinition TMinuit.h:113; TMinuit::mncrckvirtual void mncrck(TString crdbuf, Int_t maxcwd, TString &comand, Int_t &lnc, Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t isyswr)Cracks the free-format input.Definition TMinuit.cxx:1677; TMinuit::fMNOTgccDouble_t * fMNOTgccDefinition TMinuit.h:115; TMinuit::DefineParametervirtual Int_t DefineParameter(Int_t parNo, const char *name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit)Define a parameter.Definition TMinuit.cxx:695; TMinuit::fMaxpar2Int_t fMaxpar2Definition TMinuit.h:46; TMinuit::fFval3Double_t fFval3Definition TMinuit.h:52; TMinuit::fVhmatDouble_t * fVhmatDefinition TMinuit.h:89; TMinuit::fNstkrdInt_t fNstkrdDefinition TMinuit.h:138; TMinuit::mnstatvirtual void mnstat(Double_t &fmin, Double_t &fe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8h_source.html:30442,Perform,Performs,30442,doc/master/TMinuit_8h_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html,1,['Perform'],['Performs']
Performance," mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read string from TBuffer. void WriteTString(const TString& s); Write string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss, const char* classname); Check byte count with current buffer position. They should; match. If not print warning and position buffer in correct; place determined by the byte count. Startpos is position of; first byte where the byte count is written in buffer.; Returns 0 if everything is ok, otherwise the bytecount offset;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:18500,cache,cache,18500,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['cache'],['cache']
Performance," mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction4PdfBinding_double_double_double_double_bool_.html:40508,cache,cache,40508,root/html532/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html532/RooCFunction4PdfBinding_double_double_double_double_bool_.html,2,['cache'],['cache']
Performance," model = w[""model""]; d = model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ; # ROOT.This is slow in mode 0, fast in mode 1; model.fitTo(d, Verbose=True, Timer=True, PrintLevel=-1); ; # Projection on x (always slow as 2D integral over Y, at fitted value of a; # is not cached); framex = w[""x""].frame(Title=""Projection of 3D model on X""); d.plotOn(framex); model.plotOn(framex); ; # Draw x projection on canvas; c = ROOT.TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600); framex.Draw(); ; c.SaveAs(""rf903_numintcache.png""); ; # Make workspace available on command line after macro finishes; ROOT.gDirectory.Add(w); Drawth1 Draw(); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x,y,z]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x,y,z]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 1; ; prevFCN = 1659.930708 a=0.02833, [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); ; prevFCN = 1675.611563 a=-0.02833, ; prevFCN = 1673.217894 a=0.002833, ; prevFCN = 1660.205177 a=-0.002833, ; prevFCN = 1659.94939 a=0.0002833, ; prevFCN = 1659.944972 a=-0.0002833, ; prevFCN = 1659.919376 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001207, ; prevFCN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:4170,optimiz,optimization,4170,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,1,['optimiz'],['optimization']
Performance," model describing the alternate hypothesis. void SetTestStatistic(int index); set the desired test statistics:; index=1 : likelihood ratio: 2 * log( L_sb / L_b ) (DEFAULT); index=2 : number of generated events; index=3 : profiled likelihood ratio; if the index is different to any of those values, the default is used. HybridResult* Calculate(TH1& data, unsigned int nToys, bool usePriors); first compute the test statistics for data and then prepare and run the toy-MC experiments. HybridResult* Calculate(RooAbsData& data, unsigned int nToys, bool usePriors); first compute the test statistics for data and then prepare and run the toy-MC experiments. HybridResult* Calculate(unsigned int nToys, bool usePriors) const. void RunToys(vector<double>& bVals, vector<double>& sbVals, unsigned int nToys, bool usePriors) const; do the actual run-MC processing. void PrintMore(const char* options) const; Print out some information about the input models. HybridResult* GetHypoTest() const; perform the hypothesis test and return result of hypothesis test. bool DoCheckInputs() const. explicit HybridCalculator(const char *name = 0); Dummy Constructor with only name. void SetCommonPdf(RooAbsPdf& pdf); Set a common PDF for both the null and alternate. { fSbModel = &pdf; }. void SetNullPdf(RooAbsPdf& pdf); Set the PDF for the null (only B). { fBModel = &pdf; }. void SetAlternatePdf(RooAbsPdf& pdf); Set the PDF for the alternate hypothesis ( i.e. S+B). { fSbModel = &pdf; }. void SetData(RooAbsData& data); Set the DataSet. { fData = &data; }. void SetNullParameters(const RooArgSet& ); set parameter values for the null if using a common PDF. { }. void SetAlternateParameters(const RooArgSet& ); set parameter values for the alternate if using a common PDF. {}. void SetNuisancePdf(RooAbsPdf& prior_pdf); additional methods specific for HybridCalculator; set a prior pdf for the nuisance parameters. void SetNuisanceParameters(const RooArgSet& params); set the nuisance parameters to be marginalized. {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridCalculator.html:13121,perform,perform,13121,root/html526/RooStats__HybridCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridCalculator.html,1,['perform'],['perform']
Performance," modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 1061 return foundSymbol;; 1062}; 1063 ; 1064/// Checks if there is an ASTFile on disk for the given module \c M.; 1065static bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName = nullptr); 1066{; 1067 const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();; 1068 ; 1069 std::string ModuleFileName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080static GlobalModuleIndex *loadGlobalModuleIndex(cling::Interpreter &interp); 1081{; 1082 CompilerInstance &CI = *interp.getCI();; 1083 Preprocessor &PP = CI.getPreprocessor();; 1084 auto ModuleManager = CI.getASTReader();; 1085 assert(ModuleManager);; 1086 // StringRef ModuleIndexPath = HSI.getModuleCachePath();; 1087 // HeaderSearch& HSI = PP.getHeaderSearchInfo();; 1088 // HSI.setModuleCachePath(TROOT::GetSharedLibDir().Data());; 1089 std::string ModuleIndexPath = TROOT::GetSharedLibDir().Data();; 1090 if (ModuleIndexPath.empty()); 1091 return nullptr;; 1092 // Get an existing global index. This loads it if not already loaded.; 1093 ModuleManager->resetForReload();; 1094 ModuleManager->loa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:38278,Load,Load,38278,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['Load']
Performance," mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geomet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:100938,perform,perform,100938,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance," moved into Doxygen. Still some work and polish has to be done but the reference guide in this new format is now online and can be seen from the ROOT home page.; Core Libraries; Dictionary generation; Fixed the dictionary generation in the case of class inside a namespace marked inlined.; Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates.; Fix ROOT-7760 : fully allow the usage of the dylib extension on OSx.; Fix ROOT-7723 : allow IOCtors to have as argument a ref to a type called void.; We added a dictionary for map as part of the default STL dictionary.; We added support for template parameter packs in class name involved in the I/O.; Thread safety and thread awareness; We added the function TMethodCall::GetCallFunc to allow direct access to the function wrapper.; We reduced thread serialization in TClass::GetCheckSum, TClass::GetBaseClassOffset and TClass::Property; TObjArray::Delete was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock); We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: ROOT::EnableThreadSafety() which is the successor of the existing TThread::Initialize. This call must take place if ROOT needs to be used in a thread safe manner.; The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost.; TDirectory::TContext; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at destruction time and does not change the current directory.; The constructor for TDirectory::TContext that takes a single TDirectory pointer as an argument was changed to set gDirectory to zero when being passed a null pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:3713,multi-thread,multi-threaded,3713,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['multi-thread'],['multi-threaded']
Performance," msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); voidcreateTree(const char* name, const char* title); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetBranchBufferSize() const; voidinitialize(); voidTObject::MakeZombie(); voidsetBranchBufferSize(Int_t size); RooArgSetvarsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); RooRealVar*weightVar(const RooArgSet& allVars, const char* wgtName = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:9569,cache,cachedVars,9569,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,2,['cache'],['cachedVars']
Performance," msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); voidcreateTree(const char* name, const char* title); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetBranchBufferSize() const; voidinitialize(); voidTObject::MakeZombie(); voidsetBranchBufferSize(Int_t size); RooArgSetvarsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); RooRealVar*weightVar(const RooArgSet& allVars, const char* wgtName = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:9138,cache,cachedVars,9138,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,3,['cache'],['cachedVars']
Performance," msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); voidcreateTree(const char* name, const char* title); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetBranchBufferSize() const; voidinitialize(); voidTObject::MakeZombie(); voidsetBranchBufferSize(Int_t size); RooArgSetvarsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); RooRealVar*weightVar(const RooArgSet& allVars, const char* wgtName = 0). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeDataStore.html:9691,cache,cachedVars,9691,root/html602/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html602/RooTreeDataStore.html,2,['cache'],['cachedVars']
Performance," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:16639,cache,cache,16639,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,12,['cache'],['cache']
Performance," mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:12589,queue,queue,12589,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['queue'],['queue']
Performance," mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. The opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:12902,queue,queue,12902,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,5,['queue'],['queue']
Performance," name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:647006,Perform,Performance,647006,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Performance']
Performance," name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:39167,cache,cache,39167,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,['cache'],['cache']
Performance," name of the class including a possible; 3231 // namespace if there has been a using namespace statement.; 3232 ; 3233 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3234 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3235 // two different space layout. To avoid an infinite recursion, we also; 3236 // add the test on (altname != name); 3237 ; 3238 return GetClass(altname, load);; 3239 }; 3240 ; 3241 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3242 if (!ncl->IsZombie()) {; 3243 return ncl;; 3244 }; 3245 delete ncl;; 3246 }; 3247 }; 3248 return nullptr;; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Return pointer to class with name.; 3253 ; 3254TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3255{; 3256 if (!gROOT->GetListOfClasses()); 3257 return nullptr;; 3258 ; 3259 //protect access to TROOT::GetIdMap; 3260 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3261 ; 3262 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3263 ; 3264 if (cl && cl->IsLoaded()) return cl;; 3265 ; 3266 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3267 ; 3268 // Now that we got the write lock, another thread may have constructed the; 3269 // TClass while we were waiting, so we need to do the checks again.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:124256,load,load,124256,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance," name of the class including a possible; 3298 // namespace if there has been a using namespace statement.; 3299 ; 3300 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3301 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3302 // two different space layout. To avoid an infinite recursion, we also; 3303 // add the test on (altname != name); 3304 ; 3305 return GetClass(altname, load);; 3306 }; 3307 ; 3308 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3309 if (!ncl->IsZombie()) {; 3310 return ncl;; 3311 }; 3312 delete ncl;; 3313 }; 3314 }; 3315 return nullptr;; 3316}; 3317 ; 3318////////////////////////////////////////////////////////////////////////////////; 3319/// Return pointer to class with name.; 3320 ; 3321TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3322{; 3323 if (!gROOT->GetListOfClasses()); 3324 return nullptr;; 3325 ; 3326 //protect access to TROOT::GetIdMap; 3327 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3328 ; 3329 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3330 ; 3331 if (cl && cl->IsLoaded()) return cl;; 3332 ; 3333 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3334 ; 3335 // Now that we got the write lock, another thread may have constructed the; 3336 // TClass while we were waiting, so we need to do the checks again.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:127007,load,load,127007,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance," name of the file to convert; title - title which will be placed at the top of the HTML file; dirname - optional parameter, if it's not specified, output will; be placed in htmldoc/examples directory.; relpath - optional parameter pointing to the THtml generated doc; on the server, relative to the current page.; includeOutput - if != kNoOutput, run the script passed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; kForceOutput re-runs the script even if output PNGs exist; that are newer than the script. If kCompiledOutput is; passed, the script is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THtml.html:29823,cache,cached,29823,root/html530/THtml.html,https://root.cern,https://root.cern/root/html530/THtml.html,5,['cache'],['cached']
Performance," name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:15424,cache,cache,15424,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,1,['cache'],['cache']
Performance," name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsCategoryLValue::volume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:16498,cache,cache,16498,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,2,['cache'],['cache']
Performance," name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfFunctions * GetGlobalFunctions(); Internal routine returning, and creating if necessary, the list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name.; If params != 0 it will also resolve overloading other it returns the first; name match.; If params == 0 and load is true force reading of all currently defined; global functions from Cling.; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfEnums(Bool_t load = kFALSE). TCollection * GetListOfFunctionTemplates(). TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:27361,load,load,27361,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance," name, config types, default value.; 2047 * Must be in the same order as the enum const above.; 2048 */; 2049static const struct mg_option config_options[] = {; 2050 ; 2051 /* Once for each server */; 2052 {""listening_ports"", MG_CONFIG_TYPE_STRING_LIST, ""8080""},; 2053 {""num_threads"", MG_CONFIG_TYPE_NUMBER, ""50""},; 2054 {""run_as_user"", MG_CONFIG_TYPE_STRING, NULL},; 2055 {""tcp_nodelay"", MG_CONFIG_TYPE_NUMBER, ""0""},; 2056 {""max_request_size"", MG_CONFIG_TYPE_NUMBER, ""16384""},; 2057 {""linger_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2058 {""connection_queue"", MG_CONFIG_TYPE_NUMBER, ""20""},; 2059 {""listen_backlog"", MG_CONFIG_TYPE_NUMBER, ""200""},; 2060#if defined(__linux__); 2061 {""allow_sendfile_call"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2062#endif; 2063#if defined(_WIN32); 2064 {""case_sensitive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2065#endif; 2066 {""throttle"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2067 {""enable_keep_alive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2068 {""request_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""30000""},; 2069 {""keep_alive_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""500""},; 2070#if defined(USE_WEBSOCKET); 2071 {""websocket_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2072 {""enable_websocket_ping_pong"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2073#endif; 2074 {""decode_url"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2075 {""decode_query_string"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2076#if defined(USE_LUA); 2077 {""lua_background_script"", MG_CONFIG_TYPE_FILE, NULL},; 2078 {""lua_background_script_params"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2079#endif; 2080#if defined(USE_HTTP2); 2081 {""enable_http2"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2082#endif; 2083 ; 2084 /* Once for each domain */; 2085 {""document_root"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2086 ; 2087 {""access_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2088 {""error_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2089 ; 2090 {""cgi_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.cgi$|**.pl$|**.php$""},; 2091 {""cgi_environment"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2092 {""cg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:62233,throttle,throttle,62233,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance," name, config types, default value.; 2048 * Must be in the same order as the enum const above.; 2049 */; 2050static const struct mg_option config_options[] = {; 2051 ; 2052 /* Once for each server */; 2053 {""listening_ports"", MG_CONFIG_TYPE_STRING_LIST, ""8080""},; 2054 {""num_threads"", MG_CONFIG_TYPE_NUMBER, ""50""},; 2055 {""run_as_user"", MG_CONFIG_TYPE_STRING, NULL},; 2056 {""tcp_nodelay"", MG_CONFIG_TYPE_NUMBER, ""0""},; 2057 {""max_request_size"", MG_CONFIG_TYPE_NUMBER, ""16384""},; 2058 {""linger_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2059 {""connection_queue"", MG_CONFIG_TYPE_NUMBER, ""20""},; 2060 {""listen_backlog"", MG_CONFIG_TYPE_NUMBER, ""200""},; 2061#if defined(__linux__); 2062 {""allow_sendfile_call"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2063#endif; 2064#if defined(_WIN32); 2065 {""case_sensitive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2066#endif; 2067 {""throttle"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2068 {""enable_keep_alive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2069 {""request_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""30000""},; 2070 {""keep_alive_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""500""},; 2071#if defined(USE_WEBSOCKET); 2072 {""websocket_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2073 {""enable_websocket_ping_pong"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2074#endif; 2075 {""decode_url"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2076 {""decode_query_string"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2077#if defined(USE_LUA); 2078 {""lua_background_script"", MG_CONFIG_TYPE_FILE, NULL},; 2079 {""lua_background_script_params"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2080#endif; 2081#if defined(USE_HTTP2); 2082 {""enable_http2"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2083#endif; 2084 ; 2085 /* Once for each domain */; 2086 {""document_root"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2087 ; 2088 {""access_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2089 {""error_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2090 ; 2091 {""cgi_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.cgi$|**.pl$|**.php$""},; 2092 {""cgi_environment"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2093 {""cg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:62265,throttle,throttle,62265,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['throttle'],['throttle']
Performance," name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) const; 3173{; 3174 R__LOCKGUARD(gInterpreterMutex);; 3175 ; 3176 //FIXME: if we use llvm::sys::fs::make_absolute all this can go away. See; 3177 // cling::DynamicLibraryManager.; 3178 ; 3179 std::string file_name = filename;; 3180 size_t at = std::string::npos;; 3181 while ((at = file_name.find(""/./"")) != std::string::npos); 3182 file_name.replace(at, 3, ""/"");; 3183 ; 3184 std::string filesStr = """";; 3185 llvm::raw_string_ostream filesOS(filesStr);; 3186 clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();; 3187 cling::ClangInternalState::printIncludedFiles(filesOS, SM);; 3188 filesOS.flush();; 3189 ; 3190 llvm::SmallVector<llvm::Str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:122573,load,loaded,122573,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance," names from loader; 2482 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2483 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2484 ; 2485 long int range = pow(2, nbits);; 2486 ; 2487 // vector to save importances; 2488 std::vector<Double_t> importances(nbits);; 2489 for (int i = 0; i < nbits; i++); 2490 importances[i] = 0;; 2491 ; 2492 Double_t SROC, SSROC; // computed ROC value; 2493 for (UInt_t n = 0; n < nseeds; n++) {; 2494 x = rangen->Integer(range);; 2495 ; 2496 std::bitset<32> xbitset(x);; 2497 if (x == 0); 2498 continue; // data loader need at least one variable; 2499 ; 2500 // creating loader for seed; 2501 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2502 ; 2503 // adding variables from seed; 2504 for (int index = 0; index < nbits; index++) {; 2505 if (xbitset[index]); 2506 seedloader->AddVariable(varNames[index], 'F');; 2507 }; 2508 ; 2509 // Loading Dataset; 2510 DataLoaderCopy(seedloader, loader);; 2511 ; 2512 // Booking Seed; 2513 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2514 ; 2515 // Train/Test/Evaluation; 2516 TrainAllMethods();; 2517 TestAllMethods();; 2518 EvaluateAllMethods();; 2519 ; 2520 // getting ROC; 2521 SROC = GetROCIntegral(xbitset.to_string(), methodTitle);; 2522 // std::cout << ""Seed: n "" << n << "" x "" << x << "" xbitset:"" << xbitset << "" ROC "" << SROC << std::endl;; 2523 ; 2524 // cleaning information to process sub-seeds; 2525 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2526 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2527 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2528 delete sresults;; 2529 delete seedloader;; 2530 this->DeleteAllMethods();; 2531 fMethodsMap.clear();; 2532 ; 2533 // removing global result because it is requiring a lot of RAM for all seeds; 2534 ; 2535 for (uint32_t i = 0; i < 32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:104019,Load,Loading,104019,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,"['Load', 'load']","['Loading', 'loader']"
Performance," names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:43590,cache,cache,43590,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,4,['cache'],['cache']
Performance," nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event loop; ; // Prepare the event tree; // - Here the variable names have to corresponds to your tree; // - You can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; std::cout << ""--- Select signal sample"" << std::endl;; TTree* theTree = (TTree*)input->Get(""TreeS"");; Float_t userVar1, userVar2;; theTree->SetBranchAddress( ""var1"", &userVar1 );; theTree->SetBranchAddress( ""var2"", &userVar2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; // Efficiency calculator for cut method; Int_t nSelCutsGA = 0;; Double_t effS = 0.7;; ; std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; ; if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; ; theTree->GetEntry(ievt);; ; var1 = userVar1 + userVar2;; var2 = userVar1 - userVar2;; ; // Return the MVA outputs and fill into histograms; ; if (Use[""CutsGA""]) {; // Cuts is a special case: give the de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:14995,CACHE,CACHEREAD,14995,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,1,['CACHE'],['CACHEREAD']
Performance," nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Method returning errno.; 1246 ; 1247Int_t TFile::GetErrno() const; 1248{; 1249 return TSystem::GetErrno();; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:45048,cache,cache,45048,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,['cache'],['cache']
Performance," negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; map<pair<string,int>,RooNDKeysPdf::BoxInfo*>_rangeBoxInfo; Double_tRooAbsPdf::_rawValue; vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; vector<Double_t>_sigma; Double_t_sigmaAvgR; TVectorD*_sigmaR; vector<iiVec>_sortIdcs!; vector<itVec>_sortTVIdcs!; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Double_t_sqrt2pi; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:46603,cache,cache,46603,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['cache'],['cache']
Performance," negotiation; 1561 // with the viewer here; 1562 if (!shape.IsComposite()) {; 1563 // Does viewer prefer local frame positions?; 1564 Bool_t localFrame = viewer->PreferLocalFrame();; 1565 // Perform first fetch of buffer from the shape and try adding it; 1566 // to the viewer; 1567 const TBuffer3D &buffer =; 1568 shape.GetBuffer3D(TBuffer3D::kCore | TBuffer3D::kBoundingBox | TBuffer3D::kShapeSpecific, localFrame);; 1569 Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; 1570 ; 1571 // If the viewer requires additional sections fetch from the shape (if possible); 1572 // and add again; 1573 if (reqSections != TBuffer3D::kNone) {; 1574 shape.GetBuffer3D(reqSections, localFrame);; 1575 viewer->AddObject(buffer, &addDaughters);; 1576 }; 1577 }; 1578 // Composite shapes have their own internal hierarchy of shapes, each; 1579 // of which generate a filled TBuffer3D. Therefore we can't pass up a; 1580 // single buffer to here. So as a special case the TGeoCompositeShape; 1581 // performs it's own painting & negotiation with the viewer.; 1582 else {; 1583 const TGeoCompositeShape *composite = static_cast<const TGeoCompositeShape *>(&shape);; 1584 ; 1585 // We need the addDaughters flag returned from the viewer from paint; 1586 // so can't use the normal TObject::Paint(); 1587 // TGeoHMatrix *matrix = (TGeoHMatrix*)TGeoShape::GetTransform();; 1588 // if (viewer->PreferLocalFrame()) matrix->Clear();; 1589 addDaughters = composite->PaintComposite(option);; 1590 }; 1591 ; 1592 return addDaughters;; 1593}; 1594 ; 1595////////////////////////////////////////////////////////////////////////////////; 1596/// Paint an overlap.; 1597 ; 1598void TGeoPainter::PaintShape(TGeoShape *shape, Option_t *option); 1599{; 1600 TGeoShape::SetTransform(fGlobal);; 1601 fGlobal->Clear();; 1602 fGeoManager->SetPaintVolume(nullptr);; 1603 PaintShape(*shape, option);; 1604}; 1605 ; 1606////////////////////////////////////////////////////////////////////////////////; 1607/// Paints a physica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:51146,perform,performs,51146,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['perform'],['performs']
Performance," neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1125700,load,load,1125700,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance," neural network on CPU using batches with size = 100; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.629 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Training Model Summary; custom objects for loading model : {'optimizer': <class 'torch.optim.adam.Adam'>, 'criterion': BCELoss(), 'train_func': <function fit at 0x7fe43c5d1b80>, 'predict_func': <function predict at 0x7fe43c5d1ca0>}; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:16428,load,loaded,16428,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loaded']
Performance," new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }. SinceROOT version 6.07/03:; A second rendering technique is also available with the COL2 and COLZ2 options.; These options provide potential performance improvements compared to the standard COL option. The performance comparison of the COL2 to the COL option depends on the histogram and the size of the rendering region in the current pad. In general, a small (approx. less than 100 bins per axis), sparsely populated TH2 will render faster with the COL option.; However, for larger histograms (approx. more than 100 bins per axis) that are not sparse, the COL2 option will provide up to 20 times performance improvements. For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude faster with the COL2 option.; The COL2 option will also scale its performance based on the size of the pixmap the histogram image is being rendered into. It also is much better optimized for sessions where the user is forwarding X11 windows through an ssh connection.; For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL and COLZ options. There is one major difference and that concerns the treatment of bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector graphics file format like PostScript or PDF (an empty image will be generated). It can be saved only in bitmap files like PNG format for instance. The CANDLE and VIOLIN options; The mechanism behind Candle plots and Violin plots is very similar. Because of this they are implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of the corresponding plots. Followed by the keyword the user can select a plot direction (X or V for vertical projec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:48597,perform,performance,48597,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['perform'],['performance']
Performance," new entry will make the block switch to bits representation. ;  ; Int_t GetEntry (Int_t entry);  Return entry #entry. ;  ; Int_t GetNPassed ();  Returns the number of entries, passing the selection. ;  ; Int_t GetType ();  ; TClass * IsA () const override;  ; Int_t Merge (TEntryListBlock *block);  Merge with the other block Returns the resulting number of entries in the block. ;  ; Int_t Next ();  Return the next non-zero entry Faster than GetEntry() function. ;  ; TEntryListBlock & operator= (const TEntryListBlock &rhs);  ; void OptimizeStorage ();  If there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. ;  ; void Print (const Option_t *option="""") const override;  Print the entries in this block. ;  ; void PrintWithShift (Int_t shift) const;  Print the indices of this block + shift (used from TEntryList::Print()) to print the current values. ;  ; bool Remove (Int_t entry);  Remove entry #entry If the block has already been optimized and the entries are stored as a list and not as bits, trying to remove a new entry will make the block switch to bits representation. ;  ; void ResetIndices ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListBlock.html:3640,optimiz,optimized,3640,doc/master/classTEntryListBlock.html,https://root.cern,https://root.cern/doc/master/classTEntryListBlock.html,1,['optimiz'],['optimized']
Performance," newBsize = bmin;; 7133 if (newBsize > 10000000) newBsize = bmax;; 7134 if (pass) {; 7135 if (pDebug) Info(""OptimizeBaskets"", ""Changing buffer size from %6d to %6d bytes for %s\n"",oldBsize,newBsize,branch->GetName());; 7136 branch->SetBasketSize(newBsize);; 7137 }; 7138 newMemsize += newBsize;; 7139 // For this number to be somewhat accurate when newBsize is 'low'; 7140 // we do not include any space for meta data in the requested size (newBsize) even-though SetBasketSize will; 7141 // not let it be lower than 100+TBranch::fEntryOffsetLen.; 7142 newBaskets += 1+Int_t(totBytes/newBsize);; 7143 if (pass == 0) continue;; 7144 //Reset the compression level in case the compression factor is small; 7145 Double_t comp = 1;; 7146 if (branch->GetZipBytes() > 0) comp = totBytes/Double_t(branch->GetZipBytes());; 7147 if (comp > 1 && comp < minComp) {; 7148 if (pDebug) Info(""OptimizeBaskets"", ""Disabling compression for branch : %s\n"",branch->GetName());; 7149 branch->SetCompressionSettings(ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);; 7150 }; 7151 }; 7152 // coverity[divide_by_zero] newMemsize can not be zero as there is at least one leaf; 7153 memFactor = Double_t(maxMemory)/Double_t(newMemsize);; 7154 if (memFactor > 100) memFactor = 100;; 7155 Double_t bmin_new = bmin*memFactor;; 7156 Double_t bmax_new = bmax*memFactor;; 7157 static const UInt_t hardmax = 1*1024*1024*1024; // Really, really never give more than 1Gb to a single buffer.; 7158 ; 7159 // Really, really never go lower than 8 bytes (we use this number; 7160 // so that the calculation of the number of basket is consistent; 7161 // but in fact SetBasketSize will not let the size go below; 7162 // TBranch::fEntryOffsetLen + (100 + strlen(branch->GetName()); 7163 // (The 2nd part being a slight over estimate of the key length.; 7164 static const UInt_t hardmin = 8;; 7165 bmin = (bmin_new > hardmax) ? hardmax : ( bmin_new < hardmin ? hardmin : (UInt_t)bmin_new );; 7166 bmax = (bmax_new > hardmax) ? bmin : (UInt_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:280778,Optimiz,OptimizeBaskets,280778,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Optimiz'],['OptimizeBaskets']
Performance," newname = 0); Regular copy ctor. RooVectorDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). RooVectorDataStore(const RooVectorDataStore& other, const RooArgSet& vars, const char* newname = 0); Clone ctor, must connect internal storage to given new external set of vars. RooVectorDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). ~RooVectorDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. const RooArgSet* getNative(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); throw(std::string(""RooVectorDataSore::loadValues() NOT IMPLEMENTED"")) ;. Bool_t changeObservableName(const char* from, const char* to). RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added elem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:13003,Load,Load,13003,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,4,['Load'],['Load']
Performance," newname = nullptr . ). Definition at line 248 of file RooTreeDataStore.cxx. ◆ RooTreeDataStore() [8/8]. RooTreeDataStore::RooTreeDataStore ; (; const RooTreeDataStore & ; other, . const RooArgSet & ; vars, . const char * ; newname = nullptr . ). Definition at line 268 of file RooTreeDataStore.cxx. ◆ ~RooTreeDataStore(). RooTreeDataStore::~RooTreeDataStore ; (; ). override . Destructor. ; Definition at line 291 of file RooTreeDataStore.cxx. Member Function Documentation. ◆ addColumn(). RooAbsArg * RooTreeDataStore::addColumn ; (; RooAbsArg & ; newVar, . bool ; adjustRange = true . ). overridevirtual . Add a new column to the data set which holds the pre-calculated values of 'newVar'. ; This operation is only meaningful if 'newVar' is a derived value.; The return value points to the added element holding 'newVar's value in the data collection. The element is always the corresponding fundamental type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar); Note: This function is explicitly NOT intended as a speed optimization opportunity for the user. Components of complex PDFs that can be precalculated with the dataset are automatically identified as such and will be precalculated when fitting to a dataset; By forcibly precalculating functions with non-trivial Jacobians, or functions of multiple variables occurring in the data set, using addColumn(), you may alter the outcome of the fit.; Only in cases where such a modification of fit behaviour is intentional, this function should be used. ; Implements RooAbsDataStore.; Definition at line 782 of file RooTreeDataStore.cxx. ◆ append(). void RooTreeDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 867 of file RooTreeDataStore.cxx. ◆ attachBuffers(). void RooTreeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1036 of file RooTreeDataStore.cxx. ◆ attachCache(). void RooTreeD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:26579,optimiz,optimization,26579,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['optimiz'],['optimization']
Performance," ninput); ; ; dataloader.AddSignalTree(signalTree, 1.0); dataloader.AddBackgroundTree(background, 1.0); ; # check given input; datainfo = dataloader.GetDataSetInfo(); vars = datainfo.GetListOfVariables(); print(""number of variables is {}"".format(vars.size())); ; ; for v in vars:; print(v); ; nTrainSig = 0.8 * nTotEvts; nTrainBkg = 0.8 * nTotEvts; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = """" # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = """"; ; # build the string options for DataLoader::PrepareTrainingAndTestTree; dataloader.PrepareTrainingAndTestTree(; mycuts,; mycutb,; nTrain_Signal=nTrainSig,; nTrain_Background=nTrainBkg,; SplitMode=""Random"",; SplitSeed=100,; NormMode=""NumEvents"",; V=False,; CalcCorrelations=False,; ); ; print(""prepared DATA LOADER ""); ; ; ## Book TMVA recurrent models; ; # Book the different types of recurrent models in TMVA (SimpleRNN, LSTM or GRU); ; ; if useTMVA_RNN:; for i in range(3):; if not use_rnn_type[i]:; continue; ; rnn_type = rnn_types[i]; ; ## Define RNN layer layout; ## it should be LayerType (RNN or LSTM or GRU) | number of units | number of inputs | time steps | remember output (typically no=0 | return full sequence; rnnLayout = str(rnn_type) + ""|10|"" + str(ninput) + ""|"" + str(ntime) + ""|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR""; ; ## Defining Training strategies. Different training strings can be concatenate. Use however only one; trainingString1 = ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize="" + str(batchSize); trainingString1 += "",TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs="" + str(maxepochs); trainingString1 += ""Optimizer=ADAM,DropConfig=0.0+0.+0.+0.""; ; ## define the inputlayout string for RNN; ## the input data should be organize as following:; ##/ input layout for RNN: time x ndim; ## add after RNN a reshape layer (needed top flatten the output) and a dense layer with 64 units and a last one; ## Note t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:56242,LOAD,LOADER,56242,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['LOAD'],['LOADER']
Performance," nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain the absolute filename if found. Returns lib if found, or NULL; 2031/// if a library called lib was not found.; 2032/// This function does ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64730,Load,Load,64730,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,"['Load', 'load']","['Load', 'loadedlibs']"
Performance," no default constructor; 88 Factory( TString theJobName, TFile* theTargetFile, TString theOption = """" );; 89 ; 90 // constructor to work without file; 91 Factory( TString theJobName, TString theOption = """" );; 92 ; 93 // default destructor; 94 virtual ~Factory();; 95 ; 96 // use TName::GetName and define correct name in constructor; 97 //virtual const char* GetName() const { return ""Factory""; }; 98 ; 99 ; 100 MethodBase* BookMethod( DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption = """" );; 101 MethodBase* BookMethod( DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption = """" );; 102 MethodBase* BookMethod( DataLoader *, TMVA::Types::EMVA /*theMethod*/,; 103 TString /*methodTitle*/,; 104 TString /*methodOption*/,; 105 TMVA::Types::EMVA /*theComposite*/,; 106 TString /*compositeOption = """"*/ ) { return nullptr; }; 107 ; 108 // optimize all booked methods (well, if desired by the method); 109 std::map<TString,Double_t> OptimizeAllMethods (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 110 void OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 111 void OptimizeAllMethodsForRegression (TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 112 ; 113 // training for all booked methods; 114 void TrainAllMethods ();; 115 void TrainAllMethodsForClassification( void ) { TrainAllMethods(); }; 116 void TrainAllMethodsForRegression ( void ) { TrainAllMethods(); }; 117 ; 118 // testing; 119 void TestAllMethods();; 120 ; 121 // performance evaluation; 122 void EvaluateAllMethods( void );; 123 void EvaluateAllVariables(DataLoader *loader, TString options = """" );; 124 ; 125 TH1F* EvaluateImportance( DataLoader *loader,VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption = """" );; 126 ; 127 // delete all methods and reset the method vector; 128 void DeleteAllMeth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:4157,Optimiz,OptimizeAllMethods,4157,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['Optimiz'],['OptimizeAllMethods']
Performance," no partition cell number. TH2Poly(const char* name, const char* title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); Constructor with specified name and boundaries and partition cell number. ~TH2Poly(); Destructor. Int_t AddBin(TObject* poly); Adds a new bin to the histogram. It can be any object having the method; IsInside(). It returns the bin number in the histogram. It returns 0 if; it failed to add. To allow the histogram limits to expand when a bin; outside the limits is added, call SetFloat() before adding the bin. Int_t AddBin(Int_t n, const Double_t* x, const Double_t* y); Adds a new bin to the histogram. The number of vertices and their (x,y); coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. void Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. void Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned areas in; the his",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TH2Poly.html:31982,Perform,Performs,31982,root/html530/TH2Poly.html,https://root.cern,https://root.cern/root/html530/TH2Poly.html,2,['Perform'],['Performs']
Performance," node name. ;  ; virtual int GetCpuInfo (CpuInfo_t *info, Int_t sampleTime=1000) const;  Returns cpu load average and load info into the CpuInfo_t structure. ;  ; virtual Int_t GetCryptoRandom (void *buf, Int_t len);  Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ;  ; virtual TString GetDirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual const char * GetDynamicPath ();  Return the dynamic path (used to find shared libraries). ;  ; virtual Int_t GetEffectiveGid ();  Returns the effective group id. ;  ; virtual Int_t GetEffectiveUid ();  Returns the effective user id. ;  ; virtual const char * Getenv (const char *env);  Get environment variable. ;  ; virtual const char * GetError ();  Return system error string. ;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Return the debug flags. ;  ; virtual const char * GetFlagsOpt () const;  Return the optimization flags. ;  ; virtual Int_t GetFPEMask ();  Return the bitmap of conditions that trigger a floating point exception. ;  ; virtual TString GetFromPipe (const char *command);  Execute command and return output in TString. ;  ; virtual int GetFsInfo (const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree);  Get info about a file system: fs type, block size, number of blocks, number of free blocks. ;  ; virtual Int_t GetGid (const char *group=nullptr);  Returns the group's id. If group = 0, returns current user's group. ;  ; virtual UserGroup_t * GetGroupInfo (const char *group=nullptr);  Returns all group info in the UserGroup_t structure. ;  ; virtual UserGroup_t * GetGroupInfo (Int_t gid);  Returns all group info in the UserGroup_t structure. ;  ; virtual std::string GetHomeDirectory (const char *userName=nullptr) const;  Return the user's home directory. ;  ; virtual TInetAddress GetHostByName (const char *server);  Get Internet Proto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:7599,optimiz,optimization,7599,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,3,['optimiz'],['optimization']
Performance, nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration spe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:39776,cache,cache,39776,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,2,['cache'],['cache']
Performance, nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input sh,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:40158,cache,cache,40158,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,2,['cache'],['cache']
Performance, nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGaussModel.html:40479,cache,cache,40479,root/html530/RooGaussModel.html,https://root.cern,https://root.cern/root/html530/RooGaussModel.html,2,['cache'],['cache']
Performance, nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of ser,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:40882,cache,cache,40882,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,2,['cache'],['cache']
Performance," non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:54195,cache,cache,54195,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['cache'],['cache']
Performance," normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPEffDecay.html:41180,cache,cache,41180,root/html530/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPEffDecay.html,1,['cache'],['cache']
Performance," normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBDecay.html:41028,cache,cache,41028,root/html530/RooBDecay.html,https://root.cern,https://root.cern/root/html530/RooBDecay.html,1,['cache'],['cache']
Performance," normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for curre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDecay.html:40712,cache,cache,40712,root/html530/RooDecay.html,https://root.cern,https://root.cern/root/html530/RooDecay.html,1,['cache'],['cache']
Performance, not allowed in this class. ; See TList::GetObjectRef for the intended behavior. ; Reimplemented from TList.; Definition at line 271 of file TViewPubFunctions.cxx. ◆ GetSize(). Int_t TViewPubFunctions::GetSize ; (; ); const. overridevirtual . Return the total number of public methods (currently loaded in the list of functions) in this class and all its base classes. ; Reimplemented from TCollection.; Definition at line 281 of file TViewPubFunctions.cxx. ◆ Last(). TObject * TViewPubFunctions::Last ; (; ); const. overrideprotectedvirtual . Last is not allowed in this class. ; See TList::Last for the intended behavior. ; Reimplemented from TList.; Definition at line 310 of file TViewPubFunctions.cxx. ◆ LastLink(). TObjLink * TViewPubFunctions::LastLink ; (; ); const. overrideprotectedvirtual . LastLink is not allowed in this class. ; See TList::LastLink for the intended behavior. ; Reimplemented from TList.; Definition at line 320 of file TViewPubFunctions.cxx. ◆ Load(). void TViewPubFunctions::Load ; (; ). Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes. ; Definition at line 298 of file TViewPubFunctions.cxx. ◆ MakeIterator(). TIterator * TViewPubFunctions::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 122 of file TViewPubFunctions.cxx. ◆ operator=(). TViewPubFunctions & TViewPubFunctions::operator= ; (; const TViewPubFunctions & ; ). privatedelete . ◆ RecursiveRemove(). void TViewPubFunctions::RecursiveRemove ; (; TObject * ; obj). overrideprotectedvirtual . RecursiveRemove is not allowed in this class. ; See TList::RecursiveRemove for the intended behavior. ; Reimplemented from TList.; Definition at line 330 of file TViewPubFunctions.cxx. ◆ Remove() [1/2]. TObject * TViewPubFunctions::Remove ; (; TObject * ; obj). overrideprotectedvirtual . Remove is not allowed in this class. ; See TList::Remove for the intended behavior,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTViewPubFunctions.html:27216,Load,Load,27216,doc/master/classTViewPubFunctions.html,https://root.cern,https://root.cern/doc/master/classTViewPubFunctions.html,1,['Load'],['Load']
Performance," not available the; text is drawn with TGX11::DrawText. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. RXImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font properties. void DrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); Draw text string. TGX11TTF(const TGX11& org). virtual ~TGX11TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x11ttf:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11TTF.html:28871,Load,LoadQueryFont,28871,root/html602/TGX11TTF.html,https://root.cern,https://root.cern/root/html602/TGX11TTF.html,2,['Load'],['LoadQueryFont']
Performance," not belong to any directory.; 2665 ; 2666void TChain::SetDirectory(TDirectory* dir); 2667{; 2668 if (fDirectory == dir) return;; 2669 if (fDirectory) fDirectory->Remove(this);; 2670 fDirectory = dir;; 2671 if (fDirectory) {; 2672 fDirectory->Append(this);; 2673 fFile = fDirectory->GetFile();; 2674 } else {; 2675 fFile = nullptr;; 2676 }; 2677}; 2678 ; 2679////////////////////////////////////////////////////////////////////////////////; 2680/// \brief Set the input entry list (processing the entries of the chain will; 2681/// then be limited to the entries in the list).; 2682///; 2683/// \param[in] elist The entry list to be assigned to this chain.; 2684/// \param[in] opt An option string. Possible values are:; 2685/// - """" (default): both the file names of the chain elements and the file; 2686/// names of the TEntryList sublists are expanded to full path name.; 2687/// - ""ne"": the file names are taken as they are and not expanded; 2688/// - ""sync"": the TChain will go through the TEntryList in lockstep with the; 2689/// trees in the chain rather than performing a lookup based on; 2690/// treename and filename. This is mostly useful when the TEntryList; 2691/// has multiple sublists for the same tree and filename.; 2692/// \throws std::runtime_error If option ""sync"" was chosen and either:; 2693/// - \p elist doesn't have sub entry lists.; 2694/// - the number of sub entry lists in \p elist is different than the; 2695/// number of trees in the chain.; 2696/// - any of the sub entry lists in \p elist doesn't correspond to the; 2697/// tree of the chain with the same index (i.e. it doesn't share the; 2698/// same tree name and file name).; 2699///; 2700/// This function finds correspondence between the sub-lists of the TEntryList; 2701/// and the trees of the TChain.; 2702 ; 2703void TChain::SetEntryList(TEntryList *elist, Option_t *opt); 2704{; 2705 if (fEntryList){; 2706 //check, if the chain is the owner of the previous entry list; 2707 //(it happens, if the previous",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:97374,perform,performing,97374,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['perform'],['performing']
Performance," not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:8268,perform,performing,8268,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['perform'],['performing']
Performance," not enforced at run-time).; The third requirement, only necessary if you want to have class signals (i.e. for all objects of a class), is that you have to replace the standard ClassImp macro by ClassImpQ.; Signals are currently implemented for all ROOT GUI classes and the TTimer and TCanvas classes (to find quickly all defined signals do for example: grep '*SIGNAL*' $ROOTSYS/include/*.h).; 26.6 Examples; 26.6.1 A First Time Example (rqfirst.C); This example shows:. How to create interpreted class with signals with different types/number of arguments.; How to connect signals to slots.; How to activate signals. 26.6.2 Histogram Filling with Dynamic State Reported via Signals (rqsimple.C); Based on hsimple this example demonstrates:. All features of the hsimple example.; How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; How to use the TTimer class for emulation of “multithreading”.; How to use signals for the concurrent update of pad, file, benchmark facility, etc. 26.6.3 An Example on How to Use Canvas Event Signals (rqfiller.C); This example shows:. How the object communication mechanism can be used for handling the TCanvas’s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. Click the left button or move mouse with button pressed to fill histograms.; Use the right button of the mouse to reset the histograms. 26.6.4 Complex GUI Using Signals and Slots (guitest.C); Based on $ROOTSYS/test/guitest.cxx this example demonstrates:. All features of the original compiled guitest.cxx program.; Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program. 27 Automatic HTML Documentation. THtml is ROOT’s documentation engine. It can be used to document your classes in a reference guide, and to convert your text or source files to HTML.; 27.1 Reference Guide; The Reference Guide for the ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1239068,concurren,concurrent,1239068,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['concurren'],['concurrent']
Performance," not have the library defining the class. ;  ; static void StreamerTObjectInitialized (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of TObjects when fIsOffsetStreamerSet is known to have been set. ;  . Private Attributes; TViewPubDataMembers * fAllPubData;  ; TViewPubFunctions * fAllPubMethod;  ; std::atomic< TList * > fBase;  ; std::atomic< Bool_t > fCanLoadClassInfo;  Whether info was loaded from a root pcm. ;  ; std::atomic< Char_t > fCanSplit;  ; std::atomic< UInt_t > fCheckSum;  ; ClassInfo_t * fClassInfo;  ; TList * fClassMenuList;  ; Long_t fClassProperty;  Property See TClass::Property() for details. ;  ; Version_t fClassVersion;  ; TVirtualCollectionProxy * fCollectionProxy;  ; TString fContextMenuTitle;  ; ConvSIMap_t fConversionStreamerInfo;  ; ClassConvStreamerFunc_t fConvStreamerFunc;  ; std::atomic< TVirtualStreamerInfo * > fCurrentInfo;  Current 'state' of the class (Emulated,Interpreted,Loaded) ;  ; std::atomic< TListOfDataMembers * > fData;  ; Short_t fDeclFileLine;  ; const char * fDeclFileName;  ; ROOT::DelFunc_t fDelete;  ; ROOT::DelArrFunc_t fDeleteArray;  ; ROOT::DesFunc_t fDestructor;  ; ROOT::DirAutoAdd_t fDirAutoAdd;  ; std::atomic< TListOfEnums * > fEnums;  ; TListOfFunctionTemplates * fFuncTemplate;  ; IsAGlobalFunc_t fGlobalIsA;  pointer to the class's IsA proxy. ;  ; Bool_t fHasCustomStreamerMember: 1;  The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ;  ; std::atomic< Bool_t > fHasRootPcmInfo;  C++ Property of the class (is abstract, has virtual table, etc.) ;  ; Short_t fImplFileLine;  ; const char * fImplFileName;  ; UInt_t fInstanceCount;  ; TVirtualIsAProxy * fIsA;  ; std::atomic< TMethodCall * > fIsAMethod;  ; std::atomic< Bool_t > fIsOffsetStreamerSet;  Indicates whether the ClassInfo is supposed to be available. ;  ; Bool_t fIsSyntheticPair: 1;  Indicates whether this class can be split or not. Values are -1, 0, 1, 2. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:43938,Load,Loaded,43938,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['Load'],['Loaded']
Performance," not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:35700,cache,cache,35700,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['cache'],['cache']
Performance," not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:37555,cache,cache,37555,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,1,['cache'],['cache']
Performance," not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:45198,cache,cache,45198,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,1,['cache'],['cache']
Performance," not positive defined status = 1 : covariance only approximate status = 2 : full matrix but forced pos def status = 3 : full accurate matrix ;  ; double Edm () const override;  return expected distance reached from the minimum ;  ; const double * Errors () const override;  return errors at the minimum ;  ; bool FixVariable (unsigned int ivar) override;  fix an existing variable ;  ; bool GetCovMatrix (double *cov) const override;  Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. ;  ; bool GetHessianMatrix (double *h) const override;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; bool GetMinosError (unsigned int i, double &errLow, double &errUp, int=0) override;  get the minos error for parameter i, return false if Minos failed A minimizaiton must be performed befre, return false if no minimization has been done In case of Minos failed the status error is updated as following status += 10 * minosStatus. ;  ; bool GetVariableSettings (unsigned int ivar, ROOT::Fit::ParameterSettings &varObj) const override;  get variable settings in a variable object (like ROOT::Fit::ParamsSettings) ;  ; double GlobalCC (unsigned int i) const override;  get global correlation coefficient for the variable i. ;  ; bool Hesse () override;  perform a full calculation of the Hessian matrix for error calculation If a valid minimum exists the calculation is done on the minimum point otherwise is performed in the current set values of parameters Status code of minimizer is updated according to the following convention (in case Hesse failed) status += 100*hesseStatus where hesse status is: status = 1 : hesse failed status = 2 : matrix inversion failed status = 3 : matrix is not pos defined ;  ; bool IsFixedVariable (unsigned int ivar) const overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:2995,perform,performed,2995,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['perform'],['performed']
Performance," not supported"");; 960 return TTree::GetClusterIterator(-1);; 961}; 962 ; 963////////////////////////////////////////////////////////////////////////////////; 964/// Return absolute entry number in the chain.; 965/// The input parameter entry is the entry number in; 966/// the current tree of this chain.; 967 ; 968Long64_t TChain::GetChainEntryNumber(Long64_t entry) const; 969{; 970 return entry + fTreeOffset[fTreeNumber];; 971}; 972 ; 973////////////////////////////////////////////////////////////////////////////////; 974/// Return the total number of entries in the chain.; 975/// In case the number of entries in each tree is not yet known,; 976/// the offset table is computed.; 977 ; 978Long64_t TChain::GetEntries() const; 979{; 980 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 981 // Make sure the element list is up to date; 982 if (!TestBit(kProofUptodate)); 983 Warning(""GetEntries"", ""PROOF proxy not up-to-date:""; 984 "" run TChain::SetProof(true, true) first"");; 985 return fProofChain->GetEntries();; 986 }; 987 if (fEntries == TTree::kMaxEntries) {; 988 const_cast<TChain*>(this)->LoadTree(TTree::kMaxEntries-1);; 989 }; 990 return fEntries;; 991}; 992 ; 993////////////////////////////////////////////////////////////////////////////////; 994/// Get entry from the file to memory.; 995///; 996/// - getall = 0 : get only active branches; 997/// - getall = 1 : get all branches; 998///; 999/// Return the total number of bytes read,; 1000/// 0 bytes read indicates a failure.; 1001 ; 1002Int_t TChain::GetEntry(Long64_t entry, Int_t getall); 1003{; 1004 Long64_t treeReadEntry = LoadTree(entry);; 1005 if (treeReadEntry < 0) {; 1006 return 0;; 1007 }; 1008 if (!fTree) {; 1009 return 0;; 1010 }; 1011 return fTree->GetEntry(treeReadEntry, getall);; 1012}; 1013 ; 1014////////////////////////////////////////////////////////////////////////////////; 1015/// Return entry number corresponding to entry.; 1016///; 1017/// if no TEntryList set returns entry; 1018/// else ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:37245,Load,LoadTree,37245,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5634 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5619 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 597 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:19018,multi-thread,multi-threading,19018,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5663 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5648 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 596 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:18926,multi-thread,multi-threading,18926,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5847 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5832 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 543 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:19616,multi-thread,multi-threading,19616,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5861 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5846 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 542 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:19655,multi-thread,multi-threading,19655,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5870 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5855 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:22674,multi-thread,multi-threading,22674,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5884 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:24436,multi-thread,multi-threading,24436,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5884 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:31433,multi-thread,multi-threading,31433,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance," not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__Fitter.html:6466,perform,perform,6466,root/html528/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__Fitter.html,1,['perform'],['perform']
Performance," nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; TList*fFileNodesnodes with files; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Long64_t GetEntrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizer.html:10808,perform,performance,10808,root/html602/TPacketizer.html,https://root.cern,https://root.cern/root/html602/TPacketizer.html,1,['perform'],['performance']
Performance," notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_weightSqApply weights squared?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNLLVar(const char* name, const char* title, RooAbsPdf& pdf, RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:43878,cache,cache,43878,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['cache'],['cache']
Performance," nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); intidxmax(const double& m) const; intidxmin(const double& m) const; Int_tij(const Int_t& i, const Int_t& j) const; Bool_tRooAbsArg::inhibitDirty() const; voidinitialize(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMomentMorph.html:35856,optimiz,optimizeDirtyHook,35856,root/html534/RooMomentMorph.html,https://root.cern,https://root.cern/root/html534/RooMomentMorph.html,1,['optimiz'],['optimizeDirtyHook']
Performance," nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidnormLeafServerList(RooArgSet& list) const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:23100,optimiz,optimizeCacheMode,23100,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,2,['optimiz'],['optimizeCacheMode']
Performance," null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.; If we have no index, our entry number and the masterTree entry number are the same.; If we do have an index, we must find the (major, minor) value pair in masterTree to locate our corresponding entry. ; Definition at line 6557 of file TTree.cxx. ◆ MakeClass(). Int_t TTree::MakeClass ; (; const char * ; classname = nullptr, . Option_t * ; option = """" . ). virtual . Generate a skeleton analysis class for this tree. ; The following files are produced: classname.h and classname.C. If classname is 0, classname will be called ""nameoftree"".; The generated code in classname.h includes the following:. Identification of the original tree and the input file name.; Definition of an ana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:173843,Load,LoadTreeFriend,173843,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['Load'],['LoadTreeFriend']
Performance," nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void setExtended (bool extended);  . Static Private Member Functions; static double analyticalIntegralWN (RooAbsReal const &caller, RooObjCacheManager &normIntMgr, RooArgList const &funcList, RooArgList const &coefList, Int_t code, const RooArgSet *normSet, const char *rangeName, bool hasWarnedBefore);  ; static std::list< double > * binBoundaries (RooArgList const &funcList, RooAbsRealLValue &, double, double);  ; static bool checkObservables (RooAbsReal const &caller, RooArgSet const *nset, RooArgList const &funcList, RooArgList const &coefList);  ; static double evaluate (RooAbsReal const &caller, RooArgList const &funcList, RooArgList const &coefList, bool doFloor, bool &hasWarnedBefore);  ; static Int_t getAnalyticalIntegralWN (RooAbsReal const &caller, RooObjCacheManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:64948,cache,cache,64948,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['cache'],['cache']
Performance," nullptr;; 895}; 896 ; 897////////////////////////////////////////////////////////////////////////////////; 898/// Returns the expanded value of the alias. Search in the friends if any.; 899 ; 900const char* TChain::GetAlias(const char* aliasName) const; 901{; 902 const char* alias = TTree::GetAlias(aliasName);; 903 if (alias) {; 904 return alias;; 905 }; 906 if (fTree) {; 907 return fTree->GetAlias(aliasName);; 908 }; 909 const_cast<TChain*>(this)->LoadTree(0);; 910 if (fTree) {; 911 return fTree->GetAlias(aliasName);; 912 }; 913 return nullptr;; 914}; 915 ; 916////////////////////////////////////////////////////////////////////////////////; 917/// Return pointer to the branch name in the current tree.; 918 ; 919TBranch* TChain::GetBranch(const char* name); 920{; 921 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 922 // Make sure the element list is up to date; 923 if (!TestBit(kProofUptodate)); 924 SetProof(true, true);; 925 return fProofChain->GetBranch(name);; 926 }; 927 if (fTree) {; 928 return fTree->GetBranch(name);; 929 }; 930 LoadTree(0);; 931 if (fTree) {; 932 return fTree->GetBranch(name);; 933 }; 934 return nullptr;; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// See TTree::GetReadEntry().; 939 ; 940bool TChain::GetBranchStatus(const char* branchname) const; 941{; 942 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 943 // Make sure the element list is up to date; 944 if (!TestBit(kProofUptodate)); 945 Warning(""GetBranchStatus"", ""PROOF proxy not up-to-date:""; 946 "" run TChain::SetProof(true, true) first"");; 947 return fProofChain->GetBranchStatus(branchname);; 948 }; 949 return TTree::GetBranchStatus(branchname);; 950}; 951 ; 952////////////////////////////////////////////////////////////////////////////////; 953/// Return an iterator over the cluster of baskets starting at firstentry.; 954///; 955/// This iterator is not yet supported for TChain object.; 956 ; 957TTree::TClust",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:35071,Load,LoadTree,35071,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance," number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddPdf.html:40683,cache,cache,40683,root/html528/RooAddPdf.html,https://root.cern,https://root.cern/root/html528/RooAddPdf.html,1,['cache'],['cache']
Performance, number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNume,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddPdf.html:40960,cache,cache,40960,root/html530/RooAddPdf.html,https://root.cern,https://root.cern/root/html530/RooAddPdf.html,1,['cache'],['cache']
Performance," numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:42254,cache,cache,42254,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance," numerical integration if flag set; TVectorD_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ixmax; Int_t_ixmin; Int_t_iymax; Int_t_iymin; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TMatrixD_mref; static Int_tRooPrintable::_nameLength; Int_t_npoints; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Roo2DMomentMorphFunction::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; int_squareIdx[4]; TMatrixD_squareVec; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_t_verbose; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DMomentMorphFunction.html:33918,cache,cache,33918,root/html532/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo2DMomentMorphFunction.html,1,['cache'],['cache']
Performance," obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:13040,cache,cache,13040,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,1,['cache'],['cache']
Performance," object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple caches without RooAbsArg payload. ;  ;  RooCacheManager (RooAbsArg *owner, Int_t maxSize=2);  Constructor for simple caches with RooAbsArg derived payload. ;  ;  ~RooCacheManager () override;  Destructor. ;  ; Int_t cacheSize () const;  Return size of cache. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIdx, const char *isetRangeName);  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Retrieve payload",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:2201,cache,cache,2201,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance," object like for example:; root [1] serv = new THttpServer(""http:8080"");; root [2] TNamed* n1 = new TNamed(""obj"", ""title"");; root [3] serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 50331656,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. root.bin - binary data produced by object streaming with TBufferFile; root.json - ROOT JSON representation for object and objects members; root.xml - ROOT XML representation; root.png - PNG image (if object drawing implemented); root.gif - GIF image; root.jpeg - JPEG image; exe.json - method execution in the object; exe.bin - method execution, return result in binary form; cmd.json - command execution; item.json - item (object) properties, specified on the server; multi.json - perform several requests at once; multi.bin - perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.7.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: “title”.; For the root.json request one could specify the ‘compact’ parameter, w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:10461,perform,perform,10461,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['perform'],['perform']
Performance," objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPython.html:1503,Load,LoadMacro,1503,root/html530/TPython.html,https://root.cern,https://root.cern/root/html530/TPython.html,3,['Load'],['LoadMacro']
Performance," objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the Cling side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPython.html:1504,Load,LoadMacro,1504,root/html602/TPython.html,https://root.cern,https://root.cern/root/html602/TPython.html,2,['Load'],['LoadMacro']
Performance," objects that are seen when visualizing or tracking the geometry are depicted in the TOP_1 branch. These are the nodes of the physical tree of positioned volumes represented by TGeoNode objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at TGeoManage.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selected will also open its context menu (picking). Note that there are several actions that can be performed both at view (no volume selected) and volume level.; TView (mouse not selecting any volume):. Click-and-drag rotates the view.; Pressing some keys perform different actions:; J/K - zoom / unzoom; H, L, U, I - move the viewpoint; Right click + SetParallel ()/SetPerspective () - switch from parallel to perspective view.; Right click + ShowAxis() - show coordinate axes.; Right click + Centered/Left/Side/Top - change view direction. TGeoVolume (mouse selecting a volume):. Double click will focus the corresponding volume.; Right click + CheckOverlaps() - run overlap checker on current volume.; Right click + Draw () - draw that volume according current global visualization options; Right click + DrawOnly() - draw only the selected volume.; Right click + InspectShape/Material() - print info about shape or material.; Right click + Raytrace() - initiate a ray tracing algorithm on current view.; Right click + RandomPoints/Rays() - shoot random points or rays inside the bounding box of the cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:14288,perform,performed,14288,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performed']
Performance," objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindCPAsymVar(); Default constructor. RooUnblindCPAsymVar(const char* name, const char* title, const char* blindStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:36961,cache,cache,36961,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance," objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:39936,cache,cache,39936,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['cache'],['cache']
Performance," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashList.html:15078,perform,performance,15078,root/html534/THashList.html,https://root.cern,https://root.cern/root/html534/THashList.html,1,['perform'],['performance']
Performance," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 16:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THashList.html:15641,perform,performance,15641,root/html604/THashList.html,https://root.cern,https://root.cern/root/html604/THashList.html,1,['perform'],['performance']
Performance," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 15:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashList.html:15641,perform,performance,15641,root/html602/THashList.html,https://root.cern,https://root.cern/root/html602/THashList.html,1,['perform'],['performance']
Performance, objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of contex-menu toggle objects; TTree Tree descriptor (the main ROOT I/O class); TTreeCache Specialization of TFileCacheRead for a TTree; TTreeCacheUnzip Specialization of TTreeCache for parallel unzipping; TTreeCloner helper used for the fast cloning of TTrees.; TTreeDrawArgsParser Helper class to parse the argument to TTree::Draw; TTreeFormula The Tree formula; TTreeFormulaManager A class coordinating several TTreeFormula objects.; TTreeFriendLeafIter Linked list iterator; TTreeIndex A Tree Index with majorname and minorname.; TTreeInput Simple input dialog; TTreePerfStats TTree I/O performance measurement; TTreePlayer Manager class to play with TTrees; TTreeResult TTree query result; TTreeRow One row of an TTree query result; TTreeSQL TTree Implementation read and write to a SQL database.; TTreeTableInterface Interface to data in a TTree; TTreeViewer A GUI oriented tree viewer; TUDPSocket This class implements UDP client sockets; TUUID Universally Unique IDentifier; TUnfold Unfolding with support for L-curve analysis; TUnfoldSys Unfolding with support for systematic error propagation; TUnixSystem Interface to Unix OS services; TUnuran ; TUnuranBaseDist Base class for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution ; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUploadDataSetDlg New query dialog; TUri Represents an URI; TUrl Represents an URL; TVector2 A 2D physics vector; TVector3 A 3D physics vector;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:132199,perform,performance,132199,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['perform'],['performance']
Performance, objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of contex-menu toggle objects; TTree Tree descriptor (the main ROOT I/O class); TTreeCache Specialization of TFileCacheRead for a TTree; TTreeCacheUnzip Specialization of TTreeCache for parallel unzipping; TTreeCloner helper used for the fast cloning of TTrees.; TTreeDrawArgsParser Helper class to parse the argument to TTree::Draw; TTreeFormula The Tree formula; TTreeFormulaManager A class coordinating several TTreeFormula objects.; TTreeFriendLeafIter Linked list iterator; TTreeIndex A Tree Index with majorname and minorname.; TTreeInput Simple input dialog; TTreePerfStats TTree I/O performance measurement; TTreePlayer Manager class to play with TTrees; TTreeResult TTree query result; TTreeRow One row of an TTree query result; TTreeSQL TTree Implementation read and write to a SQL database.; TTreeTableInterface Interface to data in a TTree; TTreeViewer A GUI oriented tree viewer; TUUID Universally Unique IDentifier; TUnfold Unfolding with support for L-curve analysis; TUnfoldSys Unfolding with support for systematic error propagation; TUnixSystem Interface to Unix OS services; TUnuran ; TUnuranBaseDist Base class for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution ; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUploadDataSetDlg New query dialog; TUri Represents an URI; TUrl Represents an URL; TVector2 A 2D physics vector; TVector3 A 3D physics vector; TVectorT<double> Template of Vector class; TVectorT<,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:129463,perform,performance,129463,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['perform'],['performance']
Performance, objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of contex-menu toggle objects; TTree Tree descriptor (the main ROOT I/O class); TTreeCache Specialization of TFileCacheRead for a TTree; TTreeCacheUnzip Specialization of TTreeCache for parallel unzipping; TTreeCloner helper used for the fast cloning of TTrees.; TTreeDrawArgsParser Helper class to parse the argument to TTree::Draw; TTreeFormula The Tree formula; TTreeFormulaManager A class coordinating several TTreeFormula objects.; TTreeFriendLeafIter Linked list iterator; TTreeIndex A Tree Index with majorname and minorname.; TTreeInput Simple input dialog; TTreePerfStats TTree I/O performance measurement; TTreePlayer Manager class to play with TTrees; TTreeResult TTree query result; TTreeRow One row of an TTree query result; TTreeSQL TTree Implementation read and write to a SQL database.; TTreeTableInterface Interface to data in a TTree; TTreeViewer A GUI oriented tree viewer; TUUID Universally Unique IDentifier; TUnfold Unfolding with support for L-curve analysis; TUnfoldSys Unfolding with support for systematic error propagation; TUnixSystem Interface to Unix OS services; TUnuran ; TUnuranBaseDist Base class for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution ; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUploadDataSetDlg New query dialog; TUri Represents an URI; TUrl Represents an URL; TVector2 A 2D physics vector; TVector3 A 3D physics vector; TVectorT<double> Template of Vector class; TVectorT<float> Template o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:123777,perform,performance,123777,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['perform'],['performance']
Performance, objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of contex-menu toggle objects; TTree Tree descriptor (the main ROOT I/O class); TTreeCache Specialization of TFileCacheRead for a TTree; TTreeCacheUnzip Specialization of TTreeCache for parallel unzipping; TTreeCloner helper used for the fast cloning of TTrees.; TTreeDrawArgsParser Helper class to parse the argument to TTree::Draw; TTreeFormula The Tree formula; TTreeFormulaManager A class coordinating several TTreeFormula objects.; TTreeFriendLeafIter Linked list iterator; TTreeIndex A Tree Index with majorname and minorname.; TTreeInput Simple input dialog; TTreePerfStats TTree I/O performance measurement; TTreePlayer Manager class to play with TTrees; TTreeResult TTree query result; TTreeRow One row of an TTree query result; TTreeSQL TTree Implementation read and write to a SQL database.; TTreeTableInterface Interface to data in a TTree; TUUID Universally Unique IDentifier; TUnfold Unfolding with support for L-curve analysis; TUnfoldSys Unfolding with support for systematic error propagation; TUnixSystem Interface to Unix OS services; TUnuran ; TUnuranBaseDist Base class for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution ; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUploadDataSetDlg New query dialog; TUri Represents an URI; TUrl Represents an URL; TVector2 A 2D physics vector; TVector3 A 3D physics vector; TVectorT<double> Template of Vector class; TVectorT<float> Template of Vector class; TView 3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:126393,perform,performance,126393,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['perform'],['performance']
Performance," obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFunctorPdfBinding&operator=(const RooFunctorPdfBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorPdfBinding.html:23392,optimiz,optimizeCacheMode,23392,root/html602/RooFunctorPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorPdfBinding.html,4,['optimiz'],['optimizeCacheMode']
Performance," observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:49316,cache,cache,49316,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,7,['cache'],['cache']
Performance," obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program Event will report the write performance. You can measure the read performance by executing the scripts eventa and eventb. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).; 12.24 Chains. A TChain object is a list of ROOT files containing the same tree. As an example, assume we have three files called file1.root, file2.root, file3.root. Each file contains one tree called “T”. We can create a chain with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a hash table. The class TChain is derived from the class TTree. For example, to generate a histogram corresponding to the attribute “x” in tree “T” by processing sequentially the three files of this chain, we can use the TChain::Draw method.; chain.Draw(""x"");; When using a TChain, the branch address",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:651158,perform,performance,651158,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ;  ; virtual void DrawSegments (Drawable_t id, GContext_t gc, Segment_t *seg, Int_t nseg);  Draws multiple line segments. ;  ; virtual void DrawString (Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char *s, Int_t len);  Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ;  ; virtual void DrawText (Int_t x, Int_t y, Float_t angle, Float_t mgn, const char *text, ETextMode mode);  Draws a text string using current font. ;  ; virtual void DrawText (Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t *text, ETextMode mode);  Draws a text string using current font. ;  ; virtual Bool_t EmptyRegion (Region_t reg);  Returns kTRUE if the region reg is empty. ;  ; virtual Bool_t EqualRegion (Region_t rega, Region_t regb);  Returns kTRUE if the two regions have the same offset, size, and shape. ;  ; virtual Int_t EventsPending ();  Returns the number of events that have been received from the X server but have not been removed from the event queue. ;  ; virtual UInt_t ExecCommand (TGWin32Command *code);  Executes the command ""code"" coming from the other threads (Win32) ;  ; virtual void FillPolygon (Window_t id, GContext_t gc, Point_t *points, Int_t npnt);  Fills the region closed by the specified path. ;  ; virtual void FillRectangle (Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h);  Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ;  ; virtual Window_t FindRWindow (Window_t win, Window_t dragwin, Window_t input, int x, int y, int maxd);  Recursively search in the children of Window for a Window which is at location x, y and is DND aware, with a maximum depth of maxd. ;  ; virtual void FlushOpenGLBuffer (Handle_t ctx);  Flushes OpenGL buffer. ;  ; virtual void FreeColor (Colormap_t cmap, ULong_t pixel);  Frees color cell with specified pixel value. ;  ; virtual void FreeFontNames (char **fontlist);  Frees t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:10748,queue,queue,10748,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['queue'],['queue']
Performance," of all data types and a page for each typedef-to-class. ;  ; virtual void CreateStyleSheet () const;  Write the default ROOT style sheet. ;  ; virtual bool GetDeclImplFileName (TClass *cl, bool filesys, bool decl, TString &out_name) const;  Combined implementation for GetDeclFileName(), GetImplFileName(): Return declaration / implementation file name (depending on decl); return the full path if filesys is true. ;  ; TClassDocInfo * GetNextClass ();  Return the next class to be generated for MakeClassThreaded. ;  ; void MakeClass (void *cdi, Bool_t force=kFALSE);  Make HTML files for a single class. ;  ; void SetLocalFiles () const;  Fill the files available in the file system below fPathInfo.fInputPath. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static void * MakeClassThreaded (void *info);  Entry point of worker threads for multi-threaded MakeAll(). ;  . Protected Attributes; Bool_t fBatch;  ; TString fCounter;  ; TString fCounterFormat;  ; DocEntityInfo_t fDocEntityInfo;  ; DocSyntax_t fDocSyntax;  ; TFileDefinition * fFileDef;  ; TGClient * fGClient;  ; LinkInfo_t fLinkInfo;  ; TFileSysDB * fLocalFiles;  ; TVirtualMutex * fMakeClassMutex;  ; TModuleDefinition * fModuleDef;  ; OutputStyle_t fOutputStyle;  ; TPathDefinition * fPathDef;  ; PathInfo_t fPathInfo;  ; TString fProductName;  ; Int_t fThreadedClassCount;  ; TIter * fThreadedClassIter;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <THtml.h>. Inheritance diagram for THtml:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EConvertOutput. enum THtml::EConvertOutput. EnumeratorkNoOutput ; kInterpretedOutput ; kCompiledOutput ; kForceOutput ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml.html:35683,multi-thread,multi-threaded,35683,doc/master/classTHtml.html,https://root.cern,https://root.cern/doc/master/classTHtml.html,2,['multi-thread'],['multi-threaded']
Performance," of all members |; Classes |; Public Member Functions |; Private Types |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::Experimental::RCanvasPainter Class ReferenceWeb Widgets. ; Implementation of painter for ROOT::Experimental::RCanvas, using RWebWindow. ; Definition at line 61 of file RCanvasPainter.cxx. Classes; class  GeneratorImpl;  ; struct  WebCommand;  ; struct  WebConn;  ; struct  WebUpdate;  . Public Member Functions;  RCanvasPainter (RCanvas &canv);  Constructor. ;  ; virtual ~RCanvasPainter ();  Destructor. ;  ; bool AddPanel (std::shared_ptr< ROOT::RWebWindow >) final;  Add window as panel inside canvas window. ;  ; void CanvasUpdated (uint64_t ver, bool async, CanvasCallback_t callback) final;  Method invoked when canvas should be updated on the client side Depending from delivered status, each client will received new data. ;  ; void DoWhenReady (const std::string &name, const std::string &arg, bool async, CanvasCallback_t callback) final;  perform special action when drawing is ready ;  ; std::string GetWindowAddr () const final;  Returns web window name. ;  ; std::string GetWindowUrl (bool remote) final;  Returns connection URL for web window. ;  ; bool IsCanvasModified (uint64_t id) const final;  return true if canvas modified since last painting ;  ; void NewDisplay (const std::string &where) final;  Create new display for the canvas See ROOT::RWebWindowsManager::Show() docu for more info. ;  ; int NumDisplays () const final;  Returns number of connected displays. ;  ; bool ProduceBatchOutput (const std::string &fname, int width, int height) final;  Produce batch output, using chrome headless mode with DOM dump. ;  ; std::string ProduceJSON () final;  Produce JSON for the canvas. ;  ; void Run (double tm=0.) final;  Run canvas functionality for specified period of time Required when canvas used not from the main thread. ;  ; void SetClearOnClose (const std::shared_ptr< void > &) final;  Set handle to window which wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html:1147,perform,perform,1147,doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html,1,['perform'],['perform']
Performance," of bytes in TNamed at creation time. ;  ; Long64_t fSeekDir {0};  Location of directory on file. ;  ; Long64_t fSeekKeys {0};  Location of Keys record on file. ;  ; Long64_t fSeekParent {0};  Location of parent directory on file. ;  ; Bool_t fWritable {kFALSE};  True if directory is writable. ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Long64_t fgMaxFullCacheSize = 500000000;  ; static TUrl fgProxy;  size of the cached content ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:39364,cache,cached,39364,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['cache'],['cached']
Performance," of cache element with given unique ID. ; Definition at line 115 of file RooExpensiveObjectCache.cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObjectCache & ; other, . const char * ; ownerName, . bool ; verbose = false . ). Definition at line 296 of file RooExpensiveObjectCache.cxx. ◆ instance(). RooExpensiveObjectCache & RooExpensiveObjectCache::instance ; (; ). static . Return reference to singleton instance. ; Definition at line 58 of file RooExpensiveObjectCache.cxx. ◆ IsA(). TClass * RooExpensiveObjectCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ print(). void RooExpensiveObjectCache::print ; (; ); const. Definition at line 259 of file RooExpensiveObjectCache.cxx. ◆ registerObject(). bool RooExpensiveObjectCache::registerObject ; (; const char * ; ownerName, . const char * ; objectName, . TObject & ; cacheObject, . const RooArgSet & ; params . ). Register object associated with given name and given associated parameters with given values in cache. ; The cache will take ownership_of_object and is indexed under the given name (which does not need to be the name of cacheObject and with given set of dependent parameters with validity for the current values of those parameters. It can be retrieved later by callin retrieveObject() ; Definition at line 71 of file RooExpensiveObjectCache.cxx. ◆ retrieveObject(). const TObject * RooExpensiveObjectCache::retrieveObject ; (; const char * ; name, . TClass * ; tc, . const RooArgSet & ; params . ). Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ; The return object is owned by the cache instance. ; Definition at line 93 of file RooExpensiveObjectCache.cxx. ◆ setObj(). bool RooExpensiveObjectCache::setObj ; (; Int_t ; ui",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:14634,cache,cacheObject,14634,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cacheObject']
Performance, of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization ; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataWeightedAverage.html:32604,cache,cache,32604,root/html526/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html526/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance, of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataWeightedAverage.html:32871,cache,cache,32871,root/html528/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html528/RooDataWeightedAverage.html,2,['cache'],['cache']
Performance, of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty stat,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:36606,cache,cache,36606,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance," of combinations is too large , is 2^"" << nbits << Endl;; 2259 return nullptr;; 2260 }; 2261 if (nbits > 20) {; 2262 Log() << kWARNING << ""Number of combinations is very large , is 2^"" << nbits << Endl;; 2263 }; 2264 uint64_t range = static_cast<uint64_t>(pow(2, nbits));; 2265 ; 2266 ; 2267 // vector to save importances; 2268 std::vector<Double_t> importances(nbits);; 2269 // vector to save ROC; 2270 std::vector<Double_t> ROC(range);; 2271 ROC[0] = 0.5;; 2272 for (int i = 0; i < nbits; i++); 2273 importances[i] = 0;; 2274 ; 2275 Double_t SROC, SSROC; // computed ROC value; 2276 for (x = 1; x < range; x++) {; 2277 ; 2278 std::bitset<VIBITS> xbitset(x);; 2279 if (x == 0); 2280 continue; // data loader need at least one variable; 2281 ; 2282 // creating loader for seed; 2283 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2284 ; 2285 // adding variables from seed; 2286 for (int index = 0; index < nbits; index++) {; 2287 if (xbitset[index]); 2288 seedloader->AddVariable(varNames[index], 'F');; 2289 }; 2290 ; 2291 DataLoaderCopy(seedloader, loader);; 2292 seedloader->PrepareTrainingAndTestTree(loader->GetDataSetInfo().GetCut(""Signal""),; 2293 loader->GetDataSetInfo().GetCut(""Background""),; 2294 loader->GetDataSetInfo().GetSplitOptions());; 2295 ; 2296 // Booking Seed; 2297 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2298 ; 2299 // Train/Test/Evaluation; 2300 TrainAllMethods();; 2301 TestAllMethods();; 2302 EvaluateAllMethods();; 2303 ; 2304 // getting ROC; 2305 ROC[x] = GetROCIntegral(xbitset.to_string(), methodTitle);; 2306 ; 2307 // cleaning information to process sub-seeds; 2308 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2309 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2310 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2311 delete sresults;; 2312 delete seedloader;; 2313 this->Delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:96378,load,loader,96378,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance," of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 301 of file RooKeysPdf.cxx. ◆ getMaxVal(). Int_t RooKeysPdf::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 348 of file RooKeysPdf.cxx. ◆ IsA(). TClass * RooKeysPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 80 of file RooKeysPdf.h. ◆ LoadDataSet(). void RooKeysPdf::LoadDataSet ; (; RooDataSet & ; data). Definition at line 148 of file RooKeysPdf.cxx. ◆ maxVal(). double RooKeysPdf::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 354 of file RooKeysPdf.cxx. ◆ Streamer(). void RooKeysPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooKeysPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file RooKeysPdf.h. Member Data Documentation. ◆ _asymLeft. bool RooKeysPdf::_asymLeft = false. private . Definition at line 72 of file RooKeysPdf.h. ◆ _asymRight. bool RooKeysPdf::_asymRight = false. private . Definition at line 73 of file RooKeysPdf.h. ◆ _binWidth. double RooKeysPdf::_binWidth. private . Definition at line 77 of file RooKeysPdf.h. ◆ _dataPts. double* RooKeysPdf::_data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:79297,Load,LoadDataSet,79297,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,1,['Load'],['LoadDataSet']
Performance," of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR file is downloaded in the current directory or in the directory; specified by 'dstdir'. If a package with the same name already exists; at destination, a check on the MD5 sum is done and the user warned or; prompted for action, depending is the file is equal or different.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackage(const char* par, TProof::EUploadPackageOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:64966,load,loadopts,64966,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['load'],['loadopts']
Performance, of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:19444,cache,cache,19444,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,4,['cache'],"['cache', 'cached']"
Performance," of file RooAddPdf.cxx. ◆ selectNormalizationRange(). void RooAddPdf::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ; Reimplemented from RooAbsReal.; Definition at line 886 of file RooAddPdf.cxx. ◆ selfNormalized(). bool RooAddPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 55 of file RooAddPdf.h. ◆ setAllExtendable(). void RooAddPdf::setAllExtendable ; (; bool ; allExtendable). inlineprivate . Definition at line 151 of file RooAddPdf.h. ◆ setCacheAndTrackHints(). void RooAddPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooAddPdf with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 938 of file RooAddPdf.cxx. ◆ setRecursiveFraction(). void RooAddPdf::setRecursiveFraction ; (; bool ; recursiveFraction). inlineprivate . Definition at line 150 of file RooAddPdf.h. ◆ Streamer(). void RooAddPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooAddPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 153 of file RooAddPdf.h. ◆ translate(). void RooAddPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:92812,cache,cache-and-track,92812,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,2,['cache'],['cache-and-track']
Performance," of file TBufferSQL2.cxx. ◆ SqlWriteBasic() [10/13]. Bool_t TBufferSQL2::SqlWriteBasic ; (; UInt_t ; value). protected . converts UInt_t to string and creates correspondent sql structure ; Definition at line 2241 of file TBufferSQL2.cxx. ◆ SqlWriteBasic() [11/13]. Bool_t TBufferSQL2::SqlWriteBasic ; (; ULong64_t ; value). protected . converts ULong64_t to string and creates correspondent sql structure ; Definition at line 2261 of file TBufferSQL2.cxx. ◆ SqlWriteBasic() [12/13]. Bool_t TBufferSQL2::SqlWriteBasic ; (; ULong_t ; value). protected . converts ULong_t to string and creates correspondent sql structure ; Definition at line 2251 of file TBufferSQL2.cxx. ◆ SqlWriteBasic() [13/13]. Bool_t TBufferSQL2::SqlWriteBasic ; (; UShort_t ; value). protected . converts UShort_t to string and creates correspondent sql structure ; Definition at line 2231 of file TBufferSQL2.cxx. ◆ SqlWriteObject(). Int_t TBufferSQL2::SqlWriteObject ; (; const void * ; obj, . const TClass * ; cl, . Bool_t ; cacheReuse, . TMemberStreamer * ; streamer = nullptr, . Int_t ; streamer_index = 0 . ). protected . Write object to buffer. ; If object was written before, only pointer will be stored Return id of saved object ; Definition at line 265 of file TBufferSQL2.cxx. ◆ SqlWriteValue(). Bool_t TBufferSQL2::SqlWriteValue ; (; const char * ; value, . const char * ; tname . ). protected . Definition at line 2269 of file TBufferSQL2.cxx. ◆ Stack(). TSQLStructure * TBufferSQL2::Stack ; (; Int_t ; depth = 0). protected . returns head of stack ; Definition at line 2518 of file TBufferSQL2.cxx. ◆ Streamer(). void TBufferSQL2::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TBufferIO. ◆ StreamerNVirtual(). void TBufferSQL2::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 285 of file TBufferSQL2.h. ◆ StreamObject() [1/8]. void TBufferText::StreamObject ; (; TObject * ; obj). overridevirtual . Implements T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL2.html:76302,cache,cacheReuse,76302,doc/master/classTBufferSQL2.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL2.html,1,['cache'],['cacheReuse']
Performance," of file TEntryListFromFile.h. ◆ GetFileName(). const char * TEntryListFromFile::GetFileName ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 77 of file TEntryListFromFile.h. ◆ GetN(). Long64_t TEntryListFromFile::GetN ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 75 of file TEntryListFromFile.h. ◆ GetTreeName(). const char * TEntryListFromFile::GetTreeName ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 76 of file TEntryListFromFile.h. ◆ GetTreeNumber(). Int_t TEntryListFromFile::GetTreeNumber ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 78 of file TEntryListFromFile.h. ◆ IsA(). TClass * TEntryListFromFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEntryList.; Definition at line 97 of file TEntryListFromFile.h. ◆ LoadList(). Int_t TEntryListFromFile::LoadList ; (; Int_t ; listnumber). virtual . Loads the list #listnumber This is the only function that can modify fCurrent and fFile data members. ; Definition at line 231 of file TEntryListFromFile.cxx. ◆ Merge(). Int_t TEntryListFromFile::Merge ; (; TCollection * ; list). inlineoverridevirtual . Merge this list with the lists from the collection. ; Reimplemented from TEntryList.; Definition at line 82 of file TEntryListFromFile.h. ◆ Next(). Long64_t TEntryListFromFile::Next ; (; ). overridevirtual . Returns the next entry in the list. ; Faster than GetEntry() ; Reimplemented from TEntryList.; Definition at line 184 of file TEntryListFromFile.cxx. ◆ operator=(). TEntryListFromFile & TEntryListFromFile::operator= ; (; const TEntryListFromFile & ; ). private . ◆ OptimizeStorage(). void TEntryListFromFile::OptimizeStorage ; (; ). inlineoverridevirtual . Checks if the array representation is more economical and if so, switches to it. ; Reimplemented from TEntryList.; Definition at line 85 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:26158,Load,LoadList,26158,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,1,['Load'],['LoadList']
Performance," of file TEveWindow.h. Public Member Functions;  TEveContextMenu (const char *name, const char *title=""Eve context menu"");  Constructor. ;  ; TClass * IsA () const override;  ; void SetupAndPopup (TGWindow *button, TObject *obj);  Position the popup below given button and show context menu for object obj. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TContextMenu;  TContextMenu (const char *name, const char *title=""Context sensitive popup menu"");  Create a context menu. ;  ; virtual ~TContextMenu ();  Destroy a context menu. ;  ; virtual void Action (TClassMenuItem *classmenuitem);  Action to be performed when this menu item is selected. ;  ; void Action (TMethod *method);  ; virtual void Action (TObject *object, TMethod *method);  Action to be performed when this menu item is selected. ;  ; virtual void Action (TObject *object, TToggle *toggle);  Action to be performed when this toggle menu item is selected. ;  ; void Action (TToggle *toggle);  ; virtual const char * CreateArgumentTitle (TMethodArg *argument);  Create string describing argument (for use in dialog box). ;  ; virtual const char * CreateDialogTitle (TObject *object, TFunction *method);  Create title for dialog box retrieving argument values. ;  ; virtual const char * CreatePopupTitle (TObject *object);  Create title for popup menu. ;  ; void Execute (const char *method, const char *params, Int_t *error=nullptr) override;  Execute method on this object with the given parameter string, e.g. ;  ; void Execute (const char *params);  ; void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr) override;  Execute method on this object with parameters stored in the TObjArray. ;  ; void Execute (TObjArray *params);  ; virtual void Execute (TObject *object, TFunction *method, const char *params);  Execute method with specified arguments for specified object. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveContextMenu.html:1453,perform,performed,1453,doc/master/classTEveContextMenu.html,https://root.cern,https://root.cern/doc/master/classTEveContextMenu.html,1,['perform'],['performed']
Performance," of file TFile.h. ◆ fEND. Long64_t TFile::fEND {0}. protected . Last used byte in file. ; Definition at line 79 of file TFile.h. ◆ fFree. TList* TFile::fFree {nullptr}. protected . Free segments linked list table. ; Definition at line 93 of file TFile.h. ◆ fgAsyncOpenRequests. TList * TFile::fgAsyncOpenRequests = nullptr. staticprotected . Definition at line 122 of file TFile.h. ◆ fgBytesRead. std::atomic< Long64_t > TFile::fgBytesRead {0}. staticprotected . Number of bytes read by all TFile objects. ; Definition at line 131 of file TFile.h. ◆ fgBytesWrite. std::atomic< Long64_t > TFile::fgBytesWrite {0}. staticprotected . Number of bytes written by all TFile objects. ; Definition at line 130 of file TFile.h. ◆ fgCacheFileDir. TString TFile::fgCacheFileDir. staticprotected . Directory where to locally stage files. ; Definition at line 124 of file TFile.h. ◆ fgCacheFileDisconnected. Bool_t TFile::fgCacheFileDisconnected = kTRUE. staticprotected . Indicates, we trust in the files in the cache dir without stat on the cached file. ; Definition at line 125 of file TFile.h. ◆ fgCacheFileForce. Bool_t TFile::fgCacheFileForce = kFALSE. staticprotected . Indicates, to force all READ to CACHEREAD. ; Definition at line 126 of file TFile.h. ◆ fgFileCounter. std::atomic< Long64_t > TFile::fgFileCounter {0}. staticprotected . Counter for all opened files. ; Definition at line 132 of file TFile.h. ◆ fGlobalRegistration. bool TFile::fGlobalRegistration = true. protected . ! if true, bypass use of global lists ; Definition at line 115 of file TFile.h. ◆ fgOnlyStaged. Bool_t TFile::fgOnlyStaged = kFALSE. staticprotected . Before the file is opened, it is checked, that the file is staged, if not, the open fails. ; Definition at line 128 of file TFile.h. ◆ fgOpenTimeout. UInt_t TFile::fgOpenTimeout = TFile::kEternalTimeout. staticprotected . Timeout for open operations in ms - 0 corresponds to blocking i/o. ; Definition at line 127 of file TFile.h. ◆ fgReadaheadSize. Int_t TFile::fgRead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:105841,cache,cache,105841,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,4,['cache'],"['cache', 'cached']"
Performance," of file TGeoMatrix.cxx. ◆ GetRotationMatrix(). const Double_t * TGeoRotation::GetRotationMatrix ; (; ); const. inlineoverridevirtual . Implements TGeoMatrix.; Definition at line 239 of file TGeoMatrix.h. ◆ GetScale(). const Double_t * TGeoRotation::GetScale ; (; ); const. inlineoverridevirtual . Implements TGeoMatrix.; Definition at line 240 of file TGeoMatrix.h. ◆ GetTranslation(). const Double_t * TGeoRotation::GetTranslation ; (; ); const. inlineoverridevirtual . Implements TGeoMatrix.; Definition at line 238 of file TGeoMatrix.h. ◆ Inverse(). TGeoHMatrix TGeoRotation::Inverse ; (; ); const. overridevirtual . Return a temporary inverse of this. ; Implements TGeoMatrix.; Definition at line 986 of file TGeoMatrix.cxx. ◆ IsA(). TClass * TGeoRotation::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoMatrix.; Definition at line 242 of file TGeoMatrix.h. ◆ IsValid(). Bool_t TGeoRotation::IsValid ; (; ); const. Perform orthogonality test for rotation. ; Definition at line 1008 of file TGeoMatrix.cxx. ◆ LocalToMaster(). void TGeoRotation::LocalToMaster ; (; const Double_t * ; local, . Double_t * ; master . ); const. overridevirtual . convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse ; Reimplemented from TGeoMatrix.; Definition at line 1067 of file TGeoMatrix.cxx. ◆ LocalToMasterBomb(). void TGeoRotation::LocalToMasterBomb ; (; const Double_t * ; local, . Double_t * ; master . ); const. inlineoverridevirtual . convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse ; Reimplemented from TGeoMatrix.; Definition at line 206 of file TGeoMatrix.h. ◆ LocalToMasterVect(). void TGeoRotation::LocalToMasterVect ; (; const Double_t * ; local, . Double_t * ; master . ); const. inlineoverridevirtual . convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse ; Reimplemented from TGeoMatrix.; Definition at line 202 of file TGeoMatrix.h. ◆ MakeClone(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRotation.html:23589,Perform,Perform,23589,doc/master/classTGeoRotation.html,https://root.cern,https://root.cern/doc/master/classTGeoRotation.html,1,['Perform'],['Perform']
Performance," of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Mar 10 17:13:54 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:38401,cache,cache,38401,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,3,['cache'],['cache']
Performance," of multiple variables occurring in the data set, using addColumn(), you may alter the outcome of the fit.; Only in cases where such a modification of fit behaviour is intentional, this function should be used. ; Implements RooAbsDataStore.; Definition at line 782 of file RooTreeDataStore.cxx. ◆ append(). void RooTreeDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 867 of file RooTreeDataStore.cxx. ◆ attachBuffers(). void RooTreeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1036 of file RooTreeDataStore.cxx. ◆ attachCache(). void RooTreeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprivatevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 229 of file RooTreeDataStore.cxx. ◆ cacheArgs(). void RooTreeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 950 of file RooTreeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooTreeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 121 of file RooTreeDataStore.h. ◆ changeObservableName(). bool RooTreeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:27851,cache,cacheArgs,27851,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['cache'],['cacheArgs']
Performance," of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void syncCache (const RooArgSet *set=nullptr) override;  Force the internal value cache to be up to date. ;  ;  Protected Member Functions inherited from RooAbsRealLValue; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy cache of another RooAbsArg to our cache. ;  ; bool fitRangeOKForPlotting () const;  Check if fit range is usable as plot range, i.e. ;  ; virtual void setValFast (double value);  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:57425,cache,cache,57425,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,1,['cache'],['cache']
Performance," of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Jun 30 14:30:34 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:23714,cache,cache,23714,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,4,['cache'],"['cache', 'cached']"
Performance," of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Mar 10 17:14:14 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:22132,cache,cache,22132,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,4,['cache'],"['cache', 'cached']"
Performance," of pdf to equivalent unweighted dataset; # ---------------------------------------------------------------------; ; # Construct a pdf with the same shape as p0 after weighting; genPdf = ROOT.RooGenericPdf(""genPdf"", ""x*x+10"", [x]); ; # Sample a dataset with the same number of events as data; data2 = genPdf.generate({x}, 1000); ; # Sample a dataset with the same number of weights as data; data3 = genPdf.generate({x}, 43000); ; # Fit the 2nd order polynomial to both unweighted datasets and save the; # results for comparison; r_ml_unw10 = p2.fitTo(data2, Save=True, PrintLevel=-1); r_ml_unw43 = p2.fitTo(data3, Save=True, PrintLevel=-1); ; # Chis2 fit of pdf to binned weighted dataset; # ---------------------------------------------------------------------------; ; # Construct binned clone of unbinned weighted dataset; binnedData = wdata.binnedClone(); binnedData.Print(""v""); ; # Perform chi2 fit to binned weighted dataset using sum-of-weights errors; #; # NB: Within the usual approximations of a chi2 fit, chi2 fit to weighted; # data using sum-of-weights-squared errors does give correct error; # estimates; chi2 = p2.createChi2(binnedData, ROOT.RooFit.DataError(""SumW2"")); m = ROOT.RooMinimizer(chi2); m.migrad(); m.hesse(); ; # Plot chi^2 fit result on frame as well; r_chi2_wgt = m.save(); p2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Compare fit results of chi2, L fits to (un)weighted data; # ------------------------------------------------------------; ; # Note that ML fit on 1Kevt of weighted data is closer to result of ML fit on 43Kevt of unweighted data; # than to 1Kevt of unweighted data, the reference chi^2 fit with SumW2 error gives a result closer to; # that of an unbinned ML fit to 1Kevt of unweighted data.; ; print(""==> ML Fit results on 1K unweighted events""); r_ml_unw10.Print(); print(""==> ML Fit results on 43K unweighted events""); r_ml_unw43.Print(); print(""==> ML Fit results on 1K weighted events with a summed weight of 43K""); r_ml_wgt.Print(); print(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf403__weightedevts_8py.html:3891,Perform,Perform,3891,doc/master/rf403__weightedevts_8py.html,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html,1,['Perform'],['Perform']
Performance, of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsAr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:39814,cache,cache,39814,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance," of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files, TList* wrks = 0); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileOpt:; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:31451,Load,Load,31451,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,4,"['Load', 'cache']","['Load', 'cache']"
Performance," of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible. GSL uses LU decomposition without the implicit scaling of Crout. Therefore, its accuracy is not as good. For instance a (10x10) Hilbert matrix has errors 10 times larger than the LU Crout result. In ROOT v4.0, the user can choose between the Invert() and IvertFast() routines, where the latter is using the Cramer algorithm for sizes<7x7. The speed graph shows the result for InvertFast(). A*x=b the execution time is measured for solving the linear equation A*x=b. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:803256,multi-thread,multi-threading,803256,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['multi-thread'],['multi-threading']
Performance," of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:162117,perform,performed,162117,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['performed']
Performance," of the current window if id == 0. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 969 of file TVirtualX.cxx. ◆ WMDeleteNotify(). void TVirtualX::WMDeleteNotify ; (; Window_t ; id). virtual . Tells WM to send message when window is closed via WM. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1637 of file TVirtualX.cxx. ◆ WriteGIF(). Int_t TVirtualX::WriteGIF ; (; char * ; name). virtual . Writes the current window into GIF file. ; Returns 1 in case of success, 0 otherwise. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 977 of file TVirtualX.cxx. ◆ WritePixmap(). void TVirtualX::WritePixmap ; (; Int_t ; wid, . UInt_t ; w, . UInt_t ; h, . char * ; pxname . ). virtual . Writes the pixmap ""wid"" in the bitmap file ""pxname"". ; Parameters. [in]widthe pixmap address ; [in]w,hthe width and height of the pixmap. ; [in]pxnamethe file name . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 989 of file TVirtualX.cxx. ◆ XorRegion(). void TVirtualX::XorRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). virtual . Calculates the difference between the union and intersection of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2210 of file TVirtualX.cxx. Member Data Documentation. ◆ fDrawMode. EDrawMode TVirtualX::fDrawMode. protected . Definition at line 55 of file TVirtualX.h. Libraries for TVirtualX:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TVirtualX.h; core/base/src/TVirtualX.cxx; graf2d/win32gdk/src/TGWin32VirtualXProxy.cxx. TVirtualX. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:46 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:138892,perform,perform,138892,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['perform'],['perform']
Performance," of the function and manages it. ;  ; Int_t SetParameter (Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) override;  Set (add) a new fit parameter passing initial value, step size (verr) and parameter limits if vlow > vhigh the parameter is unbounded if the stepsize (verr) == 0 the parameter is treated as fixed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TVirtualFitter;  TVirtualFitter ();  Default constructor. ;  ;  ~TVirtualFitter () override;  Cleanup virtual fitter. ;  ; virtual FCNFunc_t GetFCN ();  ; virtual Foption_t GetFitOption () const;  ; TMethodCall * GetMethodCall () const;  ; virtual TObject * GetObjectFit () const;  ; virtual TObject * GetUserFunc () const;  ; virtual Int_t GetXfirst () const;  ; virtual Int_t GetXlast () const;  ; virtual Int_t GetYfirst () const;  ; virtual Int_t GetYlast () const;  ; virtual Int_t GetZfirst () const;  ; virtual Int_t GetZlast () const;  ; TClass * IsA () const override;  ; virtual Double_t * SetCache (Int_t npoints, Int_t psize);  Initialize the cache array npoints is the number of points to be stored (or already stored) in the cache psize is the number of elements per point. ;  ; virtual void SetFitOption (Foption_t option);  ; virtual void SetObjectFit (TObject *obj);  ; virtual void SetUserFunc (TObject *userfunc);  ; virtual void SetXfirst (Int_t first);  ; virtual void SetXlast (Int_t last);  ; virtual void SetYfirst (Int_t first);  ; virtual void SetYlast (Int_t last);  ; virtual void SetZfirst (Int_t first);  ; virtual void SetZlast (Int_t last);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBackCompFitter.html:9231,cache,cache,9231,doc/master/classTBackCompFitter.html,https://root.cern,https://root.cern/doc/master/classTBackCompFitter.html,2,['cache'],['cache']
Performance," of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:31446,cache,cache,31446,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,4,['cache'],['cache']
Performance," of the viewport point into 3D space. ; Line runs from near to far camera clip planes (the minimum and maximum visible depth). See also TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const for 3D viewport -> 3D world vertex conversions. See also OpenGL gluUnProject & glDepth documentation; Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 498 of file TGLCamera.cxx. ◆ ViewportToWorld() [3/3]. TGLLine3 TGLCamera::ViewportToWorld ; (; Double_t ; viewportX, . Double_t ; viewportY . ); const. Convert a 2D viewport position to 3D world line - the projection of the viewport point into 3D space. ; Line runs from near to far camera clip planes (the minimum and maximum visible depth). See also TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const for 3D viewport -> 3D world vertex conversions. See also OpenGL gluUnProject & glDepth documentation; Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 477 of file TGLCamera.cxx. ◆ WindowToViewport() [1/4]. void TGLCamera::WindowToViewport ; (; Int_t & ; , . Int_t & ; y . ); const. inline . Definition at line 198 of file TGLCamera.h. ◆ WindowToViewport() [2/4]. void TGLCamera::WindowToViewport ; (; TGLRect & ; rect); const. inline . Definition at line 200 of file TGLCamera.h. ◆ WindowToViewport() [3/4]. void TGLCamera::WindowToViewport ; (; TGLVertex3 & ; vertex); const. inline . Definition at line 201 of file TGLCamera.h. ◆ WindowToViewport() [4/4]. void TGLCamera::WindowToViewport ; (; TPoint & ; point); const. inline . Definition at line 199 of file TGLCamera.h. ◆ WorldDeltaToViewport(). TGLVector3 TGLCamera::WorldDeltaToViewport ; (; const TGLVertex3 & ; worldRef, . const TGLVector3 & ; worldDelta . ); const. Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport (screen) '3D' vector. ; The X()/Y() components of the vector are the horizonta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:39042,cache,cache,39042,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance," of this branch to read Basket buffer. ;  ; virtual void SetAddressImpl (void *addr, bool);  ; void SetSkipZip (bool skip=true);  ; Int_t WriteBasket (TBasket *basket, Int_t where);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TBranch; char * fAddress;  ! Address of 1st leaf (variable or object) ;  ; Int_t * fBasketBytes;  [fMaxBaskets] Length of baskets on file ;  ; Long64_t * fBasketEntry;  [fMaxBaskets] Table of first entry in each basket ;  ; TObjArray fBaskets;  -> List of baskets of this branch ;  ; Long64_t * fBasketSeek;  [fMaxBaskets] Addresses of baskets on file ;  ; Int_t fBasketSize;  Initial Size of Basket Buffer. ;  ; TObjArray fBranches;  -> List of Branches of this branch ;  ; TList * fBrowsables;  ! List of TVirtualBranchBrowsables used for Browse() ;  ; BulkObj fBulk;  ! Helper for performing bulk IO ;  ; CacheInfo_t fCacheInfo;  ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ;  ; Int_t fCompress;  Compression level and algorithm. ;  ; TBasket * fCurrentBasket;  ! Pointer to the current basket. ;  ; TDirectory * fDirectory;  ! Pointer to directory where this branch buffers are stored ;  ; Long64_t fEntries;  Number of entries. ;  ; TBuffer * fEntryBuffer;  ! Buffer used to directly pass the content without streaming ;  ; Long64_t fEntryNumber;  Current entry number (last one filled in this branch) ;  ; Int_t fEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TBasket * fExtraBasket;  ! Allocated basket not currently holding any data. ;  ; TString fFileName;  Name of file where buffers are stored ("""" if in same file as Tree header) ;  ; FillLeaves_t fFillLeaves;  ! Pointer to the FillLeaves implementation to use. ;  ; Long64_t fFirstBasketEntry;  ! First entry in the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchSTL.html:25256,perform,performing,25256,doc/master/classTBranchSTL.html,https://root.cern,https://root.cern/doc/master/classTBranchSTL.html,3,"['cache', 'perform']","['cache', 'performing']"
Performance," of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static void MapGlobalDialog (TGMainFrame *dialog, TGFrame *fr);  Map dialog and place it relative to selected frame. ;  ;  Static Public Member Functions inherited from TVirtualDragManager; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TVirtualDragManager * Instance ();  Load plugin and create drag manager object. ;  ;  Static Public Member Functions inherited from TGFrame; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static const TGGC & GetBckgndGC ();  Get background color graphics context. ;  ; static const TGGC & GetBlackGC ();  Get black graphics context. ;  ; static Pixel_t GetBlackPixel ();  Get black pixel value. ;  ; static Pixel_t GetDefaultFrameBackground ();  Get default frame background. ;  ; static Pixel_t GetDefaultSelectedBackground ();  Get default selected frame background. ;  ; static const TGGC & GetHilightGC ();  Get highlight color graphics context. ;  ; static const TGGC & GetShadowGC ();  Get shadow color graphics context. ;  ; static const TGGC & GetWhiteGC ();  Get white graphics context. ;  ; static Pixel_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGuiBldDragManager.html:21547,Load,Load,21547,doc/master/classTGuiBldDragManager.html,https://root.cern,https://root.cern/doc/master/classTGuiBldDragManager.html,1,['Load'],['Load']
Performance," on file; Long64_tTWebFile::fSizefile size; TSocket*TWebFile::fSocketsocket for HTTP/1.1 (stays alive between calls); Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TUrlTWebFile::fUrlOrgsave original url in case of temp redirection; Bool_tfUseMultiRangeIs the S3 server capable of serving multirange requests?; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static TUrlTWebFile::fgProxyglobally set proxy URL; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:25743,cache,cache,25743,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cached']"
Performance," on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction1Binding.html:48562,cache,cached,48562,doc/master/classRooCFunction1Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction1Binding.html,26,['cache'],"['cache', 'cached']"
Performance," one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"", ""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; // We send a clone to avoid double deletes when importing the result; fInput->Add(elist);; // This is needed to avoid warnings from output-to-members mapping; elist = nullptr;; }; Info(""Begin"", ""creating an entry-list"");; }; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; // In PROOF option ""useList"" is processed in SlaveBegin and we do not need; // to do anything here; } else {; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; ; void h1analysis::SlaveBegin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; //initialize the Tree branch addresses; Init(tree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process option: %s (tree: %p)"", option.Data(), tree);; ; //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; // Entry list stuff (re-parse option because on PROOF only SlaveBegin is called); if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:7947,perform,performs,7947,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['perform'],['performs']
Performance, one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ). More...;  ; class  IBaseParam;  Documentation for the abstract class IBaseParam. More...;  ; class  IGradientFunctionMultiDimTempl;  Interface (abstract class) for multi-dimensional functions providing a gradient calculation. More...;  ; class  IGradientFunctionOneDim;  Interface (abstract class) for one-dimensional functions providing a gradient calculation. More...;  ; class  IGradientMultiDimTempl;  ; class  IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  ; class  IntegrandTransform;  Auxiliary inner class for mapping infinite and semi-infinite integrals. More...;  ; class  IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  Interpolator;  Class for performing function interpolation of points. More...;  ; class  Inverter;  Matrix Inverter class Class to specialize calls to Dinv. More...;  ; class  Inverter< 0 >;  Inverter<0>. More...;  ; class  Inverter< 1 >;  1x1 matrix inversion \(a_{11} \to 1/a_{11}\) More...;  ; class  Inverter< 2 >;  2x2 matrix inversion using Cramers rule. More...;  ; class  IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  ; class  IParametricFunctionMultiDimTempl;  IParamFunction interface (abstract class) describing multi-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam. More...;  ; class  IParametricFunctionOneDim;  Specialized IParamFunction interface (abstract class) for one-dimensional paramet,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:17381,perform,performing,17381,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance," ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Double_t> &TMatrixT<Double_t> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSparse<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTLazy<Element> ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixT_float_.html:21210,Perform,Perform,21210,root/html602/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixT_float_.html,2,['Perform'],['Perform']
Performance," ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<float>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<float>& v1, const TVectorT<float>& v2, float alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<float>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSparse<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTLazy<Element>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixT_float_.html:20251,Perform,Perform,20251,root/html528/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixT_float_.html,3,['Perform'],['Perform']
Performance," only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; An example of pads hierarchy is shown below:. /*. */. Function Members (Methods); public:. TPad(); TPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = -1, Short_t bordersize = -1, Short_t bordermode = -2); virtual~TPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual voidAbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::App",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:1838,perform,performed,1838,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,4,['perform'],['performed']
Performance," only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; An example of pads hierarchy is shown below:. /*. */. Function Members (Methods); public:. virtual~TPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual voidAbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAutoExec(); static Bool_tTQObject::BlockAllSig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPad.html:1857,perform,performed,1857,root/html602/TPad.html,https://root.cern,https://root.cern/root/html602/TPad.html,2,['perform'],['performed']
Performance," opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition TFile.h:379; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::GetCompressInt_t GetCompress() constDefinition TFile.h:380; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::fgBytesReadstatic std::atomic< Long64_t > fgBytesReadNumber of bytes read by all TFile objects.Definition TFile.h:131; TFile::fReadCallsInt_t fReadCallsNumber of read calls ( not counting the cache calls )Definition TFile.h:89; TFile::SetFileBytesWrittenstatic void SetFileBytesWritten(Long64_t bytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:210827,CACHE,CACHEREAD,210827,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['CACHE'],['CACHEREAD']
Performance," operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. » Last changed: Mon Dec 7 13:45:31 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCache.html:1577,cache,cache,1577,root/html526/RooAbsCache.html,https://root.cern,https://root.cern/root/html526/RooAbsCache.html,7,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance," operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. XrdClient*fClientHandle to the client object; void*fInitMtxProtects fInitDone, serializes the; Bool_tfIsRootdNature of remote file server; static TFileStager*fgFileStagerStager for IsStaged checks; static Bool_tfgInitDoneAvoid initializing more than once; static Bool_tfgRootdBCControl rootd backward compatibility. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); Create a TXNetFile object. A TXNetFile object is the same as a TNetFile; (from which the former derives) except that the protocol is extended to; support dealing with new xrootd data server or xrootd load balancer; server. The ""url"" argument must be of the form. root://server1:port1[,server2:port2,...,serverN:portN]/pathfile,. Note that this means that multiple servers (>= 1) can be specified in; the url. The connection will try to connect to the first server:port; and if that does not succeed, it will try the second one, and so on; until it finds a server that will respond. See the TNetFile documentation for the description of the other arguments. The creation consists of internal variable settings (most important is; the client's domain), creation of a TXUrl array containing all specified; urls (a single url is serverX:portX/pathfile), trying to connect to the; servers calling Connect() method, getting a valid access to the remote; server the client is connected to using GetAccessToSrv() method,; recognizing the remote server (if an old rootd the TNetFile's Create; method will be called). The options fiel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXNetFile.html:26155,load,load,26155,root/html604/TXNetFile.html,https://root.cern,https://root.cern/root/html604/TXNetFile.html,1,['load'],['load']
Performance," option the libraries; 2736/// are created directly in the directory 'build_dir'; in particular this means that; 2737/// 2 scripts with the same name in different source directory will over-write each; 2738/// other's library.; 2739/// See also TSystem::SetBuildDir.; 2740///; 2741/// If dirmode is not zero and we need to create the target directory, the; 2742/// file mode bit will be change to 'dirmode' using chmod.; 2743///; 2744/// If library_specified is not specified, CompileMacro generate a default name; 2745/// for library by taking the name of the file ""filename"" but replacing the; 2746/// dot before the extension by an underscore and by adding the shared; 2747/// library extension for the current platform.; 2748/// For example on most platform, hsimple.cxx will generate hsimple_cxx.so; 2749///; 2750/// It uses the directive fMakeSharedLibs to create a shared library.; 2751/// If loading the shared library fails, it tries to output a list of missing; 2752/// symbols by creating an executable (on some platforms like OSF, this does; 2753/// not HAVE to be an executable) containing the script. It uses the; 2754/// directive fMakeExe to do so.; 2755/// For both directives, before passing them to TSystem::Exec, it expands the; 2756/// variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; 2757/// $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; 2758/// information on those variables.; 2759///; 2760/// This method is used to implement the following feature:; 2761///; 2762/// Synopsis:; 2763///; 2764/// The purpose of this addition is to allow the user to use an external; 2765/// compiler to create a shared library from its C++ macro (scripts).; 2766/// Currently in order to execute a script, a user has to type at the root; 2767/// prompt; 2768/// ~~~ {.cpp}; 2769/// .X myfunc.C(arg1,arg2); 2770/// ~~~; 2771/// We allow them to type:; 2772/// ~~~ {.cpp}; 2773/// .X myfunc.C++(arg1,arg2); 2774/// ~~~; 2775/// or; 2776/// ~~~ {.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:89698,load,loading,89698,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loading']
Performance," optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char *name, const char *title, RooAbsReal& x, RooDataSet& data, Mirror mirror, Double_t rho, Double_t nSigma, Bool_t rotate); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap); determine c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:44672,load,loadDataSet,44672,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,1,['load'],['loadDataSet']
Performance," or an array), the histogram is filled with all vector elements for each event.; You can use the objects returned by actions as if they were pointers to the desired results. There are many other possible actions, and all their results are wrapped in smart pointers; we'll see why in a minute. Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it: RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event; the name and types of the columns are inferred automatically. The string expression is required to return a bool which signals whether the event passes the filter (true) or not (false).; You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to perform actions. Multiple Filter() calls can be chained one after another.; Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet, but it can be any kind of function or even a functor class), together with a list of column names. This snippet is analogous to the one above: RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::CountRRes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:18113,perform,perform,18113,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['perform'],['perform']
Performance," or following (forward = kFALSE) bins. note: while cumulative distributions make sense in one dimension, you; may not be getting what you expect in more than 1D because the concept; of a cumulative distribution is much trickier to define; make sure you; understand the order of summation before you use this method with; histograms of dimension >= 2. void Copy(TObject& hnew) const; Copy this histogram structure to newth1. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. Note also that the histogram it will be created in gDirectory (if AddDirectoryStatus()=true); or will not be added to any directory if AddDirectoryStatus()=false; independently of the current directory stored in the original histogram. TObject* Clone(const char* newname = 0) const; Make a complete copy of the underlying object. If 'newname' is set,; the copy's name will be set to that name. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:63010,Perform,Perform,63010,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,1,['Perform'],['Perform']
Performance," other than TObject; TStreamerObjectAnyPointer Streamer element of type pointer to a non TObject; TStreamerObjectPointer Streamer element of type pointer to a TObject; TStreamerSTL Streamer element of type STL container; TStreamerSTLstring Streamer element of type C++ string; TStreamerString Streamer element of type TString; TString Basic string class; TStringLong Long string class (more than 255 chars); TStringRef ; TStringToken String tokenizer using PCRE for finding next tokens.; TStyle A collection of all graphics attributes; TStyleDialog Dialog box used by the TStyleManager class; TStyleManager Graphical User Interface for managing styles; TStylePreview Preview window used by the TStyleManager class; TSubString ; TSynapse simple weighted bidirectionnal connection between 2 neurons; TSysEvtHandler ABC for handling system events; TSystem ABC defining a generic interface to the OS; TSystemDirectory A system directory; TSystemFile A system file; TTF Interface to TTF font handling; TTRAP TRAP shape; TTRD1 TRD1 shape; TTRD2 TRD2 shape; TTUBE TUBE shape; TTUBS TUBS shape; TTabCom Perform comand line completion when hitting <TAB>; TTable vector of the C structures; TTable3Points A 3-D Points; TTable::iterator ; TTableDescriptor descrpitor defining the internal layout of TTable objects; TTableIter Iterator over ""sorted"" TTable objects; TTableMap ""Map"" array for TTable object; TTablePadView3D ; TTablePoints Defines the TTable as an element of ""event"" geometry; TTableRange Range used in TGTable.; TTableSorter Is an ""observer"" class to sort the TTable objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of contex-menu toggle objects; TTree Tree descriptor (the main ROOT I/O class); TTreeCache Speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:124993,Perform,Perform,124993,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['Perform'],['Perform']
Performance," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLBoundingBox.html:2773,cache,cached,2773,root/html528/TGLBoundingBox.html,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html,12,['cache'],['cached']
Performance," our set, deleting them if we own them.Definition RooAbsCollection.cxx:756; RooAbsCollection::removevirtual bool remove(const RooAbsArg &var, bool silent=false, bool matchByNameOnly=false)Remove the specified argument from our list.Definition RooAbsCollection.cxx:656; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsCollection::GetNameconst char * GetName() const overrideReturns name of object.Definition RooAbsCollection.h:342; RooAbsCollection::addvirtual bool add(const RooAbsArg &var, bool silent=false)Add the specified argument to list.Definition RooAbsCollection.cxx:443; RooAbsCollection::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsCollection.h:76; RooAbsCollection::overlapsbool overlaps(Iterator_t otherCollBegin, Iterator_t otherCollEnd) constDefinition RooAbsCollection.h:238; RooAbsCollection::assignvoid assign(const RooAbsCollection &other) constSets the value, cache and constant attribute of any argument in our set that also appears in the othe...Definition RooAbsCollection.cxx:283; RooAbsCollection::sizeStorage_t::size_type size() constDefinition RooAbsCollection.h:269; RooAbsCollection::firstRooAbsArg * first() constDefinition RooAbsCollection.h:291; RooAbsCollection::replacevirtual bool replace(const RooAbsArg &var1, const RooAbsArg &var2)Replace var1 with var2 and return true for success.Definition RooAbsCollection.cxx:610; RooAbsCollection::addOwnedvirtual bool addOwned(RooAbsArg &var, bool silent=false)Add an argument and transfer the ownership to the collection.Definition RooAbsCollection.cxx:367; RooAbsCollection::addClonevirtual RooAbsArg * addClone(const RooAbsArg &var, bool silent=false)Add a clone of the specified argument to list.Definition RooAbsCollection.cxx:416; RooAbsCollection::contentsStringstd::string contentsString() constReturn comma separated list of contained object names as STL string.Definition RooAbsCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:210997,cache,cache,210997,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['cache'],['cache']
Performance," ours.Definition TTree.cxx:3299; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::fReadEntryLong64_t fReadEntry! Number of the entry being processedDefinition TTree.h:107; TTree::GetNbranchesvirtual Int_t GetNbranches()Definition TTree.h:542; TTree::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find leaf..Definition TTree.cxx:4916; TTree::fDirectoryTDirectory * fDirectory! Pointer to directory holding this treeDefinition TTree.h:121; TTree::kNeedEnableDecomposedObj@ kNeedEnableDecomposedObjDefinition TTree.h:244; TTree::kNoCheck@ kNoCheckDefinition TTree.h:243; TTree::kMissingBranch@ kMissingBranchDefinition TTree.h:233; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Definition TTree.cxx:1219; TTree::CheckBranchAddressTypevirtual Int_t CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)Check whether or not the address described by the last 3 parameters matches the content of the branch...Definition TTree.cxx:2867; TTree::GetFileNumbervirtual Int_t GetFileNumber() constDefinition TTree.h:516; TTree::SetChainOffsetvirtual void SetChainOffset(Long64_t offset=0)Definition TTree.h:649; TTree::fPacketSizeInt_t fPacketSize! Number of entries in one packet for parallel rootDefinition TTree.h:109; TTree::GetChainOffsetvirtual Long64_t GetChainOffset() constDefinition TTree.h:456; TTree::Scanvirtual Long64_t Scan(const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:152393,cache,cachesize,152393,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['cache'],"['cache', 'cachesize']"
Performance," out, Option_t* option = """"); virtual voidSetAnalysisType(TMVA::Types::EAnalysisType type); voidSetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidSetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMethodBaseDir(TDirectory* methodDir); voidSetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalReferenceCut(Double_t cut); voidSetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestTime(Double_t testTime); voidSetTestvarName(const TString& v = """"); voidSetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTestMulticlass(); virtual voidTestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteEvaluationHistosToFile(TMVA::Typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBase.html:11193,tune,tuneParameters,11193,root/html530/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBase.html,2,['tune'],['tuneParameters']
Performance," out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TBuffer(); Default ctor. {}. TBuffer(const TBuffer& ); TBuffer objects cannot be copied or assigned. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBuffer.html:20876,cache,cache,20876,root/html602/TBuffer.html,https://root.cern,https://root.cern/root/html602/TBuffer.html,2,['cache'],['cache']
Performance," out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBuffer.html:19289,cache,cache,19289,root/html534/TBuffer.html,https://root.cern,https://root.cern/root/html534/TBuffer.html,1,['cache'],['cache']
Performance," output for a given event. ; Definition at line 1098 of file TMultiLayerPerceptron.cxx. ◆ GetTau(). Double_t TMultiLayerPerceptron::GetTau ; (; ); const. inline . Definition at line 81 of file TMultiLayerPerceptron.h. ◆ GetType(). TNeuron::ENeuronType TMultiLayerPerceptron::GetType ; (; ); const. inline . Definition at line 84 of file TMultiLayerPerceptron.h. ◆ IsA(). TClass * TMultiLayerPerceptron::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 151 of file TMultiLayerPerceptron.h. ◆ LineSearch(). bool TMultiLayerPerceptron::LineSearch ; (; Double_t * ; direction, . Double_t * ; buffer . ). protected . Search along the line defined by direction. ; buffer is not used but is updated with the new dw so that it can be used by a later stochastic step. It returns true if the line search fails. ; Definition at line 2274 of file TMultiLayerPerceptron.cxx. ◆ LoadWeights(). Bool_t TMultiLayerPerceptron::LoadWeights ; (; Option_t * ; filename = """"). Loads the weights from a text file conforming to the format defined by DumpWeights. ; Definition at line 1657 of file TMultiLayerPerceptron.cxx. ◆ MLP_Batch(). void TMultiLayerPerceptron::MLP_Batch ; (; Double_t * ; buffer). protected . One step for the batch (stochastic) method. ; DEDw should have been updated before calling this. ; Definition at line 2203 of file TMultiLayerPerceptron.cxx. ◆ MLP_Line(). void TMultiLayerPerceptron::MLP_Line ; (; Double_t * ; origin, . Double_t * ; dir, . Double_t ; dist . ). private . Sets the weights to a point along a line Weights are set to [origin + (dist * dir)]. ; Definition at line 2231 of file TMultiLayerPerceptron.cxx. ◆ MLP_Stochastic(). void TMultiLayerPerceptron::MLP_Stochastic ; (; Double_t * ; buffer). protected . One step for the stochastic method buffer should contain the previous dw vector and will be updated. ; Definition at line 2158 of file TMultiLayerPerceptron.cxx. ◆ operator=(). TMultiLayer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:42855,Load,LoadWeights,42855,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['Load'],['LoadWeights']
Performance, over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_flatSFInt; Bool_t_flip; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_nlo; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit se,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGExpModel.html:40143,cache,cache,40143,root/html526/RooGExpModel.html,https://root.cern,https://root.cern/root/html526/RooGExpModel.html,1,['cache'],['cache']
Performance, over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_flatSFInt; Bool_t_flip; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_nlo; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGExpModel.html:40525,cache,cache,40525,root/html528/RooGExpModel.html,https://root.cern,https://root.cern/root/html528/RooGExpModel.html,3,['cache'],['cache']
Performance," over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x85075d0 with pdf gx_CONV_model_mean_CACHE_Obs[mean] for nset () with code 2; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; ; prevFCN = 2171.275755 a=2.017, ; prevFCN = 2171.275755 a=1.983, ; prevFC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:7724,cache,cache,7724,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,1,['cache'],['cache']
Performance," over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).; 556 void DisableImplicitMT(); 557 {; 558#ifdef R__USE_IMT; 559 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableImplici",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:20332,multi-thread,multi-threading,20332,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['multi-thread'],['multi-threading']
Performance," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Fri Dec 2 14:26:49 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenContext.html:10518,Perform,Perform,10518,root/html532/RooGenContext.html,https://root.cern,https://root.cern/root/html532/RooGenContext.html,1,['Perform'],['Perform']
Performance," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Mon Jul 4 15:23:00 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenContext.html:10399,Perform,Perform,10399,root/html530/RooGenContext.html,https://root.cern,https://root.cern/root/html530/RooGenContext.html,1,['Perform'],['Perform']
Performance," over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Sat Sep 5 16:40:26 2015 » Last generated: 2015-09-05 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenContext.html:10540,Perform,Perform,10540,root/html534/RooGenContext.html,https://root.cern,https://root.cern/root/html534/RooGenContext.html,1,['Perform'],['Perform']
Performance," overlap->GetPolyMarker()->Draw(""SAME"");; 949 if (has_pad); 950 gPad->Update();; 951 }; 952 ; 953 // If we are drawing into the pad, then the view needs to be; 954 // set to perspective; 955 // if (!view->IsPerspective()) view->SetPerspective();; 956 fVisLock = kTRUE;; 957}; 958 ; 959////////////////////////////////////////////////////////////////////////////////; 960/// Draw only one volume.; 961 ; 962void TGeoPainter::DrawOnly(Option_t *option); 963{; 964 TString opt = option;; 965 opt.ToLower();; 966 if (fVisLock) {; 967 ClearVisibleVolumes();; 968 fVisLock = kFALSE;; 969 }; 970 fPaintingOverlaps = kFALSE;; 971 fIsPaintingShape = kFALSE;; 972 Bool_t has_pad = (gPad == nullptr) ? kFALSE : kTRUE;; 973 // Clear pad if option ""same"" not given; 974 if (!gPad) {; 975 gROOT->MakeDefCanvas();; 976 }; 977 if (!opt.Contains(""same"")); 978 gPad->Clear();; 979 // append this volume to pad; 980 fTopVolume = fGeoManager->GetCurrentVolume();; 981 fTopVolume->AppendPad(option);; 982 ; 983 // Create a 3-D view; 984 TView *view = gPad->GetView();; 985 if (!view) {; 986 view = TView::CreateView(11, nullptr, nullptr);; 987 // Set the view to perform a first autorange (frame) draw.; 988 // TViewer3DPad will revert view to normal painting after this; 989 view->SetAutoRange(kTRUE);; 990 fVisOption = kGeoVisOnly;; 991 if (has_pad); 992 gPad->Update();; 993 }; 994 ; 995 // If we are drawing into the pad, then the view needs to be; 996 // set to perspective; 997 // if (!view->IsPerspective()) view->SetPerspective();; 998 fVisLock = kTRUE;; 999}; 1000 ; 1001////////////////////////////////////////////////////////////////////////////////; 1002/// Draw current point in the same view.; 1003 ; 1004void TGeoPainter::DrawCurrentPoint(Int_t color); 1005{; 1006 if (!gPad); 1007 return;; 1008 if (!gPad->GetView()); 1009 return;; 1010 TPolyMarker3D *pm = new TPolyMarker3D();; 1011 pm->SetMarkerColor(color);; 1012 const Double_t *point = fGeoManager->GetCurrentPoint();; 1013 pm->SetNextPoint(point[0], ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:31463,perform,perform,31463,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['perform'],['perform']
Performance," override;  ; bool checkObservables (const RooArgSet *nset) const override;  Check if PDF is valid for given normalization set. ;  ; TObject * clone (const char *newname) const override;  ; const RooArgList & coefList () const;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; std::unique_ptr< RooAbsReal > createExpectedEventsFunc (const RooArgSet *nset) const override;  Returns an object that represents the expected number of events for a given normalization set, similar to how createIntegral() returns an object that returns the integral. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return expected number of events for extended likelihood calculation, which is the sum of all coefficients. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; void fixCoefNormalization (const RooArgSet &refCoefNorm);  By default the interpretation of the fraction coefficients is performed in the contextual choice of observables. ;  ; void fixCoefRange (const char *rangeName);  By default, fraction coefficients are assumed to refer to the default fit range. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  Force RooRealIntegral to offer all observables for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Determine which part (if any) of given integral can be performed analytically. ;  ; const RooArgSet & getCoefNormalization () const;  ; const char * getCoefRange () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  If all components that depend on obs are binned, so is their sum. ;  ; const RooArgList & pdfList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:4657,perform,performed,4657,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,2,['perform'],['performed']
Performance," override;  Creates a new window and return window number. ;  ; Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist) override;  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; void IntersectRegion (Region_t rega, Region_t regb, Region_t result) override;  Computes the intersection of two regions. ;  ; Bool_t IsCmdThread () const override;  Return kTRUE if we are inside cmd/server thread. ;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist) override;  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; Bool_t IsTransparent () const override;  ; Int_t KeysymToKeycode (UInt_t keysym) override;  Converts the ""keysym"" to the appropriate keycode. ;  ; char ** ListFonts (const char *fontname, Int_t max, Int_t &count) override;  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; FontStruct_t LoadQueryFont (const char *font_name) override;  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) override;  Convert the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; void LowerWindow (Window_t id) override;  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; void MapRaised (Window_t id) override;  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; void MapSubwindows (Window_t id) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t id) override;  Maps the window ""id"" and all of its subwindows that have had map requests. ;  ; void MoveResizeWindow (Window_t i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:16256,Load,LoadQueryFont,16256,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,2,"['Load', 'load']","['LoadQueryFont', 'loads']"
Performance," override;  Virtual function of TEveCaloViz. ;  ; TClass * IsA () const override;  ; void SetProjection (TEveProjectionManager *proj, TEveProjectable *model) override;  Set projection manager and model object. ;  ; void SetScaleAbs (Bool_t) override;  Set absolute scale in projected calorimeter. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateProjection () override;  This is virtual method from base-class TEveProjected. ;  ;  Public Member Functions inherited from TEveCaloViz;  TEveCaloViz (TEveCaloData *data=nullptr, const char *n=""TEveCaloViz"", const char *t="""");  ;  ~TEveCaloViz () override;  Destructor. ;  ; Bool_t AssertCellIdCache () const;  Assert cell id cache is ok. ;  ; TEveRGBAPalette * AssertPalette ();  Make sure the TEveRGBAPalette pointer is not null. ;  ; Bool_t CellInEtaPhiRng (TEveCaloData::CellData_t &) const;  Returns true if given cell is in the ceta phi range. ;  ; void DataChanged ();  Update setting and cache on data changed. ;  ; TEveElement * ForwardEdit () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; TEveElement * ForwardSelection () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; Bool_t GetAutoRange () const;  ; Float_t GetBackwardEndCapPos () const;  ; Float_t GetBarrelRadius () const;  ; TEveCaloData * GetData () const;  ; Color_t GetDataSliceColor (Int_t slice) const;  Get slice color from data. ;  ; Float_t GetDataSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Float_t GetEndCapPos () const;  ; Float_t GetEta () const;  ; Float_t GetEtaMax () const;  ; Float_t GetEtaMin () const;  ; Float_t GetEtaRng () const;  ; Float_t GetForwardEndCapPos () const;  ; Float_t GetMaxTowerH () const;  ; Float_t GetMaxVal () const;  ; Float_t GetMaxValAbs () const;  ; TEveRGBAPalette * GetPalette () const;  ; Float_t GetPhi () const;  ; Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCalo2D.html:3626,cache,cache,3626,doc/master/classTEveCalo2D.html,https://root.cern,https://root.cern/doc/master/classTEveCalo2D.html,1,['cache'],['cache']
Performance," overrideDefinition TLine.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetImplicitMTvirtual void SetImplicitMT(bool enabled)Definition TTree.h:661; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; int; ROOT::Experimental::Internal::GetProjectedFieldsOfModelRProjectedFields & GetProjectedFieldsOfModel(RNTupleModel &model)Definition RNTupleModel.cxx:42; ROOT::Experimental::Internal::CreateRNTupleWriterstd::unique_ptr< RNTupleWriter > CreateRNTupleWriter(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink)Definition RNTupleWriter.cxx:111; ROOT::Experimental::RNTupleImporter::RCStringTransformation::TransformRResult< void > Transform(const RImportBranch &branch, RImportField &field) finalDefinition RNTupleImporter.cxx:73; ROOT::Experimental::RNTupleImporter::RImportBranchDefinition RNTupleImporter.hxx:121; ROOT::Experimental::RNTupleImporter::RImportBranch::fBranchNamestd::string fBranchNameTop-level branch name from the input TTree.Definition RNTupleImporter.hxx:127; ROOT::Experimental::RNTupleImporter::RImportBranch::fBran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html:27128,Load,LoadTreevirtual,27128,doc/master/RNTupleImporter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html,2,['Load'],"['LoadTree', 'LoadTreevirtual']"
Performance," overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCacheManager.cxx. ◆ optimizeCacheMode(). void RooObjCacheManager::optimizeCacheMode ; (; const RooArgSet & ; obs, . RooArgSet & ; optNodes, . RooLinkedList & ; processedNodes . ). overridevirtual . Intercept calls to perform automatic optimization of cache mode operation. ; Forward calls to existing cache elements and save configuration of cache mode optimization so that it can be applied on new cache elements upon insertion ; Reimplemented from RooAbsCache.; Definition at line 129 of file RooObjCacheManager.cxx. ◆ printCompactTreeHook(). void RooObjCacheManager::printCompactTreeHook ; (; std::ostream & ; os, . const char * ; indent . ). overridevirtual . Add details on cache contents when printing in tree mode. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 194 of file RooObjCacheManager.cxx. ◆ redirectServersHook(). bool RooObjCacheManager::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overridevirtual . Intercept server redirect calls. ; If clearOnRedirect was set, sterilize the cache (i.e. keep the structure but delete all contents). If not forward serverRedirect to cache elements ; Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:10331,perform,perform,10331,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,3,"['cache', 'optimiz', 'perform']","['cache', 'optimization', 'perform']"
Performance," overwritten. ; Implements TInterpreter.; Definition at line 5478 of file TCling.cxx. ◆ UnloadAllSharedLibraryMaps(). Int_t TCling::UnloadAllSharedLibraryMaps ; (; ). finalvirtual . Unload the library map entries coming from all the loaded shared libraries. ; Returns 0 if succesful ; Implements TInterpreter.; Definition at line 5998 of file TCling.cxx. ◆ UnloadFile(). int TCling::UnloadFile ; (; const char * ; path); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7648 of file TCling.cxx. ◆ UnloadLibraryMap(). Int_t TCling::UnloadLibraryMap ; (; const char * ; library). finalvirtual . Unload library map entries coming from the specified library. ; Returns -1 in case no entries for the specified library were found, 0 otherwise. ; Implements TInterpreter.; Definition at line 6016 of file TCling.cxx. ◆ UnRegisterTClassUpdate(). void TCling::UnRegisterTClassUpdate ; (; const TClass * ; oldcl). finalvirtual . If the dictionary is loaded, we can remove the class from the list (otherwise the class might be loaded twice). ; Implements TInterpreter.; Definition at line 2393 of file TCling.cxx. ◆ UpdateAllCanvases(). void TCling::UpdateAllCanvases ; (; ). static . Update all canvases at end the terminal input command. ; Definition at line 6754 of file TCling.cxx. ◆ UpdateClassInfo(). void TCling::UpdateClassInfo ; (; char * ; name, . Long_t ; tagnum . ). static . No op: see TClingCallbacks. ; Definition at line 6739 of file TCling.cxx. ◆ UpdateClassInfoWithDecl(). void TCling::UpdateClassInfoWithDecl ; (; const clang::NamedDecl * ; ND). Internal function. Inform a TClass about its new TagDecl or NamespaceDecl. ; Definition at line 6681 of file TCling.cxx. ◆ UpdateClassInfoWork(). void TCling::UpdateClassInfoWork ; (; const char * ; name). static . Definition at line 6745 of file TCling.cxx. ◆ UpdateEnumConstants(). void TCling::UpdateEnumConstants ; (; TEnum * ; enumObj, . TClass * ; cl . ); const. finalvirtual . Implements TInterpreter.; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:140315,load,loaded,140315,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,2,['load'],['loaded']
Performance," ownership. More...;  ; class  ROOT::Internal::RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  ROOT::Internal::RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  TArchiveFile;  Class describing an archive file containing multiple sub-files, like a ZIP or TAR archive. More...;  ; class  TBufferFile;  The concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket. More...;  ; class  TBufferIO;  Direct subclass of TBuffer, implements common methods for TBufferFile and TBufferText classes. More...;  ; class  TBufferJSON;  Class for serializing object to and from JavaScript Object Notation (JSON) format. More...;  ; class  ROOT::TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  ROOT::TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TBufferSQL2;  Converts data to SQL statements or read data from SQL tables. More...;  ; class  TBufferText;  Base class for text-based streamers like TBufferJSON or TBufferXML Special actions list will use methods, introduced in this class. More...;  ; class  TBufferXML;  Class for serializing/deserializing object to/from xml. More...;  ; class  TCollectionClassStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TCollectionMemberStreamer;  Class streamer object to implement TMemberStreamer functionality for I/O emulation. More...;  ; class  TCollectionStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TStreamerInfoActions::TConfiguration;  Base class of the Configurations. More...;  ; class  TConvertClonesArrayToProxy;  Small helper to read a TBuffer containing a TClo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__IO.html:1870,queue,queue,1870,doc/master/group__IO.html,https://root.cern,https://root.cern/doc/master/group__IO.html,1,['queue'],['queue']
Performance," p. ; Definition at line 6767 of file TClass.cxx. ◆ ReadBuffer() [2/2]. Int_t TClass::ReadBuffer ; (; TBuffer & ; b, . void * ; pointer, . Int_t ; version, . UInt_t ; start, . UInt_t ; count . ). Function called by the Streamer functions to deserialize information from buffer b into object at p. ; This function assumes that the class version and the byte count information have been read.; version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer . Definition at line 6758 of file TClass.cxx. ◆ ReadRules() [1/2]. Int_t TClass::ReadRules ; (; ). static . Read the class.rules files from the default location:. ; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules) ; Definition at line 1820 of file TClass.cxx. ◆ ReadRules() [2/2]. Int_t TClass::ReadRules ; (; const char * ; filename). static . Read a class.rules file which contains one rule per line with comment starting with a #. . Returns the number of rules loaded.; Returns -1 in case of error. . Definition at line 1844 of file TClass.cxx. ◆ RegisterAddressInRepository(). void TClass::RegisterAddressInRepository ; (; const char * ; where, . void * ; location, . const TClass * ; what . ); const. private . Definition at line 290 of file TClass.cxx. ◆ RegisterStreamerInfo(). void TClass::RegisterStreamerInfo ; (; TVirtualStreamerInfo * ; info). Register the StreamerInfo in the given slot, change the State of the TClass as appropriate. ; Definition at line 7296 of file TClass.cxx. ◆ RemoveClass(). void TClass::RemoveClass ; (; TClass * ; cl). static . static: Remove a class from the list and map of classes ; Definition at line 520 of file TClass.cxx. ◆ RemoveClassDeclId(). void TClass::RemoveClassDeclId ; (; TDictionary::DeclId_t ; id). static . Definition at line 536 of file TClass.cxx. ◆ RemoveStreamerInfo(). void TClass::RemoveStreamerInfo ; (; Int_t ; slot). Remove and delete the StreamerInfo in the given slot. ; Update the slo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:111676,load,loaded,111676,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loaded']
Performance," p. ; Definition at line 6834 of file TClass.cxx. ◆ ReadBuffer() [2/2]. Int_t TClass::ReadBuffer ; (; TBuffer & ; b, . void * ; pointer, . Int_t ; version, . UInt_t ; start, . UInt_t ; count . ). Function called by the Streamer functions to deserialize information from buffer b into object at p. ; This function assumes that the class version and the byte count information have been read.; version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer . Definition at line 6825 of file TClass.cxx. ◆ ReadRules() [1/2]. Int_t TClass::ReadRules ; (; ). static . Read the class.rules files from the default location:. ; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules) ; Definition at line 1887 of file TClass.cxx. ◆ ReadRules() [2/2]. Int_t TClass::ReadRules ; (; const char * ; filename). static . Read a class.rules file which contains one rule per line with comment starting with a #. . Returns the number of rules loaded.; Returns -1 in case of error. . Definition at line 1911 of file TClass.cxx. ◆ RegisterAddressInRepository(). void TClass::RegisterAddressInRepository ; (; const char * ; where, . void * ; location, . const TClass * ; what . ); const. private . Definition at line 290 of file TClass.cxx. ◆ RegisterStreamerInfo(). void TClass::RegisterStreamerInfo ; (; TVirtualStreamerInfo * ; info). Register the StreamerInfo in the given slot, change the State of the TClass as appropriate. ; Definition at line 7363 of file TClass.cxx. ◆ RemoveClass(). void TClass::RemoveClass ; (; TClass * ; cl). static . static: Remove a class from the list and map of classes ; Definition at line 585 of file TClass.cxx. ◆ RemoveClassDeclId(). void TClass::RemoveClassDeclId ; (; TDictionary::DeclId_t ; id). static . Definition at line 603 of file TClass.cxx. ◆ RemoveStreamerInfo(). void TClass::RemoveStreamerInfo ; (; Int_t ; slot). Remove and delete the StreamerInfo in the given slot. ; Update the slo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:111677,load,loaded,111677,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loaded']
Performance," p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499245 s=0.2107, ; prevFCN = 26.37498621 f=0.2652, s=0.2107, ; prevFCN = 26.37498903 f=0.2652, ; prevFCN = 26.37498915 f=0.2652, m=2.259, ; prevFCN = 26.37498949 m=2.259, ; prevFCN = 26.37498869 m=2.259, p0=2.905e-06, ; prevFCN = 26.37499046 p0=2.736e-06, ; prevFCN = 26.37498772 p0=2.82e-06, s=0.2107, ; prevFCN = 26.37498971 s=0.2107, ; prevFCN = 26.37498846 f=0.2653, m=2.259, s=0.2107, ; prevFCN = 26.37499134 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499614 p0=2.82e-06, s=0.2108, ; prevFCN = 26.3749924 f=0.2652, m=2.259, p0=3.259e-06, s=0.2107, ; prevFCN = 26.37499844 p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499475 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499954 p0=2.82e-06, s=0.2107, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; ; prevFCN = 26.37498908 f=0.2667, ; prevFCN = 26.37503727 f=0.2636, ; prevFCN = 26.37504545 f=0.2657, ; prevFCN = 26.37499405 f=0.2646, ; prevFCN = 26.37499692 f=0.2652, m=2.261, ; prevFCN = 26.37506777 m=2.258, ; prevFCN = 26.37501136 m=2.26, ; prevFCN = 26.37500554 m=2.259, ; prevFCN = 26.37498543 m=2.259, p0=6.522e-06, ; prevFCN = 26.3750489 p0=6.471e-07, ; prevFCN = 26.37495398 p0=5.331e-06, ; prevFCN = 26.37502965 p0=1.101e-06, ; prevFCN = 26.37496132 p0=2.82e-06, s=0.2117, ; prevFCN = 26.37508362 s=0.2098, ; prevFCN = 26.37499532 s=0.2111, ; prevFCN = 26.37501134 s=0.2104, ; prevFCN = 26.37497963 f=0.2652, m=2.259, p0=1.367e-14, s=0.2103, ; prevFCN = 26.37493072 f=0.2658, ; prevFCN = 26.37493708 f=0.2647, ; prevFCN = 26.37493",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:24939,optimiz,optimization,24939,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,4,['optimiz'],['optimization']
Performance," packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the ""world"" of the model. We will often call this ""master reference system (MARS)"". Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong... We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:4079,Load,Load,4079,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['Load'],['Load']
Performance," parameter IINT from the internal parameter list. ;  ; virtual void mnfree (Int_t k);  Restores one or more fixed parameter(s) to variable status. ;  ; virtual void mngrad ();  Interprets the SET GRAD command. ;  ; virtual void mnhelp (const char *command="""");  interface to Minuit help ;  ; virtual void mnhelp (TString comd);  HELP routine for MINUIT interactive commands. ;  ; virtual void mnhes1 ();  Calculate first derivatives (GRD) and uncertainties (DGRD) ;  ; virtual void mnhess ();  Calculates the full second-derivative matrix of FCN. ;  ; virtual void mnimpr ();  Attempts to improve on a good local minimum. ;  ; virtual void mninex (Double_t *pint);  Transforms from internal coordinates (PINT) to external (U) ;  ; virtual void mninit (Int_t i1, Int_t i2, Int_t i3);  Main initialization member function for MINUIT. ;  ; virtual void mnlims ();  Interprets the SET LIM command, to reset the parameter limits. ;  ; virtual void mnline (Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler);  Perform a line search from position START. ;  ; virtual void mnmatu (Int_t kode);  Prints the covariance matrix v when KODE=1. ;  ; virtual void mnmigr ();  Performs a local function minimization. ;  ; virtual void mnmnos ();  Performs a MINOS error analysis. ;  ; virtual void mnmnot (Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi);  Performs a MINOS error analysis on one parameter. ;  ; virtual void mnparm (Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg);  Implements one parameter definition. ;  ; virtual void mnpars (TString &crdbuf, Int_t &icondn);  Implements one parameter definition. ;  ; virtual void mnpfit (Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p);  To fit a parabola to npar2p points. ;  ; virtual void mnpint (Double_t &pexti, Int_t i, Double_t &pinti);  Calculates the internal parameter value PINTI. ;  ; virtual void mnplot (Double_t *xpt, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:19940,Perform,Perform,19940,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,2,['Perform'],['Perform']
Performance," parameters one at a time, and \( \mathrm{Corr}_{i,j} = \left(\sigma_{\theta_i} \sigma_{\theta_j}\right)^{-1} \cdot \mathrm{Cov}_{i,j} \) is the correlation matrix from the fit result. ; Definition at line 2472 of file RooAbsReal.cxx. ◆ getTitle(). TString RooAbsReal::getTitle ; (; bool ; appendUnit = false); const. Return this variable's title string. ; If appendUnit is true and this variable has units, also append a string "" (<unit>)"". ; Definition at line 285 of file RooAbsReal.cxx. ◆ getUnit(). const Text_t * RooAbsReal::getUnit ; (; ); const. inline . Definition at line 143 of file RooAbsReal.h. ◆ getVal() [1/2]. double RooAbsReal::getVal ; (; const RooArgSet & ; normalisationSet); const. inline . Like getVal(const RooArgSet*), but always requires an argument for normalisation. ; Definition at line 126 of file RooAbsReal.h. ◆ getVal() [2/2]. double RooAbsReal::getVal ; (; const RooArgSet * ; normalisationSet = nullptr); const. inline . Evaluate object. ; Returns either cached value or triggers a recalculation. The recalculation happens by calling getValV(), which in the end calls the virtual evaluate() functions of the respective PDFs. Parameters. [in]normalisationSetgetValV() reacts differently depending on the value of the normalisation set. If the set is nullptr, an unnormalised value is returned. . NoteThe normalisation is arbitrary, because it is up to the implementation of the PDF to e.g. leave out normalisation constants for speed reasons. The range of the variables is also ignored.; To normalise the result properly, a RooArgSet has to be passed, which contains the variables to normalise over. These are integrated over their current ranges to compute the normalisation constant, and the unnormalised result is divided by this value. ; Definition at line 103 of file RooAbsReal.h. ◆ getValV(). double RooAbsReal::getValV ; (; const RooArgSet * ; nset = nullptr); const. virtual . Return value of object. ; If the cache is clean, return the cached value, otherwis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:113130,cache,cached,113130,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['cache'],['cached']
Performance," parameters one at a time, and \( \mathrm{Corr}_{i,j} = \left(\sigma_{\theta_i} \sigma_{\theta_j}\right)^{-1} \cdot \mathrm{Cov}_{i,j} \) is the correlation matrix from the fit result. ; Definition at line 2557 of file RooAbsReal.cxx. ◆ getTitle(). TString RooAbsReal::getTitle ; (; bool ; appendUnit = false); const. Return this variable's title string. ; If appendUnit is true and this variable has units, also append a string "" (<unit>)"". ; Definition at line 263 of file RooAbsReal.cxx. ◆ getUnit(). const Text_t * RooAbsReal::getUnit ; (; ); const. inline . Definition at line 143 of file RooAbsReal.h. ◆ getVal() [1/2]. double RooAbsReal::getVal ; (; const RooArgSet & ; normalisationSet); const. inline . Like getVal(const RooArgSet*), but always requires an argument for normalisation. ; Definition at line 126 of file RooAbsReal.h. ◆ getVal() [2/2]. double RooAbsReal::getVal ; (; const RooArgSet * ; normalisationSet = nullptr); const. inline . Evaluate object. ; Returns either cached value or triggers a recalculation. The recalculation happens by calling getValV(), which in the end calls the virtual evaluate() functions of the respective PDFs. Parameters. [in]normalisationSetgetValV() reacts differently depending on the value of the normalisation set. If the set is nullptr, an unnormalised value is returned. . NoteThe normalisation is arbitrary, because it is up to the implementation of the PDF to e.g. leave out normalisation constants for speed reasons. The range of the variables is also ignored.; To normalise the result properly, a RooArgSet has to be passed, which contains the variables to normalise over. These are integrated over their current ranges to compute the normalisation constant, and the unnormalised result is divided by this value. ; Definition at line 103 of file RooAbsReal.h. ◆ getValV(). double RooAbsReal::getValV ; (; const RooArgSet * ; nset = nullptr); const. virtual . Return value of object. ; If the cache is clean, return the cached value, otherwis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:114389,cache,cached,114389,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['cached']
Performance," parentName);; 3508 }; 3509 ; 3510 // Remove any leading dot.; 3511 if (dataName.Length()) {; 3512 if (dataName[0] == '.') {; 3513 dataName.Remove(0, 1);; 3514 }; 3515 }; 3516 ; 3517 // Remove any trailing dot.; 3518 if (dataName.Length()) {; 3519 if (dataName[dataName.Length()-1] == '.') {; 3520 dataName.Remove(dataName.Length() - 1, 1);; 3521 }; 3522 }; 3523 ; 3524 //; 3525 // Now that we have our data member name, find our offset; 3526 // in our parent class.; 3527 //; 3528 // Note: Our data member name can have many dots in it; 3529 // if branches were elided between our parent branch; 3530 // and us by Unroll().; 3531 //; 3532 // FIXME: This may not work if our member name is ambiguous.; 3533 //; 3534 ; 3535 Int_t offset = 0;; 3536 if (dataName.Length()) {; 3537 // -- We have our data member name, do a lookup in the dictionary meta info of our parent class.; 3538 // Get our parent class.; 3539 TClass* pClass = nullptr;; 3540 // First check whether this sub-branch is part of the 'cache' (because the data member it; 3541 // represents is no longer in the current class layout.; 3542 TStreamerInfo *subInfo = subBranch->GetInfoImp();; 3543 //if (subInfo && subBranch->TestBit(kCache)) { // subInfo->GetElements()->At(subBranch->GetID())->TestBit(TStreamerElement::kCache)) {; 3544 if (subBranchElement->TestBit(TStreamerElement::kCache)) {; 3545 pClass = ((TStreamerElement*)subInfo->GetElements()->At(0))->GetClassPointer();; 3546 }; 3547 // FIXME: Do we need the other base class tests here?; 3548 if (!pClass) {; 3549 if (fType == 1) {; 3550 // -- Parent branch is a base class branch.; 3551 // FIXME: Is using branchElem here the right thing?; 3552 pClass = branchElem->GetClassPointer();; 3553 if (pClass->Property() & kIsAbstract) {; 3554 // the class is abstract, let see if the; 3555 ; 3556 TBranchElement *parent = (TBranchElement*)GetMother()->GetSubBranch(this);; 3557 if (parent && parent != this && !parent->GetClass()->IsLoaded() ) {; 3558 // Our parent's class is emu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:128244,cache,cache,128244,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['cache'],['cache']
Performance," pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18745,cache,cache,18745,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance," pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20611,cache,cache,20611,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance," pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21453,cache,cache,21453,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance," pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:23453,cache,cache,23453,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance," path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:43211,load,load,43211,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,3,['load'],['load']
Performance," pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8py.html:3486,Optimiz,Optimization,3486,doc/master/rf506__msgservice_8py.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html,2,['Optimiz'],['Optimization']
Performance," peak. ; Function parameters:; a-amplitude of the peak; sx,sy-sigmas of peak; ro-correlation coefficient . Definition at line 1529 of file TSpectrum2Fit.cxx. Member Data Documentation. ◆ fA0Calc. Double_t TSpectrum2Fit::fA0Calc. protected . calculated value of background a0 parameter ; Definition at line 87 of file TSpectrum2Fit.h. ◆ fA0Err. Double_t TSpectrum2Fit::fA0Err. protected . error value of background a0 parameter ; Definition at line 88 of file TSpectrum2Fit.h. ◆ fA0Init. Double_t TSpectrum2Fit::fA0Init. protected . initial value of background a0 parameter(backgroud is estimated as a0+ax*x+ay*y) ; Definition at line 86 of file TSpectrum2Fit.h. ◆ fAlpha. Double_t TSpectrum2Fit::fAlpha. protected . convergence coefficient, input parameter, it should be positive number and <=1, for details see references ; Definition at line 28 of file TSpectrum2Fit.h. ◆ fAlphaOptim. Int_t TSpectrum2Fit::fAlphaOptim. protected . optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal ; Definition at line 25 of file TSpectrum2Fit.h. ◆ fAmpCalc. Double_t* TSpectrum2Fit::fAmpCalc. protected . [fNPeaks] array of calculated values of amplitudes of 2D peaks, output parameters ; Definition at line 43 of file TSpectrum2Fit.h. ◆ fAmpCalcX1. Double_t* TSpectrum2Fit::fAmpCalcX1. protected . [fNPeaks] array of calculated values of amplitudes of 1D ridges in x direction, output parameters ; Definition at line 46 of file TSpectrum2Fit.h. ◆ fAmpCalcY1. Double_t* TSpectrum2Fit::fAmpCalcY1. protected . [fNPeaks] array of calculated values of amplitudes of 1D ridges in y direction, output parameters ; Definition at line 49 of file TSpectrum2Fit.h. ◆ fAmpErr. Double_t* TSpectrum2Fit::fAmpErr. protected . [fNPeaks] array of amplitudes errors of 2D peaks, output parameters ; Definition at line 44 of file TSpectrum2Fit.h. ◆ fAmpErrX1. Double_t* TSpectrum2Fit::fAmpErrX1. protected . [fNPeaks] array of amplitudes errors of 1D ridges in x direction, output parameters ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:78457,optimiz,optimization,78457,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['optimiz'],['optimization']
Performance, per packet for parallel root.Definition TChainElement.cxx:92; TChainElement::~TChainElement~TChainElement() overrideDefault destructor for a chain element.Definition TChainElement.cxx:57; TChainElement::fNPacketsInt_t fNPacketsNumber of packets.Definition TChainElement.h:37; TChainElement::fPacketschar * fPackets! Packet descriptor stringDefinition TChainElement.h:46; TChainElement::EStatusBitsEStatusBitsTChainElement status bits.Definition TChainElement.h:31; TChainElement::kHasBeenLookedUp@ kHasBeenLookedUpDefinition TChainElement.h:32; TChainElement::SetDecomposedObjvoid SetDecomposedObj(bool m)Definition TChainElement.h:75; TChainElement::HasBeenLookedUpvirtual bool HasBeenLookedUp()Definition TChainElement.h:67; TChainElement::SetStatusvirtual void SetStatus(Int_t status)Definition TChainElement.h:80; TChainElement::SetLookedUpvirtual void SetLookedUp(bool y=true)Set/Reset the looked-up bit.Definition TChainElement.cxx:100; TChainElement::fLoadResultInt_t fLoadResult! Return value of TChain::LoadTree(); 0 means successDefinition TChainElement.h:48; TChainElement::GetBaddressTypevirtual UInt_t GetBaddressType() constDefinition TChainElement.h:58; TChainElement::GetBaddressIsPtrvirtual bool GetBaddressIsPtr() constDefinition TChainElement.h:57; TChainElement::SetNumberEntriesvirtual void SetNumberEntries(Long64_t n)Definition TChainElement.h:78; TChainElement::GetBranchPtrvirtual TBranch ** GetBranchPtr() constDefinition TChainElement.h:59; TChainElement::fStatusInt_t fStatusbranch status when used as a branchDefinition TChainElement.h:39; TChainElement::GetPacketSizevirtual Int_t GetPacketSize() constDefinition TChainElement.h:65; TChainElement::SetBaddressvirtual void SetBaddress(void *add)Definition TChainElement.h:69; TChainElement::TChainElementTChainElement()Default constructor for a chain element.Definition TChainElement.cxx:28; TChainElement::CreatePacketsvirtual void CreatePackets()Initialize the packet descriptor string.Definition TChainElement.cxx:65;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChainElement_8h_source.html:8664,Load,LoadTree,8664,doc/master/TChainElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TChainElement_8h_source.html,1,['Load'],['LoadTree']
Performance," performance measurements (decompression time, bytes read from storage, etc....Definition RNTupleReader.hxx:364; ROOT::Experimental::RNTupleReader::GetMetricsconst Detail::RNTupleMetrics & GetMetrics() constDefinition RNTupleReader.hxx:365; ROOT::Experimental::RNTupleReader::beginRIterator begin()Definition RNTupleReader.hxx:342; ROOT::Experimental::RNTupleReader::~RNTupleReader~RNTupleReader(); ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(DescriptorId_t fieldId, std::shared_ptr< T > objPtr)Definition RNTupleReader.hxx:295; ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(std::string_view fieldName)Provides access to an individual field that can contain either a scalar value or a collection,...Definition RNTupleReader.hxx:269; ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(std::string_view fieldName, std::shared_ptr< T > objPtr)Definition RNTupleReader.hxx:275; ROOT::Experimental::RNTupleReader::GetDescriptorconst RNTupleDescriptor & GetDescriptor()Returns a cached copy of the page source descriptor.Definition RNTupleReader.cxx:230; ROOT::Experimental::RNTupleReader::GetNEntriesNTupleSize_t GetNEntries() constDefinition RNTupleReader.hxx:175; ROOT::Experimental::RNTupleReader::fCachedDescriptorstd::unique_ptr< RNTupleDescriptor > fCachedDescriptorThe ntuple descriptor in the page source is protected by a read-write lock.Definition RNTupleReader.hxx:89; ROOT::Experimental::RNTupleReader::OpenFriendsstatic std::unique_ptr< RNTupleReader > OpenFriends(std::span< RNTupleOpenSpec > ntuples, const RNTupleReadOptions &options=RNTupleReadOptions())Open RNTuples as one virtual, horizontally combined ntuple.Definition RNTupleReader.cxx:117; ROOT::Experimental::RNTupleReader::GetCollectionViewRNTupleCollectionView GetCollectionView(std::string_view fieldName)Raises an exception if:Definition RNTupleReader.hxx:327; ROOT::Experimental::RNTupleReader::endRIterator end()Definition RNTupleReader.hxx:343; ROOT::Experimental",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:22399,cache,cached,22399,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['cache'],['cached']
Performance, performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.101 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: Higgs_trained_model.h5; PyKeras : [dataset] : Evaluation of PyKeras on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.168 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: Likelihood; : ; Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 1.0447 0.66216 [ 0.14661 10.222 ]; : m_jjj: 1.0275 0.37015 [ 0.34201 5.6016 ]; : m_lv: 1.0500 0.15582 [ 0.29757 2.8989 ]; : m_jlv: 1.0053 0.39478 [ 0.41660 5.8799 ]; : m_bb: 0.97464 0.52138 [ 0.10941 5.5163 ]; : m_wbb: 1.0296 0.35719 [ 0.38878 3.9747 ]; : m_wwbb: 0.95617 0.30368 [ 0.44118 4.0728 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: Fisher; : ; Fisher : [dataset] : Loop over test events and fill histograms with clas,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:51398,Load,Loading,51398,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['Load'],"['Loaded', 'Loading']"
Performance," platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105857,Load,Loading,1105857,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Loading']
Performance," plots will be stored here; theOption : option string; currently: ""V"" for verbose . Definition at line 113 of file Factory.cxx. ◆ Factory() [2/2]. TMVA::Factory::Factory ; (; TString ; theJobName, . TString ; theOption = """" . ). Constructor. ; Definition at line 204 of file Factory.cxx. ◆ ~Factory(). TMVA::Factory::~Factory ; (; void ; ). virtual . Destructor. ; Definition at line 306 of file Factory.cxx. Member Function Documentation. ◆ BookMethod() [1/3]. MethodBase * TMVA::Factory::BookMethod ; (; DataLoader * ; , . TMVA::Types::EMVA ; , . TString ; , . TString ; , . TMVA::Types::EMVA ; , . TString ;  . ). inline . Definition at line 102 of file Factory.h. ◆ BookMethod() [2/3]. TMVA::MethodBase * TMVA::Factory::BookMethod ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . TString ; methodTitle, . TString ; theOption = """" . ). Book a classifier or regression method. ; Definition at line 352 of file Factory.cxx. ◆ BookMethod() [3/3]. TMVA::MethodBase * TMVA::Factory::BookMethod ; (; TMVA::DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . TString ; theOption = """" . ). Books MVA method. ; The option configuration string is custom for each MVA the TString field ""theNameAppendix"" serves to define (and distinguish) several instances of a given MVA, eg, when one wants to compare the performance of various configurations ; Definition at line 487 of file Factory.cxx. ◆ BookMethodWeightfile(). TMVA::MethodBase * TMVA::Factory::BookMethodWeightfile ; (; DataLoader * ; loader, . TMVA::Types::EMVA ; methodType, . const TString & ; weightfile . ). private . Adds an already constructed method to be managed by this factory. ; NotePrivate. . Know what you are doing when using this method. The method that you are loading could be trained already. ; Definition at line 501 of file Factory.cxx. ◆ Class(). static TClass * TMVA::Factory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::Factory::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:22038,load,loader,22038,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance," point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) hte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:261154,load,loading,261154,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loading']
Performance," pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:43111,cache,cache,43111,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,4,['cache'],['cache']
Performance," pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheEl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:48449,cache,cache,48449,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance," pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void copyList(TList& dest, const TList& source); WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:26918,cache,cached,26918,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['cache'],['cached']
Performance," pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:27465,cache,cached,27465,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,4,['cache'],['cached']
Performance," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBufferFile.html:47452,perform,performance,47452,root/html532/TBufferFile.html,https://root.cern,https://root.cern/root/html532/TBufferFile.html,2,['perform'],['performance']
Performance," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferFile.html:49754,perform,performance,49754,root/html602/TBufferFile.html,https://root.cern,https://root.cern/root/html602/TBufferFile.html,2,['perform'],['performance']
Performance," points array. ;  ; void PutImage (Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Put (x,y,w,h) part of image img in window win at position dx,dy. ;  ; void PutPixel (Drawable_t id, Int_t x, Int_t y, ULong_t pixel) override;  Set pixel at specified location in XImage img. ;  ; void QueryColor (Colormap_t cmap, ColorStruct_t &color) override;  Fill in the primary color components for a specific pixel value. ;  ; void QueryPointer (Int_t &ix, Int_t &iy) override;  Query pointer position. ;  ; void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask) override;  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; void RaiseWindow (Window_t id) override;  Put window on top of window stack. ;  ; Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t id=0) override;  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data) override;  Read picture data from file and store in ret_data. ;  ; void RemoveWindow (ULong_t qwid) override;  Remove a window created by Qt (like CloseWindow1()). ;  ; void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y) override;  Reparent window to new parent window at position (x,y). ;  ; Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) override;  Request Locator position. ;  ; Int_t RequestString (Int_t x, Int_t y, char *text) override;  Request a string. ;  ; void RescaleWindow (Int_t wid, UInt_t w, UInt_t h) override;  Rescale the window wid. ;  ; Int_t ResizePixmap (Int_t wid, UInt_t w, UInt_t h) override;  Resize a pixmap. ;  ; void ResizeWindow (Int_t wid) override;  Resize the current window if necessary. ;  ; void ResizeWindow (Window_t id, UInt_t w, UInt_t h) override;  Resize the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:18018,load,loads,18018,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,2,['load'],['loads']
Performance," points to TString for compatibility with Which(const char *, const char *, EAccessMode). Returns 0 in case file is not found. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1538 of file TSystem.cxx. ◆ FindHelper(). TSystem * TSystem::FindHelper ; (; const char * ; path, . void * ; dirptr = nullptr . ). protected . Create helper TSystem to handle file and directory operations that might be special for remote file access. ; Definition at line 746 of file TSystem.cxx. ◆ FreeDirectory(). void TSystem::FreeDirectory ; (; void * ; dirp). virtual . Free a directory. ; Reimplemented in TDavixSystem, TUnixSystem, TWinNTSystem, TDCacheSystem, TWebSystem, TNetXNGSystem, and TNetSystem.; Definition at line 845 of file TSystem.cxx. ◆ GetAclicMode(). TSystem::EAclicMode TSystem::GetAclicMode ; (; ); const. virtual . AclicMode indicates whether the library should be built in debug mode or optimized. ; The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library . Definition at line 3947 of file TSystem.cxx. ◆ GetAclicProperties(). Int_t TSystem::GetAclicProperties ; (; ); const. virtual . Return the ACLiC properties field. ; See EAclicProperties for details on the semantic of each bit. ; Definition at line 3867 of file TSystem.cxx. ◆ GetBeepDefaults(). void TSystem::GetBeepDefaults ; (; Int_t & ; freq, . Int_t & ; duration . ); const. inline . Definition at line 360 of file TSystem.h. ◆ GetBuildArch(). const char * TSystem::GetBuildArch ; (; ); const. virtual . Return the build architecture. ; Definition at line 3875 of file TSystem.cxx. ◆ GetBuildCompiler(). const char * TSystem::GetBuildCompiler ; (; ); const. virtual . Return the build compiler. ; Definition at line 3883 of file TSystem.cxx. ◆ GetBuildCompilerVersion(). const char * TSystem::GetBuildCompilerVersion ; (; ); const. virtual . Return the build compiler version. ; Definition at line 3891 of file TSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:53472,optimiz,optimized,53472,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimized']
Performance," position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd1Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd1Editor.html:21019,Perform,Perform,21019,root/html528/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html528/TGeoTrd1Editor.html,1,['Perform'],['Perform']
Performance," position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd1Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrd1Editor.html:21119,Perform,Perform,21119,root/html530/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html530/TGeoTrd1Editor.html,1,['Perform'],['Perform']
Performance," position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd1Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrd1Editor.html:21119,Perform,Perform,21119,root/html532/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html532/TGeoTrd1Editor.html,1,['Perform'],['Perform']
Performance," previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for accelerated running); # Mode = 2 : Run fit from previously stored workspace including cached; # integrals (fast, run in mode=1 first); ; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; ; # Make/load workspace, here in mode 1; w = getWorkspace(mode); if mode == 1:; # Show workspace that was created; w.Print(); ; # Show plot of cached integral values; hhcache = w.expensiveObjectCache().getObj(1); if hhcache:; ROOT.TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600); hhcache.createHistogram(""a"").Draw(); else:; ROOT.RooFit.Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace""); sys.exit(); ; # Use pdf ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:1697,Load,Load,1697,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,1,['Load'],['Load']
Performance," procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:33856,queue,queued,33856,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,6,['queue'],['queued']
Performance," procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, depe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:11046,Perform,Perform,11046,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['Perform'],['Perform']
Performance," processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct stopping; 492 /// condition for the loop (i.e. the total number of entries). In the TChain; 493 /// case, calling GetEntries instead would open all the files in the chain; 494 /// upfront which could be costly.; 495 ///; 496 /// The functionality offered by this method can also be seen when used in; 497 /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; 498 /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; 499 /// satisfied if \p ievent is strictly smaller than the total number of; 500 /// entries in the dataset. In fact, even when the dataset is a TChain, the; 501 /// first time LoadTree is called with an entry number that belongs to the; 502 /// last file of the chain, this will update the internal data member of the; 503 /// class so that the next call to GetEntriesFast returns the total number; 504 /// of entries in the dataset.; 505 virtual Long64_t GetEntriesFast() const { return fEntries; }; 506 virtual Long64_t GetEntriesFriend() const;; 507 virtual Long64_t GetEstimate() const { return fEstimate; }; 508 virtual Int_t GetEntry(Long64_t entry, Int_t getall = 0);; 509 Int_t GetEvent(Long64_t entry, Int_t getall = 0) { return GetEntry(entry, getall); }; 510 virtual Int_t GetEntryWithIndex(Int_t major,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:26555,Load,LoadTree,26555,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['Load'],['LoadTree']
Performance," profile2D errors. ;  ; void GetStats (Double_t *stats) const override;  fill the array stats from the contents of this profile. ;  ; virtual Double_t GetTmax () const;  ; virtual Double_t GetTmin () const;  ; TClass * IsA () const override;  ; void LabelsDeflate (Option_t *axis=""X"") override;  Reduce the number of bins for this axis to the number of bins having a label. ;  ; void LabelsInflate (Option_t *axis=""X"") override;  Double the number of bins for axis. ;  ; void LabelsOption (Option_t *option=""h"", Option_t *axis=""X"") override;  Set option(s) to draw axis with labels. ;  ; Long64_t Merge (TCollection *list) override;  Merge all histograms in the collection in this histogram. ;  ; Bool_t Multiply (const TH1 *h1) override;  Multiply this profile2D by h1. ;  ; Bool_t Multiply (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""") override;  Replace contents of this profile2D by multiplication of h1 by h2. ;  ; Bool_t Multiply (TF1 *h1, Double_t c1=1) override;  Performs the operation: this = this*c1*f1 . ;  ; TProfile3D & operator= (const TProfile3D &profile);  ; TProfile2D * Project3DProfile (Option_t *option=""xy"") const override;  Project a 3-D profile into a 2D-profile histogram depending on the option parameter. ;  ; virtual TH3D * ProjectionXYZ (const char *name=""_pxyz"", Option_t *option=""e"") const;  Project this profile3D into a 3-D histogram along X,Y,Z. ;  ; void PutStats (Double_t *stats) override;  Replace current statistics with the values in array stats. ;  ; void Reset (Option_t *option="""") override;  Reset contents of a Profile3D histogram. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; void Scale (Double_t c1=1, Option_t *option="""") override;  Multiply this profile2D by a constant c1. ;  ; virtual void SetBinEntries (Int_t bin, Double_t w);  Set the number of entries in bin. ;  ; void SetBins (Int_t nbinsx, Double_t xmin, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:6798,Perform,Performs,6798,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['Perform'],['Performs']
Performance," projection; configurations can be cached. ; . Function Members (Methods); public:. virtual~RooCacheManager<vector<double,allocator<double> > >(); Int_tcacheSize() const; static TClass*Class(); virtual voidRooAbsCache::findConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); vector<double,allocator<double> >*getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); vector<double,allocator<double> >*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); vector<double,allocator<double> >*getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(vector<double,allocator<double> >&); virtual TClass*IsA() const; Int_tlastIndex() const; const RooNameSet*nameSet1ByIndex(Int_t index) const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<vector<double,allocator<double> > >&operator=(const RooCacheManager<vector<double,allocator<double> > >&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); RooCacheManager<vector<double,allocator<double> > >(Int_t maxSize = 10); RooCacheManager<vector<double,allocator<double> > >(RooAbsArg* owner, Int_t maxSize = 10); RooCacheManager<vector<double,allocator<double> > >(const RooCacheManager<vector<double,allocator<double> > >& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_vector_double___.html:2136,optimiz,optimizeCacheMode,2136,root/html528/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_vector_double___.html,1,['optimiz'],['optimizeCacheMode']
Performance," protected:. Int_t_arrSizeSize of the weight array; Bool_t*_binValid! Valid bins with current range definition; vector<std::vector<Double_t> >_binbounds! list of bin bounds per dimension; Double_t*_binv[_arrSize] Bin volume array ; TIterator*RooAbsData::_cacheIter! Iterator over cached variables; Double_t_cache_sum! Cache for sum of entries ;; Int_t_cache_sum_valid! Is cache sum valid; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; Int_t_curIndexCurrent index; Double_t_curSumW2Current sum of weights^2; Double_t_curVolumeVolume of bin enclosing current coordinate; Double_t_curWeightWeight associated with the current coordinate; Double_t_curWgtErrHiError on weight associated with the current coordinate; Double_t_curWgtErrLoError on weight associated with the current coordinate; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; Double_t*_errHi[_arrSize] High-side error on weight array; Double_t*_errLo[_arrSize] Low-side error on weight array; vector<Int_t>_idxMultMultiplier jump table for index calculation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; vector<const RooAbsBinning*>_lvbins! List of used binnings associated with lvalues; vector<RooAbsLValue*>_lvvars! List of observables casted as RooAbsLValue; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; vector<Double_t>*_pbinv! Partial bin volume array; RooCacheManager<std::vector<Double_t> >_pbinvCacheMgr! Cache manager for arrays of partial bin volumes; TIterator*_realIter! Iterator over realVars; RooArgSet_realVarsReal dimensions of the dataset ; Double_t*_sumw2[_arrSize] Sum of weights^2; RooArgSetRooAbsData::_varsDimensions of this data set; Double_t*_wgt[_arrSize] Weight array; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Chart",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:18040,cache,cached,18040,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,5,"['Cache', 'cache']","['Cache', 'cache', 'cached']"
Performance," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:7874,perform,perform,7874,root/html534/ROOT__Math__GSLMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html,1,['perform'],['perform']
Performance," protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTFnBinding.html:32205,cache,cache,32205,root/html534/RooTFnBinding.html,https://root.cern,https://root.cern/root/html534/RooTFnBinding.html,7,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance," provides a common mechanism for viewer clients to publish 3D objects to it. It enables:. Decoupling of producers (geometry packages etc) who model collection of 3D objects from consumers (viewers) which display them.; Producer code free of explicit drawing commands & viewer specific branching.; Support differing viewers and clients capabilities, e.g.; Mix of native (in viewer) shapes and generic client side tessellation.; Local/global frame object description; Bounding boxes; Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing client to add objects, test preferences etc.; TBuffer3D class hierarchy: Used to describe 3D objects (“shapes”) - filled /added by negotiation with viewer via TVirtualViewer3D. A typical interaction between viewer and client using these, taken from TGeoPainter is:; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; Together these allow clients to publish objects to any one of the 3D viewers free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; In addition to external viewers, created in separate windows, this architecture is also used by internal TPad drawing when it requires 3D projections. Publishing to a viewer consists of the following steps:; 1- C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:402732,Perform,Perform,402732,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Perform']
Performance," providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. Ther",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:5617,cache,cache,5617,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['cache'],['cache']
Performance," public RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__MultiBuildConfig.html:1328,perform,performed,1328,root/html534/RooSimWSTool__MultiBuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__MultiBuildConfig.html,3,['perform'],['performed']
Performance," pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringfMsgGetHeadcache GetHead() msg; TStringfMsgReadBuffercache ReadBuffer() msg; TStringfMsgReadBuffer10cache ReadBuffer10() msg; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Bool_tfNoProxydon't use proxy; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; TUrlfProxyproxy URL; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Long64_tfSizefile size; TSocket*fSocketsocket for HTTP/1.1 (stays alive between calls); Double_tTFile::fSum2BufferSum of squares of buffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:22307,cache,cache,22307,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,4,['cache'],['cache']
Performance," pyobject.; 109 if (!Initialize()); 110 return nullptr;; 111 ; 112// check validity of cast; 113 if (!CPPInstance_Check(pyobject)); 114 return nullptr;; 115 ; 116// get held object (may be null); 117 return ((CPPInstance*)pyobject)->GetObject();; 118}; 119 ; 120//-----------------------------------------------------------------------------; 121PyObject* CPyCppyy::Instance_FromVoidPtr(; 122 void* addr, const std::string& classname, bool python_owns); 123{; 124// Bind the addr to a python object of class defined by classname.; 125 if (!Initialize()); 126 return nullptr;; 127 ; 128// perform cast (the call will check TClass and addr, and set python errors); 129 PyObject* pyobject = BindCppObjectNoCast(addr, Cppyy::GetScope(classname), false);; 130 ; 131// give ownership, for ref-counting, to the python side, if so requested; 132 if (python_owns && CPPInstance_Check(pyobject)); 133 ((CPPInstance*)pyobject)->PythonOwns();; 134 ; 135 return pyobject;; 136}; 137 ; 138namespace CPyCppyy {; 139// version with C type arguments only for use with Numba; 140PyObject* Instance_FromVoidPtr(void* addr, const char* classname, int python_owns) {; 141 return Instance_FromVoidPtr(addr, std::string(classname), (bool)python_owns);; 142}; 143} // namespace CPyCppyy; 144 ; 145//-----------------------------------------------------------------------------; 146bool CPyCppyy::Scope_Check(PyObject* pyobject); 147{; 148// Test if the given object is of a CPPScope derived type.; 149 if (!Initialize()); 150 return false;; 151 ; 152 return CPPScope_Check(pyobject);; 153}; 154 ; 155//-----------------------------------------------------------------------------; 156bool CPyCppyy::Scope_CheckExact(PyObject* pyobject); 157{; 158// Test if the given object is of a CPPScope type.; 159 if (!Initialize()); 160 return false;; 161 ; 162 return CPPScope_CheckExact(pyobject);; 163}; 164 ; 165//-----------------------------------------------------------------------------; 166bool CPyCppyy::Instance_Check(PyObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:4108,perform,perform,4108,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['perform'],['perform']
Performance, queries; TStringfDataSetDirdirectory containing info about known data sets; TDataSetManager*fDataSetManagerdataset manager; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:17833,latency,latency,17833,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['latency'],['latency']
Performance, queries; TStringfDataSetDirdirectory containing info about known data sets; TDataSetManager*fDataSetManagerdataset manager; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:18042,latency,latency,18042,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['latency'],['latency']
Performance," questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy.; Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. 5.10 Minuit2 Package; Minuit2 is a new object-oriented implementation, written in C++, of the popular MINUIT minimization package. Compared with the TMinuit class, which is a direct conversion from FORTRAN to C++, Minuit2 is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 plug-ins are provided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online referen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:225853,optimiz,optimized,225853,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance," range in which events counts are to be defined; x.setRange(""signalRange"",4,6) ;; ; // Associated nsig/nbkg as expected number of events with sig/bkg _in_the_range_ ""signalRange""; RooRealVar nsig(""nsig"",""number of signal events in signalRange"",500,0.,10000) ;; RooRealVar nbkg(""nbkg"",""number of background events in signalRange"",500,0,10000) ;; ; // Use AddPdf to extend the model. Giving as many coefficients as pdfs switches; // on extension.; RooAddPdf model(""model"",""(g1+g2)+a"", RooArgList(bkg,sig), RooArgList(nbkg,nsig)) ;; ; ; // S a m p l e d a t a , f i t m o d e l; // -------------------------------------------; ; // Generate 1000 events from model so that nsig,nbkg come out to numbers <<500 in fit; std::unique_ptr<RooDataSet> data{model.generate(x,1000)};; ; ; ; auto canv = new TCanvas(""Canvas"", ""Canvas"", 1500, 600);; canv->Divide(3,1);; ; // Fit full range; // -------------------------------------------; ; canv->cd(1);; ; // Perform unbinned ML fit to data, full range; ; // IMPORTANT:; // The model needs to be copied when fitting with different ranges because; // the interpretation of the coefficients is tied to the fit range; // that's used in the first fit; RooAddPdf model1(model);; std::unique_ptr<RooFitResult> r{model1.fitTo(*data,Save(), PrintLevel(-1))};; r->Print() ;; ; RooPlot * frame = x.frame(Title(""Full range fitted""));; data->plotOn(frame);; model1.plotOn(frame, VisualizeError(*r));; model1.plotOn(frame);; model1.paramOn(frame);; frame->Draw();; ; ; // Fit in two regions; // -------------------------------------------; ; canv->cd(2);; x.setRange(""left"", 0., 4.);; x.setRange(""right"", 6., 10.);; ; RooAddPdf model2(model);; std::unique_ptr<RooFitResult> r2{model2.fitTo(*data, Range(""left,right""), Save(), PrintLevel(-1))};; r2->Print();; ; ; RooPlot * frame2 = x.frame(Title(""Fit in left/right sideband""));; data->plotOn(frame2);; model2.plotOn(frame2, VisualizeError(*r2));; model2.plotOn(frame2);; model2.paramOn(frame2);; frame2->Draw();; ; ; // Fit in o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html:2746,Perform,Perform,2746,doc/master/rf204a__extendedLikelihood_8C.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html,1,['Perform'],['Perform']
Performance," range is shown; ; # Print fit results; print(""result of fit on all data ""); r_full.Print(); print(""result of fit in in signal region (note increased error on signal fraction)""); r_sig.Print(); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf203_ranges"", ""rf203_ranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf203_ranges.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signal' created with bounds [-3,3]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-3,3]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeName>"").; The defa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf203__ranges_8py.html:2391,optimiz,optimization,2391,doc/master/rf203__ranges_8py.html,https://root.cern,https://root.cern/doc/master/rf203__ranges_8py.html,4,['optimiz'],['optimization']
Performance," rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:2273,Cache,CacheModeRooAbsArg,2273,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,32,['Cache'],['CacheModeRooAbsArg']
Performance," rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:4425,Cache,CacheModeRooAbsArg,4425,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['Cache'],['CacheModeRooAbsArg']
Performance," ranges etc ;  CRooAbsCacheRooAbsCache is the abstract base class for data members of RooAbsArgs that cache other (composite) RooAbsArg expressions ;  ►CRooAbsCachedPdfRooAbsCachedPdf is the abstract base class for p.d.f.s that need or want to cache their evaluate() output in a RooHistPdf defined in terms of the used observables ;  CAnaIntConfigRegistry for analytical integration codes ;  CPdfCacheElem;  ►CRooAbsCachedRealRooAbsCachedReal is the abstract base class for functions that need or want to cache their evaluate() output in a RooHistFunc defined in terms of the used observables ;  CFuncCacheElem;  CRooAbsCacheElementRooAbsCacheElement is the abstract base class for objects to be stored in RooAbsCache cache manager objects ;  CRooAbsCategoryRooAbsCategory is the common abstract base class for objects that represent a discrete value with a finite number of states ;  CRooAbsCategoryLValueRooAbsCategoryLValue is the common abstract base class for objects that represent a discrete value that may appear on the left hand side of an equation ('lvalue') ;  CRooAbsCollectionRooAbsCollection is an abstract container object that can hold multiple RooAbsArg objects ;  ►CRooAbsDataRooAbsData is the common abstract base class for binned and unbinned datasets ;  CPlotOpt;  CRooAbsDataStoreRooAbsDataStore is the abstract base class for data collection that use a TTree as internal storage mechanism ;  CRooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it ;  CRooAbsGenContextRooAbsGenContext is the abstract base class for generator contexts of RooAbsPdf objects ;  CRooAbsHiddenRealRooAbsHiddenReal is a base class for objects that want to hide their return value from interactive use, e.g ;  CRooAbsIntegratorRooAbsIntegrator is the abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface ;  CRooAbsLValueAbstract base class for objects that are lvalues, i.e ;  CR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:75711,cache,cache,75711,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,20,"['cache', 'perform']","['cache', 'performing']"
Performance," records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:341952,cache,cache,341952,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance," refer to 5 for a full discussion):. Define \(\mathbf{P} = (P_1, \ldots, P_5)\) are the 5 dependent quantities that define a track.; Compute, for \( M\) different values of \(\mathbf{P}\), the tracks through the magnetic field, and determine the corresponding \(\mathbf{x} = (x_1, \ldots, x_N)\).; Use the simulated observations to determine, with a simple approximation, the values of \(\mathbf{P}_j\). We call these values \(\mathbf{P}^\prime_j, j = 1, \ldots, M\).; Determine from \(\mathbf{x}\) a set of at least five relevant coordinates \(\mathbf{x}^\prime\), using contrains, or alternative:; Perform a Principal Component Analysis (using TPrincipal), and use to get a linear transformation \(\mathbf{x} \rightarrow \mathbf{x}^\prime\), so that \(\mathbf{x}^\prime\) are constrained and linear independent.; Perform a Principal Component Analysis on \(Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\), to get linear indenpendent (among themselves, but not independent of \(\mathbf{x}\)) quantities \(\mathbf{Q}^\prime\); For each component \(Q^\prime_i\) make a multidimensional fit, using \(\mathbf{x}^\prime\) as the variables, thus determining a set of coefficients \(\mathbf{c}_i\). To process data, using this parameterisation, do; Test wether the observation \(\mathbf{x}\) within the domain of the parameterization, using the result from the Principal Component Analysis.; Determine \(\mathbf{P}^\prime\) as before.; Determine \(\mathbf{x}^\prime\) as before.; Use the result of the fit to determine \(\mathbf{Q}^\prime\).; Transform back to \(\mathbf{P}\) from \(\mathbf{Q}^\prime\), using the result from the Principal Component Analysis. Testing the parameterization; The class also provides functionality for testing the, over the training sample, found parameterization (TMultiDimFit::Fit). This is done by passing the class a test sample of \( M_t\) tuples of the form \((\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\), where \(\mathbf{x}_{t,j}\) are the independent variables, \( D_{t,j}\) the k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:14982,Perform,Perform,14982,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['Perform'],['Perform']
Performance," request; Long64_tfBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tfBytesReadNumber of bytes read from this file; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tfBytesWriteNumber of bytes written to this file; TFileCacheRead*fCacheRead!Pointer to the read cache (if any); TFileCacheWrite*fCacheWrite!Pointer to the write cache (if any); TArrayC*fClassIndex!Index of TStreamerInfo classes written to this file; Int_tfCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tfDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tfENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*fFreeFree segments linked list table; TList*fInfoCache!Cached list of the streamer infos in this file; Bool_tfInitDone!True if the file has been initialized; Bool_tfIsArchive!True if this is a pure archive file; Bool_tfIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:19471,Cache,Cached,19471,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,2,['Cache'],['Cached']
Performance," requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5801 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5824 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4258 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:103144,Load,LoadClassInfo,103144,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['Load'],['LoadClassInfo']
Performance," requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5868 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5891 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4325 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:103145,Load,LoadClassInfo,103145,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['Load'],['LoadClassInfo']
Performance," resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidselectDefaultAlgorithm(); voidselectFastAlgorithm(); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooVoigtian.html:27301,cache,cache,27301,root/html528/RooVoigtian.html,https://root.cern,https://root.cern/root/html528/RooVoigtian.html,1,['cache'],['cache']
Performance," resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistPdf.html:27654,cache,cache,27654,root/html530/RooHistPdf.html,https://root.cern,https://root.cern/root/html530/RooHistPdf.html,1,['cache'],['cache']
Performance," respective PDFs. Parameters. [in]normalisationSetgetValV() reacts differently depending on the value of the normalisation set. If the set is nullptr, an unnormalised value is returned. . NoteThe normalisation is arbitrary, because it is up to the implementation of the PDF to e.g. leave out normalisation constants for speed reasons. The range of the variables is also ignored.; To normalise the result properly, a RooArgSet has to be passed, which contains the variables to normalise over. These are integrated over their current ranges to compute the normalisation constant, and the unnormalised result is divided by this value. ; Definition at line 103 of file RooAbsReal.h. ◆ getValV(). double RooAbsReal::getValV ; (; const RooArgSet * ; nset = nullptr); const. virtual . Return value of object. ; If the cache is clean, return the cached value, otherwise recalculate on the fly and refill the cache ; Reimplemented in RooConstVar, RooNormalizedPdf, ProgressMonitor, RooAbsHiddenReal, RooConvCoefVar, RooRealMPFE, RooRealVar, RooResolutionModel, RooMomentMorph, RooMomentMorphFunc, RooMomentMorphFuncND, RooAbsCachedPdf, RooAbsCachedReal, RooAbsPdf, RooAddPdf, RooErrorVar, and RooRealIntegral.; Definition at line 281 of file RooAbsReal.cxx. ◆ globalSelectComp(). void RooAbsReal::globalSelectComp ; (; bool ; flag). staticprotected . Global switch controlling the activation of the selectComp() functionality. ; Definition at line 3051 of file RooAbsReal.cxx. ◆ gradient(). virtual void RooAbsReal::gradient ; (; double * ; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 395 of file RooAbsReal.h. ◆ hasGradient(). virtual bool RooAbsReal::hasGradient ; (; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 394 of file RooAbsReal.h. ◆ hideOffset(). bool RooAbsReal::hideOffset ; (; ). static . Definition at line 169 of file RooAbsReal.cxx. ◆ integralNameSuffix(). TString RooAbsReal::inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:115352,cache,cache,115352,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,3,['cache'],"['cache', 'cached']"
Performance," respective PDFs. Parameters. [in]normalisationSetgetValV() reacts differently depending on the value of the normalisation set. If the set is nullptr, an unnormalised value is returned. . NoteThe normalisation is arbitrary, because it is up to the implementation of the PDF to e.g. leave out normalisation constants for speed reasons. The range of the variables is also ignored.; To normalise the result properly, a RooArgSet has to be passed, which contains the variables to normalise over. These are integrated over their current ranges to compute the normalisation constant, and the unnormalised result is divided by this value. ; Definition at line 103 of file RooAbsReal.h. ◆ getValV(). double RooAbsReal::getValV ; (; const RooArgSet * ; nset = nullptr); const. virtual . Return value of object. ; If the cache is clean, return the cached value, otherwise recalculate on the fly and refill the cache ; Reimplemented in RooConstVar, RooNormalizedPdf, ProgressMonitor, RooAbsHiddenReal, RooConvCoefVar, RooRealVar, RooResolutionModel, RooRealMPFE, RooMomentMorph, RooMomentMorphFunc, RooMomentMorphFuncND, RooAbsCachedPdf, RooAbsCachedReal, RooAbsPdf, RooAddPdf, RooErrorVar, and RooRealIntegral.; Definition at line 300 of file RooAbsReal.cxx. ◆ globalSelectComp(). void RooAbsReal::globalSelectComp ; (; bool ; flag). staticprotected . Global switch controlling the activation of the selectComp() functionality. ; Definition at line 2966 of file RooAbsReal.cxx. ◆ gradient(). virtual void RooAbsReal::gradient ; (; double * ; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 388 of file RooAbsReal.h. ◆ hasGradient(). virtual bool RooAbsReal::hasGradient ; (; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 387 of file RooAbsReal.h. ◆ hideOffset(). bool RooAbsReal::hideOffset ; (; ). static . Definition at line 192 of file RooAbsReal.cxx. ◆ integralNameSuffix(). TString RooAbsReal::inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:114093,cache,cache,114093,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,3,['cache'],"['cache', 'cached']"
Performance," result; 341~~~; 342The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; 343the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; 344which signals whether the event passes the filter (`true`) or not (`false`).; 345 ; 346You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; 347perform actions. Multiple Filter() calls can be chained one after another.; 348 ; 349Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; 350statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; 351runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; 352runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; 353but it can be any kind of function or even a functor class), together with a list of column names.; 354This snippet is analogous to the one above:; 355~~~{.cpp}; 356RDataFrame d(""myTree"", ""file.root"");; 357auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; 358auto c = d.Filter(metCut, {""MET""}).Count();; 359std::cout << *c << std::endl;; 360~~~; 361 ; 362An example of a more complex filter expressed as a string containing C++ code is shown below; 363 ; 364~~~{.cpp}; 365RDataFrame d(""myTree"", ""file.root"");; 366auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); 367 .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x*x; return sqrt(p2) < 10.0;"");; 368~~~; 369 ; 370The code snippet above defines a column `p` that is a fixed-size array using the component column names and then; 371filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns; 37",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:21194,perform,performance,21194,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['performance']
Performance," result; 345~~~; 346The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; 347the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; 348which signals whether the event passes the filter (`true`) or not (`false`).; 349 ; 350You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; 351perform actions. Multiple Filter() calls can be chained one after another.; 352 ; 353Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; 354statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; 355runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; 356runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; 357but it can be any kind of function or even a functor class), together with a list of column names.; 358This snippet is analogous to the one above:; 359~~~{.cpp}; 360RDataFrame d(""myTree"", ""file.root"");; 361auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; 362auto c = d.Filter(metCut, {""MET""}).Count();; 363std::cout << *c << std::endl;; 364~~~; 365 ; 366An example of a more complex filter expressed as a string containing C++ code is shown below; 367 ; 368~~~{.cpp}; 369RDataFrame d(""myTree"", ""file.root"");; 370auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); 371 .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x*x; return sqrt(p2) < 10.0;"");; 372~~~; 373 ; 374The code snippet above defines a column `p` that is a fixed-size array using the component column names and then; 375filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns; 37",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:21636,perform,performance,21636,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['performance']
Performance," results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 557 of file TThreadExecutor.hxx. ◆ MapReduce() [3/8]. template<class F , class INTEGER , class R , class Cond > . auto ROOT::TThreadExecutor::MapReduce ; (; F ; func, . ROOT::TSeq< INTEGER > ; args, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F, INTEGER>. Execute a function in parallel over the elements of a vector (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results.; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed assecond argument as a parameter. ; argsSequence of indexes to execute func on. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 504 of file TThreadExecutor.hxx. ◆ MapReduce() [4/8]. template<class F , class T , class R , class Cond > . auto ROOT::TThreadExecutor::MapReduce ; (; F ; func, . std::initializer_list< T > ; args, . R ; redfunc, . unsigned ; nChunks . ); -> InvokeResult_t<F, T>. Execute a function in parallel over the elements of an initializer_list (Map) and accumulate the results ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:26381,perform,performs,26381,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['perform'],['performs']
Performance," return ((mode & kS_IFMT) == kS_IFCHR); }; 115inline Bool_t R_ISBLK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFBLK); }; 116inline Bool_t R_ISREG(Int_t mode) { return ((mode & kS_IFMT) == kS_IFREG); }; 117inline Bool_t R_ISLNK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFLNK); }; 118inline Bool_t R_ISFIFO(Int_t mode) { return ((mode & kS_IFMT) == kS_IFIFO); }; 119inline Bool_t R_ISSOCK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFSOCK); }; 120inline Bool_t R_ISOFF(Int_t mode) { return ((mode & kS_IFMT) == kS_IFOFF); }; 121 ; 122struct FileStat_t {; 123 Long_t fDev; // device id; 124 Long_t fIno; // inode; 125 Int_t fMode; // protection (combination of EFileModeMask bits); 126 Int_t fUid; // user id of owner; 127 Int_t fGid; // group id of owner; 128 Long64_t fSize; // total size in bytes; 129 Long_t fMtime; // modification date; 130 Bool_t fIsLink; // symbolic link; 131 TString fUrl; // end point url of file; 132 FileStat_t() : fDev(0), fIno(0), fMode(0), fUid(0), fGid(0), fSize(0),; 133 fMtime(0), fIsLink(kFALSE), fUrl("""") { }; 134};; 135 ; 136struct UserGroup_t {; 137 Int_t fUid; // user id; 138 Int_t fGid; // group id; 139 TString fUser; // user name; 140 TString fGroup; // group name; 141 TString fPasswd; // password; 142 TString fRealName; // user full name; 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:5141,cache,cache,5141,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['cache'],['cache']
Performance, return fCutClassName; }; 217 const char *GetDefCanvasName() const { return fDefCanvasName; }; 218 Bool_t GetEditHistograms() const { return fEditHistograms; }; 219 Int_t GetEditorMode() const { return fEditorMode; }; 220 Bool_t GetForceStyle() const { return fForceStyle; }; 221 Int_t GetBuiltDate() const { return fBuiltDate; }; 222 Int_t GetBuiltTime() const { return fBuiltTime; }; 223 const char *GetGitCommit() const { return fGitCommit; }; 224 const char *GetGitBranch() const { return fGitBranch; }; 225 const char *GetGitDate();; 226 Int_t GetVersionDate() const { return fVersionDate; }; 227 Int_t GetVersionTime() const { return fVersionTime; }; 228 Int_t GetVersionInt() const { return fVersionInt; }; 229 Int_t GetVersionCode() const { return fVersionCode; }; 230 const char *GetVersion() const { return fVersion; }; 231 TCollection *GetListOfClasses() const { return fClasses; }; 232 TSeqCollection *GetListOfColors() const { return fColors; }; 233 TCollection *GetListOfTypes(Bool_t load = kFALSE);; 234 TCollection *GetListOfGlobals(Bool_t load = kFALSE);; 235 TCollection *GetListOfGlobalFunctions(Bool_t load = kFALSE);; 236 TSeqCollection *GetListOfClosedObjects() const { return fClosedObjects; }; 237 TSeqCollection *GetListOfFiles() const { return fFiles; }; 238 TSeqCollection *GetListOfMappedFiles() const { return fMappedFiles; }; 239 TSeqCollection *GetListOfSockets() const { return fSockets; }; 240 TSeqCollection *GetListOfCanvases() const { return fCanvases; }; 241 TSeqCollection *GetListOfStyles() const { return fStyles; }; 242 TCollection *GetListOfFunctions() const { return fFunctions; }; 243 TCollection *GetListOfFunctionOverloads(const char* name) const;; 244 TSeqCollection *GetListOfGeometries() const { return fGeometries; }; 245 TSeqCollection *GetListOfBrowsers() const { return fBrowsers; }; 246 TSeqCollection *GetListOfSpecials() const { return fSpecials; }; 247 TSeqCollection *GetListOfTasks() const { return fTasks; }; 248 TSeqCollection *GetListOfCle,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:10863,load,load,10863,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['load'],['load']
Performance," return fTree->GetListOfLeaves();; 1162 }; 1163 return nullptr;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Return maximum of column with name columname.; 1168 ; 1169Double_t TChain::GetMaximum(const char* columname); 1170{; 1171 Double_t theMax = -DBL_MAX;; 1172 for (Int_t file = 0; file < fNtrees; file++) {; 1173 Long64_t first = fTreeOffset[file];; 1174 LoadTree(first);; 1175 Double_t curmax = fTree->GetMaximum(columname);; 1176 if (curmax > theMax) {; 1177 theMax = curmax;; 1178 }; 1179 }; 1180 return theMax;; 1181}; 1182 ; 1183////////////////////////////////////////////////////////////////////////////////; 1184/// Return minimum of column with name columname.; 1185 ; 1186Double_t TChain::GetMinimum(const char* columname); 1187{; 1188 Double_t theMin = DBL_MAX;; 1189 for (Int_t file = 0; file < fNtrees; file++) {; 1190 Long64_t first = fTreeOffset[file];; 1191 LoadTree(first);; 1192 Double_t curmin = fTree->GetMinimum(columname);; 1193 if (curmin < theMin) {; 1194 theMin = curmin;; 1195 }; 1196 }; 1197 return theMin;; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Return the number of branches of the current tree.; 1202///; 1203/// Warning: May set the current tree!; 1204 ; 1205Int_t TChain::GetNbranches(); 1206{; 1207 if (fTree) {; 1208 return fTree->GetNbranches();; 1209 }; 1210 LoadTree(0);; 1211 if (fTree) {; 1212 return fTree->GetNbranches();; 1213 }; 1214 return 0;; 1215}; 1216 ; 1217////////////////////////////////////////////////////////////////////////////////; 1218/// See TTree::GetReadEntry().; 1219 ; 1220Long64_t TChain::GetReadEntry() const; 1221{; 1222 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1223 // Make sure the element list is up to date; 1224 if (!TestBit(kProofUptodate)); 1225 Warning(""GetBranchStatus"", ""PROOF proxy not up-to-date:""; 1226 "" run TChain::SetProof(true, true) first"");; 1227 return fProof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:43815,Load,LoadTree,43815,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance," return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:170613,cache,cache,170613,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,['cache'],"['cache', 'cachetagfile']"
Performance," return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:; 6551 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6552 // However save a little bit of barrier time by calling load(); 6553 // only once.; 6554 ; 6555 isvalid = kTRUE;; 6556 ; 6557 UInt_t currentChecksum = fCheckSum.load();; 6558 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6559 ; 6560 R__LOCKGUARD(gInterpreterMutex);; 6561 ; 6562 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6563 // for backward compatibility, too be able to use the inequality checks,; 6564 // we need to set the code to the largest value.; 6565 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6566 ; 6567 UInt_t id = 0;; 6568 ; 6569 int il;; 6570 TString name = GetName();; 6571 TString type;; 6572 il = name.Length();; 6573 for (int i=0; i<il; i++) id = id*3+name[i];; 6574 ; 6575 // Here we skip he base classes in case this is a pair or STL collection,; 6576 // otherwise, on some STL implementations, it can happen that pair has; 6577 // base classes which are an internal implementation detail.; 6578 TList *tlb = ((TClass*)this)->GetListOfBases();; 6579 if (tlb && !GetCollectionProxy() && !TClassEdit::IsStdPair(GetName())) {; 6580 // Loop over bases if not a proxied collection or a pair; 6581 ; 6582 TIter nextBase(tlb);; 6583 ; 6584 TBaseClass *tbc=nullptr;; 6585 while((tbc=(TBaseClass*)nextBase())) {; 6586 name = tbc->GetName();; 6587 Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:251913,load,load,251913,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance," return the same values.; 6608/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6609/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6610 ; 6611UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6612{; 6613 // fCheckSum is an atomic variable. Also once it has; 6614 // transition from a zero Value it never changes. If two; 6615 // thread reach past this if statement and calculated the; 6616 // 'kLastestCheckSum', they will by definition obtain the; 6617 // same value, so technically we could simply have:; 6618 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6619 // However save a little bit of barrier time by calling load(); 6620 // only once.; 6621 ; 6622 isvalid = kTRUE;; 6623 ; 6624 UInt_t currentChecksum = fCheckSum.load();; 6625 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6626 ; 6627 R__LOCKGUARD(gInterpreterMutex);; 6628 ; 6629 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6630 // for backward compatibility, too be able to use the inequality checks,; 6631 // we need to set the code to the largest value.; 6632 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6633 ; 6634 UInt_t id = 0;; 6635 ; 6636 int il;; 6637 TString name = GetName();; 6638 TString type;; 6639 il = name.Length();; 6640 for (int i=0; i<il; i++) id = id*3+name[i];; 6641 ; 6642 // Here we skip he base classes in case this is a pair or STL collection,; 6643 // otherwise, on some STL implementations, it can happen that pair has; 6644 // base classes which are an internal implementation detail.; 6645 TList *tlb = ((TClass*)this)->GetListOfBases();; 6646 if (tlb && !GetCollectionProxy() && !TClassEdit::IsStdPair(GetName())) {; 6647 // Loop over bases if not a proxied collection or a pair; 6648 ; 6649 TIter nextBase(tlb);; 6650 ; 6651 TBaseClass *tbc=nullptr;; 6652 while((tbc=(TBaseClass*)nextBase())) {; 6653 name = tbc->GetName();; 6654 Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:254664,load,load,254664,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance," return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:46899,Load,LoadTree,46899,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,2,"['Load', 'load']","['LoadTree', 'loads']"
Performance," returns the created window. ; The created window is placed on top in the stacking order with respect to siblings. The coordinate system has the X axis horizontal and the Y axis vertical with the origin [0,0] at the upper-left corner. Each window and pixmap has its own coordinate system.; Parameters. [in]parentthe parent window ; [in]x,ycoordinates, the top-left outside corner of the window's borders; relative to the inside of the parent window's borders ; [in]w,hwidth and height of the created window; do not include the created window's borders ; [in]borderthe border pixel value of the window ; [in]depththe window's depth ; [in]clssthe created window's class; can be InputOutput, InputOnly, or CopyFromParent ; [in]visualthe visual type ; [in]attrthe structure from which the values are to be taken. ; [in]wtypethe window type . Reimplemented from TVirtualX. ◆ DeleteFont(). void TGWin32VirtualXProxy::DeleteFont ; (; FontStruct_t ; fs). overridevirtual . Explicitly deletes the font structure ""fs"" obtained via LoadQueryFont(). ; Reimplemented from TVirtualX. ◆ DeleteGC(). void TGWin32VirtualXProxy::DeleteGC ; (; GContext_t ; gc). overridevirtual . Deletes the specified GC ""gc"". ; Reimplemented from TVirtualX. ◆ DeleteImage(). void TGWin32VirtualXProxy::DeleteImage ; (; Drawable_t ; img). overridevirtual . Deallocates the memory associated with the image img. ; Reimplemented from TVirtualX. ◆ DeletePictureData(). void TGWin32VirtualXProxy::DeletePictureData ; (; void * ; data). overridevirtual . Delete picture data created by the function ReadPictureDataFromFile. ; Reimplemented from TVirtualX. ◆ DeletePixmap(). void TGWin32VirtualXProxy::DeletePixmap ; (; Pixmap_t ; pmap). overridevirtual . Explicitly deletes the pixmap resource ""pmap"". ; Reimplemented from TVirtualX. ◆ DeleteProperty(). void TGWin32VirtualXProxy::DeleteProperty ; (; Window_t ; , . Atom_t & ;  . ). overridevirtual . Deletes the specified property only if the property was defined on the specified window an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:66403,Load,LoadQueryFont,66403,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['Load'],['LoadQueryFont']
Performance," robust fitting, see if # of good points is defined; 761 // decode parameters for robust fitting; 762 Double_t h=0;; 763 if (opt.Contains(""H=0."")) {; 764 int start = opt.Index(""H=0."");; 765 int numpos = start + strlen(""H=0."");; 766 int numlen = 0;; 767 int len = opt.Length();; 768 while( (numpos+numlen<len) && isdigit(opt[numpos+numlen]) ) numlen++;; 769 TString num = opt(numpos,numlen);; 770 opt.Remove(start+strlen(""H""),strlen(""=0."")+numlen);; 771 h = atof(num.Data());; 772 h*=TMath::Power(10, -numlen);; 773 }; 774 ; 775 if (opt.Contains(""H"")) { fitOption.Robust = 1; fitOption.hRobust = h; }; 776 if (opt.Contains(""T"")) fitOption.NoErrX = 1; // no error in X; 777 if (opt.Contains(""W"")) fitOption.W1 = 1; // ignorer all point errors when fitting; 778 }; 779 ; 780 if (opt.Contains(""U"")) {; 781 // user option can work only when not running in multiple threads; 782 if (gGlobalMutex || !ROOT::IsImplicitMTEnabled()) {; 783 fitOption.User = 1;; 784 } else {; 785 Warning(""FitOptionsMake"",""Cannot use User (U) fit option when running in multi-thread mode. The option is ignored"");; 786 fitOption.User = 0;; 787 }; 788 }; 789 if (opt.Contains(""Q"")) fitOption.Quiet = 1;; 790 if (opt.Contains(""V"")) {fitOption.Verbose = 1; fitOption.Quiet = 0;}; 791 ; 792 ; 793 if (opt.Contains(""E"")) fitOption.Errors = 1;; 794 if (opt.Contains(""R"")) fitOption.Range = 1;; 795 if (opt.Contains(""G"")) fitOption.Gradient= 1;; 796 if (opt.Contains(""M"")) fitOption.More = 1;; 797 if (opt.Contains(""N"")) fitOption.Nostore = 1;; 798 if (opt.Contains(""0"")) fitOption.Nograph = 1;; 799 if (opt.Contains(""+"")) fitOption.Plus = 1;; 800 if (opt.Contains(""B"")) fitOption.Bound = 1;; 801 if (opt.Contains(""C"")) fitOption.Nochisq = 1;; 802 if (opt.Contains(""F"")) fitOption.Minuit = 1;; 803 if (opt.Contains(""S"")) fitOption.StoreResult = 1;; 804 ; 805}; 806 ; 807void HFit::CheckGraphFitOptions(Foption_t & foption) {; 808 if (foption.Like) {; 809 Info(""CheckGraphFitOptions"",""L (Log Likelihood fit) is an invalid option when fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:29171,multi-thread,multi-thread,29171,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance," rocIntegral;; 896}; 897 ; 898////////////////////////////////////////////////////////////////////////////////; 899/// Argument iClass specifies the class to generate the ROC curve in a; 900/// multiclass setting. It is ignored for binary classification.; 901///; 902/// Returns a ROC graph for a given method, or nullptr on error.; 903///; 904/// Note: Evaluation of the given method must have been run prior to ROC; 905/// generation through Factory::EvaluateAllMetods.; 906///; 907/// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; 908/// and the others considered background. This is ok in binary classification; 909/// but in in multi class classification, the ROC surface is an N dimensional; 910/// shape, where N is number of classes - 1.; 911 ; 912TGraph *TMVA::Factory::GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles, UInt_t iClass,; 913 Types::ETreeType type); 914{; 915 return GetROCCurve((TString)loader->GetName(), theMethodName, setTitles, iClass, type);; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Argument iClass specifies the class to generate the ROC curve in a; 920/// multiclass setting. It is ignored for binary classification.; 921///; 922/// Returns a ROC graph for a given method, or nullptr on error.; 923///; 924/// Note: Evaluation of the given method must have been run prior to ROC; 925/// generation through Factory::EvaluateAllMetods.; 926///; 927/// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; 928/// and the others considered background. This is ok in binary classification; 929/// but in in multi class classification, the ROC surface is an N dimensional; 930/// shape, where N is number of classes - 1.; 931 ; 932TGraph *TMVA::Factory::GetROCCurve(TString datasetname, TString theMethodName, Bool_t setTitles, UInt_t iClass,; 933 Types::ETreeType type); 934{; 935 if (fMethodsMap.find(datasetname) == fMethodsMap.en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:37024,load,loader,37024,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance," root. ;  ; virtual void SetProof (bool on=true, bool refresh=false, bool gettreeheader=false);  Enable/Disable PROOF processing on the current default Proof (gProof). ;  ; void SetWeight (Double_t w=1, Option_t *option="""") override;  Set chain weight. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UseCache (Int_t maxCacheSize=10, Int_t pageSize=0);  Dummy function kept for back compatibility. ;  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t splitlevel=99);  Create one branch for each element in the folder. ;  ; TBranch * Branch (const char *name, char *address, const char *leaflist, Int_t bufsize=32000);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T *obj, Int_t bufsize=32000, Int_t splitlevel=99);  ; virtual TBranch * Branch (const char *name, const char *classname, void *addobj, Int_t bufsize=32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:14054,cache,cache,14054,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['cache'],['cache']
Performance," rotation matrix ;  CTRSA_fun;  CTRWLock;  CTS3HTTPRequest;  CTS3WebFile;  CTSapDBResult;  CTSapDBRow;  CTSapDBServer;  CTSAXParserTSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library ;  CTSecContext;  CTSecContextCleanup;  CTSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and make selections ;  CTSelectorCintThis class is a special version of TSelector for user interpreted classes ;  CTSelectorDrawA specialized TSelector for TTree::Draw ;  CTSelectorEntriesThe class is derived from the ROOT class TSelector ;  CTSelectorListA TList derived class that makes sure that objects added to it are not linked to the currently open file (like histograms, eventlists and trees) ;  CTSelectorScalarNamed scalar type, based on Long64_t, streamable, storable and mergable ;  CTSelEventSelector for PROOF I/O benchmark test ;  CTSelEventGenSelector for event file generation ;  CTSelHandleDataSetPROOF selector for file cache release ;  CTSelHistPROOF selector for CPU-intensive benchmark test ;  CTSelVerifyDataSetSelector to verify dataset in parallel on workers ;  CTSemaphore;  CTSeqCollectionSequenceable collection abstract base class ;  CTServerSocket;  CTSessionDescription;  CTSessionFrame;  CTSessionInputFrame;  CTSessionLogView;  CTSessionOutputFrame;  CTSessionQueryFrame;  CTSessionServerFrame;  CTSessionViewer;  CTShapeThis is the base class for all geometry shapes ;  CTShutdownTimer;  CTSignalHandler;  CTSimpleAnalysisA TSimpleAnalysis object creates histograms from a TChain ;  CTSlaveClass describing a PROOF worker server ;  CTSlaveInfo;  CTSlaveLiteVersion of TSlave for local worker servers ;  CTSliderA specialized TPad including a TSliderBox object ;  CTSliderBoxThe moving box in a TSlider ;  CTSocket;  CTSortedListA sorted doubly linked list ;  CTSpectrumAdvanced Spectra Processing ;  CTSpectrum2Advanced 2-dimensional spectra processing ;  CTSpectrum2FitAdvanced 2-dimensional spectra fitting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:185625,cache,cache,185625,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['cache'],['cache']
Performance," rotation of objects of the TVector3 class ;  CTRotationRow;  CTRotMatrixManages a detector rotation matrix ;  CTRSA_fun;  CTRWLock;  CTS3HTTPRequest;  CTS3WebFile;  CTSapDBResult;  CTSapDBRow;  CTSapDBServer;  CTSAXParserTSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library ;  CTSecContext;  CTSecContextCleanup;  CTSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and make selections ;  CTSelectorDrawA specialized TSelector for TTree::Draw ;  CTSelectorEntriesThe class is derived from the ROOT class TSelector ;  CTSelectorListA TList derived class that makes sure that objects added to it are not linked to the currently open file (like histograms, eventlists and trees) ;  CTSelectorScalarNamed scalar type, based on Long64_t, streamable, storable and mergable ;  CTSelEventSelector for PROOF I/O benchmark test ;  CTSelEventGenSelector for event file generation ;  CTSelHandleDataSetPROOF selector for file cache release ;  CTSelHistPROOF selector for CPU-intensive benchmark test ;  CTSelVerifyDataSetSelector to verify dataset in parallel on workers ;  CTSemaphore;  CTSeqCollectionSequenceable collection abstract base class ;  CTServerSocket;  CTSessionDescription;  CTSessionFrame;  CTSessionInputFrame;  CTSessionLogView;  CTSessionOutputFrame;  CTSessionQueryFrame;  CTSessionServerFrame;  CTSessionViewer;  CTShapeThis is the base class for all geometry shapes ;  CTShutdownTimer;  CTSignalHandler;  CTSimpleAnalysisA TSimpleAnalysis object creates histograms from a TChain ;  CTSlaveClass describing a PROOF worker server ;  CTSlaveInfo;  CTSlaveLiteVersion of TSlave for local worker servers ;  CTSliderA specialized TPad including a TSliderBox object ;  CTSliderBoxThe moving box in a TSlider ;  CTSocket;  CTSortedListA sorted doubly linked list ;  CTSpectrumAdvanced Spectra Processing ;  CTSpectrum2Advanced 2-dimensional spectra processing ;  CTSpectrum2FitAdvanced 2-dimensional spectra fitting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:203505,cache,cache,203505,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['cache'],['cache']
Performance," row storages for matrices m(i,j) = rep[ i * dim + j] ;  ; unsigned int NDim () const override;  Retrieve the dimension of the function. ;  ; unsigned int NTot () const;  ; const IMultiGradFunction * OriginalFunction () const;  ; const double * Transformation (const double *x) const;  transform from internal to external result is cached also inside the class ;  ; void Transformation (const double *xint, double *xext) const;  transform from internal to external ;  ;  Public Member Functions inherited from ROOT::Math::IGradientFunctionMultiDimTempl< T >; T Derivative (const T *x, unsigned int icoord, T *previous_grad, T *previous_g2, T *previous_gstep) const;  In some cases, the derivative algorithm will use information from the previous step, these can be passed in with this overload. ;  ; T Derivative (const T *x, unsigned int icoord=0) const;  Return the partial derivative with respect to the passed coordinate. ;  ; virtual void FdF (const T *x, T &f, T *df) const;  Optimized method to evaluate at the same time the function value and derivative at a point x. ;  ; virtual void Gradient (const T *x, T *grad) const;  Evaluate all the vector of function derivatives (gradient) at a point x. ;  ; virtual void GradientWithPrevResult (const T *x, T *grad, T *previous_grad, T *previous_g2, T *previous_gstep) const;  In some cases, the gradient algorithm will use information from the previous step, these can be passed in with this overload. ;  ; bool HasGradient () const;  ; virtual bool returnsInMinuit2ParameterSpace () const;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  . Private Member Functions;  MinimTransformFunction (const MinimTransformFunction &);  ; double DoDerivative (const double *x, unsigned int icoord) const override;  calculate derivatives ;  ; double DoEval (const double *x) const override;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html:3455,Optimiz,Optimized,3455,doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,1,['Optimiz'],['Optimized']
Performance," row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Double_t> &TMatrixT<Double_t> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<double>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v1, const TVectorT<double>& v2, double alpha = 1.); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixT_double_.html:21437,Perform,Perform,21437,root/html602/TMatrixT_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixT_double_.html,2,['Perform'],['Perform']
Performance," rows in each matrix. ; Definition at line 147 of file TensorDataLoader.h. ◆ fBatchIndex. template<typename Data_t , typename Architecture_t > . size_t TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::fBatchIndex. private . The index of the batch when there are multiple batches in parallel. ; Definition at line 150 of file TensorDataLoader.h. ◆ fBatchSize. template<typename Data_t , typename Architecture_t > . size_t TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::fBatchSize. private . The size of a batch. ; Definition at line 144 of file TensorDataLoader.h. ◆ fBatchWidth. template<typename Data_t , typename Architecture_t > . size_t TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::fBatchWidth. private . The number of columns in each matrix. ; Definition at line 148 of file TensorDataLoader.h. ◆ fData. template<typename Data_t , typename Architecture_t > . const Data_t& TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::fData. private . The data that should be loaded in the batches. ; Definition at line 142 of file TensorDataLoader.h. ◆ fDeviceBuffers. template<typename Data_t , typename Architecture_t > . std::vector<DeviceBuffer_t> TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::fDeviceBuffers. private . The device buffers used to keep the input, output and weight data. ; Definition at line 154 of file TensorDataLoader.h. ◆ fHostBuffers. template<typename Data_t , typename Architecture_t > . std::vector<HostBuffer_t> TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::fHostBuffers. private . The host buffers used to load the input, output and weight data. ; Definition at line 155 of file TensorDataLoader.h. ◆ fInputLayout. template<typename Data_t , typename Architecture_t > . Shape_t TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::fInputLayout. private . The input data layout (does not include batch size) ; Definition at line 145 of file TensorDataLoader.h. ◆ fNOutputFeatures. template<typename Data_t , typename Archi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader.html:26733,load,loaded,26733,doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader.html,1,['load'],['loaded']
Performance," run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.05 # The preskimmed dataset contains only 0.5 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/singletop""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df107_SingleTopAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis and make histograms of the top mass; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; using cRVecF =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:2576,load,load,2576,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['load'],['load']
Performance," running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:51515,cache,cached,51515,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,4,['cache'],"['cache', 'cached']"
Performance," same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:24402,cache,cache,24402,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance," same"");. return cb;; }; The ""BAR"" and ""HBAR"" options; When the option ""bar"" or ""hbar"" is specified, a bar chart is drawn. A vertical; bar-chart is drawn with the options ""bar"", ""bar0"",; ""bar1"", ""bar2"", ""bar3"", ""bar4"".; An horizontal bar-chart is drawn with the options ""hbar"",; ""hbar0"", ""hbar1"", ""hbar2"", ""hbar3"",; ""hbar4"". The bar is filled with the histogram fill color.; The left side of the bar is drawn with a light fill color.; The right side of the bar is drawn with a dark fill color.; The percentage of the bar drawn with either the light or dark color is:. 0% for option ""(h)bar"" or ""(h)bar0""; 10% for option ""(h)bar1""; 20% for option ""(h)bar2""; 30% for option ""(h)bar3""; 40% for option ""(h)bar4"". Picture; Source. // Example of bar charts with 1-d histograms; // Author: Rene Brun; {; TString dir = gSystem->UnixPathName(gInterpreter->GetCurrentMacroName());; dir.ReplaceAll(""hbars.C"",""../tree/cernbuild.C"");; dir.ReplaceAll(""/./"",""/"");; if (!gInterpreter->IsLoaded(dir.Data())) gInterpreter->LoadMacro(dir.Data());; TFile *f = (TFile*)gROOT->ProcessLineFast(""cernbuild(1)"");; if (!f) return;; TTree *T = (TTree*)f->Get(""T"");; T->SetFillColor(45);; TCanvas *c1 = new TCanvas(""c1"",""histograms with bars"",700,800);; c1->SetFillColor(42);; c1->Divide(1,2);; ; //horizontal bar chart; c1->cd(1); gPad->SetGrid(); gPad->SetLogx(); gPad->SetFrameFillColor(33);; T->Draw(""Nation"","""",""hbar2"");; ; //vertical bar chart; c1->cd(2); gPad->SetGrid(); gPad->SetFrameFillColor(33);; T->Draw(""Division>>hDiv"","""",""goff"");; TH1F *hDiv = (TH1F*)gDirectory->Get(""hDiv"");; hDiv->SetStats(0);; TH1F *hDivFR = (TH1F*)hDiv->Clone(""hDivFR"");; T->Draw(""Division>>hDivFR"",""Nation==\""FR\"""",""goff"");; hDiv->SetBarWidth(0.45);; hDiv->SetBarOffset(0.1);; hDiv->SetFillColor(49);; TH1 *h1 = hDiv->DrawCopy(""bar2"");; hDivFR->SetBarWidth(0.4);; hDivFR->SetBarOffset(0.55);; hDivFR->SetFillColor(50);; TH1 *h2 = hDivFR->DrawCopy(""bar2,same"");; ; TLegend *legend = new TLegend(0.55,0.65,0.76,0.82);; legend->AddEntry(h1,""All",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:22610,Load,LoadMacro,22610,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['Load'],['LoadMacro']
Performance," script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050791,load,load,1050791,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance," script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. If specified, enables packages only on the specified workers. Returns 0 in case of success and -1 in case of error. Provided for backward compatibility. ; Definition at line 8175 of file TProof.cxx. ◆ EnablePackage() [2/3]. Int_t TProof::EnablePackage ; (; const char * ; package, . const char * ; loadopts, . Bool_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.sh script if it exists followed by the PROOF-INF/SETUP.C script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. It is is possible to specify options for the loading step via 'loadopts'; the string will be passed passed as argument to SETUP. Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control plugin version checking during building: possible choices are: off no check; failure may occur at loading on check ROOT version [default] svn check ROOT version and Git commit SHA1. (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.) If specified, enables packages only on the specified workers. Returns 0 in case of success and -1 in case of error. ; Definition at line 8197 of file TProof.cxx. ◆ EnablePackage() [3/3]. Int_t TProof::EnablePackage ; (; const char * ; package, . TList * ; loadopts, . Bool_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.sh script if it exists followed by the PROOF-INF/SETUP.C script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. It is is possible to specify a list of objects to be passed to the SETUP functions via 'loadopts'; the objects must be streamable. Returns 0 in case of success and -1 in case of error. ; Definition at line 8258 of file TProof.cxx. ◆ Exec() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:87059,load,loading,87059,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['loading']
Performance," see the list of available generators do cmake --help .; Ninja; Generate a Ninja project with cmake -G Ninja /path/to/source/dir. Building ROOT with Ninja is faster.; Xcode; Generate the Xcode project with cmake -G Xcode /path/to/source/dir. Open the generated file with the Xcode application.; Visual Studio; Generate the Microsoft Visual Studio soultion with cmake -G ""Visual Studio 10"" /path/to/source/dir. Open the generated solution with C:\Program Files\Microsoft Visual Studio 10.0\Common7\IDE\devenv.exe ROOT.sln`; Variables; This is list of useful ROOT and general CMake variables that can control the build process:; CMake Standard variables; Here are some of the CMake variables that are used often, along with a brief explanation and ROOT-specific notes. For full documentation, check the CMake docs or execute cmake --help-variable VARIABLE_NAME. Variable; Type; Explanation. CMAKE_BUILD_TYPE; STRING; Sets the build type for make based generators. Possible values are Release, MinSizeRel, Debug, RelWithDebInfo and Optimized. On systems like Visual Studio the user sets the build type with the IDE settings. Default is RelWithDebInfo. CMAKE_INSTALL_PREFIX; PATH; Path where ROOT will be installed if make install is invoked or the “INSTALL” target is built. CMAKE_C_FLAGS; STRING; Extra flags to use when compiling C source files. CMAKE_CXX_FLAGS; STRING; Extra flags to use when compiling C++ source files. BUILD_SHARED_LIBS; BOOL; Flag indicating if shared libraries will be built. Its default value is ON. CMAKE_Fortran_COMPILER; PATH; Full path to the Fortran compiler. Alternatively you can specify the environment variable FC before invoking cmake. CMAKE_C_COMPILER; PATH; Full path to the C compiler. Alternatively you can specify the environment variable CC before invoking cmake. CMAKE_CXX_COMPILER; PATH; Full path to the C++ compiler. Alternatively you can specify the environment variable CXX before invoking cmake. CMAKE_INSTALL_BINDIR; PATH; Install destination for user e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:14533,Optimiz,Optimized,14533,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['Optimiz'],['Optimized']
Performance," sel_cells, TGLSelectRecord& rec); Process newly selected cells with given select-record.; Secondary-select status is set.; CellSelectionChanged() is called if needed. void SetSliceThreshold(Int_t slice, Float_t threshold); Set threshold for given slice. Float_t GetSliceThreshold(Int_t slice) const; Get threshold for given slice. void SetSliceColor(Int_t slice, Color_t col); Set color for given slice. Color_t GetSliceColor(Int_t slice) const; Get color for given slice. void SetSliceTransparency(Int_t slice, Char_t t); Set transparency for given slice. Char_t GetSliceTransparency(Int_t slice) const; Get transparency for given slice. void InvalidateUsersCellIdCache(); Invalidate cell ids cache on back ptr references. void DataChanged(); Tell users (TEveCaloViz instances using this data) that data; has changed and they should update the limits/scales etc.; This is done by calling TEveCaloViz::DataChanged(). void CellSelectionChanged(); Tell users (TEveCaloViz instances using this data) that cell selection; has changed and they should update selection cache if necessary.; This is done by calling TEveCaloViz::CellSelectionChanged(). Float_t EtaToTheta(Float_t eta). TEveCaloData& operator=(const TEveCaloData& ). virtual ~TEveCaloData(); {}. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; { return fCellsSelected; }. vCellId_t& GetCellsHighlighted(); { return fCellsHighlighted; }. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const. Int_t GetNSlices() const; { return fSliceInfos.size(); }. SliceInfo_t& RefSliceInfo(Int_t s); { return fSliceInfos[s]; }. void GetEtaLimits(Double_t& min, Double_t& max) const. void GetPhiLimits(Double_t& min, Double_t& max) const. Float_t GetMaxVal(Bool_t et) const; { return et ? fMaxValEt : fMaxValE; }. Bool_t Empty() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloData.html:21599,cache,cache,21599,root/html528/TEveCaloData.html,https://root.cern,https://root.cern/root/html528/TEveCaloData.html,4,['cache'],['cache']
Performance," sel_cells, TGLSelectRecord& rec); Process newly selected cells with given select-record.; Secondary-select status is set.; CellSelectionChanged() is called if needed. void SetSliceThreshold(Int_t slice, Float_t threshold); Set threshold for given slice. Float_t GetSliceThreshold(Int_t slice) const; Get threshold for given slice. void SetSliceColor(Int_t slice, Color_t col); Set color for given slice. Color_t GetSliceColor(Int_t slice) const; Get color for given slice. void SetSliceTransparency(Int_t slice, Char_t t); Set transparency for given slice. Char_t GetSliceTransparency(Int_t slice) const; Get transparency for given slice. void InvalidateUsersCellIdCache(); Invalidate cell ids cache on back ptr references. void DataChanged(); Tell users (TEveCaloViz instances using this data) that data; has changed and they should update the limits/scales etc.; This is done by calling TEveCaloViz::DataChanged(). void CellSelectionChanged(); Tell users (TEveCaloViz instances using this data) that cell selection; has changed and they should update selection cache if necessary.; This is done by calling TEveCaloViz::CellSelectionChanged(). Float_t EtaToTheta(Float_t eta). TEveCaloData(const TEveCaloData& ). TEveCaloData& operator=(const TEveCaloData& ). virtual ~TEveCaloData(); {}. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; { return fCellsSelected; }. vCellId_t& GetCellsHighlighted(); { return fCellsHighlighted; }. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const. Int_t GetNSlices() const; { return fSliceInfos.size(); }. SliceInfo_t& RefSliceInfo(Int_t s); { return fSliceInfos[s]; }. void GetEtaLimits(Double_t& min, Double_t& max) const. void GetPhiLimits(Double_t& min, Double_t& max) const. Float_t GetMaxVal(Bool_t et) const; { return et ? fMaxValEt : fMaxV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCaloData.html:22688,cache,cache,22688,root/html602/TEveCaloData.html,https://root.cern,https://root.cern/root/html602/TEveCaloData.html,2,['cache'],['cache']
Performance," selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:""); Draw the CPU speedup plot.; opt = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node. Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* opt = ""std:"", const char* type = ""mbs""); Draw the CPU speedup plot.; opt = 'std:' Standard scaling plot; 'norm:' Normalized scaling plot; 'stdx:' Standard scaling plot, 1 worker per node; 'normx:' Normalized scaling plot, 1 worker per node; type = 'mbs' MB/s scaling plots (default); 'evts' Event/s scaling plots. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveDataSet(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t MakeDataSet(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBench.html:8964,Perform,Perform,8964,root/html532/TProofBench.html,https://root.cern,https://root.cern/root/html532/TProofBench.html,1,['Perform'],['Perform']
Performance," server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:37188,Perform,Perform,37188,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['Perform'],['Perform']
Performance," set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:2550,perform,perform,2550,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['perform'],['perform']
Performance," set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25900,cache,cache,25900,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,3,['cache'],"['cache', 'cacheParams']"
Performance," set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:4424,cache,cache,4424,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,1,['cache'],['cache']
Performance," set of unblinding parameters ;  CRooUnblindPrecisionImplementation of BlindTools' precision blinding method A RooUnblindPrecision object is a real valued function object, constructed from a blind value holder and a set of unblinding parameters ;  CRooUnblindUniformImplementation of BlindTools' offset blinding method A RooUnblindUniform object is a real valued function object, constructed from a blind value holder and a set of unblinding parameters ;  CRooUniformFlat p.d.f ;  CRooUniformBinningRooUniformBinning is an implementation of RooAbsBinning that provides a uniform binning in 'n' bins between the range end points ;  CRooUnitTestRooUnit test is an abstract base class for unit regression tests for RooFit and RooStats tests performed in stressRooFit and stressRooStats Implementations of this class must implement abstract method testCode() which defines the regression test to be performed ;  ►CRooVectorDataStoreRooVectorDataStore is the abstract base class for data collection that use a TTree as internal storage mechanism ;  CCatVector;  CRealFullVector;  CRealVector;  CRooVoigtianRooVoigtian is an efficient implementation of the convolution of a Breit-Wigner with a Gaussian, making use of the complex error function ;  ►CRooWorkspaceThe RooWorkspace is a persistable container for RooFit projects ;  ►CCodeRepo;  CClassFiles;  CClassRelInfo;  CExtraHeader;  CWSDir;  CRooWorkspaceHandleAn interface to set and retrieve a workspace ;  CRooXYChi2Var;  CRPadUserAxisBaseBase class for user coordinates (e.g ;  Crsa_KEY;  Crsa_KEY_export;  Crsa_NUMBER;  CSegment_t;  CSetWindowAttributes_t;  CSHtmlExtensions_t;  CSHtmlIndex_t;  CSHtmlMargin_t;  CSHtmlStyle_t;  CSHtmlStyleStack_t;  CSHtmlTokenMap_t;  CSQLite3_Stmt_t;  CSysInfo_t;  CtableDescriptor_st;  CTAdvancedGraphicsDialog;  CTAlien;  CTAlienCollection;  CTAlienDirectory;  CTAlienDirectoryEntry;  CTAlienFile;  CTAliEnFind;  CTAlienJDL;  CTAlienJob;  CTAlienJobStatus;  CTAlienJobStatusList;  CTAlienMasterJob;  CTAlienMaste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:131614,perform,performed,131614,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['perform'],['performed']
Performance," set of variables. ; Only fundamental elements of vars (RooRealVar,RooCategory etc) are stored as part of the dataset ; Definition at line 183 of file RooAbsData.cxx. ◆ RooAbsData() [3/3]. RooAbsData::RooAbsData ; (; const RooAbsData & ; other, . const char * ; newname = nullptr . ). Copy constructor. ; Definition at line 245 of file RooAbsData.cxx. ◆ ~RooAbsData(). RooAbsData::~RooAbsData ; (; ). override . Destructor. ; Definition at line 280 of file RooAbsData.cxx. Member Function Documentation. ◆ add(). virtual void RooAbsData::add ; (; const RooArgSet & ; row, . double ; weight = 1 . ). pure virtual . Implemented in RooDataSet, and RooDataHist. ◆ addOwnedComponent(). void RooAbsData::addOwnedComponent ; (; const char * ; idxlabel, . RooAbsData & ; data . ). Definition at line 2366 of file RooAbsData.cxx. ◆ allClientsCached(). bool RooAbsData::allClientsCached ; (; RooAbsArg * ; var, . const RooArgSet & ; cacheList . ). protected . Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ; Definition at line 2319 of file RooAbsData.cxx. ◆ attachBuffers(). void RooAbsData::attachBuffers ; (; const RooArgSet & ; extObs). Definition at line 2337 of file RooAbsData.cxx. ◆ attachCache(). void RooAbsData::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). protectedvirtual . Internal method – Attach dataset copied with cache contents to copied instances of functions. ; Definition at line 363 of file RooAbsData.cxx. ◆ cacheArgs(). void RooAbsData::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). protectedvirtual . Internal method – Cache given set of functions with data. ; Definition at line 346 of file RooAbsData.cxx. ◆ canSplitFast(). bool RooAbsData::canSplitFast ; (; ); const. Definition at line 2351 of file RooAbsData.cxx. ◆ changeObservableName(). bool RooAbsData::changeObservableName ; (; const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:34195,cache,cached,34195,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cached']
Performance," set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxymsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:44914,cache,cache,44914,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,1,['cache'],['cache']
Performance," set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:41940,cache,cache,41940,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,2,['cache'],['cache']
Performance," set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. void attachDataStore(const RooAbsDataStore& set); Replace server nodes with names matching the dataset variable names; with those data set variables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:29322,cache,cache,29322,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,7,['cache'],['cache']
Performance," set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:16622,cache,cached,16622,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,2,['cache'],['cached']
Performance," set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling globa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:43056,cache,cache,43056,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,2,['cache'],['cache']
Performance," set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:43689,cache,cache,43689,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,2,['cache'],['cache']
Performance," set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxy_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; int_l1; int_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; int_m1; int_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:33665,cache,cache,33665,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,14,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance," sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. » Author: Guy Barrand 30/05/2001 » Copyright (C) 2001, Guy Barrand. *; » Last changed: root/gui:$Id: TGApplication.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGApplication.html:12474,Load,LoadGraphicsLibs,12474,root/html528/TGApplication.html,https://root.cern,https://root.cern/root/html528/TGApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance," sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. » Author: Guy Barrand 30/05/2001 » Copyright (C) 2001, Guy Barrand. *; » Last changed: root/gui:$Id: TGApplication.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGApplication.html:12625,Load,LoadGraphicsLibs,12625,root/html530/TGApplication.html,https://root.cern,https://root.cern/root/html530/TGApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance," sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. » Author: Guy Barrand 30/05/2001 » Copyright (C) 2001, Guy Barrand. *; » Last changed: root/gui:$Id: TGApplication.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGApplication.html:12625,Load,LoadGraphicsLibs,12625,root/html532/TGApplication.html,https://root.cern,https://root.cern/root/html532/TGApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance," shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindings for the ROOT class library in a generic way using the Cling dictionary. This way, it allows the use of any ROOT classes from the Python interpreter, and thus the “glue-ing” of ROOT libraries with any non-ROOT library or applications that provide Python bindings. Further, PyROOT can be loaded into the Cling interpreter to allow (as of now still rudimentary) access to Python classes. The best way to understand the benefits of PyROOT is through a few examples.; 19.1.1 Glue-ing Applications; The PyQt library, see http://www.riverbankcomputing.co.uk/pyqt, provides Python bindings for the Qt cross-p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1042016,perform,performance,1042016,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:2290,cache,cacheUniqueSuffix,2290,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,2,['cache'],['cacheUniqueSuffix']
Performance," shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow them to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:41947,load,loaded,41947,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,2,['load'],['loaded']
Performance," should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:2066,perform,performed,2066,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,5,['perform'],['performed']
Performance," should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; ; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCuts.html:2066,perform,performed,2066,root/html534/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCuts.html,1,['perform'],['performed']
Performance," should enter them exactly as they are listed in the cmake --help output, in quotes. For example, to generate project files specifically for Visual Studio 12, you can execute:; $ cmake -G ""Visual Studio 12"" path/to/source. For a given development platform there can be more than one adequate generator. If you use Visual Studio, “NMake Makefiles” is a generator you can use for building with NMake. By default, CMake chooses the most specific generator supported by your development environment. If you want an alternative generator, you must tell this to CMake with the -G option.; Options and variables; Variables customize how the build will be generated. Options are boolean variables, with possible values ON/OFF. Options and variables are defined on the CMake command line like this:; $ cmake -DVARIABLE=value path/to/source. You can set a variable after the initial CMake invocation to change its value. You can also undefine a variable:; $ cmake -UVARIABLE path/to/source. Variables are stored in the CMake cache. This is a file named CMakeCache.txt stored at the root of your build directory that is generated by cmake. Editing it yourself is not recommended.; Variables are listed in the CMake cache with the variable name and type separated by a colon. You can also specify the variable and type on the CMake command line:; $ cmake -DVARIABLE:TYPE=value path/to/source. Variables in the CMake cache are 'remembered', so you do not need to type them if you execute cmake command again. It is recommended to delete the file CMakeCache.txt to start from a clean configuration. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:23021,cache,cache,23021,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cache']
Performance," show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~RVirtualCanvasPainter(). RVirtualCanvasPainter::~RVirtualCanvasPainter ; (; ). virtualdefault . Default destructor. ; The implementation is here to pin the vtable. . Member Function Documentation. ◆ AddPanel(). virtual bool ROOT::Experimental::Internal::RVirtualCanvasPainter::AddPanel ; (; std::shared_ptr< ROOT::RWebWindow > ; ). inlinevirtual . Reimplemented in ROOT::Experimental::RCanvasPainter.; Definition at line 79 of file RVirtualCanvasPainter.hxx. ◆ CanvasUpdated(). virtual void ROOT::Experimental::Internal::RVirtualCanvasPainter::CanvasUpdated ; (; uint64_t ; , . bool ; , . CanvasCallback_t ;  . ). pure virtual . indicate that canvas changed, provides current version of the canvas ; Implemented in ROOT::Experimental::RCanvasPainter. ◆ Create(). std::unique_ptr< RVirtualCanvasPainter > RVirtualCanvasPainter::Create ; (; RCanvas & ; canv). static . Loads the plugin that implements this class. ; Definition at line 42 of file RVirtualCanvasPainter.cxx. ◆ DoWhenReady(). virtual void ROOT::Experimental::Internal::RVirtualCanvasPainter::DoWhenReady ; (; const std::string & ; , . const std::string & ; , . bool ; , . CanvasCallback_t ;  . ). pure virtual . perform special action when drawing is ready ; Implemented in ROOT::Experimental::RCanvasPainter. ◆ GetGenerator(). std::unique_ptr< RVirtualCanvasPainter::Generator > & RVirtualCanvasPainter::GetGenerator ; (; ). staticprotected . generator getter ; Definition at line 35 of file RVirtualCanvasPainter.cxx. ◆ GetWindowAddr(). virtual std::string ROOT::Experimental::Internal::RVirtualCanvasPainter::GetWindowAddr ; (; ); const. pure virtual . Implemented in ROOT::Experimental::RCanvasPainter. ◆ GetWindowUrl(). virtual std::string ROOT::Experimental::Internal::RVirtualCanvasPainter::GetWindowUrl ; (; bool ; remote). pure virtual . Implemented in ROOT::Experimental::RCanvasPainter. ◆ IsCanvasModified(). virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html:3295,Load,Loads,3295,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RVirtualCanvasPainter.html,1,['Load'],['Loads']
Performance," shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_weightSqApply weights squared?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNLLVar(const char* name, const char* title, RooAbsPdf& pdf, RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:42256,cache,cache,42256,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,1,['cache'],['cache']
Performance," sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum>, <file>, <rver> and; <build> placeholders in fname.; Here, <rver> is the root version in integer form, e.g. 53403, and <build> a; string includign version, architecture and compiler version, e.g.; '53403_linuxx8664gcc_gcc46' . Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access needs to be protected. Int_t UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:31064,queue,queued,31064,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,3,['queue'],['queued']
Performance," sigEff = 0.5). private . calculate the background efficiency for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 546 of file OptimizeConfigParameters.cxx. ◆ GetBkgRejAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgRejAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background rejection for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 583 of file OptimizeConfigParameters.cxx. ◆ GetFOM(). Double_t TMVA::OptimizeConfigParameters::GetFOM ; (; ). private . Return the Figure of Merit (FOM) used in the parameter optimization process. ; Definition at line 350 of file OptimizeConfigParameters.cxx. ◆ GetMethod(). MethodBase * TMVA::OptimizeConfigParameters::GetMethod ; (; ). inlineprivate . Definition at line 72 of file OptimizeConfigParameters.h. ◆ GetMVADists(). void TMVA::OptimizeConfigParameters::GetMVADists ; (; ). private . fill the private histograms with the mva distributions for sig/bkg ; Definition at line 393 of file OptimizeConfigParameters.cxx. ◆ GetROCIntegral(). Double_t TMVA::OptimizeConfigParameters::GetROCIntegral ; (; ). private . calculate the area (integral) under the ROC curve as a overall quality measure of the classification ; making pdfs out of the MVA-output distributions doesn't work reliably for cases where the MVA-output isn't a smooth distribution. this happens ""frequently"" in BDTs for example when the number of trees is small resulting in only some discrete possible MVA output values. (I still leave the code here, but use this with care!!! The default however is to use the distributions!!! ; Definition at line 458 of file OptimizeConfigParameters.cxx. ◆ GetScanIndices(). std::vector< int > TMVA::OptimizeConfigParameters::GetScanIndices ; (; int ; val, . std::vector< int > ; base . ). private . helper function to scan through the all the combi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:7198,Optimiz,OptimizeConfigParameters,7198,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance," simply returns the total number of entries in the tree. In the latter case, it depends on which point of the processing of the chain this function is called. During most of the chain processing, this function will return TTree::kMaxEntries. When the chain arrives at the last file, then the function will return the accumulated total number of entries in the whole chain. A notable use case where this function becomes quite useful is when writing the following for loop to traverse the entries in the dataset:; for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; // Do something with the event in the dataset; }; In the example above, independently on whether the dataset is a TTree or a TChain, the GetEntriesFast call will provide the correct stopping condition for the loop (i.e. the total number of entries). In the TChain case, calling GetEntries instead would open all the files in the chain upfront which could be costly.; The functionality offered by this method can also be seen when used in conjunction with LoadTree. For a call like LoadTree(ievent) , the condition ievent < dataset.GetEntriesFast() is only satisfied if ievent is strictly smaller than the total number of entries in the dataset. In fact, even when the dataset is a TChain, the first time LoadTree is called with an entry number that belongs to the last file of the chain, this will update the internal data member of the class so that the next call to GetEntriesFast returns the total number of entries in the dataset. ; Reimplemented in TTreeSQL.; Definition at line 505 of file TTree.h. ◆ GetEntriesFriend(). Long64_t TTree::GetEntriesFriend ; (; ); const. virtual . Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ; Definition at line 5512 of file TTree.cxx. ◆ GetEntry(). Int_t TTree::GetEntry ; (; Long64_t ; entry, . Int_t ; getall = 0 . ). virtual . Read all branches of entry and return total number of bytes read. . getall = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:150883,Load,LoadTree,150883,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['Load'],['LoadTree']
Performance," single prototype PDF. It is also possible to build with multiple prototype PDFs by specifying a mapping between the prototype to use and the names of states of a ""master"" splitting category. To specify these configurations, an intermediate MultiBuildConfig must be composed with all the necessary specifications. This, for example, RooSimWSTool::MultiBuildConfig mbc(""mc"");; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c""));; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d""));; RooSimWSTool::MultiBuildConfigDefinition RooSimWSTool.h:124; configures a build with two prototype PDFs \( G \) and \( F \). Prototype \( G \) is used for state ""I"" of the master split category mc and prototype \( F \) is used for states ""II"" and ""III"" of the master split category mc. Furthermore, the parameters \( m,s \) of prototype \( G \) are split in category \( c \) while the parameter \( a \) of prototype \( F \) is split in the product of the categories \( c \) and \( d \). The actual build is then performed by passing the build configuration to RooSimWSTool, e.g., wst.build(""MASTER"", mbc);; By default, a specialisation is built for each permutation of states of the splitting categories that are used. It is possible to restrict the building of specialised PDFs to a subset of states by adding a restriction on the number of states to build as follows: mbc.restrictBuild(""c"",""A,B"");; The restrictBuild method can be called multiple times, but at most once for each splitting category in use. For simple builds with a single prototype, restriction can be specified with a Restrict() argument on the build command line. PyROOT; Some member functions of RooSimWSTool that take a RooCmdArg as argument also support keyword arguments. So far, this applies to RooSimWSTool::build. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; sct.build(""model_sim2"", ""model"", ROOT.RooFit.SplitParam(""p0"", ""c,d"")); ; # With keyword arguments:; sct.build(""model_sim2"", ""model"", SplitParam=(""p0""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimWSTool.html:3457,perform,performed,3457,doc/master/classRooSimWSTool.html,https://root.cern,https://root.cern/doc/master/classRooSimWSTool.html,1,['perform'],['performed']
Performance," situated. ; Reimplemented in ROOT::RWebWindowWSHandler.; Definition at line 82 of file THttpWSHandler.h. ◆ Class(). static TClass * THttpWSHandler::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * THttpWSHandler::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THttpWSHandler::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 114 of file THttpWSHandler.h. ◆ CloseWS(). void THttpWSHandler::CloseWS ; (; UInt_t ; wsid). Close connection with given websocket id. ; Definition at line 255 of file THttpWSHandler.cxx. ◆ CompleteSend(). Int_t THttpWSHandler::CompleteSend ; (; std::shared_ptr< THttpWSEngine > & ; engine). private . Complete current send operation. ; Definition at line 370 of file THttpWSHandler.cxx. ◆ CompleteWSSend(). virtual void THttpWSHandler::CompleteWSSend ; (; UInt_t ; ). inlineprotectedvirtual . Method called when multi-threaded send operation is completed. ; Reimplemented in ROOT::RWebWindowWSHandler.; Definition at line 53 of file THttpWSHandler.h. ◆ DeclFileName(). static const char * THttpWSHandler::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 114 of file THttpWSHandler.h. ◆ FindEngine(). std::shared_ptr< THttpWSEngine > THttpWSHandler::FindEngine ; (; UInt_t ; id, . Bool_t ; book_send = kFALSE . ). private . Find websocket connection handle with given id If book_send parameter specified, have to book send operation under the mutex. ; Definition at line 127 of file THttpWSHandler.cxx. ◆ GetCodeVersion(). virtual std::string THttpWSHandler::GetCodeVersion ; (; ). inlineprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented in ROOT::RWebWindowWSHandler.; Definition at line 63 of file THttpWSHandler.h. ◆ GetDefaultPageContent(). virtual TString THttpWSHandler::GetDefaultPageContent ; (; ). inlinevirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:18838,multi-thread,multi-threaded,18838,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['multi-thread'],['multi-threaded']
Performance," size_t filterHeight, size_t filterWidth, size_t strideRows, size_t strideCols, size_t paddingHeight, size_t paddingWidth, EActivationFunction f, Scalar_t dropoutProbability=1.0)Function for adding Convolution layer in the Deep Neural Network, with a given depth,...Definition DeepNet.h:439; TMVA::DNN::TDeepNet::AddReshapeLayerTReshapeLayer< Architecture_t > * AddReshapeLayer(size_t depth, size_t height, size_t width, bool flattening)Function for adding Reshape Layer in the Deep Neural Network, with a given height and width.Definition DeepNet.h:773; TMVA::DNN::TDeepNet::AddBasicRNNLayerTBasicRNNLayer< Architecture_t > * AddBasicRNNLayer(size_t stateSize, size_t inputSize, size_t timeSteps, bool rememberState=false, bool returnSequence=false, EActivationFunction f=EActivationFunction::kTanh)Function for adding Recurrent Layer in the Deep Neural Network, with given parameters.Definition DeepNet.h:524; TMVA::DNN::TDenseLayerGeneric layer class.Definition DenseLayer.h:59; TMVA::DNN::TRMSPropRMSProp Optimizer class.Definition RMSProp.h:45; TMVA::DNN::TSGDStochastic Batch Gradient Descent Optimizer class.Definition SGD.h:46; TMVA::DNN::TTensorDataLoaderTTensorDataLoader.Definition TensorDataLoader.h:133; TMVA::DNN::VGeneralLayerGeneric General Layer class.Definition GeneralLayer.h:51; TMVA::DNN::VGeneralLayer::Initializevirtual void Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetInfo::GetNClassesUInt_t GetNClasses() constDefinition DataSetInfo.h:155; TMVA::DataSet::GetCurrentTypeTypes::ETreeType GetCurrentType() constDefinition DataSet.h:194; TMVA::DataSet::GetNEventsLong64_t GetNEvents(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:206; TMVA::DataSet::SetCurrentEventvoid SetCurrentEvent(Long64_t ievt) constDefinition DataSet.h:88; TMVA::EventDefinition Event.h:51; TMVA::Event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:99823,Optimiz,Optimizer,99823,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['Optimiz'],['Optimizer']
Performance," size_t paddingHeight, size_t paddingWidth, EActivationFunction f, Scalar_t dropoutProbability=1.0)Function for adding Convolution layer in the Deep Neural Network, with a given depth,...Definition DeepNet.h:439; TMVA::DNN::TDeepNet::AddReshapeLayerTReshapeLayer< Architecture_t > * AddReshapeLayer(size_t depth, size_t height, size_t width, bool flattening)Function for adding Reshape Layer in the Deep Neural Network, with a given height and width.Definition DeepNet.h:773; TMVA::DNN::TDeepNet::AddBasicRNNLayerTBasicRNNLayer< Architecture_t > * AddBasicRNNLayer(size_t stateSize, size_t inputSize, size_t timeSteps, bool rememberState=false, bool returnSequence=false, EActivationFunction f=EActivationFunction::kTanh)Function for adding Recurrent Layer in the Deep Neural Network, with given parameters.Definition DeepNet.h:524; TMVA::DNN::TDenseLayerGeneric layer class.Definition DenseLayer.h:59; TMVA::DNN::TRMSPropRMSProp Optimizer class.Definition RMSProp.h:45; TMVA::DNN::TSGDStochastic Batch Gradient Descent Optimizer class.Definition SGD.h:46; TMVA::DNN::TTensorDataLoaderTTensorDataLoader.Definition TensorDataLoader.h:133; TMVA::DNN::VGeneralLayerGeneric General Layer class.Definition GeneralLayer.h:51; TMVA::DNN::VGeneralLayer::Initializevirtual void Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetInfo::GetNClassesUInt_t GetNClasses() constDefinition DataSetInfo.h:155; TMVA::DataSet::GetCurrentTypeTypes::ETreeType GetCurrentType() constDefinition DataSet.h:194; TMVA::DataSet::GetNEventsLong64_t GetNEvents(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:206; TMVA::DataSet::SetCurrentEventvoid SetCurrentEvent(Long64_t ievt) constDefinition DataSet.h:88; TMVA::EventDefinition Event.h:51; TMVA::Event::SetTargetvoid SetTarget(UInt_t itgt, Float_t value)set the target value (dime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:99913,Optimiz,Optimizer,99913,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['Optimiz'],['Optimizer']
Performance," skip using Keras""); else:; # book PyKeras method only if Keras model could be created; ROOT.Info(""TMVA_Higgs_Classification"", ""Booking Deep Learning keras model""); factory.BookMethod(; loader,; TMVA.Types.kPyKeras,; ""PyKeras"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""model_higgs.h5"",; FilenameTrainedModel=""trained_model_higgs.h5"",; NumEpochs=20,; BatchSize=100,; ); # GpuOptions=""allow_growth=True"",; # ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ; ; ## Train Methods; ; # Here we train all the previously booked methods.; ; factory.TrainAllMethods(); ## Test all methods; ; # Now we test and evaluate all methods using the test data set; factory.TestAllMethods(); ; factory.EvaluateAllMethods(); ; # after we get the ROC curve and we display; ; c1 = factory.GetROCCurve(loader); c1.Draw(); # at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; # to display additional plots; ; outputFile.Close(); TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; AuthorHarshal Shende ; Definition in file TMVA_Higgs_Classification.py. tutorialstmvaTMVA_Higgs_Classification.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:68499,cache,cacheDir,68499,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,2,['cache'],"['cache', 'cacheDir']"
Performance," slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:12527,latency,latency,12527,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,6,['latency'],['latency']
Performance," snapshot options.|; 149 ; 150 ; 151### Queries; 152 ; 153These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object.; 154 ; 155| **Operation** | **Description** |; 156|---------------------|-----------------|; 157| Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; 158| GetColumnNames() | Get the names of all the available columns of the dataset. |; 159| GetColumnType() | Return the type of a given column as a string. |; 160| GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; 161| GetDefinedColumnNames() | Get the names of all the defined columns. |; 162| GetFilterNames() | Return the names of all filters in the computation graph. |; 163| GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; 164| GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; 165| SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |; 166 ; 167\anchor introduction; 168## Introduction; 169Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; 170takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; 171RDataFrame provides methods to perform most common operations required by ROOT analyses;; 172at the same time, users can just as easily specify custom code that will be executed in the event loop.; 173 ; 174RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:; 175 ; 1761. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:12396,concurren,concurrency,12396,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['concurren'],['concurrency']
Performance," snapshot options.|; 153 ; 154 ; 155### Queries; 156 ; 157These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object.; 158 ; 159| **Operation** | **Description** |; 160|---------------------|-----------------|; 161| Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; 162| GetColumnNames() | Get the names of all the available columns of the dataset. |; 163| GetColumnType() | Return the type of a given column as a string. |; 164| GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; 165| GetDefinedColumnNames() | Get the names of all the defined columns. |; 166| GetFilterNames() | Return the names of all filters in the computation graph. |; 167| GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; 168| GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; 169| SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |; 170 ; 171\anchor introduction; 172## Introduction; 173Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; 174takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; 175RDataFrame provides methods to perform most common operations required by ROOT analyses;; 176at the same time, users can just as easily specify custom code that will be executed in the event loop.; 177 ; 178RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:; 179 ; 1801. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:12838,concurren,concurrency,12838,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['concurren'],['concurrency']
Performance," so if you do not already have a pointer to the previous cache (and there was a previous cache), you ought to retrieve (and delete it if needed) using: TFileCacheRead *older = myfile->GetCacheRead();; The action specifies how to behave when detaching a cache from the the TFile. If set to (default) kDisconnect, the contents of the cache will be flushed when it is removed from the file, and it will disconnect the cache object from the file. In almost all cases, this is what you want. If you want to disconnect the cache temporarily from this tree and re-attach later to the same fil, you can set action to kDoNotDisconnect. This will allow things like prefetching to continue in the background while it is no longer the default cache for the TTree. Except for a few expert use cases, kDisconnect is likely the correct setting.; WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. ; Definition at line 2365 of file TFile.cxx. ◆ SetCacheWrite(). void TFile::SetCacheWrite ; (; TFileCacheWrite * ; cache). virtual . Set a pointer to the write cache. ; If file is null the existing write cache is deleted. ; Definition at line 2388 of file TFile.cxx. ◆ SetCompressionAlgorithm(). void TFile::SetCompressionAlgorithm ; (; Int_t ; algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal). virtual . See comments for function SetCompressionSettings. ; Definition at line 2305 of file TFile.cxx. ◆ SetCompressionLevel(). void TFile::SetCompressionLevel ; (; Int_t ; level = ROOT::RCompressionSetting::ELevel::kUseMin). virtual . See comments for function SetCompressionSettings. ; Definition at line 2319 of file TFile.cxx. ◆ SetCompressionSettings(). void TFile::SetCompressionSettings ; (; Int_t ; settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault). virtual . Used to specify the compression level and algorithm. ; See the TFile constructor for the details. ; Definition at line 2338 of file TFile.cxx. ◆ SetEND(). virtual void TFile::SetEND ; (; Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:93029,cache,cache,93029,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance," software developer from the University of Nebraska-Lincoln (CMS), based at CERN and working as a core developer in the ROOT framework. My area of research is a various improvement for ROOT I/O, particularly ROOT compression algorithms. Another area of investigation is work on improved ROOT modularity for the build system. I was involved in support of C++ modules in ROOT and performance benchmarking of ROOT.; I did my doctoral studies in Simulation group at CERN, working in GeantV project (EP-SFT, CERN). Previous work experience was a long term work in Ukrainian Grid Initiative on various positions, including responsibilities on grid sites management and experiment support, administration, and security management.; ; . Olivier Couet ; ; Olivier Couet received a Physic's Master from the  Strasbourg University and a Master’s Degree in Engineering from the ""Ecole Nationale Supérieure de Physique de Strasbourg"" (ENSPS) on work in computer graphics and image processing in 1985. He then performed his Ph.D work (in Computer Graphics) at the ""Laboratoire D'Annecy le Vieux de Physique des Particules"" (LAPP) on the PAW project. He has been employed by CERN since 1988. He was one of the main authors of the PAW system, more precisely its graphical components (HIGZ and HPLOT). HIGZ has been the standard graphics package in High Energy Physics for years and is still being used. He was responsible for the PAW system from 1995 until he joined the ROOT team in 2002 and took responsibility of the graphics work package.; ; . Philippe Canal ; ; Philippe Canal has been working in the FNAL Computing Division since 1995. Philippe graduated from Ecole Centrale Paris and has a Master in Computer Science from Northwestern University. Philippe is responsible for the development of the I/O sub-system and the Tree query mechanism and oversee the overall architecture of ROOT.  Philippe coordinates the support for ROOT for all FNAL experiments.; ; . Sergey Linev ; ; Sergey Linev was graduated fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:8326,perform,performed,8326,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['perform'],['performed']
Performance," source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidRooAbsCategoryLValue::setIndexFast(Int_t index); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:18736,optimiz,optimizeDirtyHook,18736,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance," specification makes sense if and only if the schema of the dataset is unchanged, i.e. the new specification refers to exactly the same number of columns, with the same names and types. The actual use case of this method is moving the processing of the same RDataFrame to a different range of entries of the same dataset (which may be stored in a different set of files).; Parameters. specThe specification of the dataset to be adopted. . Definition at line 419 of file RLoopManager.cxx. ◆ CheckFilters(). bool RLoopManager::CheckFilters ; (; unsigned int ; , . Long64_t ;  . ). finalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 1006 of file RLoopManager.cxx. ◆ CleanUpNodes(). void RLoopManager::CleanUpNodes ; (; ). private . Perform clean-up operations. To be called at the end of each event loop. ; Definition at line 803 of file RLoopManager.cxx. ◆ CleanUpTask(). void RLoopManager::CleanUpTask ; (; TTreeReader * ; r, . unsigned int ; slot . ). private . Perform clean-up operations. To be called at the end of each task execution. ; Definition at line 827 of file RLoopManager.cxx. ◆ Deregister() [1/5]. void RLoopManager::Deregister ; (; RDefineBase * ; definePtr). Definition at line 989 of file RLoopManager.cxx. ◆ Deregister() [2/5]. void RLoopManager::Deregister ; (; RDFInternal::RActionBase * ; actionPtr). Definition at line 952 of file RLoopManager.cxx. ◆ Deregister() [3/5]. void RLoopManager::Deregister ; (; RDFInternal::RVariationBase * ; varPtr). Definition at line 1000 of file RLoopManager.cxx. ◆ Deregister() [4/5]. void RLoopManager::Deregister ; (; RFilterBase * ; filterPtr). Definition at line 968 of file RLoopManager.cxx. ◆ Deregister() [5/5]. void RLoopManager::Deregister ; (; RRangeBase * ; rangePtr). Definition at line 979 of file RLoopManager.cxx. ◆ EvalChildrenCounts(). void RLoopManager::EvalChildrenCounts ; (; ). private . Trigger counting of number of children nodes for each node of the functional graph. ; This is done once before ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:15087,Perform,Perform,15087,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['Perform'],['Perform']
Performance," squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=20,Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:8048,perform,performance,8048,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['perform'],['performance']
Performance," standard method to be provided is ExecuteEvent(). This method actually does the event reaction. Its prototype is where px and py are the coordinates at which the event occurred, except if the event is a key press, in which case px contains the key code.; void ExecuteEvent(Int_t event, Int_t px, Int_t py);; Where event is the event that occurs and is one of the following (defined in Buttons.h):; kNoEvent, kButton1Down, kButton2Down,; kButton3Down, kKeyDown, kButton1Up,; kButton2Up, kButton3Up, kButton1Motion,; kButton2Motion, kButton3Motion, kKeyPress,; kButton1Locate, kButton2Locate, kButton3Locate,; kKeyUp, kButton1Double, kButton2Double,; kButton3Double, kMouseMotion, kMouseEnter,; kMouseLeave; We hope the names are self-explanatory.; Designing an ExecuteEvent method is not very easy, except if one wants very basic treatment. We will not go into that and let the reader refer to the sources of classes like TLine or TBox. Go and look at their ExecuteEvent method! We can nevertheless give some reference to the various actions that may be performed. For example, one often wants to change the shape of the cursor when passing on top of an object. This is done with the SetCursor method:; gPad->SetCursor(cursor); The argument cursor is the type of cursor. It may be:; kBottomLeft, kBottomRight, kTopLeft,; kTopRight, kBottomSide, kLeftSide,; kTopSide, kRightSide, kMove,; kCross, kArrowHor, kArrowVer,; kHand, kRotate, kPointer,; kArrowRight, kCaret, kWatch; They are defined in TVirtualX.h and again we hope the names are self-explanatory. If not, try them by designing a small class. It may derive from something already known like TLine.; Note that the ExecuteEvent() functions may in turn; invoke such functions for other objects, in case an object is drawn using other objects. You can also exploit at best the virtues of inheritance. See for example how the class TArrow (derived from TLine) use or redefine the picking functions in its base class.; The last comment is that mous",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:301009,perform,performed,301009,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance," start.; unsigned char*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; Long64_tTTreeCache::fZipBytes! Total compressed size of branches in cache; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very import",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:14429,cache,cache,14429,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance," state of the current navigator. ;  ; void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.);  Classify a given point. See TGeoChecker::CheckPoint(). ;  ; void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);  Test for shape navigation methods. ;  ; void CleanGarbage ();  Clean temporary volumes and shapes from garbage collection. ;  ; void ClearAttributes ();  Reset all attributes to default ones. ;  ; void ClearNavigators ();  Clear all navigators. ;  ; void ClearOverlaps ();  Clear the list of overlaps. ;  ; void ClearPhysicalNodes (Bool_t mustdelete=kFALSE);  Clear the current list of physical nodes, so that we can start over with a new list. ;  ; void ClearShape (const TGeoShape *shape);  Remove a shape from the list of shapes. ;  ; void ClearThreadData () const;  ; void ClearTracks ();  ; void CloseGeometry (Option_t *option=""d"");  Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-time shapes)building the cache manager, voxelizing all volumes, counting the total number of physical nodes and registering the manager class to the browser. ;  ; void ConvertReflections ();  Convert all reflections in geometry to normal rotations + reflected shapes. ;  ; void CountLevels ();  Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices. ;  ; Int_t CountNodes (const TGeoVolume *vol=nullptr, Int_t nlevels=10000, Int_t option=0);  Count the total number of nodes starting from a volume, nlevels down. ;  ; TGeoParallelWorld * CreateParallelWorld (const char *name);  Create a parallel world for prioritised navigation. ;  ; void CreateThreadData () const;  Create thread private data for all geometry objects. ;  ; TGeoNode * CrossBoundaryAndLocate (Bool_t downwards, TGeoNode *skipnode);  Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode. ;  ; void DefaultAngles ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:24359,cache,cache,24359,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['cache'],['cache']
Performance," static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumRunningInt.html:34989,cache,cache,34989,root/html528/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html528/RooNumRunningInt.html,6,['cache'],['cache']
Performance," static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. » Last changed: Mon Dec 7 13:48:34 2009 » Last generated: 2009-12",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumRunningInt.html:34700,cache,cache,34700,root/html526/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html526/RooNumRunningInt.html,1,['cache'],['cache']
Performance," static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstraintSum.html:33250,cache,cache,33250,root/html532/RooConstraintSum.html,https://root.cern,https://root.cern/root/html532/RooConstraintSum.html,1,['cache'],['cache']
Performance," static Double_t SetDefaultExtraRange (Double_t percentage);  Set the default extra range fraction used when doing a FFT convolution. ;  ;  Static Public Member Functions inherited from TF1AbsComposition; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; Double_t EvalFFTConv (Double_t t);  Perform FFT convolution. ;  ; Double_t EvalNumConv (Double_t t);  Perform numerical convolution. ;  ; void InitializeDataMembers (TF1 *function1, TF1 *function2, Bool_t useFFT);  Internal function to initialize data members. ;  ; void MakeFFTConv ();  Perform the FFT of the two functions. ;  . Private Attributes; Int_t fCstIndex;  Index of the constant parameter f the first function. ;  ; Bool_t fFlagFFT;  Choose FFT or numerical convolution. ;  ; Bool_t fFlagGraph = false;  ! Tells if the graph is already done or not ;  ; std::unique_ptr< TF1 > fFunction1;  First function to be convolved. ;  ; std::unique_ptr< TF1 > fFunction2;  Second function to be convolved. ;  ; std::unique_ptr< TGraph > fGraphConv;  ! Graph of the convolution ;  ; Int_t fNofParams1;  ; Int_t fNofParams2;  ; Int_t fNofPoints;  Number of point for FFT array. ;  ; std::vector< Double_t > fParams1;  ; std::vector< Double_t > fParams2;  ; std::vector< TString > fParNames;  Parameters' names. ;  ; Double_t fXmax;  Maximal bound of the range of the convolution. ;  ; Double_t fXm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1Convolution.html:12465,Perform,Perform,12465,doc/master/classTF1Convolution.html,https://root.cern,https://root.cern/doc/master/classTF1Convolution.html,1,['Perform'],['Perform']
Performance," static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooXYChi2Var&operator=(const RooXYChi2Var&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:20200,optimiz,optimizeCacheMode,20200,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,2,['optimiz'],['optimizeCacheMode']
Performance," static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*_cloneSetInternal clone of p.d.f.; RooAbsReal*_effPointer to efficiency function; RooAbsGenContext*_generatorGenerator context for p.d.f; double_maxEffMaximum of efficiency in vars; RooArgSet*_varsVars to generate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Constructor of generator context for RooEffProd products. ~RooEffGenContext(); Destructor. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. Generate an event from the p.d.f and; then perform an accept/reject sampling based on the efficiency; function. RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Tue Jun 30 14:32:39 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffGenContext.html:10762,perform,perform,10762,root/html602/RooEffGenContext.html,https://root.cern,https://root.cern/root/html602/RooEffGenContext.html,1,['perform'],['perform']
Performance," static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*_cloneSetInternal clone of p.d.f.; RooAbsReal*_effPointer to efficiency function; RooAbsGenContext*_generatorGenerator context for p.d.f; double_maxEffMaximum of efficiency in vars; RooArgSet*_varsVars to generate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Constructor of generator context for RooEffProd products. ~RooEffGenContext(); Destructor. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. Generate an event from the p.d.f and; then perform an accept/reject sampling based on the efficiency; function. RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Tue Mar 10 17:16:23 2015 » Last generated: 2015-03-10 17:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffGenContext.html:9748,perform,perform,9748,root/html534/RooEffGenContext.html,https://root.cern,https://root.cern/root/html534/RooEffGenContext.html,1,['perform'],['perform']
Performance," static Int_t _nameLength;  . #include <RooCachedPdf.h>. Inheritance diagram for RooCachedPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedPdf() [1/4]. RooCachedPdf::RooCachedPdf ; (; ). inline . Definition at line 22 of file RooCachedPdf.h. ◆ RooCachedPdf() [2/4]. RooCachedPdf::RooCachedPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 66 of file RooCachedPdf.cxx. ◆ RooCachedPdf() [3/4]. RooCachedPdf::RooCachedPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. The dimensions of the cache are automatically matched to the number of observables used in each use context. Multiple cache in different observable may exists simultaneously if the cached p.d.f is used with multiple observable configurations simultaneously ; Definition at line 44 of file RooCachedPdf.cxx. ◆ RooCachedPdf() [4/4]. RooCachedPdf::RooCachedPdf ; (; const RooCachedPdf & ; other, . const char * ; name = null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:77773,cache,cache,77773,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['cache'],['cache']
Performance," static Internal::RColumn * GetPrincipalColumnOf (const RFieldBase &other);  Fields may need direct access to the principal column of their sub fields, e.g. in RRVecField::ReadBulk. ;  ;  Protected Attributes inherited from ROOT::Experimental::RFieldBase; Internal::RColumn * fAuxiliaryColumn = nullptr;  Some fields have a second column in its column representation. ;  ; std::vector< std::unique_ptr< Internal::RColumn > > fAvailableColumns;  The columns are connected either to a sink or to a source (not to both); they are owned by the field. ;  ; std::vector< std::reference_wrapper< const ColumnRepresentation_t > > fColumnRepresentatives;  Pointers into the static vector GetColumnRepresentations().GetSerializationTypes() when SetColumnRepresentatives is called. ;  ; std::uint32_t fOnDiskTypeChecksum = 0;  TClass checksum cached from the descriptor after a call to ConnectPageSource(). ;  ; std::uint32_t fOnDiskTypeVersion = kInvalidTypeVersion;  C++ type version cached from the descriptor after a call to ConnectPageSource() ;  ; RFieldBase * fParent;  Sub fields point to their mother field. ;  ; Internal::RColumn * fPrincipalColumn = nullptr;  All fields that have columns have a distinct main column. ;  ; std::vector< ReadCallback_t > fReadCallbacks;  List of functions to be called after reading a value. ;  ; std::vector< std::unique_ptr< RFieldBase > > fSubFields;  Collections and classes own sub fields. ;  ; int fTraits = 0;  Properties of the type that allow for optimizations of collections of that type. ;  ; std::string fTypeAlias;  A typedef or using name that was used when creating the field. ;  . #include <ROOT/RField.hxx>. Inheritance diagram for ROOT::Experimental::RField< T, typename >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RField() [1/2]. template<typename T , typename = void> . ROOT::Experimental::RField< T, typename >::RField ; (; std::string_view ; name).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html:12569,cache,cached,12569,doc/master/classROOT_1_1Experimental_1_1RField.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html,1,['cache'],['cached']
Performance," static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TEventIter * Create (TDSet *dset, TSelector *sel, Long64_t first, Long64_t num);  Create and instance of the appropriate iterator. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void PreProcessEvent (Long64_t) override;  To be executed before by TProofPlayer calling TSelector::Process. ;  ;  Protected Member Functions inherited from TEventIter; Int_t LoadDir ();  Load directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; TString fClassName;  ; TList * fKeys;  ; TIter * fNextKey;  ; TObject * fObj;  . Additional Inherited Members;  Public Types inherited from TEventIter; enum  EIterType { kData = 15; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterObj.html:10345,Load,LoadDir,10345,doc/master/classTEventIterObj.html,https://root.cern,https://root.cern/doc/master/classTEventIterObj.html,2,['Load'],"['Load', 'LoadDir']"
Performance," static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObject**TObjArray::fCont!Array contents; Int_tTObjArray::fLastLast element in array containing an object; Int_tTObjArray::fLowerBoundLower bound of the array; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TSchemaRule* GetRuleWithSource(const TString& name) const; Return the rule that has 'name' as a source. const TSchemaRule* GetRuleWithTarget(const TString& name) const; Return the rule that has 'name' as a target. Bool_t HasRuleWithSource(const TString& name, Bool_t needingAlloc) const; Return true if the set of rules has at least one rule that has the data; member named 'name' as a source.; If needingAlloc is true, only the rule that requires the data member to; be cached will be taken in consideration. Bool_t HasRuleWithTarget(const TString& name, Bool_t willset) const; Return true if the set of rules has at least one rule that has the data; member named 'name' as a target.; If willset is true, only the rule that will set the value of the data member. virtual ~TSchemaMatch(); {}. » Last changed: root/core:$Id$ » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaMatch.html:11445,cache,cached,11445,root/html602/ROOT__TSchemaMatch.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaMatch.html,1,['cache'],['cached']
Performance," static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObject**TObjArray::fCont!Array contents; Int_tTObjArray::fLastLast element in array containing an object; Int_tTObjArray::fLowerBoundLower bound of the array; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TSchemaRule* GetRuleWithSource(const TString& name) const; Return the rule that has 'name' as a source. const TSchemaRule* GetRuleWithTarget(const TString& name) const; Return the rule that has 'name' as a target. Bool_t HasRuleWithSource(const TString& name, Bool_t needingAlloc) const; Return true if the set of rules has at least one rule that has the data; member named 'name' as a source.; If needingAlloc is true, only the rule that requires the data member to; be cached will be taken in consideration. Bool_t HasRuleWithTarget(const TString& name, Bool_t willset) const; Return true if the set of rules has at least one rule that has the data; member named 'name' as a target.; If willset is true, only the rule that will set the value of the data member. virtual ~TSchemaMatch(); {}. » Last changed: root/core:$Id$ » Last generated: 2015-09-08 17:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__TSchemaMatch.html:11445,cache,cached,11445,root/html604/ROOT__TSchemaMatch.html,https://root.cern,https://root.cern/root/html604/ROOT__TSchemaMatch.html,1,['cache'],['cached']
Performance, static TObject::(anonymous)TObject::kOverwrite; static TGLCamera::EFrustumPlanekPlanesPerFrustum; static TGLCamera::EFrustumPlanekRight; static TObject::(anonymous)TObject::kSingleKey; static TGLCamera::EFrustumPlanekTop; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBasetranformation to center and rotation from up to x vector; TGLMatrixfCamTranstransformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenterdefault camera center; Double_tfDollyDefaultdefault distnce from viewing centre; Double_tfDollyDistanceunit distance for camera movement in fwd/bck direction; TGLVector3fExtCenterexternal camera center; Bool_tfExternalCenteruse external center insead of scene center; TGLVector3fFDCenterfixed default camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenteruse fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngleminimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); Bool_tfWasArcBalledset when arc-ball rotation is used; static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. al,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLCamera.html:10301,cache,cached,10301,root/html602/TGLCamera.html,https://root.cern,https://root.cern/root/html602/TGLCamera.html,12,['cache'],['cached']
Performance," static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static THtml::EConvertOutputkNoOutput; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static THtml::EConvertOutputkSeparateProcessOutput; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THtml.html:27336,cache,cached,27336,root/html602/THtml.html,https://root.cern,https://root.cern/root/html602/THtml.html,2,['cache'],['cached']
Performance, static TTree::ESetBranchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THbookTree.html:24081,cache,cache,24081,root/html604/THbookTree.html,https://root.cern,https://root.cern/root/html604/THbookTree.html,2,['cache'],['cache']
Performance," static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for newsize points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fE***to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; and fEYhighd arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphBentErrors.html:29860,perform,perform,29860,doc/master/classTGraphBentErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphBentErrors.html,1,['perform'],['perform']
Performance," static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:37022,cache,cached,37022,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['cache'],['cached']
Performance," static_cast<uint64_t>(pow(2, nbits));; 2265 ; 2266 ; 2267 // vector to save importances; 2268 std::vector<Double_t> importances(nbits);; 2269 // vector to save ROC; 2270 std::vector<Double_t> ROC(range);; 2271 ROC[0] = 0.5;; 2272 for (int i = 0; i < nbits; i++); 2273 importances[i] = 0;; 2274 ; 2275 Double_t SROC, SSROC; // computed ROC value; 2276 for (x = 1; x < range; x++) {; 2277 ; 2278 std::bitset<VIBITS> xbitset(x);; 2279 if (x == 0); 2280 continue; // data loader need at least one variable; 2281 ; 2282 // creating loader for seed; 2283 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2284 ; 2285 // adding variables from seed; 2286 for (int index = 0; index < nbits; index++) {; 2287 if (xbitset[index]); 2288 seedloader->AddVariable(varNames[index], 'F');; 2289 }; 2290 ; 2291 DataLoaderCopy(seedloader, loader);; 2292 seedloader->PrepareTrainingAndTestTree(loader->GetDataSetInfo().GetCut(""Signal""),; 2293 loader->GetDataSetInfo().GetCut(""Background""),; 2294 loader->GetDataSetInfo().GetSplitOptions());; 2295 ; 2296 // Booking Seed; 2297 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2298 ; 2299 // Train/Test/Evaluation; 2300 TrainAllMethods();; 2301 TestAllMethods();; 2302 EvaluateAllMethods();; 2303 ; 2304 // getting ROC; 2305 ROC[x] = GetROCIntegral(xbitset.to_string(), methodTitle);; 2306 ; 2307 // cleaning information to process sub-seeds; 2308 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2309 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2310 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2311 delete sresults;; 2312 delete seedloader;; 2313 this->DeleteAllMethods();; 2314 ; 2315 fMethodsMap.clear();; 2316 // removing global result because it is requiring a lot of RAM for all seeds; 2317 }; 2318 ; 2319 for (x = 0; x < range; x++) {; 2320 SROC = ROC[x];; 2321 for (uint32_t i = 0; i ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:96534,load,loader,96534,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance," statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:36891,cache,cache,36891,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance," statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:35606,cache,cache,35606,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance," statistics to use; boolfTmpDoExtended; boolfUsePriorPdfuse a prior for nuisance parameters . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HybridCalculatorOriginal(const char* name = 0); constructor with name and title; set default parameters. HybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor without specifying a data set; the user need to specify the models in the S+B case and B-only case,; the list of observables of the model(s) (for MC-generation), the list of parameters; that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor for performing hypotesis test; the user need to specify the data set, the models in the S+B case and B-only case.; In case of treatment of nuisance parameter, the user need to specify the; the list of parameters that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); Constructor with a ModelConfig object representing the signal + background model and; another model config representig the background only model; a Prior pdf for the nuiscane parameter of the signal and background can be specified in; the s+b model or the b model. If it is specified in the s+b model, the one of the s+b model will be used. ~HybridCalculatorOriginal(); HybridCalculatorOriginal destructor. void SetNullModel(const RooStats::ModelConfig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html:11343,perform,performing,11343,root/html528/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html,4,['perform'],['performing']
Performance," status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(const FitResult & rhs). Copy constructor. virtual ~FitResult(). Destructor. void FillResult(const shared_ptr<ROOT::Math::Minimizer>& min, const ROOT::Fit::FitConfig& fconfig, const shared_ptr<ROOT::Fit::FitResult::IModelFunction>& f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Fill the fit result from a Minimizer instance after fitting; Run also Minos if requested from the configuration. const std::string & MinimizerType() const. Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the Minimizer class to tag a found minimum as valid or not; and to produce also a status code. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__FitResult.html:5876,perform,performed,5876,root/html604/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__FitResult.html,1,['perform'],['performed']
Performance," std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1053911,load,loading,1053911,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loading']
Performance," std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCategoryLValue.h>. Inheritance diagram for RooAbsCategoryLValue:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAbsCategoryLValue() [1/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; ). inline . Definition at line 29 of file RooAbsCategoryLValue.h. ◆ RooAbsCategoryLValue() [2/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; const char * ; name, . const char * ; title . ). Constructor. ; Definition at line 44 of file RooAbsCategoryLValue.cxx. ◆ RooAbsCategoryLValue() [3/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; const RooAbsCategoryLValu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:46532,cache,cache,46532,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['cache'],['cache']
Performance," std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCategory.h>. Inheritance diagram for RooCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ RangeMap_t. using RooCategory::RangeMap_t = std::map<std::string, std::vector<value_type> >. private . Definition at line 128 of file RooCategory.h. Constructor & Destructor Documentation. ◆ RooCategory() [1/4]. RooCategory::RooCategory ; (; ). Definition at line 104 of file RooCategory.cxx. ◆ RooCategory() [2/4]. RooCategory::RooCategory ; (; const char * ; name, . const char * ; title . ). Constructor. Types must be defined using defineType() before variable can be used.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:52072,cache,cache,52072,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['cache'],['cache']
Performance," std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStringVar.h>. Inheritance diagram for RooStringVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooStringVar() [1/3]. RooStringVar::RooStringVar ; (; ). inline . Definition at line 26 of file RooStringVar.h. ◆ RooStringVar() [2/3]. RooStringVar::RooStringVar ; (; const char * ; name, . const char * ; title, . const char * ; value, . Int_t ; size = 1024 . ). Constructor with initial value. The size argument is ignored. ; Definition at line 36 of file RooStringVar.cxx. ◆ RooStringVar() [3/3]. RooStringVar::RooStringVar ; (; const RooStringVar & ; other, . c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStringVar.html:37816,cache,cache,37816,doc/master/classRooStringVar.html,https://root.cern,https://root.cern/doc/master/classRooStringVar.html,1,['cache'],['cache']
Performance," std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSuperCategory.h>. Inheritance diagram for RooSuperCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooSuperCategory() [1/3]. RooSuperCategory::RooSuperCategory ; (; ). default . ◆ RooSuperCategory() [2/3]. RooSuperCategory::RooSuperCategory ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; inputCategories . ). Construct a super category from other categories. ; Parameters. [in]nameName of this object ; [in]titleTitle (for e.g. printing) ; [in]inputCategoriesRooArgSet with category objects. These all need to derive from RooAbsCat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:48158,cache,cache,48158,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['cache'],['cache']
Performance," std::string &typeAlias, bool continueOnError=false);  Factory method to resurrect a field from the stored on-disk type information. ;  ; static std::unique_ptr< RDeleter > GetDeleterOf (const RFieldBase &other);  ; static Internal::RColumn * GetPrincipalColumnOf (const RFieldBase &other);  Fields may need direct access to the principal column of their sub fields, e.g. in RRVecField::ReadBulk. ;  . Protected Attributes; Internal::RColumn * fAuxiliaryColumn = nullptr;  Some fields have a second column in its column representation. ;  ; std::vector< std::unique_ptr< Internal::RColumn > > fAvailableColumns;  The columns are connected either to a sink or to a source (not to both); they are owned by the field. ;  ; std::vector< std::reference_wrapper< const ColumnRepresentation_t > > fColumnRepresentatives;  Pointers into the static vector GetColumnRepresentations().GetSerializationTypes() when SetColumnRepresentatives is called. ;  ; std::uint32_t fOnDiskTypeChecksum = 0;  TClass checksum cached from the descriptor after a call to ConnectPageSource(). ;  ; std::uint32_t fOnDiskTypeVersion = kInvalidTypeVersion;  C++ type version cached from the descriptor after a call to ConnectPageSource() ;  ; RFieldBase * fParent;  Sub fields point to their mother field. ;  ; Internal::RColumn * fPrincipalColumn = nullptr;  All fields that have columns have a distinct main column. ;  ; std::vector< ReadCallback_t > fReadCallbacks;  List of functions to be called after reading a value. ;  ; std::vector< std::unique_ptr< RFieldBase > > fSubFields;  Collections and classes own sub fields. ;  ; int fTraits = 0;  Properties of the type that allow for optimizations of collections of that type. ;  ; std::string fTypeAlias;  A typedef or using name that was used when creating the field. ;  . Private Types; using ReadCallback_t = std::function< void(void *)>;  . Private Member Functions; void CommitCluster ();  Flushes data from active columns to disk and calls CommitClusterImpl. ;  ; void Con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:13102,cache,cached,13102,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['cache'],['cached']
Performance," store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:75227,optimiz,optimizeDirtyHook,75227,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance," stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:15448,cache,cache,15448,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance," stream data of specified class. void DecrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and decrease level in xml structure. void SetStreamerElementNumber(Int_t ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and add/verify next element of xml structure; This calls allows separate data, correspondent to one class member, from another. void WorkWithElement(TStreamerElement* elem, Int_t number); to be documented by Sergey. void ClassBegin(const TClass* , Version_t = -1); to be documented by Sergey. void ClassEnd(const TClass* ); to be documented by Sergey. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); to be documented by Sergey. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t /*r_s */, UInt_t /*r_c*/, const TClass* /*cl*/); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t, UInt_t, const char*); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. void CheckVersionBuf(); checks buffer, filled by WriteVersion; if next data is arriving, version should be stored in buffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:29782,Perform,PerformPreProcessing,29782,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,1,['Perform'],['PerformPreProcessing']
Performance," stream data of specified class. void DecrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and decrease level in xml structure. void SetStreamerElementNumber(Int_t ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and add/verify next element of xml structure; This calls allows separate data, correspondent to one class member, from another. void WorkWithElement(TStreamerElement* elem, Int_t number); to be documented by Sergey. void ClassBegin(const TClass* , Version_t = -1); to be documented by Sergey. void ClassEnd(const TClass* ); to be documented by Sergey. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); to be documented by Sergey. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. void CheckVersionBuf(); checks buffer, filled by WriteVersion; if next data is arriving, vers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:30493,Perform,PerformPreProcessing,30493,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,3,['Perform'],['PerformPreProcessing']
Performance," stride width | padding height | paddig; width | activation function; ; - note in this case we are using a filer 3x3 and padding=1 and stride=1 so we get the output dimension of the; conv layer equal to the input; ; - note we use after the first convolutional layer a batch normalization layer. This seems to help significantly the; convergence; ; - For the MaxPool layer:; - MAXPOOL | pool height | pool width | stride height | stride width; ; The RESHAPE layer is needed to flatten the output before the Dense layer; ; ; Note that to run the CNN is required to have CPU or GPU support; ; ***/; ; if (useTMVACNN) {; ; TString inputLayoutString(""InputLayout=1|16|16"");; ; // Batch Layout; TString layoutString(""Layout=CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,""; ""RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR"");; ; // Training strategies.; TString trainingString1(""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""MaxEpochs=10,WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0"");; ; TString trainingStrategyString(""TrainingStrategy="");; trainingStrategyString +=; trainingString1; // + ""|"" + trainingString2 + ""|"" + trainingString3; for concatenating more training strings; ; // Build full CNN Options.; TString cnnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:""; ""WeightInitialization=XAVIER"");; ; cnnOptions.Append("":"");; cnnOptions.Append(inputLayoutString);; cnnOptions.Append("":"");; cnnOptions.Append(layoutString);; cnnOptions.Append("":"");; cnnOptions.Append(trainingStrategyString);; ; //// New DL (CNN); TString cnnMethodName = ""TMVA_CNN_CPU"";; // use GPU if available; #ifdef R__HAS_TMVAGPU; cnnOptions += "":Architecture=GPU"";; cnnMethodName = ""TMVA_CNN_GPU"";; #else; cnnOptions += "":Architecture=CPU"";; cnnMethodName = ""TMVA_CNN_CPU"";; #endif; ; factory.BookMethod(&loader, TMVA::Types::kDL, cnnMethodName, cnnOptions);; }; ; /**; ### Book Convolutional Neural N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:56964,Optimiz,Optimizer,56964,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance," string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:41111,cache,cache,41111,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['cache'],['cache']
Performance," such a modification of fit behaviour is intentional, this function should be used. ; Implements RooAbsDataStore.; Definition at line 623 of file RooVectorDataStore.cxx. ◆ addReal(). RooVectorDataStore::RealVector * RooVectorDataStore::addReal ; (; RooAbsReal * ; real). protected . Definition at line 1244 of file RooVectorDataStore.cxx. ◆ addRealFull(). RooVectorDataStore::RealFullVector * RooVectorDataStore::addRealFull ; (; RooAbsReal * ; real). protected . Definition at line 1304 of file RooVectorDataStore.cxx. ◆ append(). void RooVectorDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 720 of file RooVectorDataStore.cxx. ◆ attachBuffers(). void RooVectorDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1041 of file RooVectorDataStore.cxx. ◆ attachCache(). void RooVectorDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:26698,cache,cachedVars,26698,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cachedVars']
Performance," sum of 2 vectors: c=a+b, a=a+b, NEVER USE IT, VERY SLOW!!! ; Definition at line 168 of file PDEFoamVect.cxx. ◆ operator+=(). TMVA::PDEFoamVect & TMVA::PDEFoamVect::operator+= ; (; const PDEFoamVect & ; shift). unary addition operator +=; adding vector c*=x, ; Definition at line 141 of file PDEFoamVect.cxx. ◆ operator-(). TMVA::PDEFoamVect TMVA::PDEFoamVect::operator- ; (; const PDEFoamVect & ; p2). subtraction operator -; difference of 2 vectors; c=a-b, a=a-b, NEVER USE IT, VERY SLOW!!! ; Definition at line 180 of file PDEFoamVect.cxx. ◆ operator-=(). TMVA::PDEFoamVect & TMVA::PDEFoamVect::operator-= ; (; const PDEFoamVect & ; shift). unary subtraction operator -= ; Definition at line 154 of file PDEFoamVect.cxx. ◆ operator=() [1/3]. TMVA::PDEFoamVect & TMVA::PDEFoamVect::operator= ; (; const PDEFoamVect & ; vect). substitution operator ; Definition at line 99 of file PDEFoamVect.cxx. ◆ operator=() [2/3]. TMVA::PDEFoamVect & TMVA::PDEFoamVect::operator= ; (; Double_t ; x). Loading in double prec. number, sometimes can be useful. ; Definition at line 201 of file PDEFoamVect.cxx. ◆ operator=() [3/3]. TMVA::PDEFoamVect & TMVA::PDEFoamVect::operator= ; (; Double_t ; Vect[]). Loading in ordinary double prec. vector, sometimes can be useful. ; Definition at line 191 of file PDEFoamVect.cxx. ◆ operator[](). Double_t & TMVA::PDEFoamVect::operator[] ; (; Int_t ; n). [] is for access to elements as in ordinary matrix like a[j]=b[j] (Perhaps against some strict rules but rather practical.) Range protection is built in, consequently for substitution one should use rather use a=b than explicit loop! ; Definition at line 120 of file PDEFoamVect.cxx. ◆ Print(). void TMVA::PDEFoamVect::Print ; (; Option_t * ; option); const. virtual . Printout of all vector components. ; Reimplemented from TObject.; Definition at line 217 of file PDEFoamVect.cxx. ◆ Streamer(). virtual void TMVA::PDEFoamVect::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamVect.html:14400,Load,Loading,14400,doc/master/classTMVA_1_1PDEFoamVect.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamVect.html,1,['Load'],['Loading']
Performance," summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward plot sampling hint of integrand. » Last changed: Mon Dec 7 13:48:51 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:36926,cache,cached,36926,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,4,['cache'],"['cache', 'cached']"
Performance," switch for component selection; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; RooRealProxy_x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMoment.html:32860,cache,cache,32860,root/html532/RooMoment.html,https://root.cern,https://root.cern/root/html532/RooMoment.html,1,['cache'],['cache']
Performance," sysinfo->fPhysRam = (s.Atoi() / 1024);; 5143 break;; 5144 }; 5145 }; 5146 fclose(f);; 5147 }; 5148 ; 5149 f = gSystem->OpenPipe(""uname -s -p"", ""r"");; 5150 if (f) {; 5151 s.Gets(f);; 5152 Ssiz_t from = 0;; 5153 s.Tokenize(sysinfo->fOS, from);; 5154 s.Tokenize(sysinfo->fCpuType, from);; 5155 gSystem->ClosePipe(f);; 5156 }; 5157}; 5158 ; 5159////////////////////////////////////////////////////////////////////////////////; 5160/// Get CPU load on Linux.; 5161 ; 5162static void ReadLinuxCpu(long *ticks); 5163{; 5164 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 5165 ; 5166 TString s;; 5167 FILE *f = fopen(""/proc/stat"", ""r"");; 5168 if (!f) return;; 5169 s.Gets(f);; 5170 // user, user nice, sys, idle; 5171 sscanf(s.Data(), ""%*s %ld %ld %ld %ld"", &ticks[0], &ticks[3], &ticks[1], &ticks[2]);; 5172 fclose(f);; 5173}; 5174 ; 5175////////////////////////////////////////////////////////////////////////////////; 5176/// Get CPU stat for Linux. Use sampleTime to set the interval over which; 5177/// the CPU load will be measured, in ms (default 1000).; 5178 ; 5179static void GetLinuxCpuInfo(CpuInfo_t *cpuinfo, Int_t sampleTime); 5180{; 5181 Double_t avg[3] = { -1., -1., -1. };; 5182#ifndef R__WINGCC; 5183 if (getloadavg(avg, sizeof(avg)) < 0) {; 5184 ::Error(""TUnixSystem::GetLinuxCpuInfo"", ""getloadavg failed"");; 5185 } else; 5186#endif; 5187 {; 5188 cpuinfo->fLoad1m = (Float_t)avg[0];; 5189 cpuinfo->fLoad5m = (Float_t)avg[1];; 5190 cpuinfo->fLoad15m = (Float_t)avg[2];; 5191 }; 5192 ; 5193 Long_t cpu_ticks1[4], cpu_ticks2[4];; 5194 ReadLinuxCpu(cpu_ticks1);; 5195 gSystem->Sleep(sampleTime);; 5196 ReadLinuxCpu(cpu_ticks2);; 5197 ; 5198 Long_t userticks = (cpu_ticks2[0] + cpu_ticks2[3]) -; 5199 (cpu_ticks1[0] + cpu_ticks1[3]);; 5200 Long_t systicks = cpu_ticks2[1] - cpu_ticks1[1];; 5201 Long_t idleticks = cpu_ticks2[2] - cpu_ticks1[2];; 5202 if (userticks < 0) userticks = 0;; 5203 if (systicks < 0) systicks = 0;; 5204 if (idleticks < 0) idleticks = 0;; 5205 Long_t totalticks = user",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:167307,load,load,167307,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['load']
Performance," tab element id from right tab. void CloseTabs(); Properly close the mainframes embedded in the different tabs. void CloseWindow(); Called when window is closed via the window manager. void DoTab(Int_t id); Handle Tab navigation. void EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Display a tooltip with infos about the primitive below the cursor. Long_t ExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); Execute a macro and embed the created frame in the tab ""pos""; and tab element ""subpos"". Option_t * GetDrawOption() const; Returns drawing option. TGTab* GetTab(Int_t pos) const; Returns the TGTab at position pos. Bool_t HandleKey(Event_t* event); Handle keyboard events. void HandleMenu(Int_t id); Handle menu entries events. void InitPlugins(Option_t* opt = """"); Initialize default plugins. Could be also of the form:; StartEmbedding(0);; TPluginHandler *ph;; ph = gROOT->GetPluginManager()->FindHandler(""TGClassBrowser"");; if (ph && ph->LoadPlugin() != -1) {; ph->ExecPlugin(3, gClient->GetRoot(), 200, 500);; }; StopEmbedding();. void ReallyDelete(); Really delete the browser and the this GUI. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void RecursiveReparent(TGPopupMenu* popup); Recursively reparent TGPopupMenu to gClient->GetDefaultRoot(). void Refresh(Bool_t force = kFALSE); Refresh the actual browser contents. void RemoveTab(Int_t pos, Int_t subpos); Remove tab element ""subpos"" from tab ""pos"". void SetTab(Int_t pos = kRight, Int_t subpos = -1); Switch to Tab ""subpos"" in TGTab ""pos"". void SetTabTitle(const char* title, Int_t pos = kRight, Int_t subpos = -1); Set text ""title"" of Tab ""subpos"" in TGTab ""pos"". void SetStatusText(const char* txt, Int_t col); Set text in culumn col in status bar. void ShowMenu(TGCompositeFrame* menu); Show the selected frame's menu and hide previous one. void StartEmbedding(Int_t pos = kRight, Int_t subpos = -1); Start embedding e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootBrowser.html:28163,Load,LoadPlugin,28163,root/html534/TRootBrowser.html,https://root.cern,https://root.cern/root/html534/TRootBrowser.html,3,['Load'],['LoadPlugin']
Performance," table.; 5882/// If it finds a pair that matches val, it returns directly the; 5883/// index in the table.; 5884/// If an entry corresponding to major and minor is not found, the function; 5885/// returns the index of the major,minor pair immediately lower than the; 5886/// requested value, ie it will return -1 if the pair is lower than; 5887/// the first entry in the index.; 5888///; 5889/// See also GetEntryNumberWithIndex; 5890 ; 5891Long64_t TTree::GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; 5892{; 5893 if (!fTreeIndex) {; 5894 return -1;; 5895 }; 5896 return fTreeIndex->GetEntryNumberWithBestIndex(major, minor);; 5897}; 5898 ; 5899////////////////////////////////////////////////////////////////////////////////; 5900/// Return entry number corresponding to major and minor number.; 5901/// Note that this function returns only the entry number, not the data; 5902/// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; 5903/// the BuildIndex function has created a table of Long64_t* of sorted values; 5904/// corresponding to val = major<<31 + minor;; 5905/// The function performs binary search in this sorted table.; 5906/// If it finds a pair that matches val, it returns directly the; 5907/// index in the table, otherwise it returns -1.; 5908///; 5909/// See also GetEntryNumberWithBestIndex; 5910 ; 5911Long64_t TTree::GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; 5912{; 5913 if (!fTreeIndex) {; 5914 return -1;; 5915 }; 5916 return fTreeIndex->GetEntryNumberWithIndex(major, minor);; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Read entry corresponding to major and minor number.; 5921///; 5922/// The function returns the total number of bytes read.; 5923/// If the Tree has friend trees, the corresponding entry with; 5924/// the index values (major,minor) is read. Note that the master Tree; 5925/// and its friend may have different entry se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:233122,perform,performs,233122,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['perform'],['performs']
Performance," tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26845,perform,performance-optimized,26845,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['perform'],['performance-optimized']
Performance," tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompiliation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:30868,perform,performance-optimized,30868,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['perform'],['performance-optimized']
Performance," targets for next iter. ;  . Private Attributes; Double_t fAdaBoostBeta;  beta parameter for AdaBoost algorithm ;  ; TString fAdaBoostR2Loss;  loss type used in AdaBoostR2 (Linear,Quadratic or Exponential) ;  ; Bool_t fAutomatic;  use user given prune strength or automatically determined one using a validation sample ;  ; Bool_t fBaggedBoost;  turn bagging in combination with boost on/off ;  ; Bool_t fBaggedGradBoost;  turn bagging in combination with grad boost on/off ;  ; Double_t fBaggedSampleFraction;  relative size of bagged event sample to original sample size ;  ; TString fBoostType;  string specifying the boost type ;  ; Double_t fBoostWeight;  ntuple var: boost weight ;  ; std::vector< double > fBoostWeights;  the weights applied in the individual boosts ;  ; Double_t fCbb;  Cost factor. ;  ; Double_t fCss;  Cost factor. ;  ; Double_t fCtb_ss;  Cost factor. ;  ; Double_t fCts_sb;  Cost factor. ;  ; Bool_t fDoBoostMonitor;  create control plot with ROC integral vs tree number ;  ; Bool_t fDoPreselection;  do or do not perform automatic pre-selection of 100% eff. cuts ;  ; Double_t fErrorFraction;  ntuple var: misclassification error fraction ;  ; std::vector< const TMVA::Event * > fEventSample;  the training events ;  ; std::vector< DecisionTree * > fForest;  the collection of decision trees ;  ; Double_t fFValidationEvents;  fraction of events to use for pruning ;  ; std::vector< Double_t > fHighBkgCut;  ; std::vector< Double_t > fHighSigCut;  ; Bool_t fHistoricBool;  ; Double_t fHuberQuantile;  the option string determining the quantile for the Huber Loss Function in BDT regression. ;  ; Bool_t fInverseBoostNegWeights;  boost ev. with neg. weights with 1/boostweight rather than boostweight ;  ; std::vector< Bool_t > fIsHighBkgCut;  ; std::vector< Bool_t > fIsHighSigCut;  ; std::vector< Bool_t > fIsLowBkgCut;  ; std::vector< Bool_t > fIsLowSigCut;  ; Int_t fITree;  ntuple var: ith tree ;  ; std::map< const TMVA::Event *, LossFunctionEventInfo > fLossFunction",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:34914,perform,perform,34914,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['perform'],['perform']
Performance," template functions and/or C++14 auto return types:; 1094~~~{.cpp}; 1095template <typename RDF>; 1096auto ApplySomeFilters(RDF df); 1097{; 1098 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1099}; 1100~~~; 1101 ; 1102A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1103converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1104~~~{.cpp}; 1105// a function that conditionally adds a Range to an RDataFrame node.; 1106RNode MaybeAddRange(RNode df, bool mustAddRange); 1107{; 1108 return mustAddRange ? df.Range(1) : df;; 1109}; 1110// use as :; 1111ROOT::RDataFrame df(10);; 1112auto maybeRangedDF = MaybeAddRange(df, true);; 1113~~~; 1114 ; 1115The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1116loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1117 ; 1118\anchor RDFCollections; 1119### Storing RDataFrame objects in collections; 1120 ; 1121ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1122 ; 1123~~~{.cpp}; 1124std::vector<ROOT::RDF::RNode> dfs;; 1125dfs.emplace_back(ROOT::RDataFrame(10));; 1126dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1127~~~; 1128 ; 1129\anchor callbacks; 1130### Executing callbacks every N events; 1131It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1132Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1133drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1134displaying a progress bar while the event loop runs.; 1135 ; 1136For example one can draw an up-to-date version of a result histogram every 100 entries ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:65379,perform,perform,65379,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance," template functions and/or C++14 auto return types:; 1134~~~{.cpp}; 1135template <typename RDF>; 1136auto ApplySomeFilters(RDF df); 1137{; 1138 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1139}; 1140~~~; 1141 ; 1142A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1143converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1144~~~{.cpp}; 1145// a function that conditionally adds a Range to an RDataFrame node.; 1146RNode MaybeAddRange(RNode df, bool mustAddRange); 1147{; 1148 return mustAddRange ? df.Range(1) : df;; 1149}; 1150// use as :; 1151ROOT::RDataFrame df(10);; 1152auto maybeRangedDF = MaybeAddRange(df, true);; 1153~~~; 1154 ; 1155The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1156loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1157 ; 1158\anchor RDFCollections; 1159### Storing RDataFrame objects in collections; 1160 ; 1161ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1162 ; 1163~~~{.cpp}; 1164std::vector<ROOT::RDF::RNode> dfs;; 1165dfs.emplace_back(ROOT::RDataFrame(10));; 1166dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1167~~~; 1168 ; 1169\anchor callbacks; 1170### Executing callbacks every N events; 1171It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1172Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1173drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1174displaying a progress bar while the event loop runs.; 1175 ; 1176For example one can draw an up-to-date version of a result histogram every 100 entries ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:67059,perform,perform,67059,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance," template<class IT>; 264 void SetComponents(IT begin, IT end) {; 265 for (int i = 0; i <9; ++i) {; 266 fM[i] = *begin;; 267 ++begin;; 268 }; 269 (void)end;; 270 assert (end==begin);; 271 }; 272 ; 273 /**; 274 Get the 9 matrix components into data specified by an iterator begin; 275 and another to the end of the desired data (9 past start).; 276 */; 277 template<class IT>; 278 void GetComponents(IT begin, IT end) const {; 279 for (int i = 0; i <9; ++i) {; 280 *begin = fM[i];; 281 ++begin;; 282 }; 283 (void)end;; 284 assert (end==begin);; 285 }; 286 ; 287 /**; 288 Get the 9 matrix components into data specified by an iterator begin; 289 */; 290 template<class IT>; 291 void GetComponents(IT begin) const {; 292 std::copy ( fM, fM+9, begin );; 293 }; 294 ; 295 /**; 296 Set components from a linear algebra matrix of size at least 3x3,; 297 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 298 Precondition: The matrix is assumed to be orthonormal. NO checking; 299 or re-adjusting is performed.; 300 */; 301 template<class ForeignMatrix>; 302 void; 303 SetRotationMatrix (const ForeignMatrix & m) {; 304 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2);; 305 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2);; 306 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2);; 307 }; 308 ; 309 /**; 310 Get components into a linear algebra matrix of size at least 3x3,; 311 which must support operator()(i,j) for write access to elements; 312 (0,0) thru (2,2).; 313 */; 314 template<class ForeignMatrix>; 315 void; 316 GetRotationMatrix (ForeignMatrix & m) const {; 317 m(0,0)=fM[kXX]; m(0,1)=fM[kXY]; m(0,2)=fM[kXZ];; 318 m(1,0)=fM[kYX]; m(1,1)=fM[kYY]; m(1,2)=fM[kYZ];; 319 m(2,0)=fM[kZX]; m(2,1)=fM[kZY]; m(2,2)=fM[kZZ];; 320 }; 321 ; 322 /**; 323 Set the components from nine scalars -- UNCHECKED for orthonormaility; 324 */; 325 void; 326 SetComponents (Scalar xx, Scalar xy, Scalar xz,; 327 Scalar yx, Scalar yy, Scalar yz,; 328 Scalar zx, Scalar zy, Scalar zz) {; 329 fM[kXX]=xx; fM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:9497,perform,performed,9497,doc/master/GenVector_2Rotation3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html,1,['perform'],['performed']
Performance," template<typename AReal > . void TMVA::DNN::TCpu< AReal >::ConstMult ; (; Matrix_t & ; A, . Scalar_t ; beta . ). static . Multiply the constant beta to all the elements of matrix A and write the result into A. ; Definition at line 310 of file Arithmetic.hxx. ◆ ConvLayerBackward(). template<typename AReal = Float_t> . void TMVA::DNN::TCpu< AFloat >::ConvLayerBackward ; (; Tensor_t & ; activationGradientsBackward, . Matrix_t & ; weightGradients, . Matrix_t & ; biasGradients, . Tensor_t & ; df, . Tensor_t & ; activationGradients, . const Matrix_t & ; weights, . const Tensor_t & ; activationBackward, . const Tensor_t & ; outputTensor, . EActivationFunction ; activFunc, . const ConvDescriptors_t & ; , . ConvWorkspace_t & ; , . size_t ; batchSize, . size_t ; inputHeight, . size_t ; inputWidth, . size_t ; depth, . size_t ; height, . size_t ; width, . size_t ; filterDepth, . size_t ; filterHeight, . size_t ; filterWidth, . size_t ; nLocalViews . ). static . Perform the complete backward propagation step in a Convolutional Layer. ; If the provided activationGradientsBackward matrix is not empty, compute the gradients of the objective function with respect to the activations of the previous layer (backward direction). Also compute the weight and the bias gradients. Modifies the values in df and thus produces only a valid result, if it is applied the first time after the corresponding forward propagation has been per- formed. ; Definition at line 380 of file Propagation.hxx. ◆ ConvLayerForward(). template<typename AReal = Float_t> . void TMVA::DNN::TCpu< AFloat >::ConvLayerForward ; (; Tensor_t & ; output, . Tensor_t & ; inputActivationFunc, . const Tensor_t & ; input, . const Matrix_t & ; weights, . const Matrix_t & ; biases, . const DNN::CNN::TConvParams & ; params, . EActivationFunction ; activFunc, . Tensor_t & ; , . const ConvDescriptors_t & ; , . ConvWorkspace_t & ;  . ). static . Forward propagation in the Convolutional layer. ; Definition at line 326 of file Propagatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html:38446,Perform,Perform,38446,doc/master/classTMVA_1_1DNN_1_1TCpu.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html,1,['Perform'],['Perform']
Performance," text is drawn with TGX11::DrawText. XImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). void DeleteGC(GContext_t gc); Explicitely delete a graphics context. FontH_t GetFontHandle(FontStruct_t fs); Return handle to font described by font structure. FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. void MapGCFont(GContext_t gc, FontStruct_t font); Map the XftFont with the Graphics Context using it. Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font properties. void DrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); Draw text string. TGX11TTF(const TGX11& org). virtual ~TGX11TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x11ttf:$Id$ » Last generated: 2015-04-28 16:43; This page has been automatically gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:28305,Load,LoadQueryFont,28305,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,1,['Load'],['LoadQueryFont']
Performance," than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:59799,cache,caches,59799,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['cache'],['caches']
Performance," that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different processing slot, e.g. a different element of a list. See here for an example usage of ForeachSlot(). Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other. On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage. ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently: ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");; ; // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop; ; // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Performance considerations; To obtain the maximum performance out of RDataFrame, make ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:48368,concurren,concurrently,48368,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrently']
Performance, that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ixmax; Int_t_ixmin; Int_t_iymax; Int_t_iymin; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TMatrixD_mref; static Int_tRooPrintable::_nameLength; Int_t_npoints; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Roo2DMomentMorphFunction::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs re,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DMomentMorphFunction.html:33206,cache,cache,33206,root/html532/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo2DMomentMorphFunction.html,1,['cache'],['cache']
Performance," that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_compCIter! do not persist; RooSetProxy_compCSet; TIterator*_compRIter! do not persist; RooSetProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:31025,cache,cache,31025,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,2,['cache'],['cache']
Performance, that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_compCIter! do not persist; RooSetProxy_compCSet; TIterator*_compRIter! do not persist; RooSetProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration spec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProduct.html:31715,cache,cache,31715,root/html530/RooProduct.html,https://root.cern,https://root.cern/root/html530/RooProduct.html,1,['cache'],['cache']
Performance," that should be deleted on exit of the OS interface. ;  ; virtual TStdExceptionHandler * RemoveStdExceptionHandler (TStdExceptionHandler *eh);  Remove an exception handler from list of exception handlers. ;  ; virtual void ResetTimer (TTimer *);  ; virtual void Run ();  System event loop. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ;  ; virtual void SetFlagsOpt (const char *);  FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ;  ; virtual void SetIncludePath (const char *includePath);  IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ;  ; virtual void SetLinkdefSuffix (const char *suffix);  The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary. ;  ; virtual void SetLinkedLibs (const char *linkedLibs);  LinkedLibs should contain the library directory and list of libraries needed to recreate the current executable. ;  ; virtual void SetMakeExe (const char *directives);  Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executable. ;  ; virtual void SetMakeSharedLib (const char *directives);  Directives should contain the description on how to compile and link a shared lib. ;  ; virtual void SetObjExt (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:19946,optimiz,optimized,19946,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['optimiz'],['optimized']
Performance," the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:45108,load,load,45108,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance," the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6770; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:3006; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7387; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5725; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3808; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4776; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:7036; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:44936,load,load,44936,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['load']
Performance," the File and Getting the Tree; The first thing to do is to open the file containing the tree, by calling TFile::Open(), passing the file name, and then, if the file is open (i.e. if the pointer to it is not NULL), create a TTreeReader using the tree name and the file. At the end, the code in AnalyzeTree.C should look like this:; ... // open the file; TFile *f = TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");; if (f == 0) {; // if we cannot open the file, print an error message and return immediatly; printf(""Error: cannot open http://root.cern/files/introtutorials/eventdata.root!\n"");; return;; }. // Create tyhe tree reader and its data containers; TTreeReader myReader(""EventTree"", f);. ... Getting the data out of the TTree; Fine, we have access to our tree. But now we need to get a handle on the data it stores, as shown below:; ... TTreeReaderValue<Int_t> eventSize(myReader, ""fEventSize"");. ... Loading TTree's Data; For the analysis example we need to access the events' size, which is accessible through the TTreeReaderValue eventSize. But the TTreeReader first needs to get told about which TTree entry to access. For that call TTreeReader::Next() in a loop. It will return false once it has reached the end of the TTree.; In the same loop, compute the total size of all events (simply add the current event size to the total size); ... // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Get the data from the current TTree entry by getting; // the value from the connected reader (eventSize):; totalSize += *eventSize;; }. Accessing the Analysis Result; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:4079,Load,Loading,4079,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['Load'],['Loading']
Performance," the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); {}. MethodCompositeBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); {}. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. TMVA::IMethod* GetMethod(const Int_t index) const; returns pointer to MVA that corresponds to given method index. void AddWeightsXMLTo(void* parent) const. ~MethodCompositeBase( void ); delete methods. void ReadWeightsFromXML(void* wghtnode); XML streamer. void ReadWeightsFromStream(istream& istr); text streamer. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return composite MVA response. MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). void Train(); performs classifier training. const Ranking* CreateRanking(); create ranking. void DeclareOptions(). void ProcessOptions(). UInt_t GetCurrentMethodIndex(); { return fCurrentMethodIdx; }. IMethod* GetLastMethod(); { return fMethods.back(); }. IMethod* GetPreviousMethod(); { return (fCurrentMethodIdx>0)?fMethods[fCurrentMethodIdx-1]:0; }. MethodBase* GetCurrentMethod(); { return fCurrentMethod;}. MethodBase* GetCurrentMethod(UInt_t idx); {return dynamic_cast<MethodBase*>(fMethods.at(idx)); }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodCompositeBase.html:19342,perform,performs,19342,root/html604/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html,1,['perform'],['performs']
Performance," the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); {}. MethodCompositeBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); {}. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. TMVA::IMethod* GetMethod(const Int_t index) const; returns pointer to MVA that corresponds to given method index. void AddWeightsXMLTo(void* parent) const. ~MethodCompositeBase( void ); delete methods. void ReadWeightsFromXML(void* wghtnode); XML streamer. void ReadWeightsFromStream(istream& istr); text streamer. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return composite MVA response. MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). void Train(); performs classifier training. const Ranking* CreateRanking(); create ranking. void DeclareOptions(). void ProcessOptions(). UInt_t GetCurrentMethodIndex(); { return fCurrentMethodIdx; }. IMethod* GetLastMethod(); { return fMethods.back(); }. IMethod* GetPreviousMethod(); { return (fCurrentMethodIdx>0)?fMethods[fCurrentMethodIdx-1]:0; }. MethodBase* GetCurrentMethod(); { return fCurrentMethod;}. MethodBase* GetCurrentMethod(UInt_t idx); {return dynamic_cast<MethodBase*>(fMethods.at(idx)); }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCompositeBase.html:19334,perform,performs,19334,root/html602/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCompositeBase.html,1,['perform'],['performs']
Performance," the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:83384,cache,cache,83384,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance," the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:4488,cache,cache,4488,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,3,['cache'],['cache']
Performance," the X value corresponding to the function value fy for (xmin<x<xmax).Definition BrentRootFinder.cxx:66; ROOT::Math::BrentRootFinder::Rootdouble Root() const overrideReturns root value.Definition BrentRootFinder.h:98; ROOT::Math::BrentRootFinder::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentRootFinder.h:89; ROOT::Math::BrentRootFinder::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentRootFinder.h:95; ROOT::Math::ChebyshevPolDefinition ChebyshevPol.h:129; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::Functor1DFunctor1D class for one-dimensional functions.Definition Functor.h:95; ROOT::Math::GaussIntegratorUser class for performing function integration.Definition GaussIntegrator.h:40; ROOT::Math::GaussIntegrator::Errordouble Error() const overrideReturn the estimate of the absolute Error of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:157540,perform,performing,157540,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['perform'],['performing']
Performance," the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = copy.fDestruct;; 570 fConstruct = copy.fConstruct;; 571 fFeed = copy.fFeed;; 572 fCollect = copy.fCollect;; 573 fCreateEnv.call = copy.fCreateEnv.call;; 574 fValOffset = copy.fValOffset;; 575 fValDiff = copy.fValDiff;; 576 fValue = copy.fValue.load(std::memory_order_relaxed) ? new Value(*copy.fValue) : 0;; 577 fVal = copy.fVal ? new Value(*copy.fVal) : 0;; 578 fKey = copy.fKey ? new Value(*copy.fKey) : 0;; 579 fOnFileClass = copy.fOnFileClass;; 580 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 581 fConversionReadMemberWise = 0;; 582 fWriteMemberWise = 0;; 583 fProperties = copy.fProperties;; 584 fFunctionCreateIterators = copy.fFunctionCreateIterators;; 585 fFunctionCopyIterator = copy.fFunctionCopyIterator;; 586 fFunctionNextIterator = copy.fFunctionNextIterator;; 587 fFunctionDeleteIterator = copy.fFunctionDeleteIterator;; 588 fFunctionDeleteTwoIterators = copy.fFunctionDeleteTwoIterators;; 589}; 590 ; 591////////////////////////////////////////////////////////////////////////////////; 592/// Build a proxy for a collection whose type is described by 'collectionClass'.; 593 ; 594TGenCollectionProxy::TGenCollectionProxy(Info_t info, size_t iter_size); 595 : TVirtualCollectionProxy(0),; 596 fTypeinfo(info); 597{; 598 fEnv = 0;; 599",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:17405,load,load,17405,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance," the binomial distribution hence the error on f can be estimated (same error as the binomial error for efficiency calculations \( (\sigma = \sqrt{\frac{(eff(1-eff)}{nEvts}}) \) ; Definition at line 219 of file ExpectedErrorPruneTool.cxx. ◆ GetSubTreeError(). Double_t TMVA::ExpectedErrorPruneTool::GetSubTreeError ; (; DecisionTreeNode * ; node); const. private . calculate the expected statistical error on the subtree below ""node"" which is used in the expected error pruning ; Definition at line 193 of file ExpectedErrorPruneTool.cxx. ◆ Log(). MsgLogger & TMVA::ExpectedErrorPruneTool::Log ; (; ); const. inlineprivate . Definition at line 78 of file ExpectedErrorPruneTool.h. ◆ SetPruneStrengthIncrement(). void TMVA::ExpectedErrorPruneTool::SetPruneStrengthIncrement ; (; Double_t ; dalpha). inline . Definition at line 65 of file ExpectedErrorPruneTool.h. Member Data Documentation. ◆ fDeltaPruneStrength. Double_t TMVA::ExpectedErrorPruneTool::fDeltaPruneStrength. private . ! the stepsize for optimizing the pruning strength parameter ; Definition at line 73 of file ExpectedErrorPruneTool.h. ◆ fLogger. MsgLogger* TMVA::ExpectedErrorPruneTool::fLogger. mutableprivate . ! message logger ; Definition at line 77 of file ExpectedErrorPruneTool.h. ◆ fNodePurityLimit. Double_t TMVA::ExpectedErrorPruneTool::fNodePurityLimit. private . ! the purity limit for labelling a terminal node as signal ; Definition at line 74 of file ExpectedErrorPruneTool.h. ◆ fPruneSequence. std::vector<DecisionTreeNode*> TMVA::ExpectedErrorPruneTool::fPruneSequence. private . ! the (optimal) prune sequence ; Definition at line 75 of file ExpectedErrorPruneTool.h. Libraries for TMVA::ExpectedErrorPruneTool:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/ExpectedErrorPruneTool.h; tmva/tmva/src/ExpectedErrorPruneTool.cxx. TMVAExpectedErrorPruneTool. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html:5488,optimiz,optimizing,5488,doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,1,['optimiz'],['optimizing']
Performance," the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:119954,cache,cache,119954,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['cache'],['cache']
Performance," the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the TGeoManager corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; 18.5.6 Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also allowed to access it. This works on any stack principle by using PUSH and POP calls and user code is responsible for popping the pushed states in order to keep the stack clean.; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:981558,perform,performed,981558,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance," the callable is applied to must be exactly T. Example usage together with RDataFrame (""varX"" columns must all be float variables): bool myVecFunc(std::vector<float> args);; df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});. Definition at line 103 of file RDFHelpers.hxx. ◆ RunGraphs(). unsigned int ROOT::RDF::RunGraphs ; (; std::vector< RResultHandle > ; handles). Trigger the event loop of multiple RDataFrames concurrently. ; Parameters. [in]handlesA vector of RResultHandles . ReturnsThe number of distinct computation graphs that have been processed; This function triggers the event loop of all computation graphs which relate to the given RResultHandles. The advantage compared to running the event loop implicitly by accessing the RResultPtr is that the event loops will run concurrently. Therefore, the overall computation of all results is generally more efficient. It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ROOT::RDataFrame df1(""tree1"", ""file1.root"");; auto r1 = df1.Histo1D(""var1"");; ; ROOT::RDataFrame df2(""tree2"", ""file2.root"");; auto r2 = df2.Sum(""var2"");; ; // RResultPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:14125,concurren,concurrently,14125,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['concurren'],['concurrently']
Performance," the clipboard.; A subsequent paste operation will insert the contents of the; clipboard at the current cursor location. Text Search. The editor uses a standard Search dialog. You can specify a forward; or backward search direction starting from the current cursor; location according to the selection made of a case sensitive mode; or not. The last search can be repeated by pressing F3. Text Font. You can change the text font by selecting Edit menu / Set Font.; The Font Dialog pops up and shows the Name, Style, and Size of any; available font. The selected font sample is shown in the preview; area. Executing Macros. You can execute the currently loaded macro in the editor by; selecting Tools menu / Execute Macro; by clicking on the; corresponding toolbar button, or by using Ctrl+F5 accelerator keys.; This is identical to the command "".x macro.C"" in the root prompt; command line. Compiling Macros. The currently loaded macro can be compiled with ACLiC if you select; Tools menu / Compile Macro; by clicking on the corresponding; toolbar button, or by using Ctrl+F7 accelerator keys.; This is identical to the command "".L macro.C++"" in the root prompt; command line. Interrupting a Running Macro. You can interrupt a running macro by selecting the Tools menu /; Interrupt; by clicking on the corresponding toolbar button, or by; using Shift+F5 accelerator keys. Interface to CINT Interpreter. Any command entered in the Command combo box will be passed to; the CINT interpreter. This combo box will keep the commands history; and will allow you to re-execute the same commands during an editor; session. Keyboard Bindings. The following table lists the keyboard shortcuts and accelerator; keys. Key: Action:. Up Move cursor up.; Shift+Up Move cursor up and extend selection.; Down Move cursor down.; Shift+Down Move cursor down and extend selection.; Left Move cursor left.; Shift+Left Move cursor left and extend selection.; Right Move cursor right.; Shift+Right Move cursor right and exten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEditor.html:2729,load,loaded,2729,root/html528/TGTextEditor.html,https://root.cern,https://root.cern/root/html528/TGTextEditor.html,6,['load'],['loaded']
Performance," the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20;; palette[2] = 23;; palette[3] = 30;; palette[4] = 32;; gStyle->SetPalette(5,palette);; f1->Draw(""colz"");; return c1;; }; To define more a complexe palette with a continous gradient of color, one; should use the static function TColor::CreateGradientColorTable().; The following example demostrates how to proceed:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",0,0,600,400);; TF2 *f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; UInt_t Number = 3;; Double_t Red[Number] = { 1.00, 0.00, 0.00};; Double_t Green[Number] = { 0.00, 1.00, 0.00};; Double_t Blue[Number] = { 1.00, 0.00, 1.00};; Double_t Length[Number] = { 0.00, 0.50, 1.00 };; Int_t nb=50;; TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; f2->SetContour(nb);; f2->Draw(""surf1z"");; return c2;; }; The function TColor::CreateGradientColorTable() performs automatically; a call to gStyle->SetPalette(). So there is not need to add one. After a call to TColor::CreateGradientColorTable() it is sometimes; useful to store the newly create palette for further use. In particular, it is; recomended to do if one wants to switch between several user define palettes.; To store a palette in an array it is enough to do:. Int_t MyPalette[100];; Double_t r[] = {0., 0.0, 1.0, 1.0, 1.0};; Double_t g[] = {0., 0.0, 0.0, 1.0, 1.0};; Double_t b[] = {0., 1.0, 0.0, 0.0, 1.0};; Double_t stop[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, stop, r, g, b, 100);; for (int i=0;i<100;i++) MyPalette[i] = FI+i;. Later on to reuse the palette MyPalette it will be enough to do. gStyle->SetPalette(100, MyPalette);. As only one palette is active, one need to use TExec to be able to; display plots using differents palettes on the same pad.; The following macro illust",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TColor.html:5193,perform,performs,5193,root/html528/TColor.html,https://root.cern,https://root.cern/root/html528/TColor.html,2,['perform'],['performs']
Performance," the common abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue') ;  CRooAbsRootFinderRooAbsRootFinder is the abstract interface for finding roots of real-valued 1-dimensional function that implements the RooAbsFunc interface ;  CRooAbsSelfCachedPdfRooAbsSelfCachedPdf is an abstract base class for probability density functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsSelfCachedRealRooAbsSelfCachedReal is an abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsStringRooAbsString is the common abstract base class for objects that represent a string value ;  CRooAbsStudyRooAbsStudy is an abstract base class for RooStudyManager modules ;  CRooAbsTestStatisticRooAbsTestStatistic is the abstract base class for all test statistics ;  CRooAcceptRejectClass RooAcceptReject is a generic toy monte carlo generator implement the accept/reject sampling technique on any positively valued function ;  CRooAdaptiveGaussKronrodIntegrator1DRooAdaptiveGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooAdaptiveIntegratorNDRooAdaptiveIntegratorND implements an adaptive one-dimensional numerical integration algorithm ;  CRooAddGenContextRooAddGenContext is an efficient implementation of the generator context specific for RooAddPdf PDFs ;  ►CRooAdditionRooAddition calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets ;  CCacheElemIterator over set ;  ►CRooAddModel;  CCacheElemTransiet cache with transformed values of coefficients ;  CIntCacheElem;  ►CRooAddPdfRooAddPdf is an efficient implementation of a sum of PDFs of the form ;  CCacheElemTransiet cache with transformed values of coefficients ;  CRooAICRegistryRooAICRegistry is a utility class for operator p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:103761,cache,cache,103761,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['cache'],['cache']
Performance," the covariance matrix from the fit. These pointers should be retrieved from the; 2724/// previously performed fit using the TFitResult class.; 2725/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 2752///; 2753/// The user must pass a pointer to the elements of the full covariance matrix; 2754/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2755/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2756/// shown ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:103467,multi-thread,multi-threading,103467,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance," the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:20037,cache,cache,20037,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance," the current directory. The input; // data file will be downloaded here if not present yet, then it will be read; // from the cache path directly.; TFile::SetCacheFileDir(""."");; std::unique_ptr<TFile> input{TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"")};; if (!input || input->IsZombie()) {; throw std::runtime_error(""ERROR: could not open data file"");; }; std::cout << ""--- TMVAClassification : Using input file: "" << input->GetName() << std::endl;; ; // Register the training and test trees; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVAC.root"");; std::unique_ptr<TFile> outputFile{TFile::Open(outfileName, ""RECREATE"")};; if (!outputFile || outputFile->IsZombie()) {; throw std::runtime_error(""ERROR: could not open output file"");; }; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory is; // the only TMVA object you have to interact with; //; // The first argument is the base of the name of all the; // weightfiles in the directory weight/; //; // The second argument is the output file for the training results; // All TMVA output can be suppressed by removing the ""!"" (not) in; // front of the ""Silent"" argument in the option string; auto factory = std::make_unique<TMVA::Factory>(; ""TMVAClassification"", outputFile.get(),; ""!V:!Silent:Color:DrawProgressBar:Transformations=I;D;P;G,D:AnalysisType=Classification"");; auto dataloader_raii = std::make_unique<TMVA::DataLoader>(""dataset"");; auto *dataloader = dataloader_raii.get();; // If you wish to modify default settings; // (please check ""src/Config.h"" to see all available global options); //; // (TMVA::gConfig().GetVariablePlotting()).fTimesRMS = 8.0;; // (TMVA::gConfig().GetIONames()).fWeightFileDir = ""myWeightDirectory"";; ; // Define the input variables that shall be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:85915,perform,performance,85915,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance," the dataset is not verified.; If 'opts' contains 'T' the in the dataset object (status bits, meta,...); is trusted, i.e. not reset (if the dataset manager is configured to allow so).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. TMap * GetDataSets(const char* uri = """", const char* optStr = """"); Lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* optStr = """"); Shows datasets in locations that match the uri.; By default shows the user's datasets and global ones. Bool_t ExistsDataSet(const char* dataset); Returns kTRUE if 'dataset' exists, kFALSE otherwise. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). TFileCollection * GetDataSet(const char* dataset, const char* optStr = """"); Get a list of TFileInfo objects describing the files of the specified; dataset.; To get the short version (containing only the global meta information); specify optStr = ""S:"" or optStr = ""short:"".; To get the sub-dataset of files located on a given server(s) specify; the list of servers (comma-separated) in the 'optStr' field. void ShowDataSet(const char* dataset = """", const char* opt = ""M""); display meta-info for given dataset usi. Int_t RemoveDataSet(const char* dataset, const char* optStr = """"); Remove the specified dataset from the PROOF cluster.; Files are not deleted. TList* FindDataSets(const char* searchString, const char* optStr = """"); Find datasets, returns in a TList all found datasets. Int_t VerifyDataSet(const char* dataset, const char* optStr = """"); Verify if all files in the specified dataset are available.; Print a list and return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:81502,cache,cache,81502,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['cache'],['cache']
Performance," the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetTimeInt_t GetTime() constReturn time in form of 123623 (i.e. 12:36:23)Definition TDatime.cxx:259; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoTessellated::ImportFromObjFormatstatic TGeoTessellated * ImportFromObjFormat(const char *objfile, bool check=false, bool verbose=false)Reader from .obj format.Definition TGeoTessellated.cxx:579; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::Raytracevoid Raytrace(Bool_t flag=kTRUE)Draw this volume with current settings and perform raytracing in the pad.Definition TGeoVolume.cxx:1427; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tessellatedNav_8C.html:4072,perform,perform,4072,doc/master/tessellatedNav_8C.html,https://root.cern,https://root.cern/doc/master/tessellatedNav_8C.html,1,['perform'],['perform']
Performance," the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetDynamicPath() overrideReturn the dynamic path (used to find shared libraries).Definition TUnixSystem.cxx:4738; TUnixSystem::OpenPipeFILE * OpenPipe(const char *shellcmd, const char *mode) overrideOpen a pipe.Definition TUnixSystem.cxx:2163; TUnixSystem::FreeDirectoryvoid FreeDirectory(void *dirp) overrideClose a Unix file system directory.Definition TUnixSystem.cxx:1404; TUnixSystem::UnixResetSignalsstatic void UnixResetSignals()Restore old signal handlers.Definition TUnixSystem.cxx:3836; TUnixSystem::GetCpuInfoint GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) const overrideReturns cpu load average and load info into the CpuInfo_t structure.Definition TUnixSystem.cxx:5344; TUnixSystem::AddSignalHandlervoid AddSignalHandler(TSignalHandler *sh) overrideAdd a signal handler to list of system signal handlers.Definition TUnixSystem.cxx:837; TUnixSystem::UnixOpendirstatic void * UnixOpendir(const char *name)Open a directory.Definition TUnixSystem.cxx:3984; TUnixSystem::SendRawint SendRaw(int sock, const void *buffer, int length, int flag) overrideSend exactly length bytes from buffer.Definition TUnixSystem.cxx:3405; TUnixSystem::WorkingDirectoryconst char * WorkingDirectory() overrideReturn working directory.Definition TUnixSystem.cxx:1445; TUnixSystem::GetSockOptint GetSockOpt(int sock, int option, int *val) overrideGet socket option.Definition TUnixSystem.cxx:3507; TUnixSystem::FindDynamicLibraryconst char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE) overrideReturns the path of a shared library (searches for library in the shared l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:220010,load,load,220010,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,4,['load'],['load']
Performance," the enum type.; 4420 std::string buf;; 4421 PrintingPolicy Policy(ED->getASTContext().getPrintingPolicy());; 4422 llvm::raw_string_ostream stream(buf);; 4423 // Don't trigger fopen of the source file to count lines:; 4424 Policy.AnonymousTagLocations = false;; 4425 ED->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);; 4426 stream.flush();; 4427 // If the enum is unnamed we do not add it to the list of enums i.e unusable.; 4428 if (!buf.empty()) {; 4429 const char* name = buf.c_str();; 4430 // Add the enum to the list of loaded enums.; 4431 enumList.Get(ED, name);; 4432 }; 4433 }; 4434 }; 4435 }; 4436 }; 4437}; 4438 ; 4439////////////////////////////////////////////////////////////////////////////////; 4440/// Create list of pointers to function templates for TClass cl.; 4441 ; 4442void TCling::LoadFunctionTemplates(TClass* cl) const; 4443{; 4444 R__LOCKGUARD(gInterpreterMutex);; 4445 ; 4446 const Decl * D;; 4447 TListOfFunctionTemplates* funcTempList;; 4448 if (cl) {; 4449 D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();; 4450 funcTempList = (TListOfFunctionTemplates*)cl->GetListOfFunctionTemplates(false);; 4451 }; 4452 else {; 4453 D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 4454 funcTempList = (TListOfFunctionTemplates*)gROOT->GetListOfFunctionTemplates();; 4455 }; 4456 // Iterate on the decl of the class and get the enums.; 4457 if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {; 4458 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 4459 // Collect all contexts of the namespace.; 4460 llvm::SmallVector< DeclContext *, 4> allDeclContexts;; 4461 const_cast< clang::DeclContext *>(DC)->collectAllContexts(allDeclContexts);; 4462 for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(),; 4463 declEnd = allDeclContexts.end(); declIter != declEnd; ++declIter) {; 4464 // Iterate on all decls for each context.; 4465 for (clang::DeclContext::decl_iterator DI = (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:172522,Load,LoadFunctionTemplates,172522,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadFunctionTemplates']
Performance," the existing classes are replaced with the new definition. If the directory does not exist, it creates it as in “new”.; “+”: This option can be used in combination with the other three. It will create the necessary files to easily build a shared library containing the class definitions.Specifically it will:; Generate a script called MAKE that builds the shared library containing the definition of all classes in the directory.; Generate a LinkDef.hfiles to use with rootcling in MAKE.; Run rootcling to generate a <dirname>ProjectDict.cxx file.; Compile the <dirname>ProjectDict.cxxwith the current options in compiledata.h.; Build a shared library<dirname>.so.; “++”:This option can be used instead of the single “+”. It does everything the single “+” does, and dynamically loads the shared library <dirname>.so. This example makes a directory called MyProject that will contain all class definitions from the atlfast.root file. The necessary makefile to build a shared library are also created, and since the ‘++’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; Now you can load the shared library in any consecutive root session to use the atlfast classes.; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; This is an example of a generated header file:; /////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:510679,load,loaded,510679,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance," the file name (location) ;  ; static RResult< RPage > UnsealPage (const RSealedPage &sealedPage, const RColumnElementBase &element, DescriptorId_t physicalColumnId, RPageAllocator &pageAlloc);  Helper for unstreaming a page. ;  . Protected Member Functions; virtual RNTupleDescriptor AttachImpl ()=0;  LoadStructureImpl() has been called before AttachImpl() is called ;  ; virtual std::unique_ptr< RPageSource > CloneImpl () const =0;  Returns a new, unattached page source for the same data set. ;  ; void EnableDefaultMetrics (const std::string &prefix);  Enables the default set of metrics provided by RPageSource. ;  ; RExclDescriptorGuard GetExclDescriptorGuard ();  Note that the underlying lock is not recursive. See GetSharedDescriptorGuard() for further information. ;  ; virtual RPageRef LoadPageImpl (ColumnHandle_t columnHandle, const RClusterInfo &clusterInfo, ClusterSize_t::ValueType idxInCluster)=0;  ; virtual void LoadStructureImpl ()=0;  ; void PrepareLoadCluster (const RCluster::RKey &clusterKey, ROnDiskPageMap &pageZeroMap, std::function< void(DescriptorId_t, NTupleSize_t, const RClusterDescriptor::RPageRange::RPageInfo &)> perPageFunc);  Prepare a page range read for the column set in clusterKey. ;  ; virtual void UnzipClusterImpl (RCluster *cluster);  ;  Protected Member Functions inherited from ROOT::Experimental::Internal::RPageStorage; void WaitForAllTasks ();  . Protected Attributes; RActivePhysicalColumns fActivePhysicalColumns;  The active columns are implicitly defined by the model fields or views. ;  ; std::unique_ptr< RCounters > fCounters;  ; RNTupleReadOptions fOptions;  ; RPagePool fPagePool;  Pages that are unzipped with IMT are staged into the page pool. ;  ;  Protected Attributes inherited from ROOT::Experimental::Internal::RPageStorage; Detail::RNTupleMetrics fMetrics;  ; std::string fNTupleName;  ; std::unique_ptr< RPageAllocator > fPageAllocator;  For the time being, we will use the heap allocator for all sources and sinks. This may chang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:5526,Load,LoadPageImpl,5526,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,2,['Load'],"['LoadPageImpl', 'LoadStructureImpl']"
Performance," the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:38265,cache,cache,38265,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cache']
Performance," the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:160177,perform,performed,160177,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['performed']
Performance," the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeDataStore.html:17412,cache,cache,17412,root/html534/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html,6,"['cache', 'load']","['cache', 'loaded']"
Performance," the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedPdf(); {}. TObject* clone(const char* newname) const; { return new RooCachedPdf(*this,newname); }. const char* inputBaseName() const; Return the base name for cache objects, in this case the name of the cached p.d.f. D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:42992,cache,cached,42992,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,7,['cache'],['cached']
Performance," the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:37661,perform,performing,37661,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performing']
Performance," the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:39003,perform,performing,39003,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['perform'],['performing']
Performance," the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxillary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:33593,perform,performing,33593,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['perform'],['performing']
Performance," the given range. The range needs to be within [0, GetNEntries()). ; Definition at line 180 of file RPageStorage.cxx. ◆ UnsealPage() [1/2]. ROOT::Experimental::RResult< ROOT::Experimental::Internal::RPage > ROOT::Experimental::Internal::RPageSource::UnsealPage ; (; const RSealedPage & ; sealedPage, . const RColumnElementBase & ; element, . DescriptorId_t ; physicalColumnId . ). Definition at line 480 of file RPageStorage.cxx. ◆ UnsealPage() [2/2]. ROOT::Experimental::RResult< ROOT::Experimental::Internal::RPage > ROOT::Experimental::Internal::RPageSource::UnsealPage ; (; const RSealedPage & ; sealedPage, . const RColumnElementBase & ; element, . DescriptorId_t ; physicalColumnId, . RPageAllocator & ; pageAlloc . ). static . Helper for unstreaming a page. ; This is commonly used in derived, concrete page sources. The implementation currently always makes a memory copy, even if the sealed page is uncompressed and in the final memory layout. The optimization of directly mapping pages is left to the concrete page source implementations. ; Definition at line 487 of file RPageStorage.cxx. ◆ UnzipCluster(). void ROOT::Experimental::Internal::RPageSource::UnzipCluster ; (; RCluster * ; cluster). Parallel decompression and unpacking of the pages in the given cluster. ; The unzipped pages are supposed to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set if implicit multi-threading is turned on. ; Definition at line 224 of file RPageStorage.cxx. ◆ UnzipClusterImpl(). void ROOT::Experimental::Internal::RPageSource::UnzipClusterImpl ; (; RCluster * ; cluster). protectedvirtual . Definition at line 230 of file RPageStorage.cxx. Member Data Documentation. ◆ fActivePhysicalColumns. RActivePhysicalColumns ROOT::Experimental::Internal::RPag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:19907,optimiz,optimization,19907,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['optimiz'],['optimization']
Performance," the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:140331,load,load,140331,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance," the global lock at all).; 3748///; 3749/// In the case the TClass represents a class or struct and requestListLoading; 3750/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3751/// which will implicit take the ROOT global lock upon any access.; 3752 ; 3753TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3754{; 3755 auto temp = fEnums.load();; 3756 if (temp) {; 3757 if (requestListLoading) {; 3758 if (fProperty == -1) Property();; 3759 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3760 R__LOCKGUARD(gROOTMutex);; 3761 temp->Load();; 3762 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3763 // We have a class for which the list was not loaded fully at; 3764 // first use.; 3765 R__LOCKGUARD(gROOTMutex);; 3766 temp->Load();; 3767 }; 3768 }; 3769 return temp;; 3770 }; 3771 ; 3772 if (!requestListLoading) {; 3773 if (fProperty == -1) Property();; 3774 R__LOCKGUARD(gInterpreterMutex);; 3775 if (fEnums.load()) {; 3776 return fEnums.load();; 3777 }; 3778 ; 3779 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3780 fEnums = new TListOfEnums(this);; 3781 else; 3782 fEnums = new TListOfEnumsWithLock(this);; 3783 return fEnums;; 3784 }; 3785 ; 3786 R__LOCKGUARD(gInterpreterMutex);; 3787 if (fEnums.load()) {; 3788 (*fEnums).Load();; 3789 return fEnums.load();; 3790 }; 3791 if (fProperty == -1) Property();; 3792 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3793 // For this case, the list will be immutable; 3794 temp = new TListOfEnums(this);; 3795 } else {; 3796 //namespaces can have enums added to them; 3797 temp = new TListOfEnumsWithLock(this);; 3798 }; 3799 temp->Load();; 3800 fEnums = temp;; 3801 return temp;; 3802}; 3803 ; 3804////////////////////////////////////////////////////////////////////////////////; 3805/// Create the list containing the TDataMembers (of actual data members or members; 3806/// pulled in through using declarations) of a cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:143082,load,load,143082,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance," the interpreter; 560 normCtxt = &( (TCling*) gInterpreter)->GetNormalizedContext();; 561}; 562 ; 563extern ""C""; 564void TCling__UpdateListsOnCommitted(const cling::Transaction &T, cling::Interpreter*) {; 565 ((TCling*)gCling)->UpdateListsOnCommitted(T);; 566}; 567 ; 568extern ""C""; 569void TCling__UpdateListsOnUnloaded(const cling::Transaction &T) {; 570 ((TCling*)gCling)->UpdateListsOnUnloaded(T);; 571}; 572 ; 573extern ""C""; 574void TCling__InvalidateGlobal(const clang::Decl *D) {; 575 ((TCling*)gCling)->InvalidateGlobal(D);; 576}; 577 ; 578extern ""C""; 579void TCling__TransactionRollback(const cling::Transaction &T) {; 580 ((TCling*)gCling)->TransactionRollback(T);; 581}; 582 ; 583extern ""C"" void TCling__LibraryLoadedRTTI(const void* dyLibHandle,; 584 const char* canonicalName) {; 585 ((TCling*)gCling)->LibraryLoaded(dyLibHandle, canonicalName);; 586}; 587 ; 588extern ""C"" void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 589{; 590 ((TCling *)gCling)->RegisterRdictForLoadPCM(pcmFileNameFullPath, pcmContent);; 591}; 592 ; 593extern ""C"" void TCling__LibraryUnloadedRTTI(const void* dyLibHandle,; 594 const char* canonicalName) {; 595 ((TCling*)gCling)->LibraryUnloaded(dyLibHandle, canonicalName);; 596}; 597 ; 598 ; 599extern ""C""; 600TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx) {; 601 return ((TCling*)gCling)->GetObjectAddress(Name, LookupCtx);; 602}; 603 ; 604extern ""C"" const Decl* TCling__GetObjectDecl(TObject *obj) {; 605 return ((TClingClassInfo*)obj->IsA()->GetClassInfo())->GetDecl();; 606}; 607 ; 608extern ""C"" R__DLLEXPORT TInterpreter *CreateInterpreter(void* interpLibHandle,; 609 const char* argv[]); 610{; 611 auto tcling = new TCling(""C++"", ""cling C++ Interpreter"", argv, interpLibHandle);; 612 ; 613 return tcling;; 614}; 615 ; 616extern ""C"" R__DLLEXPORT void DestroyInterpreter(TInterpreter *interp); 617{; 618 delete interp;; 619}; 620 ; 621// Load library containing specified class.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:22094,Load,Load,22094,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['Load']
Performance," the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* receiver) const; Interface to CINT function. int GetSecurityError() const; Interface to CINT function. int LoadFile(const char* path) const; Interface to CINT function. void LoadText(const char* text) const; Interface to CINT function. const char * MapCppName(const char* ) const; Interface to CINT function. void SetAlloclockfunc(void (*)() ) const; Interface to CINT function. void SetAllocunlockfunc(void (*)() ) const; Interface to CINT function. int SetClassAutoloading(int ) const; Interface to CINT function. void SetErrmsgcallback(void* p) const; Interface to CINT function. void Setgvp(Long_t ) const; Interface to CINT function. void SetRTLD_NOW() const; Interface to CINT function. void SetRTLD_LAZY() const; Interface to CINT function. void SetTempLevel(int val) const; Interface to CINT function. int UnloadFile(const char* path) const; Interface to CINT function. void CallFunc_Delete(void* func) const; Interface to CINT function. void CallFunc_Exec(CallFunc_t* func, void* address) const; Interface to CINT function. Long_t CallFunc_ExecInt(CallFunc_t* func, void* address) const; Interface to CINT function. Long64_t CallFunc_ExecInt64(CallFunc_t* func, void* address) const; Interface",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:33310,Load,LoadText,33310,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Load'],['LoadText']
Performance," the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* receiver) const; Interface to CINT function. int GetSecurityError() const; Interface to CINT function. int LoadFile(const char* path) const; Interface to CINT function. void LoadText(const char* text) const; Interface to CINT function. const char * MapCppName(const char* ) const; Interface to CINT function. void SetAlloclockfunc(void (*)() ) const; Interface to CINT function. void SetAllocunlockfunc(void (*)() ) const; Interface to CINT function. int SetClassAutoloading(int ) const; Interface to CINT function. void SetErrmsgcallback(void* p) const; Interface to CINT function. void Setgvp(Long_t ) const; Interface to CINT function. void SetRTLD_NOW() const; Interface to CINT function. void SetRTLD_LAZY() const; Interface to CINT function. void SetTempLevel(int val) const; Interface to CINT function. int UnloadFile(const char* path) const; Interface to CINT function. void CallFunc_Delete(void* func) const; Interface to CINT function. void CallFunc_Exec(CallFunc_t* func, void* address) const; Interface to CINT function. Long_t CallFunc_ExecInt(CallFunc_t* func, void* address) const; Interface to CINT function. Long_t CallFunc_ExecInt64(CallFunc_t* func, void* address) const; Interface t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:31636,Load,LoadText,31636,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,4,['Load'],['LoadText']
Performance," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_double_.html:6560,optimiz,optimized,6560,root/html528/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_double_.html,12,['optimiz'],['optimized']
Performance," the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:57008,perform,performing,57008,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['perform'],['performing']
Performance," the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:54428,perform,performing,54428,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['perform'],['performing']
Performance," the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:56208,perform,performing,56208,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['perform'],['performing']
Performance," the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsrel, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility; It is reccomended to use the other interface where one can specify also epsabs and the maximum number of; points. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t& relerr, Int_t& nfnevl, Int_t& ifail). This function computes, to an attempted specified accuracy, the value of; the integral. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; maxpts: Maximum number of function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:58787,perform,performing,58787,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['perform'],['performing']
Performance," the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|16|16"" [The Layout of the input]; : Layout: ""CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =============================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:6850,Optimiz,Optimizer,6850,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance," the letters R, O and T. Why one have to define so many volumes to make an R?”; A: Well, in real life some objects have much more complex shapes that an R. The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called primitive shapes). Gluing these together in the appropriate way is the user responsibility.; Q: “I am getting the global picture but not making much out of it… There are also a lot of calls to TGeoVolume::AddNode() that I do not understand.”; A: A volume is positioned inside another one by using this method. The relative geometrical transformation as well as a copy number must be specified. When positioned, a volume becomes a node of its container and a new object of the class TGeoNode is automatically created. This method is therefore the key element for the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw()call for the top volume. These are explained in details in the section “Visualization Settings and Attributes”. At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:882349,perform,performing,882349,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performing']
Performance," the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; I#define I(x, y, z); Note: The method T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:134602,perform,performed,134602,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performed']
Performance," the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; Note: The method TGeoManager::FindNextB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1030270,perform,performed,1030270,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance," the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in ROOT::Math::VirtualIntegratorOneDim and ROOT::Math::VirtualIntegratorMultiDim. These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance. These methods must be implemented in the concrete classes existing for the different integration algorithms. The user cannot create directly these virtual integrator interfaces. He needs to create the ROOT::Math::IntegratorOneDim class for integrating one-dimensional functions and ROOT::Math::IntegratorMultiDim for multi-dimensional functions. Through the ROOT Plug-In Manager, the user can initialize ROOT::Math::IntegratorOneDim or ROOT::Math::IntegratorMultiDim with any of the concrete integration classes without dealing with them directly. These two classes provide the same interface as in VirtualIntegratorOneDim and VirtualIntegratorMultiDim, but with the possibility to choose in the constructor, which method will be used to perform the integration.; The method to set the function to be integrated, must be of the function interface type described before. ROOT::Math::IBaseFunctionOneDimFunction is used for ROOT::Math::IBaseFunctionMultiDim and The only difference between the ROOT::Math::IntegratorOneDim and ROOT::Math::IntegratorMultiDim resides in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ROOT::Math Numerical Integrator classes. The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important to notice that the two grayed classes (the one which name starts by GSL) are part of the MathMore library. We will later show in more detail the differences between the implementations.; 13.8.1 Integration of One-dimensional Functions; 13.8.1.1 Using ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:700933,perform,perform,700933,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance," the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, double** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, double* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, double* a, int* index, double& min, double& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, double* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(double* range = 0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKDTree_int_double_.html:22236,perform,performed,22236,root/html602/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html602/TKDTree_int_double_.html,2,['perform'],['performed']
Performance," the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, double** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, double* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, double* a, int* index, double& min, double& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, double* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(double* range = 0x0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_double_.html:21525,perform,performed,21525,root/html528/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_double_.html,4,['perform'],['performed']
Performance," the old one that the mouse has left. ;  ; virtual void Clicked (TObject *obj);  Emit Clicked signal. ;  ; virtual void Clicked (TObject *obj, UInt_t button, UInt_t state);  Emit Clicked signal with button id and modifier state. ;  ; void CloseComposite () override;  ; TGLColorSet & ColorSet ();  ; TGLCamera & CurrentCamera () const;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Calculate and return pixel distance to nearest viewer object from window location px, py This is provided for use when embedding GL viewer into pad. ;  ; void DoDraw (Bool_t swap_buffers=kTRUE);  Draw out the viewer. ;  ; void DoDrawMono (Bool_t swap_buffers);  Draw out in monoscopic mode. ;  ; void DoDrawStereo (Bool_t swap_buffers);  Draw out in stereoscopic mode. ;  ; Bool_t DoOverlaySelect (Int_t x, Int_t y);  Perform GL selection, picking overlay objects only. ;  ; Bool_t DoSecondarySelect (Int_t x, Int_t y);  Secondary selection. ;  ; Bool_t DoSelect (Int_t x, Int_t y);  Perform GL selection, picking objects overlapping WINDOW area described by 'rect'. ;  ; virtual void DoubleClicked ();  ; void DrawDebugInfo ();  If in debug mode draw camera aids and overall bounding box. ;  ; void DrawGuides ();  Draw reference marker and coordinate axes. ;  ; void EndScene () override;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Process event of type 'event' - one of EEventType types, occurring at window location px, py This is provided for use when embedding GL viewer into pad. ;  ; TGLAutoRotator * GetAutoRotator ();  Get the auto-rotator for this viewer. ;  ; TGLCameraOverlay * GetCameraOverlay () const;  ; Bool_t GetClipAutoUpdate () const;  ; TGLClipSet * GetClipSet () const;  ; TGLOverlayElement * GetCurrentOvlElm () const;  ; Int_t GetDev () const;  ; EDragAction GetDragAction () const;  ; Bool_t GetDrawCameraCenter ();  ; TGEventHandler * GetEventHandler () const;  ; Float_t GetFader () const;  ; TGedEditor * GetGedEditor () const;  ; TGLWidget * GetGLWidg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:3397,Perform,Perform,3397,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,2,['Perform'],['Perform']
Performance," the one above are distributed with ROOT under the $ROOTSYS/tutorials directory.; # Example: displaying a ROOT histogram from Python; from ROOT import gRandom,TCanvas,TH1F. c1 = TCanvas('c1','Example',200,10,700,500); hpx = TH1F('hpx','px',100,-4,4). for i in xrange(25000):; px = gRandom.Gaus(); hpx.Fill(px). hpx.Draw(); c1.Update(); 19.1.3 Access to Python from ROOT; Access to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to buil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1045639,load,loaded,1045639,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance," the p.d.f cache. The default buffer size is 10% of the; observable domain size and can be changed with setBufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; is evaluated for a particular value of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', followin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:2806,perform,performance,2806,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['perform'],['performance']
Performance," the population; TLatex pupulationRef(-128, 27, ""#scale[.55]{#splitline{Source:}{http://eadiv.state.wy.us/pop/st-09est.htm}}"");; pupulationRef.DrawClone();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyUSA_8C.html:3721,cache,cacheDir,3721,doc/master/th2polyUSA_8C.html,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html,2,['cache'],"['cache', 'cacheDir']"
Performance," the processed column values in each processing slot. ;  ; RResultPtr< U > Aggregate (AccFun aggregator, MergeFun merger, std::string_view columnName="""");  Execute a user-defined accumulation operation on the processed column values in each processing slot. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Alias (std::string_view alias, std::string_view columnName);  Allow to refer to a column with a different name. ;  ; RResultPtr< typename std::decay_t< Helper >::Result_t > Book (Helper &&helper, const ColumnNames_t &columns={});  Book execution of a custom action using a user-defined helper object. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::initializer_list< std::string > columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::string_view columnNameRegexp="""");  Save selected columns in memory. ;  ; RResultPtr< ULong64_t > Count ();  Return the number of entries processed (lazy action). ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefaultValueFor (std::string_view column, const T &defaultValue);  In case the value in the given column is missing, provide a default value. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, F expression, const ColumnNames_t &columns={});  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, std::string_view expression);  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefinePerSample (std::string_view name, F expression);  Define a new column that is updated when the input sample changes. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefinePerSample (std::string_view name, std::string_view expression);  Define a new column that is updated when the input sample changes. ;  ; RInterface< ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:94782,Cache,Cache,94782,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['Cache'],['Cache']
Performance," the processed column values in each processing slot. ;  ; RResultPtr< U > Aggregate (AccFun aggregator, MergeFun merger, std::string_view columnName="""");  Execute a user-defined accumulation operation on the processed column values in each processing slot. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Alias (std::string_view alias, std::string_view columnName);  Allow to refer to a column with a different name. ;  ; RResultPtr< typename std::decay_t< Helper >::Result_t > Book (Helper &&helper, const ColumnNames_t &columns={});  Book execution of a custom action using a user-defined helper object. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::initializer_list< std::string > columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::string_view columnNameRegexp="""");  Save selected columns in memory. ;  ; RResultPtr< ULong64_t > Count ();  Return the number of entries processed (lazy action). ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, F expression, const ColumnNames_t &columns={});  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, std::string_view expression);  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefinePerSample (std::string_view name, F expression);  Define a new column that is updated when the input sample changes. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefinePerSample (std::string_view name, std::string_view expression);  Define a new column that is updated when the input sample changes. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefineSlot (std::string_view name, F expression, const ColumnNames_t &columns={});  Define a new column with a value dependent on the processing slot. ;  ; RIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:87982,Cache,Cache,87982,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['Cache'],['Cache']
Performance," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IGradientMultiDim.html:2145,Optimiz,Optimized,2145,root/html528/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IGradientMultiDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html:2147,Optimiz,Optimized,2147,root/html530/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IGradientMultiDim.html:2147,Optimiz,Optimized,2147,root/html532/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IGradientMultiDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance," the red, green and blue values for the component adjusted via the sliders. You can apply this adjustment to the shape itself, or to all shapes sharing a common ‘family’. Shapes of the same family have external objects with the same TObject name string. You can also adjust the ‘Opacity’ and ‘Shine’ for the shapes materials via the sliders.; 9.13.2.11 Geometry; Viewer Controls Pane ‘Geometry’ tab.; Review and modify the shapes X/Y/Z center and scaling factors via the edit boxes. Selection and editing of shapes is not available via the API at present.; 9.13.2.12 Outputting Viewer Contents; The current viewer rendering can be output to an external EPS or PDF, using the options under the ‘File’ menu on the top menu bar. The file is named ‘viewer.eps’ or ‘viewer.pdf’ and written to the current ROOT directory.; 9.13.3 The X3D Viewer; The X3D viewer is a fairly simple and limited viewer, capable of showing basic lines and polygons. It lacks the quality, performance and more advanced features of the GL Viewer, and additionally is not supported on Windows. It is not actively developed and you are encouraged to use the GL Viewer out of preference. The below table presents the main interactions - these are repeated in the Help dialog of the viewer.; Action KeyActionKey; Wireframe Mode wRotate about xx a; Hidden Line Mode eRotate about yy b; Hidden Surface Mode rRotate about zz c; Move object down uAuto-rotate about x1 2 3; Move object up iAuto-rotate about y4 5 6; Move object left lAuto-rotate about z7 8 9; Move object right hToggle controls styleo; Move object forward jToggle stereo displays; Move object backward kToggle blue stereo viewd; Adjust focus (stereo mode) [ ] { }Toggle double bufferf; Rotate object Left mouse button down + move.; 9.13.4 Common 3D Viewer Architecture; The 3D Viewer Architecture provides a common mechanism for viewer clients to publish 3D objects to it. It enables:. Decoupling of producers (geometry packages etc) who model collection of 3D objects fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:400804,perform,performance,400804,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; Parameters. [in]idspecifies the window ; [in]rootwthe root window that the pointer is in ; [in]childwthe child window that the pointer is located in, if any ; [in]root_x,root_ythe pointer coordinates relative to the root window's origin ; [in]win_x,win_ythe pointer coordinates relative to the specified window ""id"" ; [in]maskthe current state of the modifier keys and pointer buttons . Reimplemented from TVirtualX.; Definition at line 3155 of file TGCocoa.mm. ◆ RaiseWindow(). void TGCocoa::RaiseWindow ; (; Window_t ; id). overridevirtual . Raises the specified window to the top of the stack so that no sibling window obscures it. ; Reimplemented from TVirtualX.; Definition at line 1214 of file TGCocoa.mm. ◆ ReadGIF(). Pixmap_t TGCocoa::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file, . Window_t ; id . ). overridevirtual . If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ; Otherwise creates pixmap from gif file ; Reimplemented from TVirtualX.; Definition at line 4044 of file TGCocoa.mm. ◆ ReadPictureDataFromFile(). Bool_t TGCocoa::ReadPictureDataFromFile ; (; const char * ; filename, . char *** ; ret_data . ). overridevirtual . Reads picture data from file ""filename"" and store it in ""ret_data"". ; Returns kTRUE in case of success, kFALSE otherwise. ; Reimplemented from TVirtualX.; Definition at line 4230 of file TGCocoa.mm. ◆ ReconfigureDisplay(). void TGCocoa::ReconfigureDisplay ; (; ). Definition at line 595 of file TGCocoa.mm. ◆ RemoveWindow(). void TGCocoa::RemoveWindow ; (; ULong_t ; qwid). overridevirtual . Removes the created by Qt window ""qwid"". ; Reimplemented from TVirtualX.; Definition at line 856 of file TGCocoa.mm. ◆ ReparentChild(). void TGCocoa::ReparentChild ; (; Window_t ; wid, . Window_t ; pid, . Int_t ; x, . Int_t ; y . ). Definition at line 1042 of file TGCocoa.mm. ◆ ReparentTopLevel(). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:106722,load,loads,106722,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['load'],['loads']
Performance," the screen changes the object in memory.; 9.2.1 Moving, Resizing and Modifying Objects; Changing the graphic objects attributes can be done with the GUI or programmatically. First, let’s see how it is done in the GUI.; 9.2.1.1 The Left Mouse Button; As was just seen moving or resizing an object is done with the left mouse button. The cursor changes its shape to indicate what may be done:; Point the object or one part of it: ; Rotate: ; Resize (exists also for the other directions): ; Enlarge (used for text): ; Move: ; Here are some examples of:; Moving: Resizing: ; Rotating: ; 9.2.1.2 With C++ Statements (Programmatically); How would one move an object in a script? Since there is a tight correspondence between what is seen on the screen and the object in memory, changing the object changes it on the screen. For example, try to do:; root[] a.SetX1(0.9); This should change one of the coordinates of our line, but nothing happens on the screen. Why is that? In short, the canvas is not updated with each change for performance reasons. See “Updating the Pad”.; 9.2.2 Selecting Objects; 9.2.2.1 The Middle Mouse Button; Objects in a canvas, as well as in a pad, are stacked on top of each other in the order they were drawn. Some objects may become “active” objects, which mean they are reordered to be on top of the others. To interactively make an object “active”, you can use the middle mouse button. In case of canvases or pads, the border becomes highlighted when it is active.; 9.2.2.2 With C++ Statements (Programmatically); Frequently we want to draw in different canvases or pads. By default, the objects are drawn in the active canvas. To activate a canvas you can use the TPad::cd() method.; root[] c1->cd(); 9.2.3 Context Menus: the Right Mouse Button; The context menus are a way to interactively call certain methods of an object. When designing a class, the programmer can add methods to the context menu of the object by making minor changes to the header file.; 9.2.3.1 Usin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:293038,perform,performance,293038,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," the sometimes very large memory requirements of logical graph expansion. The caching mechanism is triggered by the total number of physical instances of volumes and the cache manager is a client of TGeoManager. The manager class also controls the painter client. This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Rules for building a valid geometry; A given geometry can be built in various ways, but there are mandatory steps that have to be followed in order to be validated by the modeler. There are general rules : volumes needs media and shapes in order to be created, both container and containee volumes must be created before linking them together, and the relative transformation matrix must be provided. All branches must have an upper link point otherwise they will not be considered as part of the geometry. Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see TGeoPainter class) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules : positioned daughters should not extrude their mother or intersect with sisters unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume (containing all geometry tree) must be specified before closing the geometry and must not be positioned - it represents the global reference frame. After building the full geometry tree, the geometry must be closed (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after this process.; Below is the general scheme of the manager class. An interactive session; Provided that a geometry was successfully built and closed (for instance the previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register itself to ROOT and the logical/physical structures will become immediately browsable. The ROOT browser will display starting from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:14754,load,loaded,14754,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['load'],['loaded']
Performance," the string, is also stripped. In the following, we have some parameters, like tick marks length and characters height (in percentage of the length of the axis, in user coordinates). The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%; Labels offset: 1.0 %. 9.5.7.7 Stripping Decimals; Use the TStyle::SetStripDecimals to strip decimals when drawing axis labels. By default, the option is set to true, and TGaxis::PaintAxis removes trailing zeros after the dot in the axis labels, e.g. {0, 0.5, 1, 1.5, 2, 2.5, etc.}; TStyle::SetStripDecimals (Bool_t strip=kTRUE); If this function is called with strip=kFALSE, TGaxis::PaintAxis() will draw labels with the same number of digits after the dot, e.g. {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}; 9.5.7.8 Optional Grid; chopt = 'W': cross-Wire; 9.5.7.9 Axis Binning Optimization; By default, the axis binning is optimized. chopt = 'N': No binning optimization; chopt = 'I': Integer labeling. 9.5.8 Axis with Time Units; Histograms’ axis can be defined as “time axis”. To do that it is enough to activate the SetTimeDisplay attribute on a given axis. If h is a histogram, it is done the following way:; h->GetXaxis()->SetTimeDisplay(1); // X axis is a time axis; Two parameters can be adjusted in order to define time axis: the time format and the time offset.; 9.5.8.1 Time Format; It defines the format of the labels along the time axis. It can be changed using the TAxis method SetTimeFormat. The time format is the one used by the C function strftime(). It is a string containing the following formatting characters:. For the date:; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century; %Y year with century. For the time:; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. The other characters are out",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:343203,optimiz,optimization,343203,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance," the subset of the fixed observables that are actual dependents of the external input p.d.f. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Interface function to create an internal cache object that represent each cached function configuration. ;  ; double evaluate () const override;  Dummy evaluate, it is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Update contents of cache histogram by resampling the input function. ;  ; const char * inputBaseName () const override;  Return base name for caches, i.e. the name of the cached function. ;  ; void operModeHook () override;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; virtual const char * binningName () const;  ; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:50299,cache,cacheNameSuffix,50299,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],"['cache', 'cacheNameSuffix']"
Performance," the system search paths. ;  ; virtual Func_t DynFindSymbol (const char *module, const char *entry);  Find specific entry point in specified library. ;  ; virtual Int_t Exec (const char *shellcmd);  Execute a command. ;  ; virtual void Exit (int code, Bool_t mode=kTRUE);  Exit the application. ;  ; virtual void ExitLoop ();  Exit from event loop. ;  ; virtual char * ExpandPathName (const char *path);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandPathName (TString &path);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual const char * FindDynamicLibrary (TString &lib, Bool_t quiet=kFALSE);  Find a dynamic library using the system search paths. ;  ; virtual const char * FindFile (const char *search, TString &file, EAccessMode mode=kFileExists);  Find location of file in a search path. ;  ; virtual void FreeDirectory (void *dirp);  Free a directory. ;  ; virtual EAclicMode GetAclicMode () const;  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual Int_t GetAclicProperties () const;  Return the ACLiC properties field. ;  ; void GetBeepDefaults (Int_t &freq, Int_t &duration) const;  ; virtual const char * GetBuildArch () const;  Return the build architecture. ;  ; virtual const char * GetBuildCompiler () const;  Return the build compiler. ;  ; virtual const char * GetBuildCompilerVersion () const;  Return the build compiler version. ;  ; virtual const char * GetBuildCompilerVersionStr () const;  Return the build compiler version identifier string. ;  ; virtual const char * GetBuildDir () const;  Return the path of the build directory. ;  ; virtual const char * GetBuildNode () const;  Return the build node name. ;  ; virtual int GetCpuInfo (CpuInfo_t *info, Int_t sampleTime=1000) const;  Returns cpu load average and load info into the CpuInfo_t structure. ;  ; virtual Int_t GetCryptoRandom (void *buf, Int_t len);  Return cryptographic random number Fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:5985,optimiz,optimized,5985,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimized']
Performance," the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // This will be set at the lastest during TROOT construction, so before; 311 // any threading could happen.; 312 if (!gClassTable || !fgTable) {; 313 if (GetDelayedAddClass().size()) {; 314 new TClassTable;; 315 return kTRUE;; 316 }; 317 return kFALSE;; 318 }; 319 return kTRUE;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Print the class table. Before printing the table is sorted; 324/// alphabetically. Only classes specified in option are listed.; 325/// The default is to list all classes.; 326/// Standard wildcarding notation supported.; 327 ; 328void TClassTable::Print(Option_t *option) const; 329{; 330 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 331 ; 332 // This is the very rare case (i.e. called before any dictionary load); 333 // so we don't need to execute this outside of the critical section.; 334 if (fgTally == 0 || !fgTable); 335 return;; 336 ; 337 SortTable();; 338 ; 339 int n = 0, ninit = 0, nl = 0;; 340 ; 341 if (!option) option = """";; 342 int nch = strlen(option);; 343 TRegexp re(option, kTRUE);; 344 ; 345 Printf(""\nDefined classes"");; 346 Printf(""class version bits initialized"");; 347 Printf(""================================================================"");; 348 for (UInt_t i = 0; i < fgTally; i++) {; 349 TClassRec *r = fgSortedTable[i];; 350 if (!r) break;; 351 n++;; 352 TString s = r->fName;; 353 if (nch && strcmp(option,r->fName) && s.Index(re) == kNPOS) continue;; 354 nl++;; 355 if (TClass::GetClass(r->fName, kFALSE)) {; 356 ninit++;; 357 Printf(""%-35s %6d %7d Yes"", r->fName, r->fId, r->fBits);; 358 } else; 359 Printf(""%-35s %6d %7d No"", r->fName, r->fId, r->fBits);; 360 }; 361 Printf(""----------------------------------------------------------------"");; 362 Printf(""Listed Classes: %4d Total classes: %4d ini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:10102,load,load,10102,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['load'],['load']
Performance," the vector.; 471 IMethod* imeth = FindMVA( methodTag );; 472 MethodBase* meth = dynamic_cast<TMVA::MethodBase*>(imeth);; 473 if(meth==0) return 0;; 474 ; 475 // Event* tmpEvent=new Event(inputVec, 2); // ToDo resolve magic 2 issue; 476 Event* tmpEvent=new Event(inputVec, DataInfo().GetNVariables()); // is this the solution?; 477 for (UInt_t i=0; i<inputVec.size(); i++){; 478 if (TMath::IsNaN(inputVec[i])) {; 479 Log() << kERROR << i << ""-th variable of the event is NaN --> return MVA value -999, \n that's all I can do, please fix or remove this event."" << Endl;; 480 delete tmpEvent;; 481 return -999;; 482 }; 483 }; 484 ; 485 if (meth->GetMethodType() == TMVA::Types::kCuts) {; 486 TMVA::MethodCuts* mc = dynamic_cast<TMVA::MethodCuts*>(meth);; 487 if(mc); 488 mc->SetTestSignalEfficiency( aux );; 489 }; 490 Double_t val = meth->GetMvaValue( tmpEvent, (fCalculateError?&fMvaEventError:0));; 491 delete tmpEvent;; 492 return val;; 493}; 494 ; 495////////////////////////////////////////////////////////////////////////////////; 496/// Evaluate a std::vector<double> of input data for a given method; 497/// The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff; 498 ; 499Double_t TMVA::Reader::EvaluateMVA( const std::vector<Double_t>& inputVec, const TString& methodTag, Double_t aux ); 500{; 501 // performs a copy to float values which are internally used by all methods; 502 if(fTmpEvalVec.size() != inputVec.size()); 503 fTmpEvalVec.resize(inputVec.size());; 504 ; 505 for (UInt_t idx=0; idx!=inputVec.size(); idx++ ); 506 fTmpEvalVec[idx]=inputVec[idx];; 507 ; 508 return EvaluateMVA( fTmpEvalVec, methodTag, aux );; 509}; 510 ; 511////////////////////////////////////////////////////////////////////////////////; 512/// evaluates MVA for given set of input variables; 513 ; 514Double_t TMVA::Reader::EvaluateMVA( const TString& methodTag, Double_t aux ); 515{; 516 IMethod* method = 0;; 517 ; 518 std::map<TString, IMethod*>::iterator it = fMeth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8cxx_source.html:18786,perform,performs,18786,doc/master/Reader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html,1,['perform'],['performs']
Performance," the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:53216,load,load,53216,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance," the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:319134,load,load,319134,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance," the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:2019; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3894; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3465; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3753; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5996; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3879; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1132; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4640; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:53044,load,load,53044,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['load']
Performance," the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:2019; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3894; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3465; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3753; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5996; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3879; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1132; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4640; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:321772,load,load,321772,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance," the; 1863/// list (plus the builtins types).; 1864 ; 1865TCollection *TROOT::GetListOfTypes(Bool_t /* load */); 1866{; 1867 if (!fInterpreter); 1868 Fatal(""GetListOfTypes"", ""fInterpreter not initialized"");; 1869 ; 1870 return fTypes;; 1871}; 1872 ; 1873////////////////////////////////////////////////////////////////////////////////; 1874/// Get number of classes.; 1875 ; 1876Int_t TROOT::GetNclasses() const; 1877{; 1878 return fClasses->GetSize();; 1879}; 1880 ; 1881////////////////////////////////////////////////////////////////////////////////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Check whether className is a known class, and only autoload; 1905/// if we can. Helper function for TROOT::IgnoreInclude().; 1906 ; 1907static TClass* R__GetClassIfKnown(const char* className); 1908{; 1909 // Check whether the class is available for auto-loading first:; 1910 const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);; 1911 TClass* cla = nullptr;; 1912 if (libsToLoad) {; 1913 // trigger autoload, and only create TClass in this case.; 1914 return TClass::GetClass(className);; 1915 } else if (gROOT->GetListOfClasses(); 1916 && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {; 1917 // cla assigned in if statement; 1918 } else if (gClassTable->FindObject(className)) {; 1919 return TClass::GetClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:72808,load,load,72808,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance," the; 5980 // 'current streamerinfo' which, at time point, would be the same as 'info'!; 5981 if (info && GetListOfDataMembers() && !GetCollectionProxy(); 5982 && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 5996 Warning(""PostLoadCheck"",""\n\; 5997 The class %s transitioned from not having a specified class version\n\; 5998 to having a specified class version (the current class version is %d).\n\; 5999 However too many different non-versioned layouts of the class have\n\; 6000 already been loaded so far. To work around this problem you can\n\; 6001 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6002 describing the class %s before opening the files or increase the version\n\; 6003 number of the class for example ClassDef(%s,%d).\n\; 6004 Do not try to write objects with the current class definition,\n\; 6005 the files might not be readable.\n"",; 6006 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6007 } else {; 6008 Warning(""PostLoadCheck"",""\n\; 6009 The StreamerInfo version %d for the class %s which was read\n\; 6010 from a file previously opened has the same version as the active class\n\; 6011 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6012 Do not try to write objects with the current class definition,\n\; 6013 the files will not be readable.\n""; 6014 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6015 }; 6016 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:230502,load,loaded,230502,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance," the; 6047 // 'current streamerinfo' which, at time point, would be the same as 'info'!; 6048 if (info && GetListOfDataMembers() && !GetCollectionProxy(); 6049 && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 6050 {; 6051 Bool_t warn = ! TestBit(kWarned);; 6052 if (warn && info->GetOldVersion()<=2) {; 6053 // Names of STL base classes was modified in vers==3. Allocators removed; 6054 //; 6055 TIter nextBC(GetListOfBases());; 6056 TBaseClass *bc;; 6057 while ((bc=(TBaseClass*)nextBC())); 6058 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 6059 }; 6060 ; 6061 if (warn) {; 6062 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 6063 Warning(""PostLoadCheck"",""\n\; 6064 The class %s transitioned from not having a specified class version\n\; 6065 to having a specified class version (the current class version is %d).\n\; 6066 However too many different non-versioned layouts of the class have\n\; 6067 already been loaded so far. To work around this problem you can\n\; 6068 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6069 describing the class %s before opening the files or increase the version\n\; 6070 number of the class for example ClassDef(%s,%d).\n\; 6071 Do not try to write objects with the current class definition,\n\; 6072 the files might not be readable.\n"",; 6073 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6074 } else {; 6075 Warning(""PostLoadCheck"",""\n\; 6076 The StreamerInfo version %d for the class %s which was read\n\; 6077 from a file previously opened has the same version as the active class\n\; 6078 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6079 Do not try to write objects with the current class definition,\n\; 6080 the files will not be readable.\n""; 6081 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6082 }; 6083 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:233253,load,loaded,233253,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance," their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently visible; scenes. void Render(); Render all scenes. This is done in two main passes:; - render opaque objects from all scenes; - render transparent objects from all scenes. void RenderNonSelected(); Render non-selected objects from all scenes. void RenderSelected(); Render selected objects from all scenes. void RenderSelectedForHighlight(); Render selected objects from all scenes for highlight. void RenderOpaque(Bool_t rnr_non_selected = kTRUE, Bool_t rnr_selected = kTRUE); Render opaque objects from all scenes. void RenderTransparent(Bool_t rnr_non_selected = kTRUE, Bool_t rnr_selected = kTRUE); Render transparent objects from all scenes. void RenderOverlay(Int_t state, Bool_t selection); Render overlay objects. void PostRender(); Function called after rendering is finished.; Here we just unlock the scenes. void PreRenderOverlaySelection(); Perform minimal initialization for overlay selection.; Here we assume that scene has already been drawn and that; camera and overall bounding box are ok.; Scenes are not locked. void PostRenderOverlaySelection(); Perform cleanup after overlay selection. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t recIdx); Process selection record on buffer-position 'recIdx' and; fill the data into 'rec'. Returns TRUE if scene was demangled and an object identified.; When FALSE is returned it is still possible that scene has been; identified. Check for this if interested in scene-selection. The select-buffer is taken form fRnrCtx. Bool_t FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); Find next select record that can be resolved, starting from; position 'recIdx'.; 'recIdx' is passed as reference and points to found record in the buffer. Bool_t FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Find next select record that can be resolved and whose result is; not transparent, startin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewerBase.html:6851,Perform,Perform,6851,root/html534/TGLViewerBase.html,https://root.cern,https://root.cern/root/html534/TGLViewerBase.html,3,['Perform'],['Perform']
Performance," this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttBBox;  TAttBBox ();  ; virtual ~TAttBBox ();  ; Float_t * AssertBBox ();  ; virtual void ComputeBBox ()=0;  ; Float_t * GetBBox ();  ; Bool_t GetBBoxOK () const;  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveProjectable;  TEveProjectable ();  Constructor. ;  ; virtual ~TEveProjectable ();  Destructor. ;  ; virtual void AddProjected (TEveProjected *p);  ; virtual void AddProjectedsToSet (std::set< TEveElement * > &set);  Add the projected elements to the set, dyn-casting them to TEveElement. ;  ; virtual void AnnihilateProjecteds ();  Optimized destroy of projected elements with condition there is only one parent for projected element. ;  ; ProjList_i BeginProjecteds ();  ; virtual void ClearProjectedList ();  ; ProjList_i EndProjecteds ();  ; virtual Bool_t HasProjecteds () const;  ; virtual void PropagateMainColor (Color_t color, Color_t old_color);  Set main color of projecteds if their color is the same as old_color. ;  ; virtual void PropagateMainTransparency (Char_t t, Char_t old_t);  Set main transparency of projecteds if their transparency is the same as the old one. ;  ; virtual void PropagateRenderState (Bool_t rnr_self, Bool_t rnr_children);  Set render state of projecteds. ;  ; virtual void PropagateVizParams (TEveElement *el=nullptr);  Set visualization parameters of projecteds. ;  ; virtual void RemoveProjected (TEveProjected *p);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Ver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloViz.html:29553,Optimiz,Optimized,29553,doc/master/classTEveCaloViz.html,https://root.cern,https://root.cern/doc/master/classTEveCaloViz.html,1,['Optimiz'],['Optimized']
Performance," this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4411; TClass::Loadstatic TClass * Load(TBuffer &b)Load class description from I/O buffer and return class object.Definition TClass.cxx:5715; TClass::fStateEState fStatecached of the streaming method to useDefinition TClass.h:277; TClass::GetDestructorROOT::DesFunc_t GetDestructor() constReturn the wrapper around the destructor.Definition TClass.cxx:7479; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4456; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:312898,Load,Loadstatic,312898,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,6,['Load'],"['Load', 'Loadstatic']"
Performance," this class.Definition TClass.cxx:5045; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:7036; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4408; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4478; TClass::Loadstatic TClass * Load(TBuffer &b)Load class description from I/O buffer and return class object.Definition TClass.cxx:5782; TClass::fStateEState fStatecached of the streaming method to useDefinition TClass.h:277; TClass::GetDestructorROOT::DesFunc_t GetDestructor() constReturn the wrapper around the destructor.Definition TClass.cxx:7546; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4523; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2537; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:315536,Load,Loadstatic,315536,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,6,['Load'],"['Load', 'Loadstatic']"
Performance," this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can stil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:120080,cache,cache,120080,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['cache'],['cache']
Performance," this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROOT::Math::GeneticMinimizer::Minimizebool Minimize() overridemethod to perform the minimizationDefinition GeneticMinimizer.cxx:252; ROOT::Math::GeneticMinimizer::GetGeneticOptionsvoid GetGeneticOptions(ROOT::Math::MinimizerOptions &opt) constDefinition GeneticMinimizer.cxx:191; ROOT::Math::GeneticMinimizer::ProvidesErrorbool ProvidesError() const overrideminimizer provides error and error matrixDefinition GeneticMinimizer.cxx:365; ROOT::Math::GeneticMinimizer::SetVariablebool SetVariable(unsigned int ivar, const std::string &name, double val, double step) overrideset a new free variableDefinition GeneticMinimizer.cxx:153; ROOT::Math::GeneticMinimizer::fResultstd::vector< double > fResultDefinition GeneticMinimizer.h:109; ROOT::Math::GeneticMinimizer::fFitnessTMVA::IFitterTarget * fFitnessDefinition GeneticMinimizer.h:107; ROOT::Math::GeneticMinimizer::fRangesstd::vector< TMVA::Interval * > fRangesDefinition GeneticMinimizer.h:106; ROOT::Math::GeneticMinimizer::SetParametersvoid SetParameters(const GeneticMinimizerParameters &params)Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneticMinimizer_8h_source.html:5675,perform,perform,5675,doc/master/GeneticMinimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html,1,['perform'],['perform']
Performance," this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100665,Load,LoadBaskets,100665,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['Load'],['LoadBaskets']
Performance," this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called everytime a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:107937,load,loaded,107937,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['load'],['loaded']
Performance," this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; Method 1 uses internally method 2.; Method 2 works for all collection classes. TIter overloads operator().; Methods 3 and 4 are specific for TList.; Methods 2, 3 and 4 can also easily iterate backwards using either a backward TIter (using argument kIterBackward) or by using LastLink() and lnk>Prev() or by using the Before() method.; 16.7 The TObjArray Collection; A TObjArray is a collection which supports traditional array semantics via the overloading of operator[]. Objects can be directly accessed via an index. The array expands automatically when objects are added. At creation time one specifies the default array size (default = 16) and lower bound (default = 0). Resizing involves a re-allocation and a copy of the old array to the new. This can be costly if done too often. If possible, set initial size close to expected final size. Index validity is always checked (if you are 100% sure and maximum performance is needed you can use UnCheckedAt() instead of At() or operator[]). If the stored objects are sort able the array can be sorted using Sort(). Once sorted, efficient searching is possible via the BinarySearch() method. The figure shows the internal data structure of a TObjArray:. The internal data structure of a TObjArray. Iterating can be done using a TIter iterator or via a simple for loop:; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; Main features of TObjArray are simple, well-known array semantics. Overhead per element: none, except possible over sizing of fCont.; 16.8 TClonesArray An Array of Identical Objects; A TClonesArray is an array of identical (clone) objects. The memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as a TObjArray. The internal data structure of a TClone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:853124,perform,performance,853124,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:142494,cache,cachefilepath,142494,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cachefilepath']
Performance," title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 68 of file RooCachedReal.cxx. ◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function ; Definition at line 42 of file RooCachedReal.cxx. ◆ RooCachedReal() [4/4]. RooCachedReal::RooCachedReal ; (; const RooCachedReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 87 of file RooCachedReal.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedReal.; Definition at line 165 of file RooCachedReal.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualParameters ; (; const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:64531,cache,cache,64531,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],['cache']
Performance," title, const RooArgSet& inputCatList); virtual~RooMultiCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiCategory.html:1790,cache,cacheUniqueSuffix,1790,root/html534/RooMultiCategory.html,https://root.cern,https://root.cern/root/html534/RooMultiCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance," title, const RooArgSet& inputCatList); virtual~RooMultiCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFund",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiCategory.html:1790,cache,cacheUniqueSuffix,1790,root/html532/RooMultiCategory.html,https://root.cern,https://root.cern/root/html532/RooMultiCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance," title, const RooArgSet& inputCatList); virtual~RooMultiCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMultiCategory.html:1790,cache,cacheUniqueSuffix,1790,root/html528/RooMultiCategory.html,https://root.cern,https://root.cern/root/html528/RooMultiCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance," title, const RooArgSet& inputCatList); virtual~RooSuperCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:2085,cache,cacheUniqueSuffix,2085,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance," title, const RooArgSet& inputCatList); virtual~RooSuperCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFund",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSuperCategory.html:2085,cache,cacheUniqueSuffix,2085,root/html532/RooSuperCategory.html,https://root.cern,https://root.cern/root/html532/RooSuperCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance," title, const RooArgSet& inputCatList); virtual~RooSuperCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSuperCategory.html:2085,cache,cacheUniqueSuffix,2085,root/html528/RooSuperCategory.html,https://root.cern,https://root.cern/root/html528/RooSuperCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance," title, const RooArgSet& sumSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFracRemainder.html:24280,cache,cache,24280,root/html602/RooFracRemainder.html,https://root.cern,https://root.cern/root/html602/RooFracRemainder.html,2,['cache'],['cache']
Performance," to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_double_.html:18780,Perform,Perform,18780,root/html602/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_double_.html,2,['Perform'],['Perform']
Performance," to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:23059,load,load,23059,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance," to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealSumPdf.html:39812,cache,cache,39812,root/html530/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html530/RooRealSumPdf.html,1,['cache'],['cache']
Performance," to add; several lines, than call Update(). void Update(); update the whole window of text view. Long_t ReturnLongestLineWidth(); Return width of longest line. Bool_t Search(const char* string, Bool_t direction, Bool_t caseSensitive); Search for string in text. If direction is true search forward.; Returns true if string is found. void SetFont(FontStruct_t font); Changes text entry font. Long_t ToScrYCoord(Long_t yCoord); Convert line number to screen coordinate. Long_t ToScrXCoord(Long_t xCoord, Long_t line); Convert column number in specified line to screen coordinate. Long_t ToObjYCoord(Long_t yCoord); Convert y screen coordinate to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. Bool_t Copy(); Copy selected text to clipboard. Bool_t SelectAll(); Select all text in the viewer. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. Bool_t HandleDNDDrop(TDNDData* data); Handle Drop event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle Drag position event. Atom_t HandleDNDEnter(Atom_t* typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextView.html:26081,Load,LoadBuffer,26081,root/html528/TGTextView.html,https://root.cern,https://root.cern/root/html528/TGTextView.html,12,['Load'],"['Load', 'LoadBuffer']"
Performance," to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:91028,optimiz,optimize,91028,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['optimiz'],['optimize']
Performance," to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::fIOFeaturesTIOFeatures fIOFeaturesIO features to define for newly-written baskets and branches.Definition TTree.h:114; TTree::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5910; TTree::fDebugMinLong64_t fDebugMin! First entry number to debugDefinition TTree.h:112; TTree::SetEntriesvirtual Long64_t SetEntries(Long64_t n=-1)Change number of entries in the tree.Definition TTree.cxx:9011; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::BranchOldvirtual TBranch * BranchOld(const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1)Create a new TTree BranchObject.Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:438374,cache,cache,438374,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance," to be sizeof...(ColTypes). ; Definition at line 174 of file RInterfaceBase.hxx. ◆ CreateAction() [2/2]. template<typename ActionTag , typename... ColTypes, typename ActionResultType , typename RDFNode , typename HelperArgType = ActionResultType, std::enable_if_t<!RDFInternal::RNeedJitting< ColTypes... >::value, int > = 0> . RResultPtr< ActionResultType > ROOT::RDF::RInterfaceBase::CreateAction ; (; const ColumnNames_t & ; columns, . const std::shared_ptr< ActionResultType > & ; r, . const std::shared_ptr< HelperArgType > & ; helperArg, . const std::shared_ptr< RDFNode > & ; proxiedPtr, . const int ; = -1 . ). inlineprotected . Create RAction object, return RResultPtr for the action Overload for the case in which all column types were specified (no jitting). ; For most actions, r and helperArg will refer to the same object, because the only argument to forward to the action helper is the result value itself. We need the distinction for actions such as Snapshot or Cache, for which the constructor arguments of the action helper are different from the returned value. ; Definition at line 150 of file RInterfaceBase.hxx. ◆ Describe(). ROOT::RDF::RDFDescription ROOT::RDF::RInterfaceBase::Describe ; (; ). Return information about the dataframe. ; Returnsinformation about the dataframe as RDFDescription object; This convenience function describes the dataframe and combines the following information:; Number of event loops run, see GetNRuns(); Number of total and defined columns, see GetColumnNames() and GetDefinedColumnNames(); Column names, see GetColumnNames(); Column types, see GetColumnType(); Number of processing slots, see GetNSlots(). This is not an action nor a transformation, just a query to the RDataFrame object. The result is dependent on the node from which this method is called, e.g. the list of defined columns returned by GetDefinedColumnNames().; Please note that this is a convenience feature and the layout of the output can be subject to change and should be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html:6817,Cache,Cache,6817,doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,1,['Cache'],['Cache']
Performance," to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html:3280,optimiz,optimizeFit,3280,root/html530/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html,2,['optimiz'],['optimizeFit']
Performance," to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:16906,Perform,Perform,16906,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,3,['Perform'],['Perform']
Performance," to be used to optimally distribute the input data objects. ;  ; void SetLogLevel (Int_t level, UInt_t mask=TProofDebug::kAll);  Set server logging level. ;  ; void SetManager (TProofMgr *mgr);  Set manager and schedule its destruction after this for clean operations. ;  ; void SetMaxDrawQueries (Int_t max);  Set max number of draw queries whose results are saved. ;  ; Int_t SetParallel (Int_t nodes=-1, Bool_t random=kFALSE);  Tell PROOF how many slaves to use in parallel. ;  ; void SetParameter (const char *par, const char *value);  Set input list parameter. ;  ; void SetParameter (const char *par, Double_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Int_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long64_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long_t value);  Set an input list parameter. ;  ; void SetPerfTree (const char *pf=""perftree.root"", Bool_t withWrks=kFALSE);  Enable/Disable saving of the performance tree. ;  ; void SetPrintProgress (PrintProgress_t pp);  ; void SetProgressDialog (Bool_t on=kTRUE);  Enable/Disable the graphic progress dialog. ;  ; void SetQueryMode (EQueryMode mode);  Change query running mode to the one specified by 'mode'. ;  ; void SetRealTimeLog (Bool_t on=kTRUE);  Switch ON/OFF the real-time logging facility. ;  ; virtual void ShowCache (Bool_t all=kFALSE);  List contents of file cache. ;  ; virtual void ShowData ();  List contents of the data directory in the sandbox. ;  ; void ShowDataSet (const char *dataset="""", const char *opt=""filter:SsCc"");  display meta-info for given dataset usi ;  ; virtual void ShowDataSetCache (const char *dataset=0);  Display the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ShowDataSetQuota (Option_t *opt=0);  shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ;  ; virtual void ShowDataSets (const char *uri=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:18877,perform,performance,18877,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['perform'],['performance']
Performance," to be used to optimally distribute the input data objects. ;  ; void SetLogLevel (Int_t level, UInt_t mask=TProofDebug::kAll);  Set server logging level. ;  ; void SetManager (TProofMgr *mgr);  Set manager and schedule its destruction after this for clean operations. ;  ; void SetMaxDrawQueries (Int_t max);  Set max number of draw queries whose results are saved. ;  ; Int_t SetParallel (Int_t nodes=-1, Bool_t random=kFALSE);  Tell PROOF how many slaves to use in parallel. ;  ; void SetParameter (const char *par, const char *value);  Set input list parameter. ;  ; void SetParameter (const char *par, Double_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Int_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long64_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long_t value);  Set an input list parameter. ;  ; void SetPerfTree (const char *pf=""perftree.root"", Bool_t withWrks=kFALSE);  Enable/Disable saving of the performance tree. ;  ; void SetPrintProgress (PrintProgress_t pp);  ; void SetProgressDialog (Bool_t on=kTRUE);  Enable/Disable the graphic progress dialog. ;  ; void SetQueryMode (EQueryMode mode);  Change query running mode to the one specified by 'mode'. ;  ; void SetRealTimeLog (Bool_t on=kTRUE);  Switch ON/OFF the real-time logging facility. ;  ; void ShowDataSet (const char *dataset="""", const char *opt=""filter:SsCc"");  display meta-info for given dataset usi ;  ; void ShowDataSetQuota (Option_t *opt=0);  shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ;  ; void ShowEnabledPackages (Bool_t all=kFALSE);  List which packages are enabled. ;  ; void ShowFeedback () const;  Show items in feedback list. ;  ; void ShowLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the content of the temporary lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:17894,perform,performance,17894,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['perform'],['performance']
Performance," to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html:3595,optimiz,optimizeFit,3595,root/html602/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html,2,['optimiz'],['optimizeFit']
Performance," to buffer. ; Definition at line 2920 of file TBufferXML.cxx. ◆ XmlWriteBlock(). void TBufferXML::XmlWriteBlock ; (; XMLNodePointer_t ; node). protected . Write binary data block from buffer to xml. ; This data can be produced only by direct call of TBuffer::WriteBuf() functions. ; Definition at line 390 of file TBufferXML.cxx. ◆ XmlWriteFastArray(). template<typename T > . R__ALWAYS_INLINE void TBufferXML::XmlWriteFastArray ; (; const T * ; arr, . Long64_t ; n . ). protected . Write array without size attribute Also treat situation, when instead of one single array chain of several elements should be produced. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Definition at line 2161 of file TBufferXML.cxx. ◆ XmlWriteObject(). XMLNodePointer_t TBufferXML::XmlWriteObject ; (; const void * ; obj, . const TClass * ; objClass, . Bool_t ; cacheReuse . ). protected . Write object to buffer If object was written before, only pointer will be stored Return pointer to top xml node, representing object. ; Definition at line 756 of file TBufferXML.cxx. ◆ XmlWriteValue(). XMLNodePointer_t TBufferXML::XmlWriteValue ; (; const char * ; value, . const char * ; name . ). protected . Create xml node with specified name and adds it to stack node. ; Definition at line 2959 of file TBufferXML.cxx. Friends And Related Symbol Documentation. ◆ TKeyXML. friend class TKeyXML. friend . Definition at line 35 of file TBufferXML.h. Member Data Documentation. ◆ fCanUseCompact. Bool_t TBufferXML::fCanUseCompact {kFALSE}. protected . ! Flag indicate that basic type (like Int_t) can be placed in the same tag ; Definition at line 327 of file TBufferXML.h. ◆ fCompressLevel. Int_t TBufferXML::fCompressLevel {0}. protected . ! Compression level and algorithm ; Definition at line 329 of file TBufferXML.h. ◆ fErrorFlag. Int_t TBufferXML::fErrorFlag {0}. p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:104236,cache,cacheReuse,104236,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['cache'],['cacheReuse']
Performance," to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedPdf(); {}. TObject* clone(const char* newname) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:42731,cache,cache,42731,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,7,['cache'],['cache']
Performance," to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:23602,load,load,23602,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance," to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boosting). Double_t CheckEvent(const TMVA::Event& , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given events",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__DecisionTree.html:13303,perform,performed,13303,root/html530/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html530/TMVA__DecisionTree.html,2,['perform'],['performed']
Performance," to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; possible multivariate split. std::vector<Double_t> GetFisherCoefficients(const TMVA::DecisionTree::EventList& eventSample, UInt_t nFisherVars, UInt_t* mapVarInFisher); calculate the fisher coefficients for the event sample and the variables used. Double_t TrainNodeFull(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node). TMVA::DecisionTreeNode* GetEventNode(const TMVA::Event& e) const; get the pointer to the leaf node where a particular event ends up in...; (used in gradient boostinge). Double_t CheckEvent(const TMVA::Event& , Bool_t UseYesNoLeaf = kFALSE) const; the event e is put into the decision tree (starting at the root node); and the output is NodeType (signal) or (background) of the final node (basket); in which the given event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:13160,perform,performed,13160,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,1,['perform'],['performed']
Performance," to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCachedReal.html:39537,cache,cache,39537,root/html604/RooCachedReal.html,https://root.cern,https://root.cern/root/html604/RooCachedReal.html,2,['cache'],['cache']
Performance," to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:38039,cache,cache,38039,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,4,['cache'],['cache']
Performance," to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external inp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:34505,cache,cache,34505,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,8,['cache'],['cache']
Performance," to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html:3257,optimiz,optimizeScan,3257,root/html534/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html,2,['optimiz'],"['optimization', 'optimizeScan']"
Performance," to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:51262,Optimiz,Optimize,51262,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,6,"['Optimiz', 'optimiz']","['Optimize', 'optimization']"
Performance," to make the global index cover all modules, so we do that here.; 1099 if (!GlobalIndex && !HaveFullGlobalModuleIndex) {; 1100 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1101 bool RecreateIndex = false;; 1102 for (ModuleMap::module_iterator I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1103 Module *TheModule = I->second;; 1104 // We want the index only of the prebuilt modules.; 1105 if (!HasASTFileOnDisk(TheModule, PP)); 1106 continue;; 1107 LoadModule(TheModule->Name, interp);; 1108 RecreateIndex = true;; 1109 }; 1110 if (RecreateIndex) {; 1111 cling::Interpreter::PushTransactionRAII deserRAII(&interp);; 1112 clang::GlobalModuleIndex::UserDefinedInterestingIDs IDs;; 1113 ; 1114 struct DefinitionFinder : public RecursiveASTVisitor<DefinitionFinder> {; 1115 DefinitionFinder(clang::GlobalModuleIndex::UserDefinedInterestingIDs& IDs,; 1116 clang::TranslationUnitDecl* TU) : DefinitionIDs(IDs) {; 1117 TraverseDecl(TU);; 1118 }; 1119 bool VisitNamedDecl(NamedDecl *ND) {; 1120 if (!ND->isFromASTFile()); 1121 return true;; 1122 if (!ND->getIdentifier()); 1123 return true;; 1124 ; 1125 if (ND->getAccess() == AS_protected || ND->getAccess() == AS_private); 1126 return true;; 1127 ; 1128 if (TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {; 1129 if (TD->isCompleteDefinition()); 1130 Register(TD);; 1131 } else if (NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {; 1132 Register(NSD, /*AddSingleEntry=*/ false);; 1133 }; 1134 else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND)); 1135 Register(TND);; 1136 // FIXME: Add the rest...; 1137 return true; // continue decending; 1138 }; 1139 private:; 1140 clang::GlobalModuleIndex::UserDefinedInterestingIDs &DefinitionIDs;; 1141 void Register(const NamedDecl* ND, bool AddSingleEntry = true) {; 1142 assert(ND->isFromASTFile());; 1143 // FIXME: All decls should have an owning module once rootcling; 1144 // updates its generated decls from within the LookupHelper & co.; 1145 if (!ND->hasOwningM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:39961,Load,LoadModule,39961,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadModule']
Performance, to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 187 of file PiecewiseInterpolation.cxx. Member Data Documentation. ◆ _highSet. RooListProxy PiecewiseInterpolation::_highSet. protected . High-side variation. ; Definition at line 95 of file PiecewiseInterpolation.h. ◆ _interpCode. std::vector<int> PiecewiseInterpolation::_interpCode. protected . Definition at line 100 of file PiecewiseInterpolation.h. ◆ _lowSet. RooListProxy PiecewiseInterpolation::_lowSet. protected . Low-side variation. ; Definition at line 94 of file PiecewiseInterpolation.h. ◆ _nominal. RooRealProxy PiecewiseInterpolation::_nominal. protected . The nominal value. ; Definition at line 92 of file PiecewiseInterpolation.h. ◆ _normIntMgr. RooObjCacheManager PiecewiseInterpolation::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition at line 90 of file PiecewiseInterpolation.h. ◆ _normSet. RooListProxy PiecewiseInterpolation::_normSet. protected . interpolation parameters ; Definition at line 97 of file PiecewiseInterpolation.h. ◆ _ownedList. RooArgList PiecewiseInterpolation::_ownedList. protected . List of owned components. ; Definition at line 93 of file PiecewiseInterpolation.h. ◆ _paramSet. RooListProxy PiecewiseInterpolation::_paramSet. protected . interpolation parameters ; Definition at line 96 of file PiecewiseInterpolation.h. ◆ _positiveDefinite. bool PiecewiseInterpolation::_positiveDefinite = false. protected . protect against negative and 0 bins. ; Definition at line 98 of file PiecewiseInterpolation.h. Libraries for PiecewiseInterpolation:. [legend]; The documentation for this class was generated from the following files:; roofit/histfactory/inc/RooStats/HistFactory/PiecewiseInterpolation.h; roofit/histfactory/src/PiecewiseInterpolation.cxx. PiecewiseInterpolation. ROOT master - Reference Guide Gene,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:70938,cache,cache,70938,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['cache'],['cache']
Performance," to prevent infinite recursion in the usage of TTree Friends.Definition TTree.h:188; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::AddFriendvirtual TFriendElement * AddFriend(const char *treename, const char *filename="""")Add a TFriendElement to the list of friends.Definition TTree.cxx:1332; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::fFriendsTList * fFriendspointer to list of friend elementsDefinition TTree.h:130; TTree::fIMTEnabledbool fIMTEnabled! true if implicit multi-threading is enabled for this treeDefinition TTree.h:142; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:144824,multi-thread,multi-threading,144824,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance," to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxydm; RooRealProxydm0; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDstD0BG.html:38702,cache,cache,38702,root/html526/RooDstD0BG.html,https://root.cern,https://root.cern/root/html526/RooDstD0BG.html,2,['cache'],['cache']
Performance," to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPoisson.html:38534,cache,cache,38534,root/html526/RooPoisson.html,https://root.cern,https://root.cern/root/html526/RooPoisson.html,2,['cache'],['cache']
Performance," to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. The leaf name can contain the name of a friend tree with the; syntax: friend_dir_and_tree.full_leaf_name; the friend_dir_and_tree can be of the form; TDirectoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:99352,Load,Load,99352,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['Load'],['Load']
Performance," to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. The leaf name can contain the name of a friend tree with the; syntax: friend_dir_and_tree.full_leaf_name; the friend_dir_and_tree can be of the form; TDirectoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache:; Create a new cache according to the autocache setting and return it. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBasket",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:103217,Load,Load,103217,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['Load'],['Load']
Performance," to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. The leaf name can contain the name of a friend tree with the; syntax: friend_dir_and_tree.full_leaf_name; the friend_dir_and_tree can be of the form; TDirectoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache; a new cache is created with default size. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 20000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:104880,Load,Load,104880,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['Load'],['Load']
Performance," to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment opeartor. virtual ~TQpLinSolverBase(); {}. void SolveCompressed(TVectorD& rhs); assemble right-hand side of augmented system and call; SolveCompressed to solve it. void PutXDiagonal(TVectorD& xdiag); perform the actual solve using the factors produced in; factor.; rhs on input contains the aggregated right-hand side of; the augmented system; on output contains the solution in; aggregated form. void PutZDiagonal(TVectorD& zdiag); places the diagonal resulting from the bounds on x into; the augmented system matrix. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-10-03 18:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpLinSolverBase.html:8489,perform,perform,8489,root/html528/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html,1,['perform'],['perform']
Performance," to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment opeartor. virtual ~TQpLinSolverBase(); {}. void SolveCompressed(TVectorD& rhs); assemble right-hand side of augmented system and call; SolveCompressed to solve it. void PutXDiagonal(TVectorD& xdiag); perform the actual solve using the factors produced in; factor.; rhs on input contains the aggregated right-hand side of; the augmented system; on output contains the solution in; aggregated form. void PutZDiagonal(TVectorD& zdiag); places the diagonal resulting from the bounds on x into; the augmented system matrix. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQpLinSolverBase.html:8558,perform,perform,8558,root/html530/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html530/TQpLinSolverBase.html,1,['perform'],['perform']
Performance," to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment opeartor. virtual ~TQpLinSolverBase(); {}. void SolveCompressed(TVectorD& rhs); assemble right-hand side of augmented system and call; SolveCompressed to solve it. void PutXDiagonal(TVectorD& xdiag); perform the actual solve using the factors produced in; factor.; rhs on input contains the aggregated right-hand side of; the augmented system; on output contains the solution in; aggregated form. void PutZDiagonal(TVectorD& zdiag); places the diagonal resulting from the bounds on x into; the augmented system matrix. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpLinSolverBase.html:8558,perform,perform,8558,root/html532/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html532/TQpLinSolverBase.html,1,['perform'],['perform']
Performance," to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7012 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:170497,Load,LoadBaskets,170497,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['Load'],['LoadBaskets']
Performance," to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7012 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 705 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:172685,Load,LoadBaskets,172685,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['Load'],['LoadBaskets']
Performance," to use it in; 111TTreeFormula expressions.; 112 ; 113## TEntryList and TEventList; 114 ; 115TTree::SetEventList() and TChain::SetEventList() transform a TEventList into a TEntryList; 116See comments to those functions for more details; 117 ; 118## Types of entry lists; 119There are two types of entry lists:; 120 ; 121#### 1.; 122 for a TTree (fBlocks data member is non-zero); 123 Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored; 124 in the TObjArray fBlocks. The range of the entry numbers is cut into intervals; 125 of kBlockSize entries (currently 64000), so that the first block contains; 126 information which entries out of the first 64000 pass the selection, the second; 127 block - which entries out of the 64000-127999 interval pass the selection, etc.; 128 Some blocks, obviously, might be empty. The internal representation of entry; 129 numbers in the blocks is described in the TEntryListBlock class description, and; 130 this representation might be changed by calling OptimizeStorage() function; 131 (when the list is filled via the Enter() function, this is done automatically,; 132 except for the last block).; 133 Individual entry lists can be merged (functions Merge() and Add()); 134 to make an entry list for a TChain of corresponding TTrees.; 135Begin_Macro; 136entrylist_figure1.C; 137End_Macro; 138 ; 139#### 2.; 140 for a TChain (fLists data member is non-zero); 141 It contains a TList of sub-lists (TEntryList objects, corresponding to each TTree); 142 Trees and lists are matched by the TTree name and its file name (full path).; 143 All sub-lists are returned by the GetLists() function and individual lists are; 144 returned by GetEntryList() function. Such lists are no different from the lists for; 145 TTrees, described above.; 146Begin_Macro; 147entrylist_figure2.C; 148End_Macro; 149 ; 150 ; 151*/; 152 ; 153#include ""TEntryList.h""; 154#include ""TEntryListBlock.h""; 155#include ""TError.h""; 156#include ""TKey.h""; 157#include ""TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:5948,Optimiz,OptimizeStorage,5948,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['Optimiz'],['OptimizeStorage']
Performance," to write the results of TTree::Draw and TChain::Draw into an entry list. Example: tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; ; Example of Loop on TEntryList with a TChain; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);; ; for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::GetEntryNumberLong64_t GetEntryNumber(Long64_t entry) const overrideReturn entry number corresponding to entry.Definition TChain.cxx:1021; TChain::SetEntryListvoid SetEntryList(TEntryList *elist, Option_t *opt="""") overrideSet the input entry list (processing the entries of the chain will then be limited to the entries in ...Definition TChain.cxx:2703; TChain::Addvirtual Int_t Add(TChain *chain)Add all files referenced by the passed chain to this chain.Definition TChain.cxx:219; TChain::LoadTreeLong64_t LoadTree(Long64_t entry) overrideFind the tree which contains entry, and set it as the current tree.Definition TChain.cxx:1324; TChain::GetEntriesLong64_t GetEntries() const overrideReturn the total number of entries in the chain.Definition TChain.cxx:978; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:2391,Load,LoadTree,2391,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['Load'],['LoadTree']
Performance," to xvalue. ; Return -1 if distance exceeds tolerance ; Definition at line 633 of file RooCurve.cxx. ◆ getFitRangeBinW(). double RooCurve::getFitRangeBinW ; (; ); const. overridevirtual . Get the bin width associated with this plotable object. ; It is alwats zero for curves ; Implements RooPlotable.; Definition at line 479 of file RooCurve.cxx. ◆ getFitRangeNEvt() [1/2]. double RooCurve::getFitRangeNEvt ; (; ); const. overridevirtual . Return the number of events associated with the plotable object, it is always 1 for curves. ; Implements RooPlotable.; Definition at line 460 of file RooCurve.cxx. ◆ getFitRangeNEvt() [2/2]. double RooCurve::getFitRangeNEvt ; (; double ; xlo, . double ; xhi . ); const. overridevirtual . Return the number of events associated with the plotable object, in the given range. ; It is always 1 for curves ; Implements RooPlotable.; Definition at line 469 of file RooCurve.cxx. ◆ initialize(). void RooCurve::initialize ; (; ). protected . Perform initialization that is common to all curves. ; Definition at line 241 of file RooCurve.cxx. ◆ interpolate(). double RooCurve::interpolate ; (; double ; xvalue, . double ; tolerance = 1e-10 . ); const. Return linearly interpolated value of curve at xvalue. ; If distance to nearest point is less than tolerance, return nearest point value instead ; Definition at line 655 of file RooCurve.cxx. ◆ IsA(). TClass * RooCurve::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 106 of file RooCurve.h. ◆ isIdentical(). bool RooCurve::isIdentical ; (; const RooCurve & ; other, . double ; tol = 1e-6, . bool ; verbose = true . ); const. Return true if curve is identical to other curve allowing for given absolute tolerance on each point compared point. ; Definition at line 851 of file RooCurve.cxx. ◆ makeErrorBand() [1/2]. RooCurve * RooCurve::makeErrorBand ; (; const std::vector< RooCurve * > & ; plusVar, . const std::vector< RooCurve * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:46887,Perform,Perform,46887,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,1,['Perform'],['Perform']
Performance," tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:37126,cache,cached,37126,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,1,['cache'],['cached']
Performance," traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:46302,cache,cached,46302,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['cache'],"['cache', 'cached']"
Performance," track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. Int_t AddNavigator(TGeoNavigator* navigator); Add a navigator in the list of navigators. If it is the first one make it; current navigator. Bool_t SetCurrentNavigator(Int_t index); Switch to another navigator. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START; and having size STEP. The created volumes will have tracking; media ID=NUMED (if N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:37838,cache,cache,37838,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,2,['cache'],['cache']
Performance," transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. It is not simple to activate the cache; by default (except case1 below) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranch(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:4267,cache,cache,4267,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,['cache'],['cache']
Performance," transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. It is not simple to activate the cache; by default (except case1 below) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:4267,cache,cache,4267,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance," transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:768161,perform,perform,768161,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance," translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects. There are two cases of object addition:. Add this object as a single independent entity in the world reference frame.; Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (unique) shapes. Some viewers (OpenGL only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching with considerable performance gains in these cases.; For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. The viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of logical object, with the fLocalMaster transform and the fColor and fTransparency attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:5793,perform,perform,5793,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,2,['perform'],"['perform', 'performance']"
Performance," tree (or possibly keyed object in the case of ...Definition TSelector.cxx:360; TSelector::ImportOutputvirtual void ImportOutput(TList *output)Imports the content of 'output' in the internal output list.Definition TSelector.cxx:270; TSelector::fOutputTSelectorList * fOutput! List of objects created during processingDefinition TSelector.h:42; TSelector::fStatusLong64_t fStatusSelector status.Definition TSelector.h:37; TSelector::Classstatic TClass * Class(); TSelector::Abortvirtual void Abort(const char *why, EAbort what=kAbortProcess)Abort processing.Definition TSelector.cxx:116; TSelector::fObjectTObject * fObject! Current object if processing object (vs. TTree)Definition TSelector.h:40; TSelector::~TSelector~TSelector() overrideSelector destructor.Definition TSelector.cxx:102; TSelector::fAbortEAbort fAbortAbort status.Definition TSelector.h:38; TSelector::TSelectorTSelector()Default selector ctor.Definition TSelector.cxx:89; TSelector::GetSelectorstatic TSelector * GetSelector(const char *filename)The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid cl...Definition TSelector.cxx:142; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; whatstatic const char * whatDefinition stlLoader.cc:5; outputstatic void output(). treetreesrcTSelector.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:21097,load,loaded,21097,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['loaded']
Performance," tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooRealProxy_varInput observable; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinearVar.html:37418,cache,cache,37418,root/html532/RooLinearVar.html,https://root.cern,https://root.cern/root/html532/RooLinearVar.html,1,['cache'],['cache']
Performance," tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:34200,cache,cache,34200,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,2,['cache'],['cache']
Performance," tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interfa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:37596,cache,cacheObs,37596,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,3,['cache'],"['cache', 'cacheObs', 'cached']"
Performance," tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:34062,cache,cacheObs,34062,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,12,['cache'],"['cache', 'cacheObs', 'cached']"
Performance," tree branches; map<Int_t,Bool_t>_bpsIdcs; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:44178,cache,cache,44178,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['cache'],['cache']
Performance," trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; 11.6 Compression and Performance; ROOT uses a compression algorithm based on the well-known gzip algorithm. It supports nine levels of compression. The default for ROOT is one. The compression level can be set with the method TFile::SetCompressionLevel. The experience with this algorithm shows that a compression level of 1.3 for raw data files and around two on most DST files is the optimum. The choice of one for the default is a compromise between the time it takes to read and write the object vs. the disk space savings.; To specify no compression, set the level to zero.; We recommend using compression when the time spent in I/O is small compared to the total processing time. If the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may compress the data by a factor of 10. On the other hand if the time spend on I/O is large, compression may have a large impact on the program’s performance.; The compression factor, i.e. the savings of disk space, varies with the type of data. A buffer with a same value array is compressed so that the value is only written once. For example, a track has the mass of a pion that it is always the same, and the charge of the pion that is either positive or negative. For 1000 pions, the mass will be written only once, and the charge only twice (positive and negative). When the data is sparse, i.e. when there are many zeros, the compression factor is also high. Compression level; Bytes; Write Time (sec); Read Time (sec.). 0; 1,004,998; 4.77; 0.07. 1; 438,366; 6.67; 0.05. 5; 429,871; 7.03; 0.06. 9; 426,899; 8.47; 0.05. The time to uncompress an object is small compared to the compression time and is independent of the selected compression level. Note that the compression level may be changed at any time, but the new compression level will only apply to newly written objects. Consequently",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:513438,perform,performance,513438,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance, true if cylindrical voxelization is optimal. ; Definition at line 1772 of file TGeoVolume.cxx. ◆ GetOption(). Option_t * TGeoVolume::GetOption ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 187 of file TGeoVolume.h. ◆ GetPointerName(). const char * TGeoVolume::GetPointerName ; (; ); const. Provide a pointer name containing uid. ; Definition at line 1792 of file TGeoVolume.cxx. ◆ GetRefCount(). Int_t TGeoVolume::GetRefCount ; (; ); const. inline . Definition at line 131 of file TGeoVolume.h. ◆ GetShape(). TGeoShape * TGeoVolume::GetShape ; (; ); const. inline . Definition at line 190 of file TGeoVolume.h. ◆ GetTransparency(). Char_t TGeoVolume::GetTransparency ; (; ); const. inline . Definition at line 369 of file TGeoVolume.h. ◆ GetUserExtension(). TGeoExtension * TGeoVolume::GetUserExtension ; (; ); const. inline . Definition at line 132 of file TGeoVolume.h. ◆ GetVoxels(). TGeoVoxelFinder * TGeoVolume::GetVoxels ; (; ); const. Getter for optimization structure. ; Definition at line 1802 of file TGeoVolume.cxx. ◆ Grab(). void TGeoVolume::Grab ; (; ). inline . Definition at line 136 of file TGeoVolume.h. ◆ GrabFocus(). void TGeoVolume::GrabFocus ; (; ). Move perspective view focus to this volume. ; Definition at line 1812 of file TGeoVolume.cxx. ◆ GrabFWExtension(). TGeoExtension * TGeoVolume::GrabFWExtension ; (; ); const. Get a copy of the framework extension pointer. ; The user must call Release() on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new()) ; Definition at line 1525 of file TGeoVolume.cxx. ◆ GrabUserExtension(). TGeoExtension * TGeoVolume::GrabUserExtension ; (; ); const. Get a copy of the user extension pointer. ; The user must call Release() on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new()) ; Definition at line 1513 of file TGeoVolume.cxx. ◆ Gsord(). void TGeoVolume::Gsord ; (; Int_t ; ). inline . Definition,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:53621,optimiz,optimization,53621,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['optimiz'],['optimization']
Performance," true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int MakeDirectory (const char *name);  Make a directory. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a connection to another host. ;  ; virtual void * OpenDirectory (const char *name);  Open a directory. Returns 0 if directory does not exist. ;  ; virtual void Openlog (const char *name, Int_t options, ELogFacili",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:13079,Load,Load,13079,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,['Load'],['Load']
Performance," true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a connection to another host. ;  ; virtual void Openlog (const char *name, Int_t options, ELogFacility facility);  Open connection to system log daemon. ;  ; virtual FILE * OpenPipe (const char *command, const char *mode);  Open a pipe. ;  ; virtual const char * PrependPathName (co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:12751,Load,Load,12751,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,4,['Load'],['Load']
Performance," tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.py. tutorialsdataframedf019_Cache.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df019__Cache_8py.html:1413,cache,cache,1413,doc/master/df019__Cache_8py.html,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html,3,"['Cache', 'cache']","['Cache', 'cache', 'cached']"
Performance," type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*const*GetPersistentRef() const; TRealData*GetRealData(const char* name) const; TVirtualRefProxy*GetReferenceProxy() const; ROOT::ResetAfterMergeFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:6777,load,load,6777,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance," typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfFunctions * GetGlobalFunctions(); Internal routine returning, and creating if necessary, the list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name.; If params != 0 it will also resolve overloading other it returns the first; name match.; If params == 0 and load is true force reading of all currently defined; global functions from Cling.; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:26762,load,load,26762,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance," typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(TJSONStackObj* stack, const TStreamerElement* elem = 0); Function is converts TObject and TString structures to more compact representation. TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Ignored in TBufferJSON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:25857,Perform,PerformPostProcessing,25857,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['Perform'],['PerformPostProcessing']
Performance," umin = fRwrmin;; 644 Double_t umax = fRwrmax;; 645 Double_t rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin);; 646 Double_t rmajmax = (frwrmax-fRwrmin)/(fRwrmax-fRwrmin);; 647 Double_t dist = (rmajmax-rmajmin)/ndivmajor;; 648 Int_t ndivminor = 0;; 649 ; 650 chopt[0] = 0;; 651 strncat(chopt, ""SDH"", 4);; 652 if (fNdivRad < 0) strncat(chopt, ""N"",2);; 653 if(drawaxis){; 654 // Paint axis.; 655 TGaxis axis;; 656 axis.SetLabelSize(GetRadialLabelSize());; 657 axis.SetLabelColor(GetRadialColorLabel());; 658 axis.SetLabelFont(GetRadialLabelFont());; 659 axis.SetLabelOffset(GetRadialOffset());; 660 axis.PaintAxis(0, 0, TMath::Cos(GetAngle()), TMath::Sin(GetAngle()),; 661 umin, umax, ndiv, chopt, 0., kFALSE);; 662 }; 663 ; 664 // Paint Circles.; 665 // First paint main circle.; 666 PaintCircle(0.,0.,1,0.,360,0);; 667 // Optimised case.; 668 if (fNdivRad>0 ) {; 669 Double_t frwrmini = 0., frwrmaxi = 0., binWidth2 =0;; 670 THLimitsFinder::Optimize(frwrmin,frwrmin+binWidth,ndivMinor,frwrmini,; 671 frwrmaxi, ndivminor,binWidth2,"""");; 672 Double_t dist2 = dist/(ndivminor);; 673 // Paint major circles.; 674 for (i=1; i<=ndivmajor+2; i++) {; 675 TAttLine::SetLineStyle(1);; 676 TAttLine::Modify();; 677 PaintCircle(0.,0.,rmajmin,0.,360,0);; 678 ; 679 //Paint minor circles.; 680 TAttLine::SetLineStyle(2);; 681 TAttLine::Modify();; 682 for (j=1; j<ndivminor+1; j++) {; 683 if (rmajmin+j*dist2<=1) PaintCircle(0.,0.,rmajmin+j*dist2,0.,360,0);; 684 }; 685 rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:22567,Optimiz,Optimize,22567,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,1,['Optimiz'],['Optimize']
Performance," underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2073 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2106 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:49261,cache,cached,49261,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cached']
Performance," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(const TLinearFitter& tlf); TLinearFitter(TFormula* function, Option_t* opt = ""D""); TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:6672,perform,perform,6672,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,4,['perform'],['perform']
Performance," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLinearFitter.html:6672,perform,perform,6672,root/html602/TLinearFitter.html,https://root.cern,https://root.cern/root/html602/TLinearFitter.html,2,['perform'],['perform']
Performance," unique match. Bool_t recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); Recursively redirect all servers with new server in collection 'newSet'.; Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could be sucessfully; substituted. If recurseInNewSet is true, the recursion algorithm also recursion into; expression trees under the arguments in the new servers (i.e. those in newset). void registerProxy(RooArgProxy& proxy); Register an RooArgProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. The proxied argument is; also added as value and/or shape server. void unRegisterProxy(RooArgProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooSetProxy& proxy); Register an RooSetProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:25960,cache,cached,25960,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,7,['cache'],['cached']
Performance," unsigned int fNSlots {1};  ; std::vector< RDFInternal::RActionBase * > fRunActions;  Non-owning pointers to actions already run. ;  ; std::unordered_map< void *, ROOT::RDF::SampleCallback_t > fSampleCallbacks;  Registered callbacks to call at the beginning of each ""data block"". ;  ; std::vector< ROOT::RDF::RSampleInfo > fSampleInfos;  ; std::unordered_map< std::string, ROOT::RDF::Experimental::RSample * > fSampleMap;  Keys are fname + ""/"" + treename as RSampleInfo::fID; Values are pointers to the corresponding sample. ;  ; std::vector< ROOT::RDF::Experimental::RSample > fSamples;  Samples need to survive throughout the whole event loop, hence stored as an attribute. ;  ; std::vector< std::string > fSuppressErrorsForMissingBranches {};  ; std::shared_ptr< TTree > fTree {nullptr};  Shared pointer to the input TTree. ;  ; std::set< std::pair< std::string_view, std::unique_ptr< ROOT::Internal::RDF::RDefinesWithReaders > > > fUniqueDefinesWithReaders;  ; std::set< std::pair< std::string_view, std::unique_ptr< ROOT::Internal::RDF::RVariationsWithReaders > > > fUniqueVariationsWithReaders;  ; ColumnNames_t fValidBranchNames;  Cache of the tree/chain branch names. Never access directy, always use GetBranchNames(). ;  . Friends; struct RCallCleanUpTask;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Detail::RDF::RNodeBase; RLoopManager * fLoopManager;  ; unsigned int fNChildren {0};  Number of nodes of the functional graph hanging from this object. ;  ; unsigned int fNStopsReceived {0};  Number of times that a children node signaled to stop processing entries. ;  ; std::vector< std::string > fVariations;  List of systematic variations that affect this node. ;  . #include <ROOT/RDF/RLoopManager.hxx>. Inheritance diagram for ROOT::Detail::RDF::RLoopManager:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ColumnNames_t. using ROOT::Detail::RDF::RLoopManager::ColumnNames",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:10301,Cache,Cache,10301,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['Cache'],['Cache']
Performance," upper-left corner. Each window and pixmap has its own coordinate system.; Parameters. [in]parentthe parent window ; [in]x,ycoordinates, the top-left outside corner of the window's borders; relative to the inside of the parent window's borders ; [in]w,hwidth and height of the created window; do not include the created window's borders ; [in]borderthe border pixel value of the window ; [in]depththe window's depth ; [in]clssthe created window's class; can be InputOutput, InputOnly, or CopyFromParent ; [in]visualthe visual type ; [in]attrthe structure from which the values are to be taken. ; [in]wtypethe window type . Reimplemented from TVirtualX.; Definition at line 862 of file TGCocoa.mm. ◆ DeclFileName(). static const char * TGCocoa::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 476 of file TGCocoa.h. ◆ DeleteFont(). void TGCocoa::DeleteFont ; (; FontStruct_t ; fs). overridevirtual . Explicitly deletes the font structure ""fs"" obtained via LoadQueryFont(). ; Reimplemented from TVirtualX.; Definition at line 2835 of file TGCocoa.mm. ◆ DeleteGC(). void TGCocoa::DeleteGC ; (; GContext_t ; gc). overridevirtual . Deletes the specified GC ""gc"". ; Reimplemented from TVirtualX.; Definition at line 3099 of file TGCocoa.mm. ◆ DeleteImage(). void TGCocoa::DeleteImage ; (; Drawable_t ; img). overridevirtual . Deallocates the memory associated with the image img. ; Reimplemented from TVirtualX.; Definition at line 2633 of file TGCocoa.mm. ◆ DeleteOpenGLContext(). void TGCocoa::DeleteOpenGLContext ; (; Int_t ; wid). overridevirtual . Deletes OpenGL context for window ""wid"". ; Reimplemented from TVirtualX.; Definition at line 3419 of file TGCocoa.mm. ◆ DeletePictureData(). void TGCocoa::DeletePictureData ; (; void * ; data). overridevirtual . Delete picture data created by the function ReadPictureDataFromFile. ; Reimplemented from TVirtualX.; Definition at line 4239 of file TGCocoa.mm. ◆ DeletePixmap(). void TGCocoa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:69825,Load,LoadQueryFont,69825,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['Load'],['LoadQueryFont']
Performance," url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset); Int_tTProof::VerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:22664,cache,cachedir,22664,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,1,['cache'],['cachedir']
Performance," use TMVA Deep Learning for RNN"",; ); ; archString = ""GPU"" if useGPU else ""CPU""; ; writeOutputFile = True; ; rnn_type = ""RNN""; ; if ""tmva-pymva"" in ROOT.gROOT.GetConfigFeatures():; TMVA.PyMethodBase.PyInitialize(); else:; useKeras = False; ; ; ; inputFileName = ""time_data_t10_d30.root""; ; fileDoesNotExist = ROOT.gSystem.AccessPathName(inputFileName); ; # if file does not exists create it; if fileDoesNotExist:; MakeTimeData(nTotEvts, ntime, ninput); ; ; inputFile = TFile.Open(inputFileName); if inputFile is None:; raise ROOT.Error(""Error opening input file %s - exit"", inputFileName.Data()); ; ; print(""--- RNNClassification : Using input file: {}"".format(inputFile.GetName())); ; # Create a ROOT output file where TMVA will store ntuples, histograms, etc.; outfileName = ""data_RNN_"" + archString + "".root""; outputFile = None; ; ; if writeOutputFile:; outputFile = TFile.Open(outfileName, ""RECREATE""); ; ; ## Declare Factory; ; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; ; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to; # pass; ; # - The first argument is the base of the name of all the output; # weightfiles in the directory weight/ that will be created with the; # method parameters; ; # - The second argument is the output file for the training results; #; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; # the option string; ; ; # // Creating the factory object; factory = TMVA.Factory(; ""TMVAClassification"",; outputFile,; V=False,; Silent=False,; Color=True,; DrawProgressBar=True,; Transformations=None,; Correlations=False,; AnalysisType=""Classification"",; ModelPersistence=True,; ); dataloader = TMVA.DataLoader(""dataset""); ; signalTree = inputFile.Get(""sgn""); background = inputFile.Get(""bk",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:54252,perform,performance,54252,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance," used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCloseOK button; TGLayoutHints*fL1layout of TGTextEdit; TGLayoutHints*fL2layout of OK button; TGTextView*fTextViewText view widget; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionLogView(TSessionViewer* viewer, UInt_t w, UInt_t h); Create an editor in a dialog. ~TSessionLogView(). void SetTitle(); Set title in editor window. void Popup(); Show editor. void AddBuffer(const char* buffer); Load a text buffer in the editor. void ClearLogView(); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the editor. void LoadFile(const char* file); Load a file in the editor. void CloseWindow(); Called when closed via window manager action. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process OK button. » Author: Bertrand Bellenot, Gerri Ganis 15/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionLogView.html:22387,Load,Load,22387,root/html534/TSessionLogView.html,https://root.cern,https://root.cern/root/html534/TSessionLogView.html,5,['Load'],"['Load', 'LoadBuffer', 'LoadFile']"
Performance," using value_type = const Long64_t;; 69 using difference_type = Long64_t;; 70 using pointer = const Long64_t *;; 71 using const_pointer = const Long64_t *;; 72 using reference = const Long64_t &;; 73 ; 74 /// Default-initialize the iterator as ""past the end"".; 75 Iterator_t(): fEntry(-1), fReader(nullptr) {}; 76 ; 77 /// Initialize the iterator with the reader it steers and a; 78 /// tree entry number; -1 is invalid.; 79 Iterator_t(TTreeReader& reader, Long64_t entry):; 80 fEntry(entry), fReader(&reader) {}; 81 ; 82 /// Compare two iterators for equality.; 83 bool operator==(const Iterator_t &lhs) const; 84 {; 85 // From C++14: value initialized (past-end) it compare equal.; 86 if (!IsValid() && !lhs.IsValid()); 87 return true;; 88 // The iterators refer to different readers; 89 if (fReader != lhs.fReader); 90 return false;; 91 // #16249: range based loop and the tree has zero entries; 92 // as well as analogous cases.; 93 // Getting the number of events can have a cost, for example in; 94 // case of chains of remote files accessible with high latency.; 95 // However, it is reasonable to assume that if iterators are; 96 // being compared is because an iteration is taking place,; 97 // therefore such cost has to be paid anyway, it's just; 98 // anticipated.; 99 if (fReader->GetTree()->GetEntriesFast() == 0 && fEntry == 0 && !lhs.IsValid()) {; 100 return true;; 101 }; 102 if (lhs.fReader->GetTree()->GetEntriesFast() == 0 && lhs.fEntry == 0 && !IsValid()) {; 103 return true;; 104 }; 105 return fEntry == lhs.fEntry;; 106 }; 107 ; 108 /// Compare two iterators for inequality.; 109 bool operator!=(const Iterator_t& lhs) const {; 110 return !(*this == lhs);; 111 }; 112 ; 113 /// Increment the iterator (postfix i++).; 114 Iterator_t operator++(int) {; 115 Iterator_t ret = *this;; 116 this->operator++();; 117 return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:3324,latency,latency,3324,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['latency'],['latency']
Performance," validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; (TString) ""python3""[7]; Factory : Booking method: ␛[1mPyKeras_LSTM␛[0m; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Loading Keras Model ; : Loaded model from file: model_LSTM.h5; Factory : Booking method: ␛[1mBDTG␛[0m; : ; : the option NegWeightTreatment=InverseBoostNegWeights does not exist for BoostType=Grad; : --> change to new default NegWeightTreatment=Pray; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree sgn; : Using variable vars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:11922,Load,Loading,11922,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,2,['Load'],"['Loaded', 'Loading']"
Performance," value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; RooAbsPdf*sumPdf(const RooArgSet* nset); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:29242,cache,cache,29242,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,1,['cache'],['cache']
Performance," value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:45361,load,load,45361,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,6,['load'],['load']
Performance," value. ;  ; void AnimateImage (TGHtmlImage *image);  TGImage *img = image->image;. ;  ; void AppendBlock (TGHtmlElement *pToken, TGHtmlBlock *pBlock);  Append a block to the block list and insert the block into the element list immediately prior to the element given. ;  ; void AppendElement (TGHtmlElement *pElem);  Append the given TGHtmlElement to the tokenizers list of elements. ;  ; void AppendText (TGString *str, TGHtmlElement *pFirst, TGHtmlElement *pEnd);  Append all text and space tokens between pStart and pEnd to the given TString. ;  ; void AppToken (TGHtmlElement *pNew, TGHtmlElement *p, int offs);  Insert token pNew before token p. ;  ; TGHtmlElement * AttrElem (const char *name, char *value);  Returns html element matching attribute name and value. ;  ; void BlockDraw (TGHtmlBlock *pBlock, Drawable_t wid, int left, int top, int width, int height, Pixmap_t pixmap);  Display a single HtmlBlock. This is where all the drawing happens. ;  ;  ClassDefOverride (TGHtml, 0);  ; void ClearGcCache ();  Clear the cache of GCs. ;  ; float ColorDistance (ColorStruct_t *pA, ColorStruct_t *pB);  Compute the squared distance between two colors. ;  ; void ComputeVirtualSize ();  Computes virtual size of html area. ;  ; int ControlSize (TGHtmlInput *p);  This routine implements the Sizer() function for <INPUT>, <SELECT> and <TEXTAREA> markup. ;  ; int DecodeBaseIndex (const char *zBase, TGHtmlElement **ppToken, int *pIndex);  Given a base index name (without any modifiers) return a pointer to the token described, and the character within that token. ;  ; void DeleteControls ();  Delete all input controls. ;  ; void DrawImage (TGHtmlImageMarkup *image, Drawable_t wid, int left, int top, int right, int bottom);  Draw all or part of an image. ;  ; void DrawRect (Drawable_t drawable, TGHtmlElement *src, int x, int y, int w, int h, int depth, int relief);  Draw a rectangle. ;  ; void DrawSelectionBackground (TGHtmlBlock *pBlock, Drawable_t Drawable_t, int x, int y);  Draw the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:29400,cache,cache,29400,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['cache'],['cache']
Performance," value.; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2571 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2613 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2441 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2640 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possible values are:; """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:96810,cache,cache,96810,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['cache'],['cache']
Performance," value.; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2597 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2639 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2467 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2666 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:97364,cache,cache,97364,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['cache'],['cache']
Performance," valueTTreeprotected; kSetBranchStatus enum valueTTreeprotected; kSingleKey enum valueTObject; kSplitCollectionOfPointers enum valueTTree; kVoidPtr enum valueTTree; kWriteDelete enum valueTObject; kZombie enum valueTObject; LoadBaskets(Long64_t maxmemory=2000000000)TTreevirtual; LoadTree(Long64_t entry)TTreevirtual; LoadTreeFriend(Long64_t entry, TTree *T)TTreevirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeClass(const char *classname=nullptr, Option_t *option="""")TTreevirtual; MakeCode(const char *filename=nullptr)TTreevirtual; MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3)TTreevirtual; MakeSelector(const char *selector=nullptr, Option_t *option="""")TTreevirtual; MakeZombie()TObjectinlineprotected; MarkEventCluster()TTreeprivate; MayNotUse(const char *method) constTObject; MemoryFull(Int_t nbytes)TTree; Merge(TCollection *list, Option_t *option="""")TTreevirtual; Merge(TCollection *list, TFileMergeInfo *info)TTreevirtual; MergeTrees(TList *list, Option_t *option="""")TTreestatic; TAttLine::Modify()TAttLinevirtual; TAttFill::Modify()TAttFillvirtual; TAttMarker::Modify()TAttMarkervirtual; MoveReadCache(TFile *src, TDirectory *dir)TTreeprotected; Notify() overrideTTreevirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TNtuple &)=deleteTNtupleprivate; TTree::operator=(const TTree &tt)=deleteTTree; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple-members.html:18161,Optimiz,OptimizeBaskets,18161,doc/master/classTNtuple-members.html,https://root.cern,https://root.cern/doc/master/classTNtuple-members.html,1,['Optimiz'],['OptimizeBaskets']
Performance," values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPolyVar.html:30523,cache,cache,30523,root/html526/RooPolyVar.html,https://root.cern,https://root.cern/root/html526/RooPolyVar.html,2,['cache'],['cache']
Performance," values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooPolyVar.html:31190,cache,cache,31190,root/html530/RooPolyVar.html,https://root.cern,https://root.cern/root/html530/RooPolyVar.html,1,['cache'],['cache']
Performance," values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooPolyVar.html:31565,cache,cache,31565,root/html532/RooPolyVar.html,https://root.cern,https://root.cern/root/html532/RooPolyVar.html,1,['cache'],['cache']
Performance," values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooSetProxy_cacheObsVariables to be cached; Bool_t_cacheSourceKeep an attached clone of the source in the cache for fast operation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:35984,cache,cache,35984,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,2,['cache'],['cache']
Performance," vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; vector<Double_t>_sigma; Double_t_sigmaAvgR; TVectorD*_sigmaR; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Double_t_sqrt2pi; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooListProxy_varList; vector<std::string>_varName; Bool_t_verbose; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; map<Int_t,Double_t>_wMap; vector<std::vector<Double_t> >*_weights!; vector<std::vector<Double_t> >_weights0; vector<std::vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_xVarHiP3s; vector<Double_t>_xVarLo; vector<Double_t>_xVarLoM3s; vector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:45592,cache,cache,45592,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,1,['cache'],['cache']
Performance," vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; vector<Double_t>_sigma; Double_t_sigmaAvgR; TVectorD*_sigmaR; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Double_t_sqrt2pi; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooListProxy_varList; vector<string>_varName; Bool_t_verbose; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; map<Int_t,Double_t>_wMap; vector<vector<Double_t> >*_weights!; vector<vector<Double_t> >_weights0; vector<vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNDKeysPdf.html:42541,cache,cache,42541,root/html530/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html530/RooNDKeysPdf.html,2,['cache'],['cache']
Performance," verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsAnaConvPdf::makeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:34672,optimiz,optimizeDirtyHook,34672,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,6,['optimiz'],['optimizeDirtyHook']
Performance," version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:175017,load,loading,175017,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loading']
Performance," version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4685 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4686 // to indicates they are not yet properly protection against mutli-thread access.; 4687 //; 4688 // However, the use of these functions is rare and mostly done at library loading time which should; 4689 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterpreterMutex);; 4695 ; 4696 return GetStreamerInfoImpl(version, isTransient);; 4697};; 4698 ; 4699// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4700// This routine assumes the global lock has been taken.; 4701TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4702{; 4703 // Warning: version may be -1 for an emulated class, or -2 if the; 4704 // user requested the emulated streamerInfo for an abstract; 4705 // base class, even though we have a dictionary for it.; 4706 ; 4707 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4708 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4709 // FIXME: Shouldn't we go to -1 here, or better",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:177768,load,loading,177768,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loading']
Performance," version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDirDirectory containing info about known data sets; TDataSetManager*fDataSetManagerDataset manager; Bool_tfForkStartupStartup N-1 workers forking the first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TStringfSandboxPROOF sandbox root dir; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configuration",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:24061,cache,cache,24061,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cache']
Performance," via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:3421,cache,cache,3421,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance," via the GetEntryList() or some other function, they have to add it to the current directory to be able to use it in TTreeFormula expressions. TEntryList and TEventList; TTree::SetEventList() and TChain::SetEventList() transform a TEventList into a TEntryList See comments to those functions for more details. Types of entry lists; There are two types of entry lists:; 1.; for a TTree (fBlocks data member is non-zero) Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored in the TObjArray fBlocks. The range of the entry numbers is cut into intervals of kBlockSize entries (currently 64000), so that the first block contains information which entries out of the first 64000 pass the selection, the second block - which entries out of the 64000-127999 interval pass the selection, etc. Some blocks, obviously, might be empty. The internal representation of entry numbers in the blocks is described in the TEntryListBlock class description, and this representation might be changed by calling OptimizeStorage() function (when the list is filled via the Enter() function, this is done automatically, except for the last block). Individual entry lists can be merged (functions Merge() and Add()) to make an entry list for a TChain of corresponding TTrees. 2.; for a TChain (fLists data member is non-zero) It contains a TList of sub-lists (TEntryList objects, corresponding to each TTree) Trees and lists are matched by the TTree name and its file name (full path). All sub-lists are returned by the GetLists() function and individual lists are returned by GetEntryList() function. Such lists are no different from the lists for TTrees, described above. Definition at line 25 of file TEntryList.h. Public Types; enum  { kBlockSize = 64000; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:7128,Optimiz,OptimizeStorage,7128,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['Optimiz'],['OptimizeStorage']
Performance," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientFunctionOneDim.html:2108,Optimiz,Optimized,2108,root/html526/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientFunctionOneDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html:2110,Optimiz,Optimized,2110,root/html530/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction, ROOT::Math::GradFunctor1D::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IGradientFunctionOneDim.html:2108,Optimiz,Optimized,2108,root/html528/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IGradientFunctionOneDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction, ROOT::Math::GradFunctor1D::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IGradientFunctionOneDim.html:2110,Optimiz,Optimized,2110,root/html532/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IGradientFunctionOneDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance," viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HypoTestInverter. class RooStats::HypoTestInverter: public RooStats::IntervalCalculator. HypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of an; HypoTestCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverter::UseCLs has been called). Contributions to this class have been written by Giovanni Petrucciani and Annapaola Decosa. Function Members (Methods); public:. virtual~HypoTestInverter(); static TClass*Class(); voidClear(); virtual Double_tConfidenceLevel() const; RooStats::HypoTestCalculatorGeneric*GetHypoTestCalculator() const; virtual RooStats::HypoTestInverterResult*GetInterval() const; RooStats::SamplingDistribution*GetLowerLimitDistribution(bool rebuild = false, int nToys = 100); RooStats::TestStatistic*GetTestStatistic() const; RooStats::SamplingDistribution*GetUpperLimitDistribution(bool rebuild = false, int nToys = 100); RooStats::HypoTestInverterHypoTestInverter(); RooStats::HypoTestInverterHypoTestInverter(RooStats::HypoTestCalcu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:1108,perform,perform,1108,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,5,['perform'],['perform']
Performance," viewer.; 9.13.1 Invoking a 3D viewer; A 3D viewer can be created in a script by passing the appropriate option to Draw()when attaching the drawn object(s) to a pad. For a fuller explanation of pads, attaching objects with Draw() etc. refer to “Graphical Containers: Canvas and Pad”.; root[] myShapes->Draw(""ogl"");; Valid option strings are:. “ogl” : external GL viewer; “x3d”: external X3D viewer; “pad”: pad viewer. If no option is passed to Draw() then the “pad” is used by default. If you already have content in a pad, which you would like to display in one of the external viewers you can select from the canvas View menu / View With, and pick the viewer type. Invoking external 3D viewers from canvas menus. Note: A current limitation means that when an external viewer is created the pad is no longer redrawn. When the external viewer is closed, clicking in the pad will refresh.; 9.13.2 The GL Viewer; The GL Viewer uses <OpenGL®> (or compliant libraries such as ) to generate high quality, high-performance 3D renderings, with sophisticated lighting, materials and rendering styles for 3D scenes. Many users will be able to take advantage of hardware acceleration of the underlying OpenGL commands by their computer’s video card, resulting is considerable performance gains - up to interactive manipulation of 1000’s of complex shapes in real-time.; The GL Viewer is supported on all official ROOT platforms (assuming you have suitable <OpenGL®> libraries), and is the main 3D viewer, which development effort is concentrated upon. As OpenGL® is a trademark we refer to our viewer built on this technology as the ‘GL Viewer’. The code for it can be found under $ROOTSYS/gl. The GL 3D Viewer. You can manipulate the viewer via the GUI or via the base TGLViewer object behind the interface. These are detailed below - see also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.1 Projections Modes (Cameras); The GL Viewer supports two basic types of camera, which affect how the 3D world is p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:387387,perform,performance,387387,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance," virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t operator()(const Double_t[] xvector) const; Evaluate our analytic integral at the specified values of the dependents. inline RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); { }. virtual ~RooRealAnalytic();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealAnalytic.html:1658,load,loadValues,1658,root/html602/RooRealAnalytic.html,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html,2,['load'],['loadValues']
Performance," virtual Double_t FindBlocking (TQpVar *step, Double_t &primalValue, Double_t &primalStep, Double_t &dualValue, Double_t &dualStep, Int_t &firstOrSecond);  Performs the same function as StepBound, and supplies additional information about which component of the nonnegative variables is responsible for restricting alpha. ;  ; virtual Double_t GetMu ();  compute complementarity gap, obtained by taking the inner product of the complementary vectors and dividing by the total number of components computes mu = (t'lambda +u'pi + v'gamma + w'phi)/(mclow+mcupp+nxlow+nxupp) ;  ; virtual void InteriorPoint (Double_t alpha, Double_t beta);  Sets components of (u,t,v,w) to alpha and of (lambda,pi,phi,gamma) to beta. ;  ; virtual Bool_t IsInteriorPoint ();  Is the current position an interior point ? ;  ; virtual Double_t MuStep (TQpVar *step, Double_t alpha);  Compute the complementarity gap resulting from a step of length ""alpha"" along direction ""step"". ;  ; virtual void Negate ();  Perform a ""negate"" operation on all data vectors : x = -x. ;  ; virtual Double_t Norm1 ();  Return the sum of the vector-norm1's. ;  ; virtual Double_t NormInf ();  Return the sum of the vector-normInf's. ;  ; TQpVar & operator= (const TQpVar &source);  Assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print class members. ;  ; virtual void Saxpy (TQpVar *b, Double_t alpha);  Perform a ""saxpy"" operation on all data vectors : x += alpha*y. ;  ; virtual void ShiftBoundVariables (Double_t alpha, Double_t beta);  Add alpha to components of (u,t,v,w) and beta to components of (lambda,pi,phi,gamma) ;  ; virtual Double_t StepBound (TQpVar *b);  calculate the largest alpha in (0,1] such that the/ nonnegative variables stay nonnegative in the given search direction. ;  ; virtual Bool_t ValidNonZeroPattern ();  Check that the variables conform to the non-zero indices. ;  ; virtual Double_t Violation ();  The amount by which the current variables violate the non-negativity constraints",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQpVar.html:2891,Perform,Perform,2891,doc/master/classTQpVar.html,https://root.cern,https://root.cern/doc/master/classTQpVar.html,1,['Perform'],['Perform']
Performance," virtual Int_tTNetFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCastorFile.html:13086,cache,cache,13086,root/html532/TCastorFile.html,https://root.cern,https://root.cern/root/html532/TCastorFile.html,1,['cache'],['cache']
Performance," virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:12461,cache,cache,12461,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,2,['cache'],['cache']
Performance," virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:13929,cache,cache,13929,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['cache'],['cache']
Performance," virtual Int_t CheckByteCount (UInt_t startpos, UInt_t bcnt, const char *classname)=0;  ; virtual Int_t CheckByteCount (UInt_t startpos, UInt_t bcnt, const TClass *clss)=0;  ; virtual void ClassBegin (const TClass *, Version_t=-1)=0;  ; virtual void ClassEnd (const TClass *)=0;  ; virtual void ClassMember (const char *, const char *=nullptr, Int_t=-1, Int_t=-1)=0;  ; virtual void DecrementLevel (TVirtualStreamerInfo *)=0;  ; void DetachBuffer ();  ; void Expand (Int_t newsize, Bool_t copy=kTRUE);  Expand (or shrink) the I/O buffer to newsize bytes. ;  ; Int_t GetBufferVersion () const;  ; char * GetCurrent () const;  ; virtual TVirtualStreamerInfo * GetInfo ()=0;  ; TObject * GetParent () const;  Return pointer to parent of this buffer. ;  ; ReAllocCharFun_t GetReAllocFunc () const;  Return the reallocation method currently used. ;  ; virtual void IncrementLevel (TVirtualStreamerInfo *info)=0;  ; Bool_t IsReading () const;  ; Bool_t IsWriting () const;  ; Int_t Length () const;  ; virtual TVirtualArray * PeekDataCache () const;  Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual TVirtualArray * PopDataCache ();  Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual void PushDataCache (TVirtualArray *);  Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ;  ; virtual Int_t ReadArray (Bool_t *&b)=0;  ; virtual Int_t ReadArray (Char_t *&c)=0;  ; virtual Int_t ReadArray (Double_t *&d)=0;  ; virtual Int_t ReadArray (Float_t *&f)=0;  ; virtual Int_t ReadArray (Int_t *&i)=0;  ; virtual Int_t ReadArray (Long64_t *&l)=0;  ; virtual Int_t ReadArray (Long_t *&l)=0;  ; virtual Int_t ReadArray (Short_t *&h)=0;  ; virtual Int_t ReadArray (UChar_t *&c)=0;  ; virtual Int_t ReadArray (UInt_t *&i)=0;  ; virtual Int_t ReadArray (ULong64_t *&l)=0;  ; virtual Int_t ReadArray ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:7324,cache,cache,7324,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cache']
Performance," virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Mon Dec 7 13:49:41 2009 » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:14211,cache,cached,14211,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,2,['cache'],['cached']
Performance," virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetFile.html:12447,cache,cache,12447,root/html530/TXNetFile.html,https://root.cern,https://root.cern/root/html530/TXNetFile.html,1,['cache'],['cache']
Performance," virtual void TFile::SetReadCalls ; (; Int_t ; readcalls = 0). inlinevirtual . Definition at line 290 of file TFile.h. ◆ SetReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one can still read the StreamerInfo with myfile.ReadStreamerInfo(); ; Definition at line 3732 of file TFile.cxx. ◆ ShowStreamerInfo(). void TFile::ShowStreamerInfo ; (; ). virtual . Show the StreamerInfo of all classes written to this file. ; Definition at line 3750 of file TFile.cxx. ◆ ShrinkCacheFileDir(). Bool_t TFile::ShrinkCacheFileDir ; (; Long64_t ; shrinksize, . Long_t ; cleanupinterval = 0 . ). static . Try to shrink the cache to the desired size. ; With the clenupinterval you can specify the minimum amount of time after the previous cleanup before the cleanup operation is repeated in the cache directory ; Definition at line 4666 of file TFile.cxx. ◆ Sizeof(). Int_t TFile::Sizeof ; (; ); const. overridevirtual . Return the size in bytes of the file header. ; Reimplemented from TDirectoryFile.; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2397 of file TFile.cxx. ◆ Streamer(). void TFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TDirectoryFile.; Reimplemented in TMemFile, TSQLFile, TXMLFile, TNetFile, TParallelMergingFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 2405 of file TFile.cxx. ◆ StreamerNVirtual(). void TFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 344 of file TFile.h. ◆ SumBuffer(). void TFile::SumBuffer ; (; Int_t ; bufsize). Increment statistics for buffer siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:96293,cache,cache,96293,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,1,['cache'],['cache']
Performance," virtual void TFile::SetReadCalls ; (; Int_t ; readcalls = 0). inlinevirtual . Definition at line 290 of file TFile.h. ◆ SetReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one can still read the StreamerInfo with myfile.ReadStreamerInfo(); ; Definition at line 3732 of file TFile.cxx. ◆ ShowStreamerInfo(). void TFile::ShowStreamerInfo ; (; ). virtual . Show the StreamerInfo of all classes written to this file. ; Definition at line 3750 of file TFile.cxx. ◆ ShrinkCacheFileDir(). Bool_t TFile::ShrinkCacheFileDir ; (; Long64_t ; shrinksize, . Long_t ; cleanupinterval = 0 . ). static . Try to shrink the cache to the desired size. ; With the clenupinterval you can specify the minimum amount of time after the previous cleanup before the cleanup operation is repeated in the cache directory ; Definition at line 4666 of file TFile.cxx. ◆ Sizeof(). Int_t TFile::Sizeof ; (; ); const. overridevirtual . Return the size in bytes of the file header. ; Reimplemented from TDirectoryFile.; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2397 of file TFile.cxx. ◆ Streamer(). void TFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TDirectoryFile.; Reimplemented in TXNetFile, TMemFile, TSQLFile, TXMLFile, TNetFile, TParallelMergingFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 2405 of file TFile.cxx. ◆ StreamerNVirtual(). void TFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 344 of file TFile.h. ◆ SumBuffer(). void TFile::SumBuffer ; (; Int_t ; bufsize). Increment statistics for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:96449,cache,cache,96449,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['cache'],['cache']
Performance," virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t* xvector, Bool_t clipInvalid = kFALSE) const. Data Members; protected:. Bool_t_clipInvalidIf true, invalid x values are clipped into their valid range; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_funcPointer to input function; const RooAbsReal*_modelPointer to input resolution model; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nsetNormalization set to be used for function evaluations; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_varsArray of pointers to variables; Bool_t_xvecValidIf true _xvec defines a valid point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvIntegrandBinding(const RooAbsReal& func, const RooAbsReal& model, RooAbsReal& x, RooAbsReal& xprime, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE); Constructor where func and model. 'func' = func(xprime); 'model' = model(xprime). and. ~RooConvIntegrandBinding(); Destructor. void loadValues(const Double_t* xvector, Bool_t clipInvalid = kFALSE) const; Load external input values. Double_t operator()(const Double_t* xvector) const; Evaluate self at given parameter values. Double_t getMinLimit(UInt_t dimension) const; Retrieve lower limit of i-th observable. Double_t getMaxLimit(UInt_t dimension) const; Retrieve upper limit of i-th observable. RooConvIntegrandBinding(const RooAbsReal& func, const RooAbsReal& model, RooAbsReal& x, RooAbsReal& xprime, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE). void setNormalizationSet(const RooArgSet* nset); Use the supplied nset as normalization set for calls to func and model. » Last changed: Tue Mar 10 17:16:07 2015 » Last generated: 2015-03-10 17:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConvIntegrandBinding.html:2756,load,loadValues,2756,root/html534/RooConvIntegrandBinding.html,https://root.cern,https://root.cern/root/html534/RooConvIntegrandBinding.html,2,"['Load', 'load']","['Load', 'loadValues']"
Performance," virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; TPointSet3DGL&operator=(const TPointSet3DGL&); TPointSet3DGL&operator=(TPointSet3DGL&&); virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TPointSet3DGL(); TPointSet3DGL(const TPointSet3DGL&); TPointSet3DGL(TPointSet3DGL&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPointSet3DGL.html:1925,cache,cached,1925,root/html602/TPointSet3DGL.html,https://root.cern,https://root.cern/root/html602/TPointSet3DGL.html,2,['cache'],['cached']
Performance," virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:16519,cache,cache,16519,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance," virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGlobalBoundary(double boundary); static voidRooAbsReal::setHideOffset(Bool_t flag); voidsetHigh(RooAbsReal& param, Double_t newHigh); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpCode(RooAbsReal& param, int code); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; voidsetLow(RooAbsReal& param, Double_t newLow); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNominal(Double_t newNominal); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html:24928,cache,cache,24928,root/html534/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html,3,['cache'],['cache']
Performance," virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedReal.html:22951,cache,cache,22951,root/html530/RooCachedReal.html,https://root.cern,https://root.cern/root/html530/RooCachedReal.html,1,['cache'],['cache']
Performance," virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore& vstore); TStringRooAbsArg::cleanBranchName() const; voidclearTypes(); virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*defineType(const char* label); const RooCatType*defineType(const char* label, Int_t index); const RooCatType*defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidfillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tisValid() const; virtual Bool_tisValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); RooCatTypetraceEval() const; virtual Bool_ttraceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:18280,optimiz,optimizeDirtyHook,18280,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance," virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  . #include <TParallelCoordRange.h>. Inheritance diagram for TParallelCoordSelect:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkActivated ; kShowRanges . Definition at line 71 of file TParallelCoordRange.h. Constructor & Destructor Documentation. ◆ TParallelCoordSelect() [1/2]. TParallelCoordSelect::TParallelCoordSelect ; (; ). Default constructor. ; Definition at line 472 of file TParallelCoordRange.cxx. ◆ TParallelCoordSelect() [2/2]. TParallelCoordSelect::TParallelCoordSelect ; (; const char * ; title",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoordSelect.html:21953,cache,cache,21953,doc/master/classTParallelCoordSelect.html,https://root.cern,https://root.cern/doc/master/classTParallelCoordSelect.html,1,['cache'],['cache']
Performance," virtual void PropagateRnrStateToProjecteds ();  Propagate render state to the projected replicas of this element. ;  ; virtual void PropagateVizParamsToElements (TEveElement *el=nullptr);  Propagate visualization parameters from element el (defaulting to this) to all elements (children). ;  ; virtual void PropagateVizParamsToProjecteds ();  Propagate visualization parameters to dependent elements. ;  ; virtual TEveTrans * PtrMainTrans (Bool_t create=kTRUE);  Return pointer to main transformation. ;  ; void RecheckImpliedSelections ();  Call this if it is possible that implied-selection or highlight has changed for this element or for implied-selection this element is member of and you want to maintain consistent selection state. ;  ; const List_t & RefChildren () const;  ; virtual TEveTrans & RefMainTrans ();  Return reference to main transformation. ;  ; virtual void RemoveElement (TEveElement *el);  Remove el from the list of children. ;  ; virtual void RemoveElementLocal (TEveElement *el);  Perform additional local removal of el. ;  ; virtual void RemoveElements ();  Remove all elements. ;  ; virtual void RemoveElementsLocal ();  Perform additional local removal of all elements. ;  ; virtual Bool_t RemoveFromListTree (TGListTree *ltree, TGListTreeItem *parent_lti);  Remove element from list-tree 'ltree' where its parent item is 'parent_lti'. ;  ; virtual Int_t RemoveFromListTrees (TEveElement *parent);  Remove element from all list-trees where 'parent' is the user-data of the parent list-tree-item. ;  ; virtual void RemoveParent (TEveElement *re);  Remove re from the list of parents. ;  ; void ResetAllCSCBits ();  ; void ResetCSCBits (UChar_t f);  ; void SaveVizParams (std::ostream &out, const TString &tag, const TString &var);  Save visualization parameters for this element with given tag. ;  ; virtual void SelectElement (Bool_t state);  Set element's selection state. Stamp appropriately. ;  ; void SetCompound (TEveCompound *c);  ; void SetCSCBits (UChar_t f);  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveArrow.html:13049,Perform,Perform,13049,doc/master/classTEveArrow.html,https://root.cern,https://root.cern/doc/master/classTEveArrow.html,51,['Perform'],['Perform']
Performance," virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:2079,cache,cacheUniqueSuffix,2079,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,5,"['Cache', 'cache']","['CacheModecanNodeBeCached', 'cacheUniqueSuffix']"
Performance," virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:2074,cache,cacheUniqueSuffix,2074,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,4,"['Cache', 'cache']","['CacheModecanNodeBeCached', 'cacheUniqueSuffix']"
Performance," virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:1792,cache,cacheUniqueSuffix,1792,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,1,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:1792,cache,cacheUniqueSuffix,1792,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,3,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:1787,cache,cacheUniqueSuffix,1787,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:1833,Cache,CacheModeRooAbsArg,1833,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['Cache'],['CacheModeRooAbsArg']
Performance," virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:1861,cache,cacheUniqueSuffix,1861,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDepende",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:1861,cache,cacheUniqueSuffix,1861,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,3,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:1856,cache,cacheUniqueSuffix,1856,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsDataStore.html:1047,cache,cachedVars,1047,root/html532/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html532/RooAbsDataStore.html,4,['cache'],"['cacheOwner', 'cachedVars']"
Performance," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsDataStore.html:1047,cache,cachedVars,1047,root/html534/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html,12,['cache'],"['cacheOwner', 'cachedVars']"
Performance," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsDataStore.html:995,cache,cachedVars,995,root/html526/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html526/RooAbsDataStore.html,12,['cache'],"['cacheOwner', 'cachedVars']"
Performance," virtual~RooAbsString(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:1620,cache,cacheUniqueSuffix,1620,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,1,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsString(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsString.html:1620,cache,cacheUniqueSuffix,1620,root/html528/RooAbsString.html,https://root.cern,https://root.cern/root/html528/RooAbsString.html,3,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooAbsString(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:1615,cache,cacheUniqueSuffix,1615,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,4,"['Cache', 'cache']","['CacheModeRooAbsArg', 'cacheUniqueSuffix']"
Performance," virtual~RooBinningCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:1415,cache,cacheUniqueSuffix,1415,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooCompositeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidRooAbsDataStore::checkInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCompositeDataStore.html:1067,cache,cachedVars,1067,root/html602/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html602/RooCompositeDataStore.html,4,['cache'],"['cacheOwner', 'cachedVars']"
Performance," virtual~RooMappedCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:1311,cache,cacheUniqueSuffix,1311,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooMultiCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiCategory.html:1608,cache,cacheUniqueSuffix,1608,root/html602/RooMultiCategory.html,https://root.cern,https://root.cern/root/html602/RooMultiCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); static Bool_tclearObsList(); static voiddoClearObsList(Bool_t flag); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:987,cache,cacheSize,987,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,2,['cache'],['cacheSize']
Performance," virtual~RooStringVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStringVar.html:1342,cache,cacheUniqueSuffix,1342,root/html602/RooStringVar.html,https://root.cern,https://root.cern/root/html602/RooStringVar.html,4,"['Cache', 'cache']","['CacheModeRooAbsArg', 'cacheUniqueSuffix']"
Performance," virtual~RooSuperCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:1903,cache,cacheUniqueSuffix,1903,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,2,['cache'],['cacheUniqueSuffix']
Performance," virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeDataStore.html:1042,cache,cachedVars,1042,root/html602/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html602/RooTreeDataStore.html,4,['cache'],"['cacheOwner', 'cachedVars']"
Performance," virtual~RooVectorDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); const RooVectorDataStore*cache() const; virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidRooAbsDataStore::checkInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVectorDataStore.html:919,cache,cachedVars,919,root/html602/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html602/RooVectorDataStore.html,8,['cache'],"['cache', 'cacheOwner', 'cachedVars']"
Performance," virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:1385,latency,latency,1385,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,4,"['cache', 'latency']","['cachesz', 'latency']"
Performance," virtual~TQtPadFont(); static const char*ArialFontName(); boolQFont::bold() const; static voidQFont::cacheStatistics(); QFont::CapitalizationQFont::capitalization() const; static TClass*Class(); static voidQFont::cleanup(); voidTAttText::Copy(TAttText& atttext) const; static const char*CourierFontName(); QStringQFont::defaultFamily() const; boolQFont::exactMatch() const; QStringQFont::family() const; boolQFont::fixedPitch() const; FT_FaceQFont::freetypeFace() const; boolQFont::fromString(const QString&); virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() const; virtual Color_tTAttText::GetTextColor() const; virtual Font_tTAttText::GetTextFont() const; virtual Float_tTAttText::GetTextSize() const; Qt::HANDLEQFont::handle() const; QFont::HintingPreferenceQFont::hintingPreference() const; static voidQFont::initialize(); static voidQFont::insertSubstitution(const QString&, const QString&); static voidQFont::insertSubstitutions(const QString&, const QStringList&); virtual TClass*IsA() const; boolQFont::isCopyOf(const QFont&) const; boolQFont::italic() const; boolQFont::kerning() const; QStringQFont::key() const; QStringQFont::lastResortFamily() const; QStringQFont::lastResortFont() const; qrealQFont::letterSpacing() const; QFont::SpacingTypeQFont::letterSpacingType() const; virtual voidTAttText::Modify(); QVariantQFont::operator QVariant() const; boolQFont::operator!=(const QFont&) const; boolQFont::operator<(const QFont&) const; TQtPadFont&operator=(const TQtPadFont&); boolQFont::operator==(const QFont&) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtPadFont.html:538,cache,cacheStatistics,538,root/html602/TQtPadFont.html,https://root.cern,https://root.cern/root/html602/TQtPadFont.html,1,['cache'],['cacheStatistics']
Performance," virtual~TQtPadFont(); static const char*ArialFontName(); boolQFont::bold() const; static voidQFont::cacheStatistics(); QFont::CapitalizationQFont::capitalization() const; static TClass*Class(); static voidQFont::cleanup(); voidTAttText::Copy(TAttText& atttext) const; static const char*CourierFontName(); QStringQFont::defaultFamily() const; boolQFont::exactMatch() const; QStringQFont::family() const; boolQFont::fixedPitch() const; FT_FaceQFont::freetypeFace() const; boolQFont::fromString(const QString&); virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() const; virtual Color_tTAttText::GetTextColor() const; virtual Font_tTAttText::GetTextFont() const; virtual Float_tTAttText::GetTextSize() const; Qt::HANDLEQFont::handle() const; QFont::HintingPreferenceQFont::hintingPreference() const; static voidQFont::initialize(); static voidQFont::insertSubstitution(const QString&, const QString&); static voidQFont::insertSubstitutions(const QString&, const QStringList&); virtual TClass*IsA() const; boolQFont::isCopyOf(const QFont&) const; boolQFont::italic() const; boolQFont::kerning() const; QStringQFont::key() const; QStringQFont::lastResortFamily() const; QStringQFont::lastResortFont() const; qrealQFont::letterSpacing() const; QFont::SpacingTypeQFont::letterSpacingType() const; virtual voidTAttText::Modify(); QVariantQFont::operator QVariant() const; boolQFont::operator!=(const QFont&) const; boolQFont::operator<(const QFont&) const; TQtPadFont&operator=(const TQtPadFont&); boolQFont::operator==(const QFont&) const; boolQFont::overline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQtPadFont.html:514,cache,cacheStatistics,514,root/html604/TQtPadFont.html,https://root.cern,https://root.cern/root/html604/TQtPadFont.html,1,['cache'],['cacheStatistics']
Performance," visited, . bool ; recurse . ). protected . From the second level of recursion onwards it is different state check. ; Definition at line 3990 of file TClass.cxx. ◆ GetNdata(). Int_t TClass::GetNdata ; (; ). Return the number of data members of this class Note that in case the list of data members is not yet created, it will be done by GetListOfDataMembers(). ; Definition at line 4554 of file TClass.cxx. ◆ GetNew(). ROOT::NewFunc_t TClass::GetNew ; (; ); const. Return the wrapper around new ThisClass(). ; Definition at line 7447 of file TClass.cxx. ◆ GetNewArray(). ROOT::NewArrFunc_t TClass::GetNewArray ; (; ); const. Return the wrapper around new ThisClass[]. ; Definition at line 7455 of file TClass.cxx. ◆ GetNmethods(). Int_t TClass::GetNmethods ; (; ). Return the number of methods of this class Note that in case the list of methods is not yet created, it will be done by GetListOfMethods(). ; This will also load/populate the list of methods, to get 'just' the number of currently loaded methods use: cl->GetListOfMethods(false)->GetSize(); ; Definition at line 4573 of file TClass.cxx. ◆ GetPersistentRef(). TClass *const * TClass::GetPersistentRef ; (; ); const. inline . Definition at line 481 of file TClass.h. ◆ GetRealData(). TRealData * TClass::GetRealData ; (; const char * ; name); const. Return pointer to TRealData element with name ""name"". ; Name can be a data member in the class itself, one of its base classes, or a member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built. ; Definition at line 3503 of file TClass.cxx. ◆ GetReferenceProxy(). TVirtualRefProxy * TClass::GetReferenceProxy ; (; ); const. inline . Definition at line 483 of file TClass.h. ◆ GetResetAfterMerge(). ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7439 of file TClass.cxx. ◆ GetSchemaRules() [1/2]. const ROOT::Detail::TSchemaRuleSet * TClass::GetSchemaRules ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:88931,load,load,88931,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['load'],"['load', 'loaded']"
Performance," visited, . bool ; recurse . ). protected . From the second level of recursion onwards it is different state check. ; Definition at line 4057 of file TClass.cxx. ◆ GetNdata(). Int_t TClass::GetNdata ; (; ). Return the number of data members of this class Note that in case the list of data members is not yet created, it will be done by GetListOfDataMembers(). ; Definition at line 4621 of file TClass.cxx. ◆ GetNew(). ROOT::NewFunc_t TClass::GetNew ; (; ); const. Return the wrapper around new ThisClass(). ; Definition at line 7514 of file TClass.cxx. ◆ GetNewArray(). ROOT::NewArrFunc_t TClass::GetNewArray ; (; ); const. Return the wrapper around new ThisClass[]. ; Definition at line 7522 of file TClass.cxx. ◆ GetNmethods(). Int_t TClass::GetNmethods ; (; ). Return the number of methods of this class Note that in case the list of methods is not yet created, it will be done by GetListOfMethods(). ; This will also load/populate the list of methods, to get 'just' the number of currently loaded methods use: cl->GetListOfMethods(false)->GetSize(); ; Definition at line 4640 of file TClass.cxx. ◆ GetPersistentRef(). TClass *const * TClass::GetPersistentRef ; (; ); const. inline . Definition at line 481 of file TClass.h. ◆ GetRealData(). TRealData * TClass::GetRealData ; (; const char * ; name); const. Return pointer to TRealData element with name ""name"". ; Name can be a data member in the class itself, one of its base classes, or a member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built. ; Definition at line 3570 of file TClass.cxx. ◆ GetReferenceProxy(). TVirtualRefProxy * TClass::GetReferenceProxy ; (; ); const. inline . Definition at line 483 of file TClass.h. ◆ GetResetAfterMerge(). ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7506 of file TClass.cxx. ◆ GetSchemaRules() [1/2]. const ROOT::Detail::TSchemaRuleSet * TClass::GetSchemaRules ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:88932,load,load,88932,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,2,['load'],"['load', 'loaded']"
Performance," visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); static TClass*LoadClassCustom(const char* requestedname, Bool_t silent); static TClass*LoadClassDefault(const char* requestedname, Bool_t silent); voidLoadClassInfo() const; TClass&operator=(const TClass&); voidSetClassSize(Int_t sizof); voidSetClassVersion(Version_t version); voidSetStreamerImpl(); static voidStreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerExternal(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObject(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectEmulated(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectInitialized(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TClass(const TClass& tc). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TDictionary::ESTLTypeTDictionary::k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:16130,Load,LoadClassCustom,16130,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['Load'],"['LoadClassCustom', 'LoadClassDefault']"
Performance," void * New() constConstruct a new container object and return its address.Definition TVirtualCollectionProxy.h:111; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::Atvirtual void * At(UInt_t idx)=0Return the address of the value at index idx; TVirtualCollectionProxy::GetCollectionTypevirtual Int_t GetCollectionType() const =0Return the type of the proxied collection (see enumeration TClassEdit::ESTLType); TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; TVirtualStreamerInfo::fIsBuiltBool_t fIsBuilttrue if the StreamerInfo has been optimizedDefinition TVirtualStreamerInfo.h:48; TVirtualStreamerInfo::ForceWriteInfovirtual void ForceWriteInfo(TFile *file, Bool_t force=kFALSE)=0; TVirtualStreamerInfo::IsCompiledBool_t IsCompiled() constDefinition TVirtualStreamerInfo.h:173; TVirtualStreamerInfo::fIsCompiledstd::atomic< Bool_t > fIsCompiledtrue if the StreamerInfo has been 'built' (i.e. has all the StreamerElements it should have)Definition TVirtualStreamerInfo.h:49; TVirtualStreamerInfo::GetElementCounterStartstatic const char * GetElementCounterStart(const char *dmTitle)Given a comment/title declaring an array counter, for example:Definition TVirtualStreamerInfo.cxx:99; TVirtualStreamerInfo::EReadWriteEReadWriteEReadWrite Enumerator.Definition TVirtualStreamerInfo.h:116; TVirtualStreamerInfo::kStreamer@ kStreamerDefinition TVirtualStreamerInfo.h:130; TVirtualStreamerInfo::kULong64@ kULong64Definition TVirtualStreamerInfo.h:122; TVirtualStreamerInfo::kObjectp@ kObjectpDefinition TVirtualStreame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:294650,optimiz,optimizedDefinition,294650,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['optimiz'],['optimizedDefinition']
Performance," void ClearNavigators(); Clear all navigators. void RemoveNavigator(const TGeoNavigator* nav); Clear a single navigator. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START; and having size STEP. The created volumes will have tracking; media ID=NUMED (if N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:39172,cache,cache,39172,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,1,['cache'],['cache']
Performance," void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:13195,cache,cache,13195,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,3,['cache'],['cache']
Performance," void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& b); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:126029,Perform,Perform,126029,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['Perform'],['Perform']
Performance," void TBuffer::MapObject ; (; const TObject * ; obj, . UInt_t ; offset = 1 . ). pure virtual . Implemented in TBufferIO. ◆ MapObject() [2/2]. virtual void TBuffer::MapObject ; (; const void * ; obj, . const TClass * ; cl, . UInt_t ; offset = 1 . ). pure virtual . Implemented in TBufferIO. ◆ operator=(). void TBuffer::operator= ; (; const TBuffer & ; ). protecteddelete . ◆ PeekDataCache(). TVirtualArray * TBuffer::PeekDataCache ; (; ); const. virtual . Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ; Definition at line 371 of file TBuffer.cxx. ◆ PopDataCache(). TVirtualArray * TBuffer::PopDataCache ; (; ). virtual . Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ; Definition at line 381 of file TBuffer.cxx. ◆ PushDataCache(). void TBuffer::PushDataCache ; (; TVirtualArray * ; obj). virtual . Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ; Definition at line 362 of file TBuffer.cxx. ◆ Read(). Int_t TBuffer::Read ; (; const char * ; name). inlineoverrideprotectedvirtual . Read contents of object with specified name from the current directory. ; First the key with the given name is searched in the current directory, next the key buffer is deserialized into the object. The object must have been created before via the default constructor. See TObject::Write(). ; Reimplemented from TObject.; Definition at line 66 of file TBuffer.h. ◆ ReadArray() [1/13]. virtual Int_t TBuffer::ReadArray ; (; Bool_t *& ; b). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ ReadArray() [2/13]. virtual Int_t TBuffer::ReadArray ; (; Char_t *& ; c). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ ReadArray() [3/13]. virtual Int_t TBuffer::ReadArray ; (; Double_t *& ; d). pure virtual . Implemented in TBufferJSON, TBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:35534,cache,cache,35534,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['cache'],['cache']
Performance," void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::Config::Instancestatic Config & Instance()static function: returns TMVA instanceDefinition Config.cxx:98; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; Drawth1 Draw(); AuthorHarshal Shende ; Definition in file TMVA_RNN_Classification.py. tutorialstmvaTMVA_RNN_Classification.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:63259,multi-thread,multi-threading,63259,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['multi-thread'],['multi-threading']
Performance," void(unsigned)> WebWindowConnectCallback_tfunction signature for connect/disconnect call-backs argument is connection idDefinition RWebWindow.hxx:35; ROOT::WebWindowWaitFunc_tstd::function< int(double)> WebWindowWaitFunc_tfunction signature for waiting call-backs Such callback used when calling thread need to waits for so...Definition RWebWindow.hxx:46; ROOT::RWebWindow::MasterConnDefinition RWebWindow.hxx:118; ROOT::RWebWindow::MasterConn::channelint channelDefinition RWebWindow.hxx:120; ROOT::RWebWindow::MasterConn::MasterConnMasterConn(unsigned _connid, int _channel)Definition RWebWindow.hxx:121; ROOT::RWebWindow::MasterConn::connidunsigned connidDefinition RWebWindow.hxx:119; ROOT::RWebWindow::QueueEntryDefinition RWebWindow.hxx:126; ROOT::RWebWindow::QueueEntry::fDatastd::string fData! data for given connectionDefinition RWebWindow.hxx:129; ROOT::RWebWindow::QueueEntry::fKindEQueueEntryKind fKind! kind of dataDefinition RWebWindow.hxx:128; ROOT::RWebWindow::QueueEntry::fConnIdunsigned fConnId! connection idDefinition RWebWindow.hxx:127; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry()=default; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&data)Definition RWebWindow.hxx:131; ROOT::RWebWindow::QueueItemDefinition RWebWindow.hxx:62; ROOT::RWebWindow::QueueItem::QueueItemQueueItem(int chid, bool txt, std::string &&data)Definition RWebWindow.hxx:66; ROOT::RWebWindow::QueueItem::fDatastd::string fData! text or binary dataDefinition RWebWindow.hxx:65; ROOT::RWebWindow::QueueItem::fChIDint fChID! channelDefinition RWebWindow.hxx:63; ROOT::RWebWindow::QueueItem::fTextbool fText! is text dataDefinition RWebWindow.hxx:64; ROOT::RWebWindow::WebConnDefinition RWebWindow.hxx:69; ROOT::RWebWindow::WebConn::fReadyint fReady! 0 - not ready, 1..9 - interim, 10 - doneDefinition RWebWindow.hxx:80; ROOT::RWebWindow::WebConn::fHoldstd::shared_ptr< THttpCallArg > fHold! request used to hold headless browserDefinition RWebW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:46839,Queue,QueueEntry,46839,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['Queue'],['QueueEntry']
Performance," void(unsigned)> WebWindowConnectCallback_tfunction signature for connect/disconnect call-backs argument is connection idDefinition RWebWindow.hxx:37; ROOT::WebWindowWaitFunc_tstd::function< int(double)> WebWindowWaitFunc_tfunction signature for waiting call-backs Such callback used when calling thread need to waits for so...Definition RWebWindow.hxx:48; ROOT::RWebWindow::MasterConnDefinition RWebWindow.hxx:121; ROOT::RWebWindow::MasterConn::channelint channelDefinition RWebWindow.hxx:123; ROOT::RWebWindow::MasterConn::MasterConnMasterConn(unsigned _connid, int _channel)Definition RWebWindow.hxx:124; ROOT::RWebWindow::MasterConn::connidunsigned connidDefinition RWebWindow.hxx:122; ROOT::RWebWindow::QueueEntryDefinition RWebWindow.hxx:129; ROOT::RWebWindow::QueueEntry::fDatastd::string fData! data for given connectionDefinition RWebWindow.hxx:132; ROOT::RWebWindow::QueueEntry::fKindEQueueEntryKind fKind! kind of dataDefinition RWebWindow.hxx:131; ROOT::RWebWindow::QueueEntry::fConnIdunsigned fConnId! connection idDefinition RWebWindow.hxx:130; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry()=default; ROOT::RWebWindow::QueueEntry::QueueEntryQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&data)Definition RWebWindow.hxx:134; ROOT::RWebWindow::QueueItemDefinition RWebWindow.hxx:64; ROOT::RWebWindow::QueueItem::QueueItemQueueItem(int chid, bool txt, std::string &&data)Definition RWebWindow.hxx:68; ROOT::RWebWindow::QueueItem::fDatastd::string fData! text or binary dataDefinition RWebWindow.hxx:67; ROOT::RWebWindow::QueueItem::fChIDint fChID! channelDefinition RWebWindow.hxx:65; ROOT::RWebWindow::QueueItem::fTextbool fText! is text dataDefinition RWebWindow.hxx:66; ROOT::RWebWindow::WebConnDefinition RWebWindow.hxx:71; ROOT::RWebWindow::WebConn::fReadyint fReady! 0 - not ready, 1..9 - interim, 10 - doneDefinition RWebWindow.hxx:83; ROOT::RWebWindow::WebConn::fHoldstd::shared_ptr< THttpCallArg > fHold! request used to hold headless browserDefinition RWebW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:47123,Queue,QueueEntry,47123,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['Queue'],['QueueEntry']
Performance," void*fInterStreamer!saved info to call Streamer; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; TMethodCall*fIsAMethod!saved info to call a IsA member function; TList*fMethodlinked list for methods; void*fNewpointer to a function newing one object.; void*fNewArraypointer to a function newing an array of objects.; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; Long_tfProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; TClassRef*fRefStart!List of references to this object; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClassStreamer*fStreamerpointer to streamer function; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; Bool_tfVersionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash; static ROOT::TMapTypeToTClass*fgIdMapMap from typeid to TClass pointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:15382,cache,cached,15382,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['cache'],['cached']
Performance," voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*,allocator<TMVA::DecisionTreeNode*> >fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const vector<const TMVA::Event*,allocator<const TMVA::Event*> >* testEvents = NULL, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Tue Sep 8 17:04:42 2015 » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__CostComplexityPruneTool.html:2202,Optimiz,Optimize,2202,root/html534/TMVA__CostComplexityPruneTool.html,https://root.cern,https://root.cern/root/html534/TMVA__CostComplexityPruneTool.html,1,['Optimiz'],['Optimize']
Performance," voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionOneDim.html:3369,cache,cached,3369,root/html528/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionOneDim.html,2,['cache'],['cached']
Performance," voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html:3371,cache,cached,3371,root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,2,['cache'],['cached']
Performance," voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionOneDim.html:3371,cache,cached,3371,root/html532/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionOneDim.html,2,['cache'],['cached']
Performance," voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; static voidRooAbsReal::printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); virtual voidRooPrintable::printExtras(ostream& os) const; voidPrintInfo(ostream&) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; virtual voidRooAbsPdf::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsArg::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); Roo2DKeysPdf(const Roo2DKeysPdf& other, const char* name = 0); Roo2DKeysPdf(const char* name, const char* title, RooAbsReal& xx, RooAbsReal& yy, RooDataSet& data, TString options = ""a"", Double_t widthScaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:27722,cache,cache,27722,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,2,['cache'],['cache']
Performance," voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLPolyLine&operator=(const TGLPolyLine&); TGLPolyLine&operator=(TGLPolyLine&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPolyLine(const TBuffer3D& buffer); TGLPolyLine(const TGLPolyLine&); TGLPolyLine(TGLPolyLine&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPolyLine.html:1910,cache,cached,1910,root/html602/TGLPolyLine.html,https://root.cern,https://root.cern/root/html602/TGLPolyLine.html,2,['cache'],['cached']
Performance," voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; voidEnforceTriangles(); static Bool_tGetEnforceTriangles(); TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); UInt_tGetNbPols(); vector<Double_t>&GetNormals(); vector<Int_t>&GetPolyDesc(); TGLScene*TGLLogicalShape::GetScene() const; vector<Double_t>&GetVertices(); TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLFaceSet&operator=(const TGLFaceSet&); TGLFaceSet&operator=(TGLFaceSet&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidSetEnforceTriangles(Bool_t e); voidSetFromMesh(const RootCsg::TBaseMesh* m); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLFaceSet(const TBuffer3D& buffer); TGLFaceSet(const TGLFaceSet&); TGLFaceSet(TGLFaceSet&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLFaceSet.html:2121,cache,cached,2121,root/html602/TGLFaceSet.html,https://root.cern,https://root.cern/root/html602/TGLFaceSet.html,2,['cache'],['cached']
Performance," voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsRealLValue::volume(const char* rangeName) const; virtual Double_tRooAbsRealLValue::volume(const RooAbsBinning& binning) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinearVar.html:29576,cache,cache,29576,root/html532/RooLinearVar.html,https://root.cern,https://root.cern/root/html532/RooLinearVar.html,1,['cache'],['cache']
Performance," voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:29477,optimiz,optimizeDirtyHook,29477,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,12,['optimiz'],['optimizeDirtyHook']
Performance," voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tprocessEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNLLVar.html:28878,optimiz,optimizeDirtyHook,28878,root/html526/RooNLLVar.html,https://root.cern,https://root.cern/root/html526/RooNLLVar.html,3,['optimiz'],['optimizeDirtyHook']
Performance," voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooCategory&operator=(const RooCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:11969,optimiz,optimizeCacheMode,11969,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance," voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMemFile.html:12342,cache,cache,12342,root/html534/TMemFile.html,https://root.cern,https://root.cern/root/html534/TMemFile.html,3,['cache'],['cache']
Performance," voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFile.html:13901,cache,cache,13901,root/html534/TNetFile.html,https://root.cern,https://root.cern/root/html534/TNetFile.html,6,['cache'],['cache']
Performance," voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCachedReal.html:22525,cache,cache,22525,root/html528/RooCachedReal.html,https://root.cern,https://root.cern/root/html528/RooCachedReal.html,1,['cache'],['cache']
Performance," voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsHiddenReal.html:24340,cache,cache,24340,root/html534/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html,51,['cache'],['cache']
Performance," voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; voidsetMode(const Roo1DMomentMorphFunction::Setting& setting); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:24233,cache,cache,24233,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,1,['cache'],['cache']
Performance," voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; voidsetMode(const Roo2DMomentMorphFunction::Setting& setting); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DMomentMorphFunction.html:24535,cache,cache,24535,root/html534/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo2DMomentMorphFunction.html,1,['cache'],['cache']
Performance," voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:28305,cache,cache,28305,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,2,['cache'],['cache']
Performance," voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:12529,tune,tuneParameters,12529,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,2,['tune'],['tuneParameters']
Performance," voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodANNBase.html:11550,tune,tuneParameters,11550,root/html534/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodANNBase.html,1,['tune'],['tuneParameters']
Performance," voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEventIterObj(); TEventIterObj(const TEventIterObj&); TEventIterObj(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tTEventIter::LoadDir(); voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TEventIter::EIterTypeTEventIter::kData; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tTEventIter::fCurcurrent entry; TDSet*TEventIter::fDSetdata set over which to iterate; TDirectory*TEven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterObj.html:5451,Load,LoadDir,5451,root/html602/TEventIterObj.html,https://root.cern,https://root.cern/root/html602/TEventIterObj.html,2,['Load'],['LoadDir']
Performance," voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:10974,optimiz,optimizeCacheMode,10974,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,1,['optimiz'],['optimizeCacheMode']
Performance," voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:11089,optimiz,optimizeCacheMode,11089,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,4,['optimiz'],['optimizeCacheMode']
Performance," voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:5721,load,loadopts,5721,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,2,['load'],['loadopts']
Performance," voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:5948,load,loadopts,5948,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,4,['load'],['loadopts']
Performance," voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp, char* parent); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html:3263,cache,cache,3263,root/html526/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance," voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*specialIntegratorConfig() const; RooNumIntConfig*specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:24144,cache,cache,24144,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['cache'],['cache']
Performance," voidsetUnitNorm(Bool_t flag); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:30750,cache,cache,30750,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['cache'],['cache']
Performance," void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) final;  Inject the module named ""modulename"" into cling; load all headers. ;  ; bool RegisterPrebuiltModulePath (const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const final;  ; void RegisterTClassUpdate (TClass *oldcl, DictFuncPtr_t dict) final;  Register classes that already existed prior to their dictionary loading and that already had a ClassInfo (and thus would not be refresh via UpdateClassInfo. ;  ; void RegisterTemporary (const cling::Value &value);  Register value as a temporary, extending its lifetime to that of the interpreter. ;  ; void RegisterTemporary (const TInterpreterValue &value);  ; Int_t ReloadAllSharedLibraryMaps () final;  Reload the library map entries coming from all the loaded shared libraries, after first unloading the current ones. ;  ; void ReportDiagnosticsToErrorHandler (bool enable=true) final;  Report diagnostics to the ROOT error handler (see TError.h). ;  ; Int_t RescanLibraryMap () final;  Scan again along the dynamic path for library maps. ;  ; void Reset () final;  Pressing Ctrl+C should forward here. ;  ; void ResetAll () final;  Reset the Cling state to its initial state. ;  ; void ResetGlobals () final;  Reset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void ResetGlobalVar (void *obj) final;  Reset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void RewindDictionary () final;  Rewind Cling dictionary to the point where it was before executing the current macro. ;  ; void * RewindInterpreterMutex ();  Reset the interpreter lock to the state it had be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:28786,load,loaded,28786,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance," void Set2DMode (E2DMode_e p);  ; void SetAutoRebin (Bool_t s);  ; void SetBoxMode (EBoxMode_e p);  ; void SetCellPixelFontSize (Int_t x);  ; virtual void SetData (TEveCaloData *d);  ; void SetDrawHPlane (Bool_t s);  ; void SetDrawNumberCellPixels (Int_t x);  ; void SetFixedHeightValIn2DMode (float x);  ; void SetFontColor (Color_t ci);  ; void SetGridColor (Color_t ci);  ; void SetHasFixedHeightIn2DMode (bool x);  ; void SetHPlaneVal (Float_t s);  ; void SetNormalizeRebin (Bool_t s);  ; void SetNZSteps (Int_t s);  ; void SetPixelsPerBin (Int_t bw);  ; void SetPlaneColor (Color_t ci);  ; void SetPlaneTransparency (Char_t t);  ; void SetProjection (EProjection_e p);  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveCaloViz;  TEveCaloViz (TEveCaloData *data=nullptr, const char *n=""TEveCaloViz"", const char *t="""");  ;  ~TEveCaloViz () override;  Destructor. ;  ; Bool_t AssertCellIdCache () const;  Assert cell id cache is ok. ;  ; TEveRGBAPalette * AssertPalette ();  Make sure the TEveRGBAPalette pointer is not null. ;  ; Bool_t CellInEtaPhiRng (TEveCaloData::CellData_t &) const;  Returns true if given cell is in the ceta phi range. ;  ; virtual void CellSelectionChanged ();  ; void DataChanged ();  Update setting and cache on data changed. ;  ; TEveElement * ForwardEdit () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; TEveElement * ForwardSelection () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; Bool_t GetAutoRange () const;  ; Float_t GetBackwardEndCapPos () const;  ; Float_t GetBarrelRadius () const;  ; TEveCaloData * GetData () const;  ; Color_t GetDataSliceColor (Int_t slice) const;  Get slice color from data. ;  ; Float_t GetDataSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Float_t GetEndCapPos () const;  ; Float_t GetE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloLego.html:4112,cache,cache,4112,doc/master/classTEveCaloLego.html,https://root.cern,https://root.cern/doc/master/classTEveCaloLego.html,1,['cache'],['cache']
Performance," void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Transfer contents to std::vector for use below. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStepFunction.html:48481,cache,cached,48481,doc/master/classRooStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooStepFunction.html,2,['cache'],"['cache', 'cached']"
Performance," void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMacro;  TMacro ();  Create an empty macro, use AddLine() or ReadFile() to fill this macro. ;  ;  TMacro (const char *name, const char *title="""");  Create a macro with a name and a title. ;  ;  TMacro (const TMacro &);  Copy constructor. ;  ; virtual ~TMacro ();  Delete this macro. ;  ; virtual TObjString * AddLine (const char *text);  Add line with text in the list of lines of this macro. ;  ; void Browse (TBrowser *b) override;  When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ;  ; virtual TMD5 * Checksum ();  Returns checksum of the current content. ;  ; virtual TObjString * GetLineWith (const char *text) const;  Search the first line containing text. ;  ; TList * GetListOfLines () const;  ; TClass * IsA () const override;  ; virtual Bool_t Load () const;  Load the macro into the interpreter. ;  ; TMacro & operator= (const TMacro &);  Copy constructor. ;  ; void Paint (Option_t *option="""") override;  Execute this macro (called by TPad::Paint). ;  ; void Print (Option_t *option="""") const override;  Print contents of this macro. ;  ; virtual Int_t ReadFile (const char *filename);  Read lines in filename in this macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save macro source on stream out. ;  ; virtual void SaveSource (const char *filename);  Save macro source in filename. ;  ; virtual void SetParams (const char *params=nullptr);  Set default parameters to execute this macro. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveMacro.html:1812,Load,Load,1812,doc/master/classTEveMacro.html,https://root.cern,https://root.cern/doc/master/classTEveMacro.html,2,['Load'],['Load']
Performance," void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Interface function to create an internal cache object that represent each cached function configuration. ;  ; double evaluate () const override;  Dummy evaluate, it is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Update contents of cache histogram by resampling the input function. ;  ; const char * inputBaseName () const override;  Return base name for caches, i.e. the name of the cached function. ;  ; void operModeHook () override;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; virtual const char * binningName () const;  ; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:49874,cache,cacheFunc,49874,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],"['cache', 'cacheFunc']"
Performance," void setOwner (RooAbsArg *owner);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Public Attributes; std::unique_ptr< RooAbsReal > _norm;  . Additional Inherited Members;  Public Types inherited from RooAbsCacheElement; enum  Action { OperModeChange; , OptimizeCaching; , FindConstantNodes; };  ;  Static Public Member Functions inherited from RooAbsCacheElement; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Attributes inherited from RooAbsCacheElement; RooAbsArg * _owner;  ! Pointer to owning RooAbsArg ;  . #include <RooAbsPdf.h>. Inheritance diagram for RooAbsPdf::CacheElem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ CacheElem(). RooAbsPdf::CacheElem::CacheElem ; (; RooAbsReal & ; norm). inline . Definition at line 324 of file RooAbsPdf.h. ◆ ~CacheElem(). RooAbsPdf::CacheElem::~CacheElem ; (; ). override . Destructor of normalization cache element. ; If this element provides the 'current' normalization stored in RooAbsPdf::_norm zero _norm pointer here before object pointed to is deleted here ; Definition at line 2430 of file RooAbsPdf.cxx. Member Function Documentation. ◆ containedArgs(). RooArgList RooAbsPdf::CacheElem::containedArgs ; (; Action ; ). inlineoverridevirtual . Implements RooAbsCacheElement.; Definition at line 326 of file RooAbsPdf.h. Member Data Documentation. ◆ _norm. std::unique_ptr<RooAbsReal> RooAbsPdf::CacheElem::_norm. Definition at line 327 of file RooAbsPdf.h. Libraries for RooAbsPdf::CacheElem:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAbsPdf.h; roofit/roofitcore/src/RooAbsPdf.cxx. RooAbsPdfCacheElem. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html:2418,Cache,CacheElem,2418,doc/master/classRooAbsPdf_1_1CacheElem.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html,7,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance," w.factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)""); ; ; # Interpreted and compiled expression based pdfs; # ---------------------------------------------------------------------------------------------------; ; # Create a ROOT.RooGenericPdf interpreted p.d.f. You can use single quotes; # to pass the expression string argument; w.factory(""EXPR::G('x*x+1',x)""); ; # Create a custom compiled p.d.f similar to the above interpreted p.d.f.; # The code required to make self p.d.f. is automatically embedded in; # the workspace; w.factory(""CEXPR::GC('x*x+a',{x,a[1]})""); ; # Compiled and interpreted functions (rather than p.d.f.s) can be made with the lower case; # 'expr' and 'cexpr' types; ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html:3372,cache,cache,3372,doc/master/rf512__wsfactory__oper_8py.html,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html,1,['cache'],['cache']
Performance," wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5757,perform,performance,5757,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['perform'],['performance']
Performance," we deal with possible aliases, we could also have normalized; 2663 // the name.; 2664 TClass *search = TClass::GetClass(classname,kTRUE,kTRUE);; 2665 ; 2666 if (search) return GetBaseClass(search);; 2667 else return nullptr;; 2668}; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Return pointer to the base class ""cl"". Returns 0 in case ""cl""; 2672/// is not a base class. Takes care of multiple inheritance.; 2673 ; 2674TClass *TClass::GetBaseClass(const TClass *cl); 2675{; 2676 // check if class name itself is equal to classname; 2677 if (cl == this) return this;; 2678 ; 2679 if (!HasDataMemberInfo()) return nullptr;; 2680 ; 2681 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2682 ; 2683 // otherwise look at inheritance tree; 2684 while (lnk) {; 2685 TClass *c, *c1;; 2686 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2687 c = base->GetClassPointer();; 2688 if (c) {; 2689 if (cl == c) return c;; 2690 c1 = c->GetBaseClass(cl);; 2691 if (c1) return c1;; 2692 }; 2693 lnk = lnk->Next();; 2694 }; 2695 return nullptr;; 2696}; 2697 ; 2698////////////////////////////////////////////////////////////////////////////////; 2699/// Return data member offset to the base class ""cl"".; 2700/// - Returns -1 in case ""cl"" is not a base class.; 2701/// - Returns -2 if cl is a base class, but we can't find the offset; 2702/// because it's virtual.; 2703/// Takes care of multiple inheritance.; 2704 ; 2705Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2706{; 2707 // check if class name itself is equal to classname; 2708 if (cl == this) return 0;; 2709 ; 2710 if (!fBase.load()) {; 2711 if (fCanLoadClassInfo) LoadClassInfo();; 2712 // If the information was not provided by the root pcm files and; 2713 // if we can not find the ClassInfo, we have to fall back to the; 2714 // StreamerInfo; 2715 if (!fClassInfo) {; 2716 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2717 if (!sinfo) return -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:100650,load,load,100650,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance," we deal with possible aliases, we could also have normalized; 2730 // the name.; 2731 TClass *search = TClass::GetClass(classname,kTRUE,kTRUE);; 2732 ; 2733 if (search) return GetBaseClass(search);; 2734 else return nullptr;; 2735}; 2736 ; 2737////////////////////////////////////////////////////////////////////////////////; 2738/// Return pointer to the base class ""cl"". Returns 0 in case ""cl""; 2739/// is not a base class. Takes care of multiple inheritance.; 2740 ; 2741TClass *TClass::GetBaseClass(const TClass *cl); 2742{; 2743 // check if class name itself is equal to classname; 2744 if (cl == this) return this;; 2745 ; 2746 if (!HasDataMemberInfo()) return nullptr;; 2747 ; 2748 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2749 ; 2750 // otherwise look at inheritance tree; 2751 while (lnk) {; 2752 TClass *c, *c1;; 2753 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2754 c = base->GetClassPointer();; 2755 if (c) {; 2756 if (cl == c) return c;; 2757 c1 = c->GetBaseClass(cl);; 2758 if (c1) return c1;; 2759 }; 2760 lnk = lnk->Next();; 2761 }; 2762 return nullptr;; 2763}; 2764 ; 2765////////////////////////////////////////////////////////////////////////////////; 2766/// Return data member offset to the base class ""cl"".; 2767/// - Returns -1 in case ""cl"" is not a base class.; 2768/// - Returns -2 if cl is a base class, but we can't find the offset; 2769/// because it's virtual.; 2770/// Takes care of multiple inheritance.; 2771 ; 2772Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2773{; 2774 // check if class name itself is equal to classname; 2775 if (cl == this) return 0;; 2776 ; 2777 if (!fBase.load()) {; 2778 if (fCanLoadClassInfo) LoadClassInfo();; 2779 // If the information was not provided by the root pcm files and; 2780 // if we can not find the ClassInfo, we have to fall back to the; 2781 // StreamerInfo; 2782 if (!fClassInfo) {; 2783 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2784 if (!sinfo) return -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:103401,load,load,103401,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance," we have to do schema evolution?; 4675 // Or it didn't have a dictionary before, but does now?; 4676 sinfo->BuildOld();; 4677 }; 4678 }; 4679 ; 4680 // Cache the current info if we now have it.; 4681 if (version == fClassVersion); 4682 fCurrentInfo = sinfo;; 4683 ; 4684 // If the compilation succeeded, remember this StreamerInfo.; 4685 if (sinfo->IsCompiled()); 4686 fLastReadInfo = sinfo;; 4687 ; 4688 return sinfo;; 4689}; 4690 ; 4691////////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:178564,load,loaded,178564,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance," we have to do schema evolution?; 4742 // Or it didn't have a dictionary before, but does now?; 4743 sinfo->BuildOld();; 4744 }; 4745 }; 4746 ; 4747 // Cache the current info if we now have it.; 4748 if (version == fClassVersion); 4749 fCurrentInfo = sinfo;; 4750 ; 4751 // If the compilation succeeded, remember this StreamerInfo.; 4752 if (sinfo->IsCompiled()); 4753 fLastReadInfo = sinfo;; 4754 ; 4755 return sinfo;; 4756}; 4757 ; 4758////////////////////////////////////////////////////////////////////////////////; 4759/// For the case where the requestor class is emulated and this class is abstract,; 4760/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4761/// representation whether or not the class is loaded.; 4762///; 4763/// If the object does not exist, it is created; 4764///; 4765/// Note: There are two special version numbers:; 4766///; 4767/// - 0: Use the class version from the currently loaded class library.; 4768/// - -1: Assume no class library loaded (emulated class).; 4769///; 4770/// Warning: If we create a new streamer info, whether or not the build; 4771/// optimizes is controlled externally to us by a global variable!; 4772/// Don't call us unless you have set that variable properly; 4773/// with TStreamer::Optimize()!; 4774///; 4775 ; 4776TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4777{; 4778 TVirtualStreamerInfo *sinfo = nullptr;; 4779 ; 4780 TString newname(GetName());; 4781 newname += ""@@emulated"";; 4782 ; 4783 R__LOCKGUARD(gInterpreterMutex);; 4784 ; 4785 TClass *emulated = TClass::GetClass(newname);; 4786 ; 4787 if (emulated); 4788 sinfo = emulated->GetStreamerInfo(version);; 4789 ; 4790 if (!sinfo) {; 4791 // The emulated version of the streamerInfo is explicitly requested and has; 4792 // not been built yet.; 4793 ; 4794 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4795 ; 4796 if (!sinfo && (version != fClassVersion)) {; 4797 // When the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:181315,load,loaded,181315,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance, weight file: ␛[0;36mdataset/weights/TMVAClassification_SVM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_RuleFit.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Cuts for Classification performance; : ; Cuts : [dataset] : Evaluation of Cuts on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00226 sec ; Factory : Test method: CutsD for Classification performance; : ; CutsD : [dataset] : Evaluation of CutsD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00756 sec ; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; Factory : Test method: LikelihoodPCA for Classification performance; : ; LikelihoodPCA : [dataset] : Evaluation of LikelihoodPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Classification performance; : ; PDEFoam : [dataset] : Evaluation of PDEFoam on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification performance; : ; KNN : [dataset] : Evaluation of KNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.2 sec ; Factory : Test method: LD for Classification performance; : ; LD : [dataset] : Evaluation of LD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00474 sec ; : Dataset[dataset] : Evaluation of LD on testing sample; Factory : Test method: FDA_GA for Clas,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:65936,perform,performance,65936,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance, weight file: ␛[0;36mdataset/weights/TMVAMulticlass_BDTG.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_MLP.weights.xml␛[0m; MLP : Building Network. ; : Initializing weights; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_PDEFoam.weights.xml␛[0m; : Read foams from file: ␛[0;36mdataset/weights/TMVAMulticlass_PDEFoam.weights_foams.root␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_DL_CPU.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: BDTG for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of BDTG on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 1.01 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: MLP for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of MLP on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.0114 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: PDEFoam for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of PDEFoam on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.122 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: DL_CPU for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of DL_CPU on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:19762,perform,performance,19762,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance," when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Friends; class RooSimGenContext;  ; class RooSimSplitGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsCategory; using value_type = int;  The type used to denote a specific category state. ;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:42213,Cache,CacheMode,42213,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['Cache'],['CacheMode']
Performance," when window is closed via WM. ; Reimplemented from TVirtualX.; Definition at line 4270 of file TGCocoa.mm. ◆ WriteGIF(). Int_t TGCocoa::WriteGIF ; (; char * ; name). overridevirtual . Writes the current window into GIF file. ; Returns 1 in case of success, 0 otherwise. ; Reimplemented from TVirtualX.; Definition at line 4163 of file TGCocoa.mm. ◆ WritePixmap(). void TGCocoa::WritePixmap ; (; Int_t ; wid, . UInt_t ; w, . UInt_t ; h, . char * ; pxname . ). overridevirtual . Writes the pixmap ""wid"" in the bitmap file ""pxname"". ; Parameters. [in]widthe pixmap address ; [in]w,hthe width and height of the pixmap. ; [in]pxnamethe file name . Reimplemented from TVirtualX.; Definition at line 4172 of file TGCocoa.mm. ◆ XorRegion(). void TGCocoa::XorRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Calculates the difference between the union and intersection of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented from TVirtualX.; Definition at line 4350 of file TGCocoa.mm. Member Data Documentation. ◆ fAtomToName. std::vector<std::string> TGCocoa::fAtomToName. private . Definition at line 459 of file TGCocoa.h. ◆ fCocoaDraw. Int_t TGCocoa::fCocoaDraw. protected . Definition at line 445 of file TGCocoa.h. ◆ fDirectDraw. bool TGCocoa::fDirectDraw. protected . Definition at line 448 of file TGCocoa.h. ◆ fDisplayRect. ROOT::MacOSX::X11::Rectangle TGCocoa::fDisplayRect. mutableprivate . Definition at line 466 of file TGCocoa.h. ◆ fDisplayShapeChanged. bool TGCocoa::fDisplayShapeChanged. mutableprivate . Definition at line 465 of file TGCocoa.h. ◆ fDrawMode. EDrawMode TGCocoa::fDrawMode. protected . Definition at line 447 of file TGCocoa.h. ◆ fForegroundProcess. bool TGCocoa::fForegroundProcess. private . Definition at line 455 of file TGCocoa.h. ◆ fgDeleteWindowAtom. Atom_t TGCocoa::fgDeleteWindowAtom = 0. static . De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:128507,perform,perform,128507,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['perform'],['perform']
Performance," which can be executed; # create 2 conv2d layer + maxpool + dense; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; ; # from keras.initializers import TruncatedNormal; # from keras import initializations; from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, SimpleRNN, GRU, LSTM, Reshape, BatchNormalization; ; model = Sequential(); model.add(Reshape((10, 30), input_shape=(10 * 30,))); # add recurrent neural network depending on type / Use option to return the full output; if rnn_types[i] == ""LSTM"":; model.add(LSTM(units=10, return_sequences=True)); elif rnn_types[i] == ""GRU"":; model.add(GRU(units=10, return_sequences=True)); else:; model.add(SimpleRNN(units=10, return_sequences=True)); # m.AddLine(""model.add(BatchNormalization())"");; model.add(Flatten()) # needed if returning the full time output sequence; model.add(Dense(64, activation=""tanh"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(modelName); model.summary(); print(""saved recurrent model"", modelName); ; if not os.path.exists(modelName):; useKeras = False; print(""Error creating Keras recurrent model file - Skip using Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:60096,optimiz,optimizer,60096,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['optimiz'],['optimizer']
Performance," which first character of string is drawn. firstChar – Index of first character. lastChar – Index of one after the last character. ; Definition at line 617 of file TGFont.cxx. ◆ XTextWidth(). Int_t TGFont::XTextWidth ; (; const char * ; string, . Int_t ; numChars = -1 . ); const. Return text width in pixels. ; Definition at line 590 of file TGFont.cxx. Friends And Related Symbol Documentation. ◆ TGFontPool. friend class TGFontPool. friend . Definition at line 142 of file TGFont.h. ◆ TGTextLayout. friend class TGTextLayout. friend . Definition at line 143 of file TGFont.h. Member Data Documentation. ◆ fBarHeight. Int_t TGFont::fBarHeight. private . Height of underline or overstrike bar (used for simulating a native underlined or strikeout font). ; Definition at line 159 of file TGFont.h. ◆ fFA. FontAttributes_t TGFont::fFA. private . Actual font attributes obtained when the font was created. ; Definition at line 149 of file TGFont.h. ◆ fFM. FontMetrics_t TGFont::fFM. private . Cached font metrics. ; Definition at line 148 of file TGFont.h. ◆ fFontH. FontH_t TGFont::fFontH. private . Font handle (derived from fontstruct) ; Definition at line 147 of file TGFont.h. ◆ fFontStruct. FontStruct_t TGFont::fFontStruct. private . Low level graphics fontstruct. ; Definition at line 146 of file TGFont.h. ◆ fNamedHash. TObjString* TGFont::fNamedHash. private . Pointer to the named object TGFont was based on. ; Definition at line 150 of file TGFont.h. ◆ fTabWidth. Int_t TGFont::fTabWidth. private . Width of tabs in this font (pixels). ; Definition at line 151 of file TGFont.h. ◆ fTypes. char TGFont::fTypes[256]. private . Array giving types of all characters in the font, used when displaying control characters. ; Definition at line 156 of file TGFont.h. ◆ fUnderlineHeight. Int_t TGFont::fUnderlineHeight. private . Height of underline bar (used for drawing underlines on a non-underlined font). ; Definition at line 154 of file TGFont.h. ◆ fUnderlinePos. Int_t TGFont::fUnderlinePos. p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:25526,Cache,Cached,25526,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['Cache'],['Cached']
Performance," which normally it would not match.; Used together, as /ms, they let the ""."" match any character whatsoever,; while still allowing ""^"" and ""$"" to match, respectively, just after and; just before newlines within the string.; - i; Do case-insensitive pattern matching.; - x; Extend your pattern's legibility by permitting whitespace and comments.; - p; Preserve the string matched such that ${^PREMATCH}, ${^MATCH},; and ${^POSTMATCH} are available for use after matching.; - g and c; Global matching, and keep the Current position after failed matching.; Unlike i, m, s and x, these two flags affect the way the regex is used; rather than the regex itself. See Using regular expressions in Perl in; perlretut for further explanation of the g and c modifiers.; For more detail see: http://perldoc.perl.org/perlre.html#Modifiers. TString GetModifiers() const; Return PCRE modifier options as string.; For meaning of mods see ParseMods(). void Compile(); Compile the fPattern. void Optimize(); Send the pattern through the optimizer. Int_t ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Returns the number of expanded '$' constructs. Int_t MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0) const; Perform the actual matching - protected method. Int_t Match(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10, TArrayI* pos = 0); The number of matches is returned, this equals the full match +; sub-pattern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects and must be deleted by the user.; The first entry is the full matched pattern, fol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPRegexp.html:3959,Optimiz,Optimize,3959,root/html602/TPRegexp.html,https://root.cern,https://root.cern/root/html602/TPRegexp.html,4,"['Optimiz', 'optimiz']","['Optimize', 'optimizer']"
Performance," which normally it would not match.; Used together, as /ms, they let the ""."" match any character whatsoever,; while still allowing ""^"" and ""$"" to match, respectively, just after and; just before newlines within the string.; - i; Do case-insensitive pattern matching.; - x; Extend your pattern's legibility by permitting whitespace and comments.; - p; Preserve the string matched such that ${^PREMATCH}, ${^MATCH},; and ${^POSTMATCH} are available for use after matching.; - g and c; Global matching, and keep the Current position after failed matching.; Unlike i, m, s and x, these two flags affect the way the regex is used; rather than the regex itself. See Using regular expressions in Perl in; perlretut for further explanation of the g and c modifiers.; For more detail see: http://perldoc.perl.org/perlre.html#Modifiers. TString GetModifiers() const; Return PCRE modifier options as string.; For meaning of mods see ParseMods(). void Compile(); Compile the fPattern. void Optimize(); Send the pattern through the optimizer. Int_t ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Returns the number of expanded '$' constructs. Int_t MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); Perform the actual matching - protected method. Int_t Match(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10, TArrayI* pos = 0); The number of matches is returned, this equals the full match +; sub-pattern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects and must be deleted by the user.; The first entry is the full matched pattern, followed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPRegexp.html:3844,Optimiz,Optimize,3844,root/html534/TPRegexp.html,https://root.cern,https://root.cern/root/html534/TPRegexp.html,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizer']"
Performance," which normally it would not match.; Used together, as /ms, they let the ""."" match any character whatsoever,; while still allowing ""^"" and ""$"" to match, respectively, just after and; just before newlines within the string.; - i; Do case-insensitive pattern matching.; - x; Extend your pattern's legibility by permitting whitespace and comments.; - p; Preserve the string matched such that ${^PREMATCH}, ${^MATCH},; and ${^POSTMATCH} are available for use after matching.; - g and c; Global matching, and keep the Current position after failed matching.; Unlike i, m, s and x, these two flags affect the way the regex is used; rather than the regex itself. See Using regular expressions in Perl in; perlretut for further explanation of the g and c modifiers.; For more detail see: http://perldoc.perl.org/perlre.html#Modifiers. TString GetModifiers() const; Return PCRE modifier options as string.; For meaning of mods see ParseMods(). void Compile(); Compile the fPattern. void Optimize(); Send the pattern through the optimizer. Int_t ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Returns the number of expanded '$' constructs. Int_t MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); Perform the actual matching - protected method. Int_t Match(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10, TArrayI* pos = 0); The number of matches is returned, this equals the full match +; sub-pattern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects. The first entry is the full; matched pattern, followed by the subpatterns.; If a patter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPRegexp.html:3677,Optimiz,Optimize,3677,root/html528/TPRegexp.html,https://root.cern,https://root.cern/root/html528/TPRegexp.html,6,"['Optimiz', 'optimiz']","['Optimize', 'optimizer']"
Performance," which satisfies the following requisites:. for 3D vectors implementing the x(), y() and z() methods; for Lorentz vectors implementing the x(), y(), z() and t() methods. CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; 13.13 Linear Algebra: SMatrix Package; The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains the generic ROOT::Math::SMatrix and ROOT::Math::SVector classes for describing matrices and vectors of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size, like number of rows and columns for a matrix . Therefore, the matrix/vector dimension has to be known at compile time. An advantage of using the dimension as template parameters is that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:748426,optimiz,optimized,748426,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance," while preserving the possibility to have them in case of problems. void TruncateLogFile(); Truncate the log file to the 80% of the required max size if this; is set. void HandleException(Int_t sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum> and <file> placeholders in fname. Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access needs to be protected. Int_t UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:29899,queue,queued,29899,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['queue'],['queued']
Performance," width is > sigma and the peak maximum greater than threshold*maximum bin content of this. ; for more details see TSpectrum::Search. note the difference in the default value for option compared to TSpectrum2::Search option="""" by default (instead of ""goff"") ; Reimplemented from TH1.; Definition at line 2695 of file TH2.cxx. ◆ Smooth(). void TH2::Smooth ; (; Int_t ; ntimes = 1, . Option_t * ; option = """" . ). overridevirtual . Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community. ; Bin contents in the active range are replaced by their smooth values. The algorithm retains the input dimension by using Kernel Crop at the input boundaries. Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the normalization accordingly. If Errors are defined via Sumw2, they are also scaled and computed. However, note the resulting errors will be correlated between different-bins, so the errors should not be used blindly to perform any calculation involving several bins, like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; 3 kernels are proposed k5a, k5b and k3a. k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j) k5b is a bit more stronger in smoothing k3a acts only on 3x3 cells (i-1,i,i+1, and same for j). By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a"" via the option argument. If TAxis::SetRange has been called on the x or/and y axis, only the bins in the specified range are smoothed. In the current implementation if the first argument is not used (default value=1).; implementation by David McKee (dmcke.nosp@m.e@ba.nosp@m.ma.ua.nosp@m..edu). Extended by Rene Brun ; Reimplemented from TH1.; Definition at line 2727 of file TH2.cxx. ◆ Streamer(). void TH2::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TH2. ; Reimplemented from TH1.; Reimplemented in TH2C, TH2S, TH2I,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:108778,perform,perform,108778,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['perform'],['perform']
Performance," will be filled as h[i *ndim + j]. int CovMatrixStatus() const. return the status of the covariance matrix. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int i) const. get global correlation coefficient for the variable i. This is a number between zero and one which gives; the correlation between the i-th variable and that linear combination of all other variables which; is most strongly correlated with i.; If the variable is fixed or const the return value is zero. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0). get the minos error for parameter i, return false if Minos failed; A minimizaiton must be performed befre, return false if no minimization has been done; In case of Minos failed the status error is updated as following; status += 10 * minosStatus where the minos status is:; status = 1 : maximum number of function calls exceeded when running for lower error; status = 2 : maximum number of function calls exceeded when running for upper error; status = 3 : new minimum found when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html:10338,perform,performed,10338,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html,2,['perform'],['performed']
Performance," with FCN only fites, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const ROOT::Fit::FitResult& ). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__FitResult.html:5166,perform,performed,5166,root/html526/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__FitResult.html,1,['perform'],['performed']
Performance," with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:1762,perform,performance,1762,doc/master/rf513__wsfactory__tools_8py.html,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html,1,['perform'],['performance']
Performance," with all possible combinations of; fix and variable bin size like in TH3D. TProfile3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins, Option_t* option = """"); Create a 3-D Profile with variable bins in X , Y and Z. void BuildOptions(Double_t tmin, Double_t tmax, Option_t* option); Set Profile3D histogram structure and options*-*-; *-* =============================================. tmin: minimum value allowed for t; tmax: maximum value allowed for t; if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf). option: this is the option for the computation of the t error of the profile ( TProfile3D::GetBinError ); possible values for the options are documented in TProfile3D::SetErrorOption. see also TProfile::BuildOptions for a detailed description. TProfile3D(const TProfile3D& profile); copy constructor. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); -*-*Replace contents of this profile3D by the addition of h1 and h2; *-* ===============================================================. this = c1*h1 + c2*h2. void Approximate(Bool_t approx = kTRUE); static function; set the fgApproximate flag. When the flag is true, the function GetBinError; will approximate the bin error with the average profile error on all bins; in the following situation only; - the number of bins in the profile3D is less than 10404 (eg 100x100x100); - the bin number of entries is small ( <5); - the estimated bin error is extremely small compared to the bin content; (see TProfile3D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:32767,Perform,Performs,32767,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,3,['Perform'],['Performs']
Performance," with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanyli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:271147,optimiz,optimization,271147,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimization']
Performance," with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_int_.html:42938,cache,cache,42938,root/html534/RooCFunction4PdfBinding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_int_.html,1,['cache'],['cache']
Performance," with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction2PdfBinding_double_int_int_.html:39885,cache,cache,39885,root/html530/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html530/RooCFunction2PdfBinding_double_int_int_.html,2,['cache'],['cache']
Performance," with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* parIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Mon Dec 7 13:47:31 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache.html:7747,cache,cache,7747,root/html526/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache.html,1,['cache'],['cache']
Performance," with name starting at //root.; This function scans the list of all folders.; if no object found in folders, it scans the memory list of all files. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:22556,load,load,22556,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance," with range in z; *-* ====================================================; The first eight parameters are similar to TH2D::TH2D.; Only the values of Z between ZMIN and ZMAX will be considered at filling time.; zmin and zmax will also be the maximum and minimum values; on the z scale when drawing the profile2D. See TProfile2D::BuildOptions for more explanations on errors. void BuildOptions(Double_t zmin, Double_t zmax, Option_t* option); Set Profile2D histogram structure and options*-*-; *-* =============================================. zmin: minimum value allowed for z; zmax: maximum value allowed for z; if (zmin = zmax = 0) there are no limits on the allowed z values (zmin = -inf, zmax = +inf). option: this is the option for the computation of the t error of the profile ( TProfile2D::GetBinError ); possible values for the options are documented in TProfile2D::SetErrorOption. TProfile2D(const TProfile2D& profile); Copy constructor. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); -*-*Replace contents of this profile2D by the addition of h1 and h2; *-* ===============================================================. this = c1*h1 + c2*h2. void Approximate(Bool_t approx = kTRUE); static function; set the fgApproximate flag. When the flag is true, the function GetBinError; will approximate the bin error with the average profile error on all bins; in the following situation only; - the number of bins in the profile2D is less than 10404 (eg 100x100); - the bin number of entries is small ( <5); - the estimated bin error is extremely small compared to the bin content; (see TProfile2D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile2D.html:32775,Perform,Performs,32775,root/html534/TProfile2D.html,https://root.cern,https://root.cern/root/html534/TProfile2D.html,3,['Perform'],['Performs']
Performance," with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursivness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:9523,perform,performance,9523,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['perform'],['performance']
Performance," with surface proportional to the content's absolute value. A negative content is marked with a X. . ""BOX1"" A button is drawn for each cell with surface proportional to content's absolute value. A sunken button is drawn for negative values a raised one for positive. . ""COL"" A box is drawn for each cell with a color scale varying with contents. All the none empty bins are painted. Empty bins are not painted unless some bins have a negative content because in that case the null bins might be not empty. TProfile2D histograms are handled differently because, for this type of 2D histograms, it is possible to know if an empty bin has been filled or not. So even if all the bins' contents are positive some empty bins might be painted. And vice versa, if some bins have a negative content some empty bins might be not painted (default). . ""COLZ"" Same as ""COL"". In addition the color palette is also drawn. . ""COL2"" Alternative rendering algorithm to ""COL"". Can significantly improve rendering performance for large, non-sparse 2-D histograms. . ""COLZ2"" Same as ""COL2"". In addition the color palette is also drawn. . ""Z CJUST"" In combination with colored options ""COL"",""CONT0"" etc: Justify labels in the color palette at color boundaries. For more details see TPaletteAxis . ""CANDLE"" Draw a candle plot along X axis. . ""CANDLEX"" Same as ""CANDLE"". . ""CANDLEY"" Draw a candle plot along Y axis. . ""CANDLEXn"" Draw a candle plot along X axis. Different candle-styles with n from 1 to 6. . ""CANDLEYn"" Draw a candle plot along Y axis. Different candle-styles with n from 1 to 6. . ""VIOLIN"" Draw a violin plot along X axis. . ""VIOLINX"" Same as ""VIOLIN"". . ""VIOLINY"" Draw a violin plot along Y axis. . ""VIOLINXn"" Draw a violin plot along X axis. Different violin-styles with n being 1 or 2. . ""VIOLINYn"" Draw a violin plot along Y axis. Different violin-styles with n being 1 or 2. . ""CONT"" Draw a contour plot (same as CONT0). . ""CONT0"" Draw a contour plot using surface colors to distinguish contours. . ""CO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:9658,perform,performance,9658,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['perform'],['performance']
Performance," with the Library, with the complete machine-readable ""work that; uses the Library"", as object code and/or source code, so that the; user can modify the Library and then relink to produce a modified; executable containing the modified Library. (It is understood; that the user who changes the contents of definitions files in the; Library will not necessarily be able to recompile the application; to use the modified definitions.). b) Use a suitable shared library mechanism for linking with the; Library. A suitable mechanism is one that (1) uses at run time a; copy of the library already present on the user's computer system,; rather than copying library functions into the executable, and (2); will operate properly with a modified version of the library, if; the user installs one, as long as the modified version is; interface-compatible with the version that the work was made with. c) Accompany the work with a written offer, valid for at; least three years, to give the same user the materials; specified in Subsection 6a, above, for a charge no more; than the cost of performing this distribution. d) If distribution of the work is made by offering access to copy; from a designated place, offer equivalent access to copy the above; specified materials from the same place. e) Verify that the user has already received a copy of these; materials or that you have already sent this user a copy. For an executable, the required form of the ""work that uses the; Library"" must include any data and utility programs needed for; reproducing the executable from it. However, as a special exception,; the materials to be distributed need not include anything that is; normally distributed (in either source or binary form) with the major; components (compiler, kernel, and so on) of the operating system on; which the executable runs, unless that component itself accompanies; the executable. It may happen that this requirement contradicts the license; restrictions of other proprietary librarie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:18584,perform,performing,18584,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['perform'],['performing']
Performance," with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a hash table. The class TChain is derived from the class TTree. For example, to generate a histogram corresponding to the attribute “x” in tree “T” by processing sequentially the three files of this chain, we can use the TChain::Draw method.; chain.Draw(""x"");; When using a TChain, the branch address(es) must be set with:; chain.SetBranchAdress(branchname,...) // use this for TChain; rather than:; branch->SetAddress(...); // this will not work; The second form returns the pointer to the branch of the current TTree in the chain, typically the first one. The information is lost when the next TTree is loaded. The following statements illustrate how to set the address of the object to be read and how to loop on all events of all files of the chain.; {; TChain chain(""T""); // create the chain with tree ""T""; chain.Add(""file1.root""); // add the files; chain.Add(""file2.root"");; chain.Add(""file3.root"");; TH1F *hnseg = new TH1F(""hnseg"",; ""Number of segments for selected tracks"",; 5000,0,5000);; // create an object before setting the branch address; Event *event = new Event();; // Specify the address where to read the event object; chain.SetBranchAddress(""event"", &event);. // Start main loop on all events In case you want to read only a few; // branches, use TChain::SetBranchStatus to activate a branch.; Int_t nevent = chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; 12.24.1 TChain::AddFr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:652512,load,loaded,652512,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance," with the suffix suffix appended. The cumulative distribution is formed by filling each bin of the; resulting histogram with the sum of that bin and all previous; (forward == kTRUE) or following (forward = kFALSE) bins. note: while cumulative distributions make sense in one dimension, you; may not be getting what you expect in more than 1D because the concept; of a cumulative distribution is much trickier to define; make sure you; understand the order of summation before you use this method with; histograms of dimension >= 2. void Copy(TObject& hnew) const; Copy this histogram structure to newth1. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. TObject* Clone(const char* newname = 0) const; Make a clone of an object bur for performance we are not using the; Streamer facility for TH1 and derived. Instead we rely on the; (required) implementation of Copy. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:62845,Perform,Perform,62845,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,1,['Perform'],['Perform']
Performance," with your own. For example:; root[] delete gRandom;; root[] gRandom = new TRandom2(0); //seed=0; TRandom2 is another generator, which is also very fast and uses only three words for its state.; 2.6.6 gEnv; gEnv is the global variable (of type TEnv) with all the environment settings for the current session. This variable is set by reading the contents of a .rootrc file (or $ROOTSYS/etc/system.rootrc) at the beginning of the root session. See Environment Setup below for more information.; 2.7 Environment Setup; The behavior of a ROOT session can be tailored with the options in the .rootrc file. At start-up, ROOT looks for a .rootrc file in the following order:. ./.rootrc //local directory; $HOME/.rootrc //user directory; $ROOTSYS/etc/system.rootrc //global ROOT directory. If more than one .rootrc files are found in the search paths above, the options are merged, with precedence local, user, global. While in a session, to see current settings, you can do:; root[] gEnv->Print(); The rootrc file typically looks like:; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:63594,load,loader,63594,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loader']
Performance," work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile, If ReadBuffers; is supported by xrootd it will try to gt the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t BufferLength); Override TNetFile::WriteBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Bool_t IsOpen() const; Return kTRUE if the file is open, kFALSE otherwise. TFile::EAsyncOpenStatus GetAsyncOpenStatus(); Return status of asynchronous request. Int_t ReOpen(Option_t* mode); Re-open the file (see TNetFile::ReOpen() or TFile::ReOpen(); for more details). void Close(Option_t* opt = """"); Close the file (see TNetFile::Close() or TFile::Close(); for more details). void Flush(); Flushes un-written data. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Override TNetFile::SysStat (see parent's method for more details). Int_t SysClose(Int_t fd); Override TNetFile::SysClo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:27512,latency,latency,27512,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,4,['latency'],['latency']
Performance," works also for local processing.; ; #include ""h1analysis.h""; #include ""TH2.h""; #include ""TF1.h""; #include ""TStyle.h""; #include ""TBranch.h""; #include ""TCanvas.h""; #include ""TPaveStats.h""; #include ""TLine.h""; #include ""TMath.h""; ; const Double_t dxbin = (0.17-0.13)/40; // Bin-width; const Double_t sigma = 0.0012;; ; ; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, par[1]); + par[2] / 2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }; ; ; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, 0.25); + par[1] / 2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }; ; ; void h1analysis::Begin(TTree * /*tree*/); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; // This is needed when re-processing the object; Reset();; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""Begin"", ""starting h1analysis with process option: %s"", option.Data());; ; //process cases with entry list; if (fChain) fChain->SetEntryList(nullptr);; delete gDirectory->GetList()->FindObject(""elist"");; ; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"", ""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; // We send a clone to avoid double deletes when importing the result; fInput->Add(elist);; // This is needed to avoid warnings from output-to-members mapping; elist = nullptr;; }; Info(""Begin"", ""creating an entry-list"");; }; // case when one uses the entry list generated in a previous",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:6467,perform,performs,6467,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['perform'],['performs']
Performance," works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:20753,cache,cache,20753,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance," written out with that name (which is not a valid C++ variable name). Instead, go through an; 1440 /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; 1441 ///; 1442 /// ### Example usage:; 1443 ///; 1444 /// **Types and columns specified:**; 1445 /// ~~~{.cpp}; 1446 /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; 1447 /// ~~~; 1448 ///; 1449 /// **Types inferred and columns specified (this invocation relies on jitting):**; 1450 /// ~~~{.cpp}; 1451 /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; 1452 /// ~~~; 1453 ///; 1454 /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; 1455 /// ~~~{.cpp}; 1456 /// auto cache_all_cols_df = df.Cache(myRegexp);; 1457 /// ~~~; 1458 template <typename... ColumnTypes>; 1459 RInterface<RLoopManager> Cache(const ColumnNames_t &columnList); 1460 {; 1461 auto staticSeq = std::make_index_sequence<sizeof...(ColumnTypes)>();; 1462 return CacheImpl<ColumnTypes...>(columnList, staticSeq);; 1463 }; 1464 ; 1465 ////////////////////////////////////////////////////////////////////////////; 1466 /// \brief Save selected columns in memory.; 1467 /// \param[in] columnList columns to be cached in memory; 1468 /// \return a `RDataFrame` that wraps the cached dataset.; 1469 ///; 1470 /// See the previous overloads for more information.; 1471 RInterface<RLoopManager> Cache(const ColumnNames_t &columnList); 1472 {; 1473 // Early return: if the list of columns is empty, just return an empty RDF; 1474 // If we proceed, the jitted call will not compile!; 1475 if (columnList.empty()) {; 1476 auto nEntries = *this->Count();; 1477 RInterface<RLoopManager> emptyRDF(std::make_shared<RLoopManager>(nEntries));; 1478 return emptyRDF;; 1479 }; 1480 ; 1481 std::stringstream cacheCall;; 1482 auto upcastNode = RDFInternal::UpcastNode(fProxiedPtr);; 1483 RInterface<TTraits::TakeFirstParameter_t<decltype(upcastNode)>> upcastInterface(fProxiedPtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:81552,Cache,CacheImpl,81552,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['Cache'],['CacheImpl']
Performance," x, . double * ; g . ). staticprotected . implementation of FCN for Fumili when user provided gradient is used ; static function implementing the evaluation of the FCN (it uses static instance fgFumili) ; Definition at line 240 of file TFumiliMinimizer.cxx. ◆ Fcn(). void TFumiliMinimizer::Fcn ; (; int & ; , . double * ; g, . double & ; f, . double * ; x, . int ;  . ). staticprotected . implementation of FCN for Fumili ; Definition at line 221 of file TFumiliMinimizer.cxx. ◆ IsA(). virtual TClass * TFumiliMinimizer::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 162 of file TFumiliMinimizer.h. ◆ MinGradient(). const double * TFumiliMinimizer::MinGradient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 93 of file TFumiliMinimizer.h. ◆ Minimize(). bool TFumiliMinimizer::Minimize ; (; ). overridevirtual . method to perform the minimization ; Implements ROOT::Math::Minimizer.; Definition at line 508 of file TFumiliMinimizer.cxx. ◆ MinValue(). double TFumiliMinimizer::MinValue ; (; ); const. inlineoverridevirtual . return minimum function value ; Implements ROOT::Math::Minimizer.; Definition at line 84 of file TFumiliMinimizer.h. ◆ NCalls(). unsigned int TFumiliMinimizer::NCalls ; (; ); const. inlineoverridevirtual . number of function calls to reach the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 96 of file TFumiliMinimizer.h. ◆ NDim(). unsigned int TFumiliMinimizer::NDim ; (; ); const. inlineoverridevirtual . this is <= Function().NDim() which is the total number of variables (free+ constrained ones) ; Implements ROOT::Math::Minimizer.; Definition at line 100 of file TFumiliMinimizer.h. ◆ NFree(). unsigned int TFumiliMinimizer::NFree ; (; ); const. inlineoverridevirtual . number of free variables (real dimension of the problem) this is <= Function().NDim() which is the total ; Reimplemented fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumiliMinimizer.html:14572,perform,perform,14572,doc/master/classTFumiliMinimizer.html,https://root.cern,https://root.cern/doc/master/classTFumiliMinimizer.html,1,['perform'],['perform']
Performance," x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52923,cache,cache,52923,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance," y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. RXImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font properties. void DrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); Draw text string. TGX11TTF(const TGX11& org). virtual ~TGX11TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x11ttf:$Id$ » Last generated: 2015-06-30 14:59; This page has been automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11TTF.html:28564,load,loading,28564,root/html602/TGX11TTF.html,https://root.cern,https://root.cern/root/html602/TGX11TTF.html,2,['load'],"['load', 'loading']"
Performance," y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. RXImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). void DeleteGC(GContext_t gc); Explicitely delete a graphics context. FontH_t GetFontHandle(FontStruct_t fs); Return handle to font described by font structure. FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. void MapGCFont(GContext_t gc, FontStruct_t font); Map the XftFont with the Graphics Context using it. Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font prope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGX11TTF.html:28702,load,loading,28702,root/html604/TGX11TTF.html,https://root.cern,https://root.cern/root/html604/TGX11TTF.html,2,['load'],"['load', 'loading']"
Performance," yet, then it will be read; 177 // from the cache path directly.; 178 TFile::SetCacheFileDir(""."");; 179 std::unique_ptr<TFile> input{TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"")};; 180 if (!input || input->IsZombie()) {; 181 throw std::runtime_error(""ERROR: could not open data file"");; 182 }; 183 std::cout << ""--- TMVAClassification : Using input file: "" << input->GetName() << std::endl;; 184 ; 185 // Register the training and test trees; 186 ; 187 TTree *signalTree = (TTree*)input->Get(""TreeS"");; 188 TTree *background = (TTree*)input->Get(""TreeB"");; 189 ; 190 // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; 191 TString outfileName(""TMVAC.root"");; 192 std::unique_ptr<TFile> outputFile{TFile::Open(outfileName, ""RECREATE"")};; 193 if (!outputFile || outputFile->IsZombie()) {; 194 throw std::runtime_error(""ERROR: could not open output file"");; 195 }; 196 ; 197 // Create the factory object. Later you can choose the methods; 198 // whose performance you'd like to investigate. The factory is; 199 // the only TMVA object you have to interact with; 200 //; 201 // The first argument is the base of the name of all the; 202 // weightfiles in the directory weight/; 203 //; 204 // The second argument is the output file for the training results; 205 // All TMVA output can be suppressed by removing the ""!"" (not) in; 206 // front of the ""Silent"" argument in the option string; 207 auto factory = std::make_unique<TMVA::Factory>(; 208 ""TMVAClassification"", outputFile.get(),; 209 ""!V:!Silent:Color:DrawProgressBar:Transformations=I;D;P;G,D:AnalysisType=Classification"");; 210 auto dataloader_raii = std::make_unique<TMVA::DataLoader>(""dataset"");; 211 auto *dataloader = dataloader_raii.get();; 212 // If you wish to modify default settings; 213 // (please check ""src/Config.h"" to see all available global options); 214 //; 215 // (TMVA::gConfig().GetVariablePlotting()).fTimesRMS = 8.0;; 216 // (TMVA::gConfig().GetIONames()).fWeightFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:7592,perform,performance,7592,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,1,['perform'],['performance']
Performance," you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutorials, copy the entire directory to your area. The script hsimple.C displays a histogram as it is being filled, and creates a ROOT file used by the other examples.; To execute it type:; $ cd $ROOTSYS/tutorials; $ root; ---------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073358,load,load,1073358,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance," { fgBytesRead = bytes; }; 4610 ; 4611//______________________________________________________________________________; 4612void TFile::SetFileBytesWritten(Long64_t bytes) { fgBytesWrite = bytes; }; 4613 ; 4614//______________________________________________________________________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:169199,cache,cachedir,169199,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,['cache'],"['cached', 'cachedir']"
Performance," {; 1345 theta = TMath::ACos(m[8]) * TMath::RadToDeg();; 1346 phi = TMath::ATan2(-m[8] * m[1], m[0]) * TMath::RadToDeg();; 1347 psi = 0.; // convention, phi+psi matters; 1348 return;; 1349 }; 1350 // sin(theta) != 0; 1351 phi = TMath::ATan2(m[2], -m[5]);; 1352 Double_t sphi = TMath::Sin(phi);; 1353 if (TMath::Abs(sphi) < 1.e-9); 1354 theta = -TMath::ASin(m[5] / TMath::Cos(phi)) * TMath::RadToDeg();; 1355 else; 1356 theta = TMath::ASin(m[2] / sphi) * TMath::RadToDeg();; 1357 phi *= TMath::RadToDeg();; 1358 psi = TMath::ATan2(m[6], m[7]) * TMath::RadToDeg();; 1359}; 1360 ; 1361////////////////////////////////////////////////////////////////////////////////; 1362/// computes determinant of the rotation matrix; 1363 ; 1364Double_t TGeoRotation::Determinant() const; 1365{; 1366 Double_t det = fRotationMatrix[0] * fRotationMatrix[4] * fRotationMatrix[8] +; 1367 fRotationMatrix[3] * fRotationMatrix[7] * fRotationMatrix[2] +; 1368 fRotationMatrix[6] * fRotationMatrix[1] * fRotationMatrix[5] -; 1369 fRotationMatrix[2] * fRotationMatrix[4] * fRotationMatrix[6] -; 1370 fRotationMatrix[5] * fRotationMatrix[7] * fRotationMatrix[0] -; 1371 fRotationMatrix[8] * fRotationMatrix[1] * fRotationMatrix[3];; 1372 return det;; 1373}; 1374 ; 1375////////////////////////////////////////////////////////////////////////////////; 1376/// performes an orthogonality check and finds if the matrix is a reflection; 1377/// Warning(""CheckMatrix"", ""orthogonality check not performed yet"");; 1378 ; 1379void TGeoRotation::CheckMatrix(); 1380{; 1381 if (Determinant() < 0); 1382 SetBit(kGeoReflection);; 1383 Double_t dd = fRotationMatrix[0] + fRotationMatrix[4] + fRotationMatrix[8] - 3.;; 1384 if (TMath::Abs(dd) < 1.E-12); 1385 ResetBit(kGeoRotation);; 1386 else; 1387 SetBit(kGeoRotation);; 1388}; 1389 ; 1390////////////////////////////////////////////////////////////////////////////////; 1391/// Get the inverse rotation matrix (which is simply the transpose); 1392 ; 1393void TGeoRotation::GetInverse(Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:49573,perform,performes,49573,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,2,['perform'],"['performed', 'performes']"
Performance," {; 1589 TStreamerElement *aElement = conf->fCompInfo->fElem;; 1590 TStreamerInfo *info = (TStreamerInfo*)conf->fInfo;; 1591 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1592 char *ptr = (char*)addr;; 1593 info->ReadBufferSkip(b,&ptr,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,1,0);; 1594 } else {; 1595 config->fAction(b, (*cached)[0]);; 1596 }; 1597 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1598 if (config->fNeedRepeat) {; 1599 b.SetBufferOffset(bufpos);; 1600 }; 1601 return 0;; 1602 }; 1603 ; 1604 INLINE_TEMPLATE_ARGS Int_t UseCacheVectorPtrLoop(TBuffer &b, void *start, const void *end, const TConfiguration *conf); 1605 {; 1606 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1607 Int_t bufpos = b.Length();; 1608 ; 1609 TVirtualArray *cached = b.PeekDataCache();; 1610 if (cached==0) {; 1611 TStreamerElement *aElement = config->fCompInfo->fElem;; 1612 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1613 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1614 char *ptr = (char*)start;; 1615 UInt_t n = (((void**)end)-((void**)start));; 1616 info->ReadBufferSkip(b,&ptr,config->fCompInfo,conf->fCompInfo->fType+TStreamerInfo::kSkip,aElement,n,0);; 1617 } else {; 1618 TVectorLoopConfig cached_config( nullptr, cached->fClass->Size(), /* read */ kTRUE );; 1619 void *cached_start = (*cached)[0];; 1620 void *cached_end = ((char*)cached_start) + cached->fSize * cached_config.fIncrement;; 1621 config->fAction(b,cached_start,cached_end,&cached_config);; 1622 }; 1623 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1624 if (config->fNeedRepeat) {; 1625 b.SetBufferOffset(bufpos);; 1626 }; 1627 return 0;; 1628 }; 1629 ; 1630 INLINE_TEMPLATE_ARGS Int_t UseCacheVectorLoop(TBuffer &b, void *start, const void *end, const TLoopConfiguration *loopconf, const TConfiguration *conf); 1631 {; 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:66424,cache,cached,66424,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance," {; 1856 //otherwise we read all blocks that fit in the read-ahead buffer; 1857 Seek(curbegin);; 1858 if (!buf2) buf2 = new char[fgReadaheadSize];; 1859 //we read ahead; 1860 Long64_t nahead = pos[i-1]+len[i-1]-curbegin;; 1861 result = ReadBuffer(buf2, nahead);; 1862 if (result) break;; 1863 //now copy from the read-ahead buffer to the cache; 1864 Int_t kold = k;; 1865 for (Int_t j=0;j<n;j++) {; 1866 memcpy(&buf[k],&buf2[pos[i-n+j]-curbegin],len[i-n+j]);; 1867 k += len[i-n+j];; 1868 }; 1869 Int_t nok = k-kold;; 1870 Long64_t extra = nahead-nok;; 1871 fBytesReadExtra += extra;; 1872 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:67825,cache,cache,67825,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,['cache'],['cache']
Performance," {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:129966,Load,LoadLibraryMap,129966,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,4,"['Load', 'load']","['LoadLibrary', 'LoadLibraryMap', 'loadLib', 'loading']"
Performance," {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5615 Int_t i = fStreamerInfo->LowerBound();; 5616 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5617 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5618 if (fStreamerInfo->At(i)) {; 5619 // Print some debugging info.; 5620 Error(""DeleteArray"", ""Doing Dump() ..."");; 5621 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5622 }; 5623 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:214633,load,loaded,214633,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance," {; 5647 currentVersion = kTRUE;; 5648 break;; 5649 }; 5650 }; 5651 }; 5652 }; 5653 ; 5654 if (!inRepo || currentVersion) {; 5655 // The object was allocated using code for the same class version; 5656 // as is loaded now. We may proceed without worry.; 5657 TVirtualStreamerInfo* si = GetStreamerInfo();; 5658 if (si) {; 5659 si->DeleteArray(ary, dtorOnly);; 5660 } else {; 5661 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5662 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5663 Int_t i = fStreamerInfo->LowerBound();; 5664 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5665 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5666 if (fStreamerInfo->At(i)) {; 5667 Error(""DeleteArray"", ""Doing Dump() ..."");; 5668 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5669 }; 5670 }; 5671 }; 5672 } else {; 5673 // The loaded class version is not the same as the version of the code; 5674 // which was used to allocate this array. The best we can do is use; 5675 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5676 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5677 if (si) {; 5678 si->DeleteArray(ary, dtorOnly);; 5679 } else {; 5680 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5681 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5682 Int_t i = fStreamerInfo->LowerBound();; 5683 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5684 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5685 if (fStreamerInfo->At(i)) {; 5686 // Print some debugging info.; 5687 Error(""DeleteArray"", ""Doing Dump() ..."");; 5688 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5689 }; 5690 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:217384,load,loaded,217384,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance," {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void finalizeConstruction ();  ; std::pair< const RooArgSet *, AddCacheElem * > getNormAndCache (const RooArgSet *nset) const;  Look up projection cache and per-PDF norm sets. ;  ; void materializeRefCoefNormFromAttribute () const;  ; void setAllExtendable (bool allExtendable);  ; void setRecursiveFraction (bool recursiveFraction);  . Private Attributes; std::unique_ptr< const RooArgSet > _copyOfLastNormSet = nullptr;  ! ;  ; RooFit::UniqueId< RooArgSet >::Value_t _idOfLastUsedNormSet = RooFit::UniqueId<RooArgSet>::nullval;  ! ;  . Friends; class RooAddGenContext;  ; class RooAddModel;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:74536,cache,cache,74536,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,1,['cache'],['cache']
Performance," {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void finalizeConstruction ();  ; std::pair< const RooArgSet *, AddCacheElem * > getNormAndCache (const RooArgSet *nset) const;  Look up projection cache and per-PDF norm sets. ;  ; void materializeRefCoefNormFromAttribute () const;  ; void setAllExtendable (bool allExtendable);  ; void setRecursiveFraction (bool recursiveFraction);  . Private Attributes; std::unique_ptr< const RooArgSet > _copyOfLastNormSet = nullptr;  ! ;  ; RooFit::UniqueId< RooArgSet >::Value_t _idOfLastUsedNormSet = RooFit::UniqueId<RooArgSet>::nullval;  ! ;  . Friends; class RooAddGenContext;  ; class RooAddModel;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; typedef std::map< constRooAbsArg *, std::pair< std::string, std::list< EvalError > > >::const_iterator EvalErrorIter;  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:75686,cache,cache,75686,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,1,['cache'],['cache']
Performance," | Band2 |; // | |; // +-------------+-----------+; // |; ; x.setRange(""SB1"", -10, +10);; y.setRange(""SB1"", -10, 0);; ; x.setRange(""SB2"", -10, 0);; y.setRange(""SB2"", 0, +10);; ; x.setRange(""SIG"", 0, +10);; y.setRange(""SIG"", 0, +10);; ; x.setRange(""FULL"", -10, +10);; y.setRange(""FULL"", -10, +10);; ; // P e r f o r m f i t s i n i n d i v i d u a l s i d e b a n d r e g i o n s; // -------------------------------------------------------------------------------------; ; // Perform fit in SideBand1 region (RooAddPdf coefficients will be interpreted in full range); std::unique_ptr<RooFitResult> r_sb1{model.fitTo(*modelData, Range(""SB1""), Save(), PrintLevel(-1))};; ; // Perform fit in SideBand2 region (RooAddPdf coefficients will be interpreted in full range); std::unique_ptr<RooFitResult> r_sb2{model.fitTo(*modelData, Range(""SB2""), Save(), PrintLevel(-1))};; ; // P e r f o r m f i t s i n j o i n t s i d e b a n d r e g i o n s; // -----------------------------------------------------------------------------; ; // Now perform fit to joint 'L-shaped' sideband region 'SB1|SB2'; // (RooAddPdf coefficients will be interpreted in full range); std::unique_ptr<RooFitResult> r_sb12{model.fitTo(*modelData, Range(""SB1,SB2""), Save(), PrintLevel(-1))};; ; // Print results for comparison; r_sb1->Print();; r_sb2->Print();; r_sb12->Print();; }; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooFitResult.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; mxOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf312__multirangefit_8C.html:2873,perform,perform,2873,doc/master/rf312__multirangefit_8C.html,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8C.html,1,['perform'],['perform']
Performance," |; Static Public Member Functions |; Private Attributes |; List of all members ; TMVA::HyperParameterOptimisation Class ReferenceTMVA. . Definition at line 73 of file HyperParameterOptimisation.h. Public Member Functions;  HyperParameterOptimisation (DataLoader *dataloader);  ;  ~HyperParameterOptimisation ();  ; virtual void Evaluate ();  Virtual method to be implemented with your algorithm. ;  ; TString GetFiiter ();  ; TString GetFOMType ();  ; UInt_t GetNumFolds ();  ; const HyperParameterOptimisationResult & GetResults () const;  ; virtual TClass * IsA () const;  ; void SetFitter (TString fitType);  ; void SetFOMType (TString ftype);  ; void SetNumFolds (UInt_t folds);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; virtual void ParseOptions ();  Method to parse the internal option string. ;  ; void SetDataLoader (DataLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1HyperParameterOptimisation.html:1244,perform,perform,1244,doc/master/classTMVA_1_1HyperParameterOptimisation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1HyperParameterOptimisation.html,1,['perform'],['perform']
Performance," } else {; 6532 return 0;; 6533 }; 6534 }; 6535 ; 6536 R__LOCKGUARD(gInterpreterMutex);; 6537 ; 6538 if (gDebug > 1) {; 6539 Info(""TCling::AutoParse"",; 6540 ""Trying to autoparse for %s"", cls);; 6541 }; 6542 ; 6543 // The catalogue of headers is in the dictionary; 6544 if (fClingCallbacks->IsAutoLoadingEnabled(); 6545 && !gClassTable->GetDictNorm(cls)) {; 6546 // Need RAII against recursive (dictionary payload) parsing (ROOT-8445).; 6547 ROOT::Internal::ParsingStateRAII parsingStateRAII(fInterpreter->getParser(),; 6548 fInterpreter->getSema());; 6549 AutoLoad(cls, true /*knowDictNotLoaded*/);; 6550 }; 6551 ; 6552 // Prevent the recursion when the library dictionary are loaded.; 6553 SuspendAutoLoadingRAII autoLoadOff(this);; 6554 ; 6555 // No recursive header parsing on demand; we require headers to be standalone.; 6556 SuspendAutoParsing autoParseRAII(this);; 6557 ; 6558 Int_t nHheadersParsed = AutoParseImplRecurse(cls,/*topLevel=*/ true);; 6559 ; 6560 ProcessClassesToUpdate();; 6561 ; 6562 return nHheadersParsed > 0 ? 1 : 0;; 6563}; 6564 ; 6565// This is a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.; 6566// Try to solve the problem by AutoLoading. Return true when AutoLoading success, return; 6567// false if not.; 6568bool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 6569{; 6570 StringRef errMsg(errmessage);; 6571 if (errMsg.contains(""undefined symbol: "")) {; 6572 // This branch is taken when the callback was from DynamicLibraryManager::loadLibrary; 6573 std::string mangled_name = std::string(errMsg.split(""undefined symbol: "").second);; 6574 void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);; 6575 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 6576 if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess)); 6577 // Return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:255169,load,loadLibrary,255169,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loadLibrary']
Performance," }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if (fBasketBytes[basketnumber] == 0) {; 1255 fBasketBytes[basketnumber] = basket->ReadBasketBytes(fBasketSeek[basketnumber],file);; 1256 }; 1257 //add branch to cache (if any); 1258 {; 1259 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 1260 TFileCacheRead *pf = fTree->GetReadCache(file);; 1261 if (pf){; 1262 if (pf->IsLearning()) pf->LearnBranch(this, false);; 1263 if (fSkipZip) pf->SetSkipZip();; 1264 }; 1265 }; 1266 ; 1267 //now read basket; 1268 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[basketnumber],fBasketBytes[basketnumber],file);; 1269 if (R__unlikely(badread || basket->GetSeekKey() != fBasketSeek[basketnumber] || basket->IsZombie())) {; 1270 nerrors++;; 1271 if (nerrors > 10) return nullptr;; 1272 if (nerrors == 10) {; 1273 printf("" file probably overwritten: stopping reporting error messages\n"");; 1274 if (fBasketSeek[basketnumber] > 2000000000) {; 1275 printf(""===>File is more than 2 Gigabytes\n"");; 1276 return nullptr;; 1277 }; 1278 if (fBasketSeek[basketnumber] > 1000000000) {; 1279 printf(""===>Your file is may be bigger than the maximum file size allowed on your system\n"");; 1280 printf("" Check your AFS maximum file size limit for example\n"");; 1281 return nullptr;; 1282 }; 1283 }; 1284 Error(""GetBasket"",""File: %s at byte:%lld, branch:%s, entry:%lld, badread=%d, nerrors=%d, basketnumber=%d"",file->GetName(),basket->GetSeekKey(),GetName(),fReadEntry,badread,nerrors.load(),basketnumber);; 1285 return nullptr;; 1286 }; 1287 ; 1288 ++fNBaskets;; 1289 ; 1290 fCacheInfo.SetUsed(basketnumber);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:44132,cache,cache,44132,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['cache'],['cache']
Performance," }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interprete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:68492,load,load,68492,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance," }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:68926,load,loaded,68926,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance," }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math; 303 ; 304} // end namespace ROOT; 305 ; 306 ; 307#endif /* ROOT_Math_WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const Wrapped",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedParamFunction_8h_source.html:9588,cache,cached,9588,doc/master/WrappedParamFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html,1,['cache'],['cached']
Performance," }; 3076 fComp[fNdata].fType = element->GetType();; 3077 fComp[fNdata].fNewType = element->GetNewType();; 3078 fComp[fNdata].fOffset = element->GetOffset();; 3079 fComp[fNdata].fLength = element->GetArrayLength();; 3080 fComp[fNdata].fElem = element;; 3081 fComp[fNdata].fMethod = element->GetMethod();; 3082 fComp[fNdata].fClass = element->GetClassPointer();; 3083 fComp[fNdata].fNewClass = element->GetNewClass();; 3084 fComp[fNdata].fClassName = TString(element->GetTypeName()).Strip(TString::kTrailing, '*');; 3085 fComp[fNdata].fStreamer = element->GetStreamer();; 3086 ; 3087 // try to group consecutive members of the same type; 3088 if (!TestBit(kCannotOptimize); 3089 && (keep >= 0); 3090 && (element->GetType() > 0); 3091 && (element->GetType() < 10); 3092 && (fComp[fNdata].fType == fComp[fNdata].fNewType); 3093 && (fComp[keep].fMethod == 0); 3094 && (element->GetArrayDim() == 0); 3095 && (fComp[keep].fType < kObject); 3096 && (fComp[keep].fType != kCharStar) /* do not optimize char* */; 3097 && (element->GetType() == (fComp[keep].fType%kRegrouped)); 3098 && ((element->GetOffset()-fComp[keep].fOffset) == (fComp[keep].fLength)*asize); 3099 && ((fOldVersion<6) || !previous || /* In version of TStreamerInfo less than 6, the Double32_t were merged even if their annotation (aka factor) were different */; 3100 ((element->GetFactor() == previous->GetFactor()); 3101 && (element->GetXmin() == previous->GetXmin()); 3102 && (element->GetXmax() == previous->GetXmax()); 3103 ); 3104 ); 3105 && (element->TestBit(TStreamerElement::kCache) == previous->TestBit(TStreamerElement::kCache)); 3106 && (element->TestBit(TStreamerElement::kWrite) == previous->TestBit(TStreamerElement::kWrite)); 3107 // kWholeObject and kDoNotDelete do not apply to numerical elements.; 3108 ); 3109 {; 3110 if (!previousOptimized) {; 3111 // The element was not yet optimized we first need to copy it into; 3112 // the set of original copies.; 3113 fComp[fNslots - (++optiOut) ] = fComp[keep]; // Copy the optimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:135296,optimiz,optimize,135296,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['optimiz'],['optimize']
Performance," }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGenCollectionProxy(*this);; 737 ; 738 switch(fSTL_type) {; 739 case ROOT::kSTLbitset: {; 740 return new TGenBitsetProxy(*this);; 741 }; 742 case ROOT::kSTLvector: {; 7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21662,load,load,21662,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance," };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ; The value of the function in the ith bin is given by:; F(i) = gamma_i * nominal(i); Where the nominal values are simply fixed numbers (default = 1.0 for all i) ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:62520,cache,cache,62520,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['cache'],['cache']
Performance," };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* wor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlaveLite.html:7522,perform,performance,7522,root/html528/TSlaveLite.html,https://root.cern,https://root.cern/root/html528/TSlaveLite.html,1,['perform'],['performance']
Performance," };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSlave(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSlave.html:7672,perform,performance,7672,root/html528/TXSlave.html,https://root.cern,https://root.cern/root/html528/TXSlave.html,1,['perform'],['performance']
Performance," ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. {}. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cached inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(const double* x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoParameterDerivative(const double* x, const double* p, unsigned int ipar) const; evaluate the partial derivative with respect to the parameter. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__WrappedMultiTF1.html:2907,cache,cached,2907,root/html526/ROOT__Math__WrappedMultiTF1.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__WrappedMultiTF1.html,4,['cache'],['cached']
Performance,"  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:28362,cache,cache,28362,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,8,['cache'],['cache']
Performance,"  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); # -----------------------------------------------------------------------; ; # Create 2D histogram; h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8py.html:1050,cache,cache,1050,doc/master/rf705__linearmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html,1,['cache'],['cache']
Performance,"  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooCachedReal Class ReferenceRooFit » RooFit Core. ; Implementation of RooAbsCachedReal that can cache any external RooAbsReal input function provided in the constructor. ; Definition at line 20 of file RooCachedReal.h. Public Member Functions;  RooCachedReal ();  ;  RooCachedReal (const char *name, const char *title, RooAbsReal &_func);  Constructor taking name, title and function to be cached. ;  ;  RooCachedReal (const char *name, const char *title, RooAbsReal &_func, const RooArgSet &cacheObs);  Constructor taking name, title and function to be cached and fixed choice of variable to cache. ;  ;  RooCachedReal (const RooCachedReal &other, const char *name=nullptr);  Copy constructor. ;  ; bool cacheSource () const;  ; TObject * clone (const char *newname) const override;  ; bool getCdfBoundaries () const;  If true the c.d.f boundary mode is active. ;  ; TClass * IsA () const override;  ; void setCacheSource (bool flag);  ; void setCdfBoundaries (bool flag);  If flag is true the RooHistFunc that represent the cache histogram will use special boundary conditions for use with cumulative distribution functions: at the lower bound the function is forced to converge at zero and the upper bound is the function is forced to converge at 1.0. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsCachedReal;  RooAbsCachedReal ();  ;  RooAbsCachedReal (const char *name, const char *title, Int_t ipOrder=0);  Constructor. ;  ;  RooAbsCachedReal (const RooAbsCachedReal &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:986,cache,cacheSource,986,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cacheSource']
Performance,"  ; Bool_t GetDebug ();  ; const char * GetOutFileName () const;  ; TClass * IsA () const override;  ; Int_t MakeDataSet (const char *dset=0, Long64_t nevt=-1, const char *fnroot=""event"", Bool_t regenerate=kFALSE);  Create the largest dataset for the run. ;  ; Int_t OpenOutFile (Bool_t wrt=kFALSE, Bool_t verbose=kTRUE);  Set the otuput file Return 0 on success, -1 on error. ;  ; Int_t ReleaseCache (const char *dset);  Release memory cache for dataset 'dset' Return 0 on success, -1 on error. ;  ; Int_t RemoveDataSet (const char *dset);  Physically remove the dataset 'dset', i.e. ;  ; Int_t RunCPU (Long64_t nevents=-1, Int_t start=-1, Int_t stop=-1, Int_t step=-1);  Perform the CPU run Return 0 on success, -1 on error. ;  ; Int_t RunCPUx (Long64_t nevents=-1, Int_t start=-1, Int_t stop=-1);  Perform the CPU run scanning over the number of workers per node Return 0 on success, -1 on error. ;  ; Int_t RunDataSet (const char *dset=""BenchDataSet"", Int_t start=1, Int_t stop=-1, Int_t step=1);  Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ;  ; Int_t RunDataSetx (const char *dset=""BenchDataSet"", Int_t start=1, Int_t stop=-1);  Perform a test using dataset 'dset' scanning over the number of workers per node. ;  ; void SetCPUPar (const char *par);  ; void SetCPUSel (const char *sel);  ; void SetDataGenPar (const char *par);  ; void SetDataGenSel (const char *sel);  ; void SetDataPar (const char *par);  ; void SetDataSel (const char *sel);  ; void SetDebug (Bool_t debug=kTRUE);  ; void SetHistType (TPBHistType *histtype);  ; void SetNFilesWrk (Int_t nf=0);  ; void SetNHist (Int_t nh);  ; void SetNTries (Int_t nt);  ; Int_t SetOutFile (const char *outfile, Bool_t verbose=kTRUE);  Set the output file Return 0 on success, -1 on error. ;  ; void SetProofDS (TProof *p);  Set the PROOF instance to be used for dataset operations, like releasing cache ... Use SetProofDS(0) to reset and using the default PROOF. ;  ; void SetReadType",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:1934,Perform,Perform,1934,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['Perform'],['Perform']
Performance,"  ; Double_t AndersonDarling2SamplesTest (const Char_t *option=""p"") const;  Anderson-Darling 2-Sample Test. ;  ; void AndersonDarling2SamplesTest (Double_t &pvalue, Double_t &testStat) const;  Performs the Anderson-Darling 2-Sample Test. ;  ; Double_t AndersonDarlingTest (const Char_t *option=""p"") const;  Anderson-Darling 2-Sample Test. ;  ; void AndersonDarlingTest (Double_t &pvalue, Double_t &testStat) const;  Performs the Anderson-Darling 1-Sample Test. ;  ; Double_t KolmogorovSmirnov2SamplesTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; void KolmogorovSmirnov2SamplesTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; Double_t KolmogorovSmirnovTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void KolmogorovSmirnovTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void operator() (ETestType test, Double_t &pvalue, Double_t &testStat) const;  The class's unary functions performing the gif test according to the ETestType provided. ;  ; Double_t operator() (ETestType test=kAD, const Char_t *option=""p"") const;  Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value specific to the test type. ;  ; void SetDistribution (EDistribution dist, const std::vector< double > &distParams={});  Sets the distribution for the predefined distribution types and optionally its parameters for 1-sample tests. ;  ; void SetUserCDF (const IGenFunction &cdf, Double_t xmin=1, Double_t xmax=0);  Specialization to set the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; template<class Dist > ; void SetUserCDF (Dist &cdf, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; void SetUserDistribution (const IGenFunction &dist, GoFTest::EUserDistribution userDist=kPDF, Double_t xmin=1, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:3953,perform,performing,3953,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['perform'],['performing']
Performance,"  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:14398,cache,cache,14398,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:15795,cache,cached,15795,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cached']
Performance,"  ; ROOT::ResetAfterMergeFunc_t GetResetAfterMerge () const;  Return the wrapper around Merge. ;  ; const ROOT::Detail::TSchemaRuleSet * GetSchemaRules () const;  Return the set of the schema rules if any. ;  ; ROOT::Detail::TSchemaRuleSet * GetSchemaRules (Bool_t create=kFALSE);  Return the set of the schema rules if any. ;  ; const char * GetSharedLibs ();  Get the list of shared libraries containing the code for class cls. ;  ; ShowMembersFunc_t GetShowMembersWrapper () const;  ; EState GetState () const;  ; TClassStreamer * GetStreamer () const;  Return the Streamer Class allowing streaming (if any). ;  ; ClassStreamerFunc_t GetStreamerFunc () const;  Get a wrapper/accessor function around this class custom streamer (member function). ;  ; TVirtualStreamerInfo * GetStreamerInfo (Int_t version=0, Bool_t isTransient=kFALSE) const;  returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ;  ; TVirtualStreamerInfo * GetStreamerInfoAbstractEmulated (Int_t version=0) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; const TObjArray * GetStreamerInfos () const;  ; const std::type_info * GetTypeInfo () const;  ; Bool_t HasConsistentHashMember ();  Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ;  ; Bool_t HasCustomStreamerMember () const;  The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ;  ; Bool_t HasDataMemberInfo () const;  ; Bool_t HasDefaultConstructor (Bool_t testio=kFALSE) const;  Return true if we have access to a constructor usable for I/O. ;  ; Bool_t HasDictionary () const;  Check whether a class has a dictionary or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:15172,load,loaded,15172,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['load'],['loaded']
Performance,"  ; TLeaf * GetLeaf (const char *name) override;  Return a pointer to the leaf name in the current tree. ;  ; TObjArray * GetListOfFiles () const;  ; Double_t GetMaximum (const char *columname) override;  Return maximum of column with name columname. ;  ; Double_t GetMinimum (const char *columname) override;  Return minimum of column with name columname. ;  ; Int_t GetNbranches () override;  Return the number of branches of the current tree. ;  ; Int_t GetNtrees () const;  ; TList * GetStatus () const;  ; TTree * GetTree () const override;  ; Int_t GetTreeNumber () const override;  ; Long64_t * GetTreeOffset () const;  ; Int_t GetTreeOffsetLen () const;  ; Double_t GetWeight () const override;  Return the chain weight. ;  ; bool InPlaceClone (TDirectory *newdirectory, const char *options="""") override;  Move content to a new file. (NOT IMPLEMENTED for TChain) ;  ; Int_t LoadBaskets (Long64_t maxmemory) override;  Dummy function. ;  ; Long64_t LoadTree (Long64_t entry) override;  Find the tree which contains entry, and set it as the current tree. ;  ; void Lookup (bool force=false);  Check / locate the files in the chain. ;  ; virtual void Loop (Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED) ;  ; void ls (Option_t *option="""") const override;  List the chain. ;  ; virtual Long64_t Merge (const char *name, Option_t *option="""");  Merge all the entries in the chain into a new tree in a new file. ;  ; Long64_t Merge (TCollection *list, Option_t *option="""") override;  Merge all chains in the collection. (NOT IMPLEMENTED) ;  ; Long64_t Merge (TCollection *list, TFileMergeInfo *info) override;  Merge all chains in the collection. (NOT IMPLEMENTED) ;  ; virtual Long64_t Merge (TFile *file, Int_t basketsize, Option_t *option="""");  Merge all the entries in the chain into a new tree in the current file. ;  ; void Print (Option_t *option="""") const override;  Print the header infor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:9071,Load,LoadTree,9071,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['Load'],['LoadTree']
Performance,"  ; UserGroup_t * GetUserInfo (const char *user=nullptr) override;  Returns all user info in the UserGroup_t structure. ;  ; UserGroup_t * GetUserInfo (Int_t uid) override;  Returns all user info in the UserGroup_t structure. ;  ; std::string GetWorkingDirectory () const override;  Return working directory. ;  ; const char * HomeDirectory (const char *userName=nullptr) override;  Return the user's home directory. ;  ; const char * HostName () override;  Return the system's host name. ;  ; void IgnoreSignal (ESignals sig, Bool_t ignore=kTRUE) override;  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t Init () override;  Initialize Unix system interface. ;  ; TClass * IsA () const override;  ; Bool_t IsPathLocal (const char *path) override;  Returns TRUE if the url in 'path' points to the local file system. ;  ; int Link (const char *from, const char *to) override;  Create a link from file1 to file2. ;  ; void ListLibraries (const char *regexp="""") override;  List all loaded shared libraries. ;  ; void ListSymbols (const char *module, const char *re="""") override;  List symbols in a shared library. ;  ; int Load (const char *module, const char *entry="""", Bool_t system=kFALSE) override;  Load a shared library. ;  ; int MakeDirectory (const char *name) override;  Make a Unix file system directory. ;  ; TTime Now () override;  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"") override;  Open a connection to a service on a server. ;  ; void * OpenDirectory (const char *name) override;  Open a Unix file system directory. Returns 0 if directory does not exist. ;  ; void Openlog (const char *name, Int_t options, ELogFacility facility) override;  Open connection to system log daemon. ;  ; FILE * OpenPipe (const char *shellcmd, const char *mode) override;  Open a pipe. ;  ; const char * PrependPathName (const char *dir, TString ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:7851,load,loaded,7851,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['load'],['loaded']
Performance,"  ; class  MinimizerOptions;  Minimizer options. More...;  ; class  MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  MinOp;  Subtraction Operation Class. More...;  ; class  Minus;  Unary Minus Operation Class. More...;  ; struct  MinusEquals;  Evaluate the expression performing a -= operation Need to check whether creating a temporary object with the expression result (like in op: A -= A * B ) More...;  ; struct  MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >;  Specialization for symmetrix -= general : NOT Allowed operation. More...;  ; struct  MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  Specialization for symmetric matrices. More...;  ; struct  MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; class  MixMaxEngine;  MixMaxEngine is a wrapper class for the MIXMAX Random number generator. More...;  ; class  MixMaxEngineImpl;  ; class  MixMaxEngineImpl< ROOT_MM_N >;  ; class  MulOp;  Multiplication (element-wise) Operation Class. More...;  ; class  MultiDimParamFunctionAdapter;  MultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimensional parametric function interface This is used typically in fitting where internally the function is stored as multi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:21739,perform,performing,21739,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"  ; class  PDFIntegral;  ; struct  PlaceExpr;  ; struct  PlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  ; struct  PlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  ; struct  PlaceMatrix;  Structure to deal when a submatrix is placed in a matrix. More...;  ; struct  PlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  ; struct  PlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  ; struct  PlainParameters;  ; struct  PlusEquals;  Evaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) More...;  ; struct  PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >;  Specialization for symmetrix += general : NOT Allowed operation. More...;  ; struct  PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) More...;  ; class  Polar2D;  Class describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polar3D;  Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polynomial;  Parametric Function class describing polynomials of order n. More...;  ; class  PositionVector2D;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  PositionVector3D;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  PtEtaPhiE4D;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:25274,perform,performing,25274,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Observable to be cached for given choice of normalization. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Parameters of the cache. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Create and return a derived MorphCacheElem. ;  ; double evaluate () const override;  Dummy. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the cache with the interpolated shape. ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool rec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:64864,cache,cache,64864,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Observable to be cached for given choice of normalization. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Parameters of the cache. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Create and return a derived MorphCacheElem. ;  ; double evaluate () const override;  Dummy. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the cache with the interpolated shape. ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual const char * payloadUniqueSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:65228,cache,cache,65228,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherite,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:49495,cache,cache,49495,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ;  ; Int_t Sizeof () const override;  Return the size in bytes of the file header. ;  ; void Streamer (TBuffer &) override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:6806,cache,cache,6806,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,2,['cache'],['cache']
Performance,"  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Test ();  Perform test evaluation in all booked methods. ;  ; virtual void TestMethod (TString methodname, TString methodtitle);  Lets perform test an specific ml method. ;  ; virtual void TestMethod (Types::EMVA method, TString methodtitle);  Lets perform test an specific ml method given the method type in enum TMVA::Types::EMVA. ;  ; virtual void Train ();  Method to train all booked ml methods. ;  ; virtual void TrainMethod (TString methodname, TString methodtitle);  Lets train an specific ml method. ;  ; virtual void TrainMethod (Types::EMVA method, TString methodtitle);  Lets train an specific ml method given the method type in enum TMVA::Types::EMVA. ;  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; virtual void ParseOptions ();  Method to parse the internal option string. ;  ; void SetDataLoader (DataLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html:2109,perform,perform,2109,doc/master/classTMVA_1_1Experimental_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html,1,['perform'],['perform']
Performance,"  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:49009,Cache,CacheMode,49009,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,14,"['Cache', 'cache']","['CacheMode', 'cache']"
Performance,"  ; void Delete (Option_t *option="""") override;  Delete all TFunction object files. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const char *name) const override;  Specialize FindObject to do search for the a function just by name or create it if its not already in the list. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TFunctionTemplate * Get (DeclId_t id);  Return (after creating it if necessary) the TMethod or TFunction describing the function corresponding to the Decl 'id'. ;  ; virtual TList * GetListForObject (const char *name) const;  Return the set of overloads for this name, collecting all available ones. ;  ; virtual TList * GetListForObject (const TObject *obj) const;  Return the set of overloads for function obj, collecting all available ones. ;  ; TClass * IsA () const override;  ; void Load ();  Load all the functions known to the interpreter for the scope 'fClass' into this collection. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TFunctionTemplate *func);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:2700,Load,Load,2700,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,2,['Load'],['Load']
Performance,"  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStreamerElement. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBase.html:4073,cache,cache,4073,doc/master/classTStreamerBase.html,https://root.cern,https://root.cern/doc/master/classTStreamerBase.html,1,['cache'],['cache']
Performance,"  ; void MakeZombie ();  . Protected Attributes; TBranch * fBranchCount;  Branch with clones count. ;  ; TString fClassName;  Name of the class of the objets in the ClonesArray. ;  ; TClonesArray * fList;  ! Pointer to the clonesarray ;  ; Int_t fN;  ! Number of elements in ClonesArray ;  ; Int_t fNdataMax;  ! Maximum value of fN ;  ; Int_t fRead;  ! flag = 1 if clonesarray has been read ;  ;  Protected Attributes inherited from TBranch; char * fAddress;  ! Address of 1st leaf (variable or object) ;  ; Int_t * fBasketBytes;  [fMaxBaskets] Length of baskets on file ;  ; Long64_t * fBasketEntry;  [fMaxBaskets] Table of first entry in each basket ;  ; TObjArray fBaskets;  -> List of baskets of this branch ;  ; Long64_t * fBasketSeek;  [fMaxBaskets] Addresses of baskets on file ;  ; Int_t fBasketSize;  Initial Size of Basket Buffer. ;  ; TObjArray fBranches;  -> List of Branches of this branch ;  ; TList * fBrowsables;  ! List of TVirtualBranchBrowsables used for Browse() ;  ; BulkObj fBulk;  ! Helper for performing bulk IO ;  ; CacheInfo_t fCacheInfo;  ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ;  ; Int_t fCompress;  Compression level and algorithm. ;  ; TBasket * fCurrentBasket;  ! Pointer to the current basket. ;  ; TDirectory * fDirectory;  ! Pointer to directory where this branch buffers are stored ;  ; Long64_t fEntries;  Number of entries. ;  ; TBuffer * fEntryBuffer;  ! Buffer used to directly pass the content without streaming ;  ; Long64_t fEntryNumber;  Current entry number (last one filled in this branch) ;  ; Int_t fEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TBasket * fExtraBasket;  ! Allocated basket not currently holding any data. ;  ; TString fFileName;  Name of file where buffers are stored ("""" if in same file as Tree header) ;  ; FillLeaves_t fFillLeaves;  ! Pointer to the FillLeaves implementation to use. ;  ; Long64_t fFirstBasketEntry;  ! First entry in the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchClones.html:23545,perform,performing,23545,doc/master/classTBranchClones.html,https://root.cern,https://root.cern/doc/master/classTBranchClones.html,3,"['cache', 'perform']","['cache', 'performing']"
Performance,"  ; void PutImage (Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Combines an image with a rectangle of the specified drawable. ;  ; void PutPixel (Drawable_t id, Int_t x, Int_t y, ULong_t pixel) override;  Overwrites the pixel in the image with the specified pixel value. ;  ; void QueryColor (Colormap_t cmap, ColorStruct_t &color) override;  Fill in the primary color components for a specific pixel value. ;  ; void QueryPointer (Int_t &ix, Int_t &iy) override;  Query pointer position. ;  ; void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask) override;  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; void RaiseWindow (Window_t id) override;  Put window on top of window stack. ;  ; Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t id=0) override;  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data) override;  Read picture data from file and store in ret_data. ;  ; void RemoveWindow (ULongptr_t qwid) override;  Remove a window created by Qt (like CloseWindow1()). ;  ; void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y) override;  Reparent window, make pid the new parent and position the window at position (x,y) in new parent. ;  ; Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) override;  Request Locator position. ;  ; Int_t RequestString (Int_t x, Int_t y, char *text) override;  Request a string. ;  ; void RescaleWindow (Int_t wid, UInt_t w, UInt_t h) override;  Rescale the window wid. ;  ; Int_t ResizePixmap (Int_t wid, UInt_t w, UInt_t h) override;  Resize a pixmap. ;  ; void ResizeWindow (Int_t wid) override;  Resize the current window if necessary. ;  ; void ResizeWindow (Window_t i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:16973,load,loads,16973,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['load'],['loads']
Performance,"  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; bool _logx = false;  Flag indicating logarithmic scaling of x values. ;  ; bool _logy = false;  Flag indicating logarithmic scaling of y values. ;  ; std::unique_ptr< TSpline > _spline;  The spline object. ;  ; RooRealProxy _x;  The independent variable. ;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:56683,Cache,CacheMode,56683,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,1,['Cache'],['CacheMode']
Performance,"  ; void weightError (double &lo, double &hi, RooAbsData::ErrorType etype=RooAbsData::Poisson) const override;  ; double weightError (RooAbsData::ErrorType etype=RooAbsData::Poisson) const override;  Return the error of the current weight. ;  ; Internal RooFit interface.; The classes and functions in the internal RooFit interface are implementation details and not part of the public user interface.; Everything in this group might change without warning. . ArraysStruct getArrays () const;  Exports all arrays in this RooVectorDataStore into a simple datastructure to be used by RooFit internal export functions. ;  ; void recomputeSumWeight ();  Trigger a recomputation of the cached weight sums. ;  ;  Public Member Functions inherited from RooAbsDataStore;  RooAbsDataStore ();  ;  RooAbsDataStore (const RooAbsDataStore &other, const char *newname=nullptr);  ;  RooAbsDataStore (const RooAbsDataStore &other, const RooArgSet &vars, const char *newname=nullptr);  ;  RooAbsDataStore (RooStringView name, RooStringView title, const RooArgSet &vars);  ; RooArgSet * addColumns (const RooArgList &varList);  ; const RooArgSet & cachedVars () const;  ; virtual void checkInit () const;  ; int defaultPrintContents (Option_t *) const override;  Define default print options, for a given print style. ;  ; bool dirtyProp () const;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printArgs (std::ostream &os) const override;  Print argument of dataset, i.e. the observable names. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose, TString indent) const override;  Detailed printing interface. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void printValue (std::ostream &os) const ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:7071,cache,cachedVars,7071,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cachedVars']
Performance,"  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TListOfEnums.h>. Inheritance diagram for TListOfEnums:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ DeclId_t. typedef TDictionary::DeclId_t TListOfEnums::DeclId_t. Definition at line 59 of file TListOfEnums.h. Constructor & Destructor Documentation. ◆ TListOfEnums() [1/2]. TListOfEnums::TListOfEnums ; (; const TListOfEnums & ; ). privatedelete . Represent interpreter state when we last did a full load. . ◆ TListOfEnums() [2/2]. TListOfEnums::TListOfEnums ; (; TClass * ; cl = nullptr). Constructor. ; Definition at line 35 of file TListOfEnums.cxx. ◆ ~TListOfEnums(). TListOfEnums::~TListOfEnums ; (; ). override . Destructor. ; Definition at line 45 of file TListOfEnums.cxx. Member Function Documentation. ◆ AddAfter() [1/2]. void TListOfEnums::AddAfter ; (; const TObject * ; after, . TObject * ; obj . ). overridevirtual . Insert object after object after in the list. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 120 of file TListOfEnums.cxx. ◆ AddAfter() [2/2]. void TListOfEnums::AddAfter ; (; TObjLink * ; after, . TObject * ; obj . ). overridevirtual . Insert object after object after in the list. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 129 of file TListOfEnums.cxx. ◆ AddAt(). void TListOfEnums::AddAt ; (; TObject * ; obj, . Int_t ; idx . ). overridevirtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:23199,load,load,23199,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['load'],['load']
Performance,"  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy pdf;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendedBinding.html:55191,Cache,Cache,55191,doc/master/classRooExtendedBinding.html,https://root.cern,https://root.cern/doc/master/classRooExtendedBinding.html,1,['Cache'],['Cache']
Performance,"  ;  Public Member Functions inherited from TGLCamera;  TGLCamera ();  Default base camera constructor. ;  ;  TGLCamera (const TGLVector3 &hAxis, const TGLVector3 &vAxis);  Default base camera constructor. ;  ;  ~TGLCamera () override;  Base camera destructor. ;  ; Bool_t AdjustAndClampVal (Double_t &val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const;  Adjust a passed REFERENCE value 'val', based on screenShift delta. ;  ; Double_t AdjustDelta (Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const;  Adjust a passed screen value and apply modifiers. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () const;  ; Double_t * GetCenterVec ();  ; Bool_t GetExternalCenter ();  ; Double_t GetFarClip () const;  ; Double_t * GetFixDefCenterVec ();  ; Double_t GetNearClip () const;  ; Double_t GetTheta () const;  Get angle between camer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLOrthoCamera.html:5085,cache,cache,5085,doc/master/classTGLOrthoCamera.html,https://root.cern,https://root.cern/doc/master/classTGLOrthoCamera.html,1,['cache'],['cache']
Performance,"  Create and fill a histogram with the efficiency N[1] / ( N[1] + N[0] ), where N(1/0) is the number of data points with effCat=1 and effCat=0 as function of the frames variable. ;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Create and fill a histogram of the frame's variable and append it to the frame. ;  ; virtual std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t=std::numeric_limits< std::size_t >::max()) const =0;  ; virtual void resetCache ();  Internal method – Remove cached function values. ;  ; virtual void setArgStatus (const RooArgSet &set, bool active);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from RooAbsData; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsData; static StorageType defaultStorageType =RooAbsData::Vector;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFitLegacy/RooTreeData.h>. Inheritance diagram for RooTreeData:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ Class(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:27540,cache,cached,27540,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,1,['cache'],['cached']
Performance,"  Default constructor for Profile3D histograms. ;  ;  TProfile3D (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, const Double_t *ybins, Int_t nbinsz, const Double_t *zbins, Option_t *option="""");  Create a 3-D Profile with variable bins in X , Y and Z. ;  ;  TProfile3D (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup, Option_t *option="""");  Normal Constructor for Profile histograms. ;  ;  TProfile3D (const TProfile3D &profile);  Copy constructor. ;  ;  ~TProfile3D () override;  Default destructor for Profile3D histograms. ;  ; Bool_t Add (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1) override;  Replace contents of this profile3D by the addition of h1 and h2. ;  ; Bool_t Add (const TH1 *h1, Double_t c1=1) override;  Performs the operation: this = this + c1*h1 . ;  ; Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""") override;  Performs the operation: this = this + c1*f1 . ;  ; Int_t BufferEmpty (Int_t action=0) override;  Fill histogram with all entries in the buffer. ;  ; void BuildOptions (Double_t tmin, Double_t tmax, Option_t *option);  Set Profile3D histogram structure and options. ;  ; void Copy (TObject &hnew) const override;  Copy a Profile3D histogram to a new profile2D histogram. ;  ; Bool_t Divide (const TH1 *h1) override;  Divide this profile2D by h1. ;  ; Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""") override;  Replace contents of this profile2D by the division of h1 by h2. ;  ; Bool_t Divide (TF1 *h1, Double_t c1=1) override;  Performs the operation: this = this/(c1*f1) . ;  ; void ExtendAxis (Double_t x, TAxis *axis) override;  Profile histogram is resized along axis such that x is in the axis range. ;  ; Int_t Fill (Double_t x, Double_t y, Double_t z, Double_t t) override;  Fill a Profile3D histogram (no weights). ;  ; virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:3841,Perform,Performs,3841,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['Perform'],['Performs']
Performance,"  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; enum  IntOperMode { Hybrid; , Analytic; , PassThrough; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; RooArgSet const * actualFuncNormSet () const;  ; void autoSelectDirtyMode ();  Set appropriate cache operation mode for integral depending on cache operation mode of server objects. ;  ; double evaluate () const override;  Perform the integration and return the result. ;  ; bool initNumIntegrator () const;  (Re)Initialize numerical integration engine if necessary. ;  ; virtual double integrate () const;  Perform hybrid numerical/analytical integration over all real-valued dependents. ;  ; bool isValidReal (double value, bool printError=false) const override;  Check if current value is valid. ;  ; virtual double jacobianProduct () const;  Return product of jacobian terms originating from analytical integration. ;  ; const RooArgSet & parameters () const;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Intercept server redirects and reconfigure internal object accordingly. ;  ; virtual double sum () const;  Perform summation of list of category dependents to be integrated. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:49683,cache,cache,49683,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,2,['cache'],['cache']
Performance,"  Handle focus change event. ;  ; Bool_t HandleHtmlInput (TGHtmlInput *pr, Event_t *event);  Handle html input (button, checkbox, ...) event. ;  ; Bool_t HandleIdleEvent (TGIdleHandler *i) override;  Handles idle event. ;  ; void HandleMenu (Int_t);  Handle context menu entries events. ;  ; Bool_t HandleMotion (Event_t *event) override;  handle mouse motion events ;  ; Bool_t HandleRadioButton (TGHtmlInput *p);  Handle radio button event. ;  ; Bool_t HandleTimer (TTimer *timer) override;  Handle timer event. ;  ; int InArea (TGHtmlMapArea *p, int left, int top, int x, int y);  Only support rect and circles for now. ;  ; virtual void InputSelected (const char *name, const char *val);  Emit Selected() signal. ;  ; virtual int IsVisited (const char *);  ; Bool_t ItemLayout () override;  Layout html widget. ;  ; TGString * ListTokens (TGHtmlElement *p, TGHtmlElement *pEnd);  Return all tokens between the two elements as a string list. ;  ; virtual TImage * LoadImage (const char *uri, int w=0, int h=0);  This is the default LoadImage() procedure. ;  ; virtual void MouseDown (const char *uri);  ; virtual void MouseOver (const char *uri);  ; void MoveVertically (TGHtmlElement *p, TGHtmlElement *pLast, int dy);  Move all elements in the given list vertically by the amount dy. ;  ; int ParseText (char *text, const char *index=nullptr);  Appends (or insert at the specified position) the given HTML text to the end of any HTML text that may have been inserted by prior calls to this command. ;  ; void PrintList (TGHtmlElement *first, TGHtmlElement *last);  Print a list of tokens. ;  ; virtual TGFrame * ProcessApplet (TGHtmlInput *);  ; virtual int ProcessFrame ();  ; Bool_t ProcessMessage (Longptr_t, Longptr_t, Longptr_t) override;  Process messages (GUI events) in the html widget. ;  ; virtual char * ProcessScript (TGHtmlScript *);  ; virtual int ProcessToken (TGHtmlElement *, const char *, int);  ; virtual void RadioChanged (const char *name, const char *val);  Emit RadioChange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:4027,Load,LoadImage,4027,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,2,['Load'],['LoadImage']
Performance,"  Normalize a vector. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void CheckMatrix ();  performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"", ""orthogonality check not performed yet""); ;  ;  Protected Member Functions inherited from TGeoMatrix;  TGeoMatrix (const TGeoMatrix &other);  copy constructor ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t fRotationMatrix [3 *3];  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TGeoMatrix; enum  EGeoTransfTypes { ;   kGeoIdentity = 0; , kGeoShared = (1ULL << ( 14 )); , kGeoTranslation = (1ULL << ( 17 )); , kGeoRotation = (1ULL << ( 18 )); , ;   kGeoScale = (1ULL << ( 19 )); , kGeoReflection = (1ULL << ( 20 )); , kGeoRegistered = (1ULL << ( 21 )); , kGeoSavePrimitive = (1ULL << ( 22 )); , ;   kGeoMatrixOwned = (1ULL << ( 23 )); , kGeoCombiTrans = kGeoTranslation | kGeoRotation; , kGeoGenTrans = kGeoTranslation | kGeoRotation | kGeoScale; , kGeoMatrixBits = kGeoShared | kGeoGenTrans | kGeoReflect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRotation.html:16185,perform,performes,16185,doc/master/classTGeoRotation.html,https://root.cern,https://root.cern/doc/master/classTGeoRotation.html,2,['perform'],"['performed', 'performes']"
Performance,"  ROOT::Internal;  . Macros; #define gROOT   (ROOT::GetROOT());  . Functions; void ROOT::CallRecursiveRemoveIfNeeded (TObject &obj);  call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true. ;  ; void ROOT::DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void ROOT::Internal::DisableParBranchProcessing ();  Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ;  ; void ROOT::EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void ROOT::Internal::EnableParBranchProcessing ();  Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ;  ; void ROOT::EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; TROOT * ROOT::GetROOT ();  ; TROOT * ROOT::Internal::GetROOT2 ();  ; UInt_t ROOT::GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; Bool_t ROOT::IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; Bool_t ROOT::Internal::IsParBranchProcessingEnabled ();  Returns true if parallel branch processing is enabled. ;  ; Bool_t ROOT::Internal::RequiresCleanup (TObject &obj);  ; void ROOT::Internal::SetRequireCleanup (TObject &obj);  . Variables; R__EXTERN TROOT * ROOT::Internal::gROOTLocal = ROOT::GetROOT();  ; R__EXTERN TVirtualMutex * gROOTMutex;  . Macro Definition Documentation. ◆ gROOT. #define gROOT   (ROOT::GetROOT()). Definition at line 406 of file TROOT.h. Variable Documentation. ◆ gROOTMutex. R__EXTERN TVirtualMutex* gROOTMutex. Definition at line 63 of file TROOT.h. corebaseincTROOT.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h.html:2014,multi-thread,multi-threading,2014,doc/master/TROOT_8h.html,https://root.cern,https://root.cern/doc/master/TROOT_8h.html,1,['multi-thread'],['multi-threading']
Performance,"  RPageSource (std::string_view ntupleName, const RNTupleReadOptions &fOptions);  ;  ~RPageSource () override;  ; ColumnHandle_t AddColumn (DescriptorId_t fieldId, RColumn &column) override;  Register a new column. ;  ; void Attach ();  Open the physical storage container and deserialize header and footer. ;  ; std::unique_ptr< RPageSource > Clone () const;  Open the same storage multiple time, e.g. ;  ; void DropColumn (ColumnHandle_t columnHandle) override;  Unregisters a column. ;  ; REntryRange GetEntryRange () const;  ; NTupleSize_t GetNElements (ColumnHandle_t columnHandle);  ; NTupleSize_t GetNEntries ();  ; const RNTupleReadOptions & GetReadOptions () const;  ; const RSharedDescriptorGuard GetSharedDescriptorGuard () const;  Takes the read lock for the descriptor. ;  ; EPageStorageType GetType () final;  Whether the concrete implementation is a sink or a source. ;  ; virtual std::vector< std::unique_ptr< RCluster > > LoadClusters (std::span< RCluster::RKey > clusterKeys)=0;  Populates all the pages of the given cluster ids and columns; it is possible that some columns do not contain any pages. ;  ; virtual RPageRef LoadPage (ColumnHandle_t columnHandle, NTupleSize_t globalIndex);  Allocates and fills a page that contains the index-th element. ;  ; virtual RPageRef LoadPage (ColumnHandle_t columnHandle, RClusterIndex clusterIndex);  Another version of LoadPage that allows to specify cluster-relative indexes. ;  ; virtual void LoadSealedPage (DescriptorId_t physicalColumnId, RClusterIndex clusterIndex, RSealedPage &sealedPage)=0;  Read the packed and compressed bytes of a page into the memory buffer provided by sealedPage. ;  ; void LoadStructure ();  Loads header and footer without decompressing or deserializing them. ;  ; RPageSource & operator= (const RPageSource &)=delete;  ; RPageSource & operator= (RPageSource &&)=delete;  ; void SetEntryRange (const REntryRange &range);  Promise to only read from the given entry range. ;  ; RResult< RPage > UnsealPage (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:2544,Load,LoadClusters,2544,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadClusters']
Performance,"  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooSetProxy _anaList;  Set of observables over which is integrated/summed analytically. ;  ; bool _cacheNum = false;  Cache integral if numeric. ;  ; RooSetProxy _facList;  Set of observables on which function does not depends, which are integrated nevertheless. ;  ; std::unique_ptr< RooArgSet > _funcNormSet;  Optional normalization set passed to function. ;  ; RooRealProxy _function;  Function being integrated. ;  ; RooNumIntConfig * _iconfig = nullptr;  ; RooSetProxy _intList;  Set of continuous observables over which is integrated numerically. ;  ; IntOperMode _intOperMode = Hybrid;  integration operation mode ;  ; RooSetProxy _jacList;  Set of lvalue observables over which is analytically integration that have a non-unit Jacobian. ;  ; Int_t _mode = 0;  ; std::unique_ptr< RooAbsFunc > _numIntegrand;  ! ;  ; std::unique_ptr< RooAbsIntegrator > _numIntEngine;  ! ;  ; std::unique_ptr< RooArgSet > _params;  ! cache for set of parameters ;  ; TNamed * _rangeName = nullptr;  ; bool _respectCompSelect = true;  ; bool _restartNumIntEngine = false;  ! ;  ; RooArgSet _saveInt;  ! ;  ; RooArgSet _saveSum; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:57212,Cache,Cache,57212,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['Cache'],['Cache']
Performance,"  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Evaluate in batch mode. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRatio.html:48302,cache,cached,48302,doc/master/classRooRatio.html,https://root.cern,https://root.cern/doc/master/classRooRatio.html,2,['cache'],"['cache', 'cached']"
Performance,"  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; virtual RooDataSet * createDataSet (const char *name, const char *title, const RooArgSet &obs);  Create an empty dataset to hold the events that will be generated. ;  ; void resampleData (double &ratio);  Rescale existing output buffer with given ratio. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsGenContext.html:14470,load,load,14470,doc/master/classRooAbsGenContext.html,https://root.cern,https://root.cern/doc/master/classRooAbsGenContext.html,1,['load'],['load']
Performance,"  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; virtual RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const =0;  ; virtual RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const =0;  ; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; virtual PdfCacheElem * createCache (const RooArgSet *nset) const;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; virtual void fillCacheObject (PdfCacheElem &cache) const =0;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual const char * inputBaseName () const =0;  ; virtual const char * payloadUniqueSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:63311,cache,cache,63311,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Static Public Attributes; static constexpr value_type NoCatIdx = std::numeric_limits<value_type>::min();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; const RooMappedCategoryCache * getOrCreateCache () const;  ; void recomputeShape () override;  When the input category changes states, the cached state mappings are invalidated. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:35793,cache,cached,35793,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cached']
Performance,"  TConvertClonesArrayToProxy;  Small helper to read a TBuffer containing a TClonesArray into any valid collection. More...;  ; class  TDCacheFile;  A TDCacheFile is like a normal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. More...;  ; class  TDirectoryFile;  A ROOT file is structured in Directories (like a file system). More...;  ; class  TDomParser;  DOM stands for the Document Object Model; this is an API for accessing XML or HTML structured documents. More...;  ; class  TEmulatedCollectionProxy;  Streamer around an arbitrary STL like container, which implements basic container functionality. More...;  ; class  TEmulatedMapProxy;  Streamer around a map container. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__IO.html:3713,cache,cache,3713,doc/master/group__IO.html,https://root.cern,https://root.cern/doc/master/group__IO.html,1,['cache'],['cache']
Performance,"  The object which is actually drawn, this might be TH1 or THStack. ;  ; Bool_t fHistDrawProxyStack = kFALSE;  If stack was assigned as proxy. ;  ; Float_t fInsetWidth = 0.0025;  ; Bool_t fIsUpdating = kFALSE;  ! Keeps track of whether its currently updating to reject other calls until done ;  ; Float_t fLeftMargin = 0.1;  Stores the common left margin of both pads. ;  ; Float_t fLowBottomMargin = 0.3;  Stores the bottom margin of the lower pad. ;  ; TGaxis * fLowerGXaxis = nullptr;  Lower graphical x axis. ;  ; TGaxis * fLowerGXaxisMirror = nullptr;  Lower mirror of the x axis. ;  ; TGaxis * fLowerGYaxis = nullptr;  Lower graphical y axis. ;  ; TGaxis * fLowerGYaxisMirror = nullptr;  Lower mirror of the y axis. ;  ; TPad * fLowerPad = nullptr;  The pad which contains the calculated lower plot part. ;  ; Float_t fLowTopMargin = 0.05;  Stores the top margin of the lower pad. ;  ; TAxis * fLowYaxis = nullptr;  Clone of the lower y axis. ;  ; Int_t fMode = 0;  Stores which calculation is supposed to be performed as specified by user option. ;  ; TString fOption;  Stores the option which is given in the constructor as a string. ;  ; TVirtualPad * fParentPad = nullptr;  Stores the pad the ratio plot was created in. ;  ; TGraph * fRatioGraph = nullptr;  Stores the lower plot's graph. ;  ; Float_t fRightMargin = 0.1;  Stores the common right margin of both pads. ;  ; TAxis * fSharedXAxis = nullptr;  X axis that stores the range for both plots. ;  ; Bool_t fShowConfidenceIntervals = kTRUE;  Stores whether to show the confidence interval bands. From Draw option. ;  ; Bool_t fShowGridlines = kTRUE;  Stores whether to show the gridlines at all. ;  ; Float_t fSplitFraction = 0.3;  Stores the fraction at which the upper and lower pads meet. ;  ; TPad * fTopPad = nullptr;  The Pad that drawn on top on the others to have consistent coordinates. ;  ; Float_t fUpBottomMargin = 0.05;  Stores the bottom margin of the upper pad. ;  ; TGaxis * fUpperGXaxis = nullptr;  Upper graphical x a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:23308,perform,performed,23308,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['perform'],['performed']
Performance,"  This class provides the plots for the result of a study performed with the HybridCalculatorOriginal class. More...;  ; class  HybridResult;  Class encapsulating the result of the HybridCalculatorOriginal. More...;  ; class  HypoTestCalculator;  HypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults. More...;  ; class  HypoTestCalculatorGeneric;  Common base class for the Hypothesis Test Calculators. More...;  ; class  HypoTestInverter;  A class for performing a hypothesis test inversion by scanning the hypothesis test results of a HypoTestCalculator for various values of the parameter of interest. More...;  ; class  HypoTestInverterPlot;  Class to plot a HypoTestInverterResult, the output of the HypoTestInverter calculator. More...;  ; class  HypoTestInverterResult;  HypoTestInverterResult class holds the array of hypothesis test results and compute a confidence interval. More...;  ; class  HypoTestPlot;  This class provides the plots for the result of a study performed with any of the HypoTestCalculatorGeneric (e.g. More...;  ; class  HypoTestResult;  HypoTestResult is a base class for results from hypothesis tests. More...;  ; class  IntervalCalculator;  IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. More...;  ; struct  LikelihoodFunction;  ; class  LikelihoodInterval;  LikelihoodInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  LikelihoodIntervalPlot;  This class provides simple and straightforward utilities to plot a LikelihoodInterval object. More...;  ; class  MarkovChain;  Stores the steps in a Markov Chain of points. More...;  ; class  MaxLikelihoodEstimateTestStat;  MaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter. More...;  ; class  MCMCCalculator;  Bayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:3229,perform,performed,3229,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['perform'],['performed']
Performance,"  Waits until provided check function or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  ; int WaitForTimed (WebWindowWaitFunc_t check);  Waits until provided check function or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  ; int WaitForTimed (WebWindowWaitFunc_t check, double duration);  Waits until provided check function or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  . Static Public Member Functions; static std::shared_ptr< RWebWindow > Create ();  Create new RWebWindow Using default RWebWindowsManager. ;  ; static bool EmbedFileDialog (const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args);  Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tries to call RFileDialog::Embedded() method Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embedded() providing received string as second argument. ;  ; static bool IsFileDialogMessage (const std::string &msg);  Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ;  ; static unsigned ShowWindow (std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""");  Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ;  . Private Types; using ConnectionsList_t = std::vector<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:11627,Load,Loads,11627,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['Load'],['Loads']
Performance,"  fSize of the contained object ;  ; TClassRef fType;  TClass reference of Value_type in collection. ;  . #include <TGenCollectionProxy.h>; Constructor & Destructor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition at line 64 of file TGenCollectionProxy.h. ◆ fCtor. ROOT::NewFunc_t TGenCollectionProxy::Value::fCtor. Method cache for containee constructor. ; Definition at line 61 of file TGenCollectionProxy.h. ◆ fDelete. ROOT::DelFunc_t TGenCollectionProxy::Value::fDelete. Method cache for containee delete. ; Definition at line 63 of file TGenCollectionProxy.h. ◆ fDtor. ROOT::DesFunc_t TGenCollectionProxy::Value::fDtor. Method cache for containee destructor. ; Definition at line 62 of file TGenCollectionProxy.h. ◆ fKind. EDataType TGenCollectionProxy::Value::fKind. kind of ROOT-fundamental type ; Definition at line 67 of file TGenCollectionProxy.h. ◆ fProperties. UInt_t TGenCollectionProxy::Value::fProperties. Additional properties of the value type (kNeedDelete) ; Definition at line 65 of file TGenCollectionProxy.h. ◆ fSize. size_t TGenCollectionProxy::Value::fSize. fSize of the contained object ; Definition at line 68 of file TGenCollectionProxy.h. ◆ fType. TClassRef TGenCollectionProxy::Value::fType. TClass reference of Value_type in collection. ; Definition at line 66 of file TGenCollectionProxy.h. Collaboration ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:2111,cache,cache,2111,doc/master/structTGenCollectionProxy_1_1Value.html,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html,1,['cache'],['cache']
Performance," » TMVA::MethodCuts. class TMVA::MethodCuts: public TMVA::MethodBase, public TMVA::IFitterTarget. Multivariate optimisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:1240,perform,performed,1240,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,6,['perform'],['performed']
Performance," » TREE; » TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionMethodBrowsa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionMethodBrowsable.html:1185,cache,cached,1185,root/html526/TCollectionMethodBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionMethodBrowsable.html,10,['cache'],['cached']
Performance," » TREE; » TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionMeth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionMethodBrowsable.html:1185,cache,cached,1185,root/html602/TCollectionMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html,4,['cache'],['cached']
Performance," ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the includ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270654,optimiz,optimizations,270654,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimizations']
Performance, ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.weights.xml␛[0m; MLPBNN : Building Network. ; : Initializing weights; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_SVM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_RuleFit.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Cuts for Classification performance; : ; Cuts : [dataset] : Evaluation of Cuts on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00226 sec ; Factory : Test method: CutsD for Classification performance; : ; CutsD : [dataset] : Evaluation of CutsD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00756 sec ; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; Factory : Test method: LikelihoodPCA for Classification performance; : ; LikelihoodPCA : [dataset] : Evaluation of LikelihoodPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Classification performance; : ; PDEFoam : [dataset] : Evaluation of PDEFoam on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification performance; : ; KNN : [dataset] : Evaluation of KNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.2 sec ; Factory : Test method: LD for Classification performance; : ; LD : ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:65719,perform,performance,65719,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance, ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0107 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00276 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0472 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0995 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_higgs.h5; PyKeras : [dataset] : Evaluation of PyKeras on testing ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:49944,perform,performance,49944,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['perform'],['performance']
Performance," ◆ CheckConnectArgs(). Int_t TQObject::CheckConnectArgs ; (; TQObject * ; sender, . TClass * ; sender_class, . const char * ; signal, . TClass * ; receiver_class, . const char * ; slot . ). staticprotected . Checking of consistency of sender/receiver methods/arguments. ; Returns -1 on error, otherwise number or arguments of signal function. Static method. ; Definition at line 179 of file TQObject.cxx. ◆ Class(). static TClass * TQObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TQObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TQObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 229 of file TQObject.h. ◆ CollectClassSignalLists(). void TQObject::CollectClassSignalLists ; (; TList & ; list, . TClass * ; cls . ). Collect class signal lists from class cls and all its base-classes. ; The recursive traversal is not performed for classes not deriving from TQClass. ; Definition at line 451 of file TQObject.cxx. ◆ CompressName(). TString TQObject::CompressName ; (; const char * ; method_name). staticprotected . Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ; If a null or empty string is passed in, an empty string is returned.; Example: CompressName("" Draw(const char *, const char *,; Option_t * , Int_t , Int_t)"");; TQObject::CompressNamestatic TString CompressName(const char *method_name)Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in t...Definition TQObject.cxx:98; returns the string ""Draw(char*,char*,char*,int,int)"". ; Definition at line 98 of file TQObject.cxx. ◆ Connect() [1/3]. Bool_t TQObject::Connect ; (; const char * ; class_name, . const char * ; signal, . const char * ; cl, . void * ; receiver, . const char * ; slot . ). static . This method allows to make a connection f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQObject.html:9120,perform,performed,9120,doc/master/classTQObject.html,https://root.cern,https://root.cern/doc/master/classTQObject.html,1,['perform'],['performed']
Performance," ◆ GetGUIThreadId(). ULong_t TWinNTSystem::GetGUIThreadId ; (; ); const. inline . Definition at line 115 of file TWinNTSystem.h. ◆ GetHomeDirectory(). std::string TWinNTSystem::GetHomeDirectory ; (; const char * ; userName = nullptr); const. overridevirtual . Return the user's home directory. ; Reimplemented from TSystem.; Definition at line 2214 of file TWinNTSystem.cxx. ◆ GetHostByName(). TInetAddress TWinNTSystem::GetHostByName ; (; const char * ; server). overridevirtual . Get Internet Protocol (IP) address of host. ; Reimplemented from TSystem.; Definition at line 4688 of file TWinNTSystem.cxx. ◆ GetLibraries(). const char * TWinNTSystem::GetLibraries ; (; const char * ; regexp = """", . const char * ; options = """", . Bool_t ; isRegexp = kTRUE . ). overridevirtual . Return a space separated list of loaded shared libraries. ; This list is of a format suitable for a linker, i.e it may contain -Lpathname and/or -lNameOfLib. Option can be any of: S: shared libraries loaded at the start of the executable, because they were specified on the link line. D: shared libraries dynamically loaded after the start of the program. L: list the .LIB rather than the .DLL (this is intended for linking) [This options is not the default] ; Reimplemented from TSystem.; Definition at line 4307 of file TWinNTSystem.cxx. ◆ GetLinkedLibraries(). const char * TWinNTSystem::GetLinkedLibraries ; (; ). overrideprivatevirtual . Get list of shared libraries loaded at the start of the executable. ; Returns 0 in case list cannot be obtained or in case of error. ; Reimplemented from TSystem.; Definition at line 4153 of file TWinNTSystem.cxx. ◆ GetMemInfo(). Int_t TWinNTSystem::GetMemInfo ; (; MemInfo_t * ; info); const. overridevirtual . Returns ram and swap memory usage info into the MemInfo_t structure. ; Returns -1 in case of error, 0 otherwise. ; Reimplemented from TSystem.; Definition at line 6144 of file TWinNTSystem.cxx. ◆ GetNbGroups(). Bool_t TWinNTSystem::GetNbGroups ; (; ). private . Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:53841,load,loaded,53841,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['load'],['loaded']
Performance," ◆ GetWorkingPath(). const Browsable::RElementPath_t & ROOT::RBrowserData::GetWorkingPath ; (; ); const. inline . Definition at line 73 of file RBrowserData.hxx. ◆ ProcessBrowserRequest(). bool RBrowserData::ProcessBrowserRequest ; (; const RBrowserRequest & ; request, . RBrowserReply & ; reply . ). private . Process browser request. ; Definition at line 171 of file RBrowserData.cxx. ◆ ProcessRequest(). std::string RBrowserData::ProcessRequest ; (; const RBrowserRequest & ; request). Process browser request, returns string with JSON of RBrowserReply data. ; Definition at line 269 of file RBrowserData.cxx. ◆ RemoveFromCache() [1/2]. bool RBrowserData::RemoveFromCache ; (; const Browsable::RElementPath_t & ; path). Remove path (and all sub-paths) from cache Returns true if any element was removed. ; Definition at line 406 of file RBrowserData.cxx. ◆ RemoveFromCache() [2/2]. bool RBrowserData::RemoveFromCache ; (; void * ; obj). Remove object from cache If nullptr specified - removes no-longer-valid elements Returns true if any element was removed. ; Definition at line 380 of file RBrowserData.cxx. ◆ ResetLastRequestData(). void RBrowserData::ResetLastRequestData ; (; bool ; with_element). private . Reset all data correspondent to last request. ; Definition at line 138 of file RBrowserData.cxx. ◆ SetTopElement(). void RBrowserData::SetTopElement ; (; std::shared_ptr< Browsable::RElement > ; elem). set top element for browsing ; Definition at line 88 of file RBrowserData.cxx. ◆ SetWorkingPath(). void RBrowserData::SetWorkingPath ; (; const Browsable::RElementPath_t & ; path). set working directory relative to top element ; Definition at line 98 of file RBrowserData.cxx. Friends And Related Symbol Documentation. ◆ RBrowserDataCleanup. friend class RBrowserDataCleanup. friend . Definition at line 39 of file RBrowserData.hxx. Member Data Documentation. ◆ fCache. std::vector<std::pair<Browsable::RElementPath_t, std::shared_ptr<Browsable::RElement> > > ROOT::RBrowserData::fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html:6269,cache,cache,6269,doc/v632/classROOT_1_1RBrowserData.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html,2,['cache'],['cache']
Performance,"! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooVoigtian.html:39136,cache,cache,39136,root/html526/RooVoigtian.html,https://root.cern,https://root.cern/root/html526/RooVoigtian.html,2,['cache'],['cache']
Performance,"! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Fill cache with sampling of function as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Mon Dec 7 13:45:49 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:33976,cache,cache,33976,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,"! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSet_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:34072,cache,cache,34072,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance,"! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooSetProxy_cacheObsNon-convolution observables that are also cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:46920,cache,cache,46920,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSpHarmonic.html:32020,cache,cache,32020,root/html528/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html528/RooSpHarmonic.html,2,['cache'],['cache']
Performance,"! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSpHarmonic.html:32520,cache,cache,32520,root/html532/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html532/RooSpHarmonic.html,1,['cache'],['cache']
Performance,"!Lock for writing baskets / keys into the file.Definition TFile.h:118; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw map of objects in this file.Definition TFile.cxx:1128; TFile::DirWriteHeadervirtual void DirWriteHeader(TDirectory *)Definition TFile.h:170; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::fCacheWriteTFileCacheWrite * fCacheWrite!Pointer to the write cache (if any)Definition TFile.h:100; TFile::fRealNameTString fRealNameEffective real file name (not original url)Definition TFile.h:90; TFile::SetOffsetvirtual void SetOffset(Long64_t offset, ERelativeTo pos=kBeg)Set position from where to start reading.Definition TFile.cxx:2253; TFile::fOffsetLong64_t fOffset!Seek offset cacheDefinition TFile.h:96; TFile::fgBytesWritestatic std::atomic< Long64_t > fgBytesWriteNumber of bytes written by all TFile objects.Definition TFile.h:130; TFile::GetNbytesInfovirtual Int_t GetNbytesInfo() constDefinition TFile.h:248; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::MustFlushvirtual Bool_t MustFlush() constDefinition TFile.h:269; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:44934,cache,cacheDefinition,44934,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cacheDefinition']
Performance,"!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; Long64_tfKeyCounter! counter of created keys, used for keys id; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; XMLNodePointer_tfStreamerInfoNode! pointer of node with streamer info data; Double_tTFile::fSum2BufferSum of squares o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:22795,cache,cache,22795,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,4,['cache'],['cache']
Performance,"!gEnv) return """";; 3919 const_cast<TSystem*>(this)->fBuildDir = gEnv->GetValue(""ACLiC.BuildDir"","""");; 3920 }; 3921 return fBuildDir;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Return the debug flags.; 3926 ; 3927const char *TSystem::GetFlagsDebug() const; 3928{; 3929 return fFlagsDebug;; 3930}; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Return the optimization flags.; 3934 ; 3935const char *TSystem::GetFlagsOpt() const; 3936{; 3937 return fFlagsOpt;; 3938}; 3939 ; 3940////////////////////////////////////////////////////////////////////////////////; 3941/// AclicMode indicates whether the library should be built in; 3942/// debug mode or optimized. The values are:; 3943/// - TSystem::kDefault : compile the same as the current ROOT; 3944/// - TSystem::kDebug : compiled in debug mode; 3945/// - TSystem::kOpt : optimized the library; 3946 ; 3947TSystem::EAclicMode TSystem::GetAclicMode() const; 3948{; 3949 return fAclicMode;; 3950}; 3951 ; 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 3960 ; 3961////////////////////////////////////////////////////////////////////////////////; 3962/// Return the command line use to make an executable.; 3963/// See TSystem::CompileMacro for more details.; 3964 ; 3965const char *TSystem::GetMakeExe() const; 3966{; 3967 return fMakeExe;; 3968}; 3969 ; 3970////////////////////////////////////////////////////////////////////////////////; 3971/// Get the list of include path.; 3972 ; 3973const char *TSystem::GetIncludePath(); 3974{; 3975 fListPaths = fIncludePath;; 3976#ifndef _MSC_VER; 3977 // FIXME: This is a temporary fix for the following error with ACLiC; 3978 // (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:133779,optimiz,optimized,133779,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimized']
Performance,""" + TROOT::GetIncludeDir()).Data()));; 1376 ; 1377 // Add the current path to the include path; 1378 // TCling::AddIncludePath(""."");; 1379 ; 1380 // Attach the PCH (unless we have C++ modules enabled which provide the; 1381 // same functionality).; 1382 if (!fCxxModulesEnabled) {; 1383 std::string pchFilename = interpInclude + ""/allDict.cxx.pch"";; 1384 if (gSystem->Getenv(""ROOT_PCH"")) {; 1385 pchFilename = gSystem->Getenv(""ROOT_PCH"");; 1386 }; 1387 ; 1388 clingArgsStorage.push_back(""-include-pch"");; 1389 clingArgsStorage.push_back(pchFilename);; 1390 }; 1391 ; 1392 clingArgsStorage.push_back(""-Wno-undefined-inline"");; 1393 clingArgsStorage.push_back(""-fsigned-char"");; 1394 // The -O1 optimization flag has nasty side effects on Windows (32 and 64 bit); 1395 // See the GitHub issues #9809 and #9944; 1396 // TODO: to be reviewed after the upgrade of LLVM & Clang; 1397#ifndef _MSC_VER; 1398 clingArgsStorage.push_back(""-O1"");; 1399 // Disable optimized register allocation which is turned on automatically; 1400 // by -O1, but seems to require -O2 to not explode in run time.; 1401 clingArgsStorage.push_back(""-mllvm"");; 1402 clingArgsStorage.push_back(""-optimize-regalloc=0"");; 1403#endif; 1404 }; 1405 ; 1406 // Process externally passed arguments if present.; 1407 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(""EXTRA_CLING_ARGS"");; 1408 if (EnvOpt.has_value()) {; 1409 StringRef Env(*EnvOpt);; 1410 while (!Env.empty()) {; 1411 StringRef Arg;; 1412 std::tie(Arg, Env) = Env.split(' ');; 1413 clingArgsStorage.push_back(Arg.str());; 1414 }; 1415 }; 1416 ; 1417 auto GetEnvVarPath = [](const std::string &EnvVar, std::vector<std::string> &Paths) {; 1418 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(EnvVar);; 1419 if (EnvOpt.has_value()) {; 1420 StringRef Env(*EnvOpt);; 1421 while (!Env.empty()) {; 1422 StringRef Arg;; 1423 std::tie(Arg, Env) = Env.split(ROOT::FoundationUtils::GetEnvPathSeparator());; 1424 if (std::find(Paths.begin(), Paths.end(), Arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:50988,optimiz,optimized,50988,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['optimiz'],['optimized']
Performance,""" + entry.second + ""';"";; 947 arg->ReplaceAllinContent(search, replace);; 948 }; 949 ; 950 } else {; 951 ; 952 bool first = true;; 953 TString importmap = ""<script type=\""importmap\"">\n{\n \""imports\"": "";; 954 for (auto &entry : modules) {; 955 importmap.Append(TString::Format(""%s\n \""%s\"": \""%smodules/%s\"""", first ? ""{"" : "","", entry.first.c_str(), jsroot_prefix.c_str(), entry.second.c_str()));; 956 first = false;; 957 }; 958 importmap.Append(TString::Format("",\n \""jsrootsys/\"": \""%s\"""", jsroot_prefix.c_str()));; 959 ; 960 for (auto &entry : fLocations); 961 if (entry.first != ""jsrootsys/""); 962 importmap.Append(TString::Format("",\n \""%s\"": \""%s%s\"""", entry.first.c_str(), path_prefix.c_str(), entry.first.c_str()));; 963 importmap.Append(""\n }\n}\n</script>\n"");; 964 ; 965 arg->fContent.erase(p, place_holder.length());; 966 ; 967 arg->fContent.insert(p, importmap.Data());; 968 }; 969 }; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Process single http request; 974///; 975/// Depending from requested path and filename different actions will be performed.; 976/// In most cases information is provided by TRootSniffer class; 977 ; 978void THttpServer::ProcessRequest(std::shared_ptr<THttpCallArg> arg); 979{; 980 if (fTerminated) {; 981 arg->Set404();; 982 return;; 983 }; 984 ; 985 if ((arg->fFileName == ""root.websocket"") || (arg->fFileName == ""root.longpoll"")) {; 986 ExecuteWS(arg);; 987 return;; 988 }; 989 ; 990 if (arg->fFileName.IsNull() || (arg->fFileName == ""index.htm"") || (arg->fFileName == ""default.htm"")) {; 991 ; 992 std::string version;; 993 ; 994 if (arg->fFileName == ""default.htm"") {; 995 ; 996 if (!IsWSOnly()); 997 arg->fContent = ReadFileContent((fJSROOTSYS + ""/files/online.htm"").Data());; 998 ; 999 } else {; 1000 auto wsptr = FindWS(arg->GetPathName());; 1001 ; 1002 auto handler = wsptr.get();; 1003 ; 1004 if (!handler); 1005 handler = dynamic_cast<THttpWSHandler *>(fSniffer->FindTObjectInHierarchy(arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:31224,perform,performed,31224,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['perform'],['performed']
Performance,""" << Endl;; 1341 }; 1342 } else {; 1343 ; 1344 // no classifier specified, print all help messages; 1345 MVector *methods = fMethodsMap.find(datasetname)->second;; 1346 MVector::const_iterator itrMethod;; 1347 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 1348 MethodBase *method = dynamic_cast<MethodBase *>(*itrMethod);; 1349 if (method == 0); 1350 continue;; 1351 Log() << kINFO << ""Print help message for classifier: "" << method->GetMethodName() << Endl;; 1352 method->PrintHelpMessage();; 1353 }; 1354 }; 1355}; 1356 ; 1357////////////////////////////////////////////////////////////////////////////////; 1358/// Iterates over all MVA input variables and evaluates them.; 1359 ; 1360void TMVA::Factory::EvaluateAllVariables(DataLoader *loader, TString options); 1361{; 1362 Log() << kINFO << ""Evaluating all variables..."" << Endl;; 1363 Event::SetIsTraining(kFALSE);; 1364 ; 1365 for (UInt_t i = 0; i < loader->GetDataSetInfo().GetNVariables(); i++) {; 1366 TString s = loader->GetDataSetInfo().GetVariableInfo(i).GetLabel();; 1367 if (options.Contains(""V"")); 1368 s += "":V"";; 1369 this->BookMethod(loader, ""Variable"", s);; 1370 }; 1371}; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Iterates over all MVAs that have been booked, and calls their evaluation methods.; 1375 ; 1376void TMVA::Factory::EvaluateAllMethods(void); 1377{; 1378 Log() << kHEADER << gTools().Color(""bold"") << ""Evaluate all methods"" << gTools().Color(""reset"") << Endl;; 1379 ; 1380 // don't do anything if no method booked; 1381 if (fMethodsMap.empty()) {; 1382 Log() << kINFO << ""...nothing found to evaluate"" << Endl;; 1383 return;; 1384 }; 1385 std::map<TString, MVector *>::iterator itrMap;; 1386 ; 1387 for (itrMap = fMethodsMap.begin(); itrMap != fMethodsMap.end(); ++itrMap) {; 1388 MVector *methods = itrMap->second;; 1389 ; 1390 // -----------------------------------------------------------------------; 1391 // First part o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:55743,load,loader,55743,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,""""") const; virtual voidprintValue(ostream& os) const; virtual voidRooAbsRealLValue::randomize(const char* rangeName = 0); virtual voidRooAbsRealLValue::randomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidremoveAsymError(); voidremoveError(); voidremoveMax(const char* name = 0); voidremoveMin(const char* name = 0); voidremoveRange(const char* name = 0); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRealVar(); RooRealVar(const RooRealVar& other, const char* name = 0); RooRealVar(const char* name, const char* title, Double_t value, const char* unit = """"); RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:26959,cache,cache,26959,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,2,['cache'],['cache']
Performance,""""") const; virtual voidprintValue(ostream& os) const; virtual voidRooAbsRealLValue::randomize(const char* rangeName = 0); virtual voidRooAbsRealLValue::randomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidremoveAsymError(); voidremoveError(); voidremoveMax(const char* name = 0); voidremoveMin(const char* name = 0); voidremoveRange(const char* name = 0); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAsymError(Double_t lo, Double_t hi); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:25528,cache,cache,25528,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,2,['cache'],['cache']
Performance,""""") const; virtual voidprintValue(ostream& os) const; virtual voidRooAbsRealLValue::randomize(const char* rangeName = 0); virtual voidRooAbsRealLValue::randomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidremoveAsymError(); voidremoveError(); voidremoveMax(const char* name = 0); voidremoveMin(const char* name = 0); voidremoveRange(const char* name = 0); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAsymError(Double_t lo, Double_t hi); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:26518,cache,cache,26518,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,2,['cache'],['cache']
Performance,""""") const; virtual voidprintValue(ostream& os) const; virtual voidRooAbsRealLValue::randomize(const char* rangeName = 0); virtual voidRooAbsRealLValue::randomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidremoveAsymError(); voidremoveError(); voidremoveMax(const char* name = 0); voidremoveMin(const char* name = 0); voidremoveRange(const char* name = 0); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAsymError(Double_t lo, Double_t hi); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealVar.html:26015,cache,cache,26015,root/html530/RooRealVar.html,https://root.cern,https://root.cern/root/html530/RooRealVar.html,1,['cache'],['cache']
Performance,""""") override;  reset data members ;  ; Double_t Determinant () const;  computes determinant of the rotation matrix ;  ; void FastRotZ (const Double_t *sincos);  Perform a rotation about Z having the sine/cosine of the rotation angle. ;  ; void GetAngles (Double_t &phi, Double_t &theta, Double_t &psi) const;  Retrieve Euler angles. ;  ; void GetAngles (Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) const;  Retrieve rotation angles. ;  ; void GetInverse (Double_t *invmat) const;  Get the inverse rotation matrix (which is simply the transpose) ;  ; Double_t GetPhiRotation (Bool_t fixX=kFALSE) const;  Returns rotation angle about Z axis in degrees. ;  ; const Double_t * GetRotationMatrix () const override;  ; const Double_t * GetScale () const override;  ; const Double_t * GetTranslation () const override;  ; TGeoHMatrix Inverse () const override;  Return a temporary inverse of this. ;  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  Perform orthogonality test for rotation. ;  ; void LocalToMaster (const Double_t *local, Double_t *master) const override;  convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse ;  ; void LocalToMasterBomb (const Double_t *local, Double_t *master) const override;  convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse ;  ; void LocalToMasterVect (const Double_t *local, Double_t *master) const override;  convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse ;  ; TGeoMatrix * MakeClone () const override;  Make a clone of this matrix. ;  ; void MasterToLocal (const Double_t *master, Double_t *local) const override;  convert a point by multiplying its column vector (x, y, z, 1) to matrix ;  ; void MasterToLocalBomb (const Double_t *master, Double_t *local) const override;  convert a point by multiplying its column vector (x, y, z, 1) to matrix ;  ; void MasterToLocalVect (const Double_t *master, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRotation.html:2135,Perform,Perform,2135,doc/master/classTGeoRotation.html,https://root.cern,https://root.cern/doc/master/classTGeoRotation.html,1,['Perform'],['Perform']
Performance,"""""); ; for s in samples:; # Select events with electron or muon trigger and with a missing transverse energy above 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Perform preselection of highly isolated leptons; df[s] = df[s].Define(""goodlep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(goodlep) > 0""); ; # Find a single good lepton, otherwise return -1 as index; df[s] = df[s].Define(""idx_lep"", ""FindGoodLepton(goodlep, lep_type, lep_pt, lep_eta, lep_phi, lep_E, lep_trackd0pvunbiased, lep_tracksigd0pvunbiased, lep_z0)"")\; .Filter(""idx_lep != -1""); ; # Compute transverse mass of the W boson using the missing transverse energy and the good lepton; # Use only events with a transverse mass of the reconstructed W boson larger than 60 GeV; df[s] = df[s].Define(""mtw"", ""sqrt(2 * lep_pt[idx_lep] * met_et * (1 - cos(lep_phi[idx_lep] - met_phi)))"")\; .Filter(""mtw > 60000""); ; # Perform preselection of jets; df[s] = df[s].Filter(""ROOT::VecOps::Sum(jet_pt > 30000 && abs(jet_eta) < 2.5) > 0""); ; # Select events with two good jets and one b-jet and find the indices in the collections; df[s] = df[s].Define(""goodjet"", ""jet_pt > 60000 || abs(jet_eta) > 2.4 || jet_jvt > 0.59"")\; .Filter(""ROOT::VecOps::Sum(goodjet) == 2"")\; .Define(""goodbjet"", ""goodjet && jet_MV2c10 > 0.8244273"")\; .Filter(""ROOT::VecOps::Sum(goodbjet) == 1"")\; .Define(""idx_tagged"", ""ROOT::VecOps::ArgMax(goodjet && goodbjet)"")\; .Define(""idx_untagged"", ""ROOT::VecOps::ArgMax(goodjet && !goodbjet)""); ; # Select events based on the jet kinematics and the scalar sum of the transverse momentum; # from the lepton, jets and met above 195 GeV; df[s] = df[s].Filter(""abs(jet_eta[idx_untagged]) > 1.5 && abs(jet_eta[idx_tagged] - jet_eta[idx_untagged]) > 1.5"")\; .Filter(""lep_pt[idx_lep] + jet_pt[idx_tagged] + jet_pt[idx_untagged] + met_et > 195000""); ; # Compute luminosity, scale factors and MC weights for simulated events",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:5607,Perform,Perform,5607,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['Perform'],['Perform']
Performance,""""");; 5958 }; 5959 else if (sharedLibBaseStr.EndsWith("".sl"")) {; 5960 rootMapBaseStr.ReplaceAll("".sl"", """");; 5961 }; 5962 else if (sharedLibBaseStr.EndsWith("".dl"")) {; 5963 rootMapBaseStr.ReplaceAll("".dl"", """");; 5964 }; 5965 else if (sharedLibBaseStr.EndsWith("".a"")) {; 5966 rootMapBaseStr.ReplaceAll("".a"", """");; 5967 }; 5968 else {; 5969 Error(""ReloadAllSharedLibraryMaps"", ""Unknown library type %s"", sharedLibBaseStr.Data());; 5970 delete sharedLibL;; 5971 return -1;; 5972 }; 5973 rootMapBaseStr += "".rootmap"";; 5974 const char* rootMap = gSystem->Which(gSystem->GetDynamicPath(), rootMapBaseStr);; 5975 if (!rootMap) {; 5976 Error(""ReloadAllSharedLibraryMaps"", ""Could not find rootmap %s in path"", rootMapBaseStr.Data());; 5977 delete[] rootMap;; 5978 delete sharedLibL;; 5979 return -1;; 5980 }; 5981 const Int_t status = LoadLibraryMap(rootMap);; 5982 if (status < 0) {; 5983 Error(""ReloadAllSharedLibraryMaps"", ""Error loading map %s"", rootMap);; 5984 delete[] rootMap;; 5985 delete sharedLibL;; 5986 return -1;; 5987 }; 5988 delete[] rootMap;; 5989 }; 5990 delete sharedLibL;; 5991 return 0;; 5992}; 5993 ; 5994////////////////////////////////////////////////////////////////////////////////; 5995/// Unload the library map entries coming from all the loaded shared libraries.; 5996/// Returns 0 if succesful; 5997 ; 5998Int_t TCling::UnloadAllSharedLibraryMaps(); 5999{; 6000 const TString sharedLibLStr = GetSharedLibs();; 6001 const TObjArray* sharedLibL = sharedLibLStr.Tokenize("" "");; 6002 for (Int_t ilib = 0; ilib < sharedLibL->GetEntriesFast(); ilib++) {; 6003 const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();; 6004 const TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);; 6005 UnloadLibraryMap(sharedLibBaseStr);; 6006 }; 6007 delete sharedLibL;; 6008 return 0;; 6009}; 6010 ; 6011////////////////////////////////////////////////////////////////////////////////; 6012/// Unload library map entries coming from the specified library.; 6013/// Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:232306,Load,LoadLibraryMap,232306,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,3,"['Load', 'load']","['LoadLibraryMap', 'loaded', 'loading']"
Performance,""""")TGeoVolume; ls(Option_t *option="""") const overrideTNamedvirtual; MakeCopyNodes(const TGeoVolume *other)TGeoVolume; MakeCopyVolume(TGeoShape *newshape)TGeoVolumevirtual; MakeReflectedVolume(const char *newname="""") constTGeoVolume; MakeZombie()TObjectinlineprotected; MayNotUse(const char *method) constTObject; TAttLine::Modify()TAttLinevirtual; TAttFill::Modify()TAttFillvirtual; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TGeoVolume &)=deleteTGeoVolumeprivate; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; OptimizeVoxels()TGeoVolume; Paint(Option_t *option="""") overrideTGeoVolumevirtual; Pop()TObjectvirtual; Print(Option_t *option="""") const overrideTGeoVolumevirtual; PrintNodes() constTGeoVolume; PrintVoxels() constTGeoVolume; RandomPoints(Int_t npoints=1000000, Option_t *option="""")TGeoVolume; RandomRays(Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE)TGeoVolume; Raytrace(Bool_t flag=kTRUE)TGeoVolume; Read(const char *name)TObjectvirtual; RecursiveRemove(TObject *obj)TObjectvirtual; RegisterYourself(Option_t *option="""")TGeoVolume; Release()TGeoVolumeinline; RemoveNode(TGeoNode *node)TGeoVolume; ReplaceNode(TGeoNode *nodeorig, TGeoShape *newshape=nullptr, TGeoMatrix *newpos=nullptr, TGeoMedium *newmed=nullptr)TGeoVolume; ReplayCreation(const TGeoVolume *other)TGeoVolume; ResetAttBit(UInt_t f)TGeoAttinline; ResetAttFill(Option_t *option="""")TAttFillvirtual; ResetAttLine(Option_t *option="""")TAttLinevirtual; ResetBit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume-members.html:10858,Optimiz,OptimizeVoxels,10858,doc/master/classTGeoVolume-members.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume-members.html,1,['Optimiz'],['OptimizeVoxels']
Performance,""""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for specified entries. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual TBranch * FindBranch (const char *name);  Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find leaf.. ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaskets (bool create_cluster=true) const;  Write to d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:7463,cache,cache,7463,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['cache'],['cache']
Performance,""""" . ). Collect information about geometry hierarchy into flat list like it done in JSROOT ClonedNodes.createClones. ; Definition at line 425 of file RGeomData.cxx. ◆ Build() [2/2]. void RGeomDescription::Build ; (; TGeoVolume * ; vol). Collect information about geometry from single volume like it done in JSROOT ClonedNodes.createClones. ; Definition at line 460 of file RGeomData.cxx. ◆ BuildDescription(). void RGeomDescription::BuildDescription ; (; TGeoNode * ; topnode, . TGeoVolume * ; topvolume . ). private . Build geometry description. ; Definition at line 494 of file RGeomData.cxx. ◆ ChangeConfiguration(). bool RGeomDescription::ChangeConfiguration ; (; const std::string & ; json). Change configuration by client Returns true if any parameter was really changed. ; Definition at line 2105 of file RGeomData.cxx. ◆ ChangeNodeVisibility(). bool RGeomDescription::ChangeNodeVisibility ; (; const std::vector< std::string > & ; path, . bool ; on . ). Change visibility for specified element Returns true if changes was performed. ; Definition at line 1850 of file RGeomData.cxx. ◆ ClearAllPhysVisibility(). bool RGeomDescription::ClearAllPhysVisibility ; (; ). Reset all custom visibility settings. ; Definition at line 2089 of file RGeomData.cxx. ◆ ClearCache(). void RGeomDescription::ClearCache ; (; ). Clear cached data, need to be clear when connection broken. ; Definition at line 1381 of file RGeomData.cxx. ◆ ClearDescription(). void RGeomDescription::ClearDescription ; (; ). private . Clear geometry description. ; Definition at line 478 of file RGeomData.cxx. ◆ ClearDrawData(). void RGeomDescription::ClearDrawData ; (; ). Clear raw data. Will be rebuild when next connection will be established. ; Definition at line 1370 of file RGeomData.cxx. ◆ ClearPhysNodeVisibility(). bool RGeomDescription::ClearPhysNodeVisibility ; (; const std::vector< std::string > & ; path). Reset custom visibility of physical node by path. ; Definition at line 2065 of file RGeomData.cxx. ◆ Collec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:12469,perform,performed,12469,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['perform'],['performed']
Performance,""") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooProdPdf(); RooProdPdf(const RooProdPdf& other, const char* name = 0); RooProdPdf(const char* name, const char* title, Double_t cutOff = 0); RooProdPdf(const char* name, const char* title, const RooArgList& pdfList, Double_t cutOff = 0); RooProdPdf(const char* name, const char* title, const RooArgSet& fullPdfSet, const RooLinkedList& cmdArgList); RooProdPdf(const char* name, const char* title, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Double_t cutOff = 0); RooProdPdf(const char* name, const char* title, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:28295,cache,cache,28295,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,2,['cache'],['cache']
Performance,""") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:28482,cache,cache,28482,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['cache'],['cache']
Performance,""") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProdPdf.html:27879,cache,cache,27879,root/html530/RooProdPdf.html,https://root.cern,https://root.cern/root/html530/RooProdPdf.html,1,['cache'],['cache']
Performance,""") const;; 241 Long64_t GetZipBytes(Option_t *option="""") const;; 242 Long64_t GetEntryNumber() const {return fEntryNumber;}; 243 Long64_t GetFirstEntry() const {return fFirstEntry; }; 244 TIOFeatures GetIOFeatures() const;; 245 TObjArray *GetListOfBaskets() {return &fBaskets;}; 246 TObjArray *GetListOfBranches() {return &fBranches;}; 247 TObjArray *GetListOfLeaves() {return &fLeaves;}; 248 Int_t GetMaxBaskets() const {return fMaxBaskets;}; 249 Int_t GetNleaves() const {return fNleaves;}; 250 Int_t GetSplitLevel() const {return fSplitLevel;}; 251 Long64_t GetEntries() const {return fEntries;}; 252 TTree *GetTree() const {return fTree;}; 253 virtual Int_t GetRow(Int_t row);; 254 virtual bool GetMakeClass() const;; 255 TBranch *GetMother() const;; 256 TBranch *GetSubBranch(const TBranch *br) const;; 257 TBuffer *GetTransientBuffer(Int_t size);; 258 bool IsAutoDelete() const;; 259 bool IsFolder() const override;; 260 virtual void KeepCircular(Long64_t maxEntries);; 261 virtual Int_t LoadBaskets();; 262 void Print(Option_t *option="""") const override;; 263 void PrintCacheInfo() const;; 264 virtual void ReadBasket(TBuffer &b);; 265 virtual void Refresh(TBranch *b);; 266 virtual void Reset(Option_t *option="""");; 267 virtual void ResetAfterMerge(TFileMergeInfo *);; 268 virtual void ResetAddress();; 269 virtual void ResetReadEntry() {fReadEntry = -1;}; 270 virtual void SetAddress(void *add);; 271 virtual void SetObject(void *objadd);; 272 virtual void SetAutoDelete(bool autodel=true);; 273 virtual void SetBasketSize(Int_t buffsize);; 274 virtual void SetBufferAddress(TBuffer *entryBuffer);; 275 void SetCompressionAlgorithm(Int_t algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);; 276 void SetCompressionLevel(Int_t level = ROOT::RCompressionSetting::ELevel::kUseMin);; 277 void SetCompressionSettings(Int_t settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 278 virtual void SetEntries(Long64_t entries);; 279 virtual void SetEntryOffsetLen(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8h_source.html:12228,Load,LoadBaskets,12228,doc/master/TBranch_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html,1,['Load'],['LoadBaskets']
Performance,""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodLDMethodLD(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = 0); TMVA::MethodLDMethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTMVA::MethodBase::Reset(); void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLD.html:8498,Optimiz,OptimizeTuningParameters,8498,root/html528/TMVA__MethodLD.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLD.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,""");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeName>"").; The default (full) range can be denoted with Range("""") / NormRange("""").; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) only plotting range 'fit_nll_model_modelData_LEFT,fit_nll_model_modelData_RIGHT'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_model_modelData_LEFT,fit_nll_model_modelData_RIGHT'; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_extmodel_modelData_LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_extmodel_modelData_RIGHT' created with bounds [60,100]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(extmodel) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_extmodel_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -15500.6, estimated distance to minimum: 0.000427967; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; N 4.4939e+03 +/- 6.70e+01; alpha -4.8258e-02 +/- 8.32e-04; ; [#1] INFO:Plotting -- RooAbsPdf::plotOn(extmodel) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:16087,optimiz,optimization,16087,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,4,['optimiz'],['optimization']
Performance,""");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter();; 4211 ; 4212 // change names to be recognized by the plugin manager; 4213 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4214 TUrl urlname(n, kTRUE);; 4215 name = urlname.GetUrl();; 4216 // Check first if a pending async open request matches this one; 4217 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4218 TIter nxr(fgAsyncOpenRequests);; 4219 TFileOpenHandle *fh = nullptr;; 4220 while ((fh = (TFileOpenHandle *)nxr())); 4221 if (fh->Matches(name)); 4222 return TFile::Open(fh);; 4223 }; 4224 ; 4225 TString urlOptions(urlname.GetOptions());; 4226 if (urlOptions.BeginsWith(""pmerge"") || urlOptions.Contains(""&pmerge"") || urlOptions.Contains("" pmerge"")) {; 4227 type = kMerge;; 4228 ; 4229 // Pass the full name including the url options:; 4230 f = (TFile*) gROOT->ProcessLineFast(TString::Format(""new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:153689,cache,cache,153689,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,"['CACHE', 'cache']","['CACHEREAD', 'cache']"
Performance,""");; ; // Reconstruct Higgs to 2 electrons and 2 muons; auto df_sig_2el2mu_reco = reco_higgs_to_2el2mu(df_sig_4l);; auto df_h_sig_2el2mu = df_sig_2el2mu_reco; .Define(""weight"", [&] { return luminosity * xsec_SMHiggsToZZTo4L / nevt_SMHiggsToZZTo4L; }); .Histo1D({""h_sig_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; const auto xsec_ZZTo2el2mu = 0.18; // ZZ->2el2mu: Standard Model cross-section; const auto nevt_ZZTo2el2mu = 1497445.0; // ZZ->2el2mu: Number of simulated events; auto df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu);; auto df_h_bkg_2el2mu = df_bkg_2el2mu_reco; .Define(""weight"", [&] { return luminosity * xsec_ZZTo2el2mu * scale_ZZTo4l / nevt_ZZTo2el2mu; }); .Histo1D({""h_bkg_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; auto df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu);; auto df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", [] { return 1.0; }); .Histo1D({""h_data_2el2mu_doublemu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; // RunGraphs allows to run the event loops of the separate RDataFrame graphs; // concurrently. This results in an improved usage of the available resources; // if each separate RDataFrame can not utilize all available resources, e.g.,; // because not enough data is available.; ROOT::RDF::RunGraphs({df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu});; ; // Make plots; plot(df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf"");; plot(df_h_sig_4el, df_h_bkg_4el, df_h_data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf"");; plot(df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf"");; ; // Combine channels for final plot; auto h_data_4l = df_h_data_4mu.GetPtr();; h_data_4l->Add(df_h_data_4el.GetPtr());; h_data_4l->Add(df_h_data_2el2mu.GetPtr());; auto h_sig_4l = df_h_sig_4mu.GetPtr();; h_sig_4l->Add(df_h_sig_4el.GetPtr());; h_sig_4l->Add(df_h_sig_2el2mu.GetPtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:20116,concurren,concurrently,20116,doc/master/df103__NanoAODHiggsAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html,1,['concurren'],['concurrently']
Performance,""");; dnnOptions.Append(layoutString);; dnnOptions.Append("":"");; dnnOptions.Append(trainingStrategyString);; dnnOptions.Append("":"");; dnnOptions.Append(archString);; ; TString dnnName = ""TMVA_DNN"";; factory->BookMethod(dataloader, TMVA::Types::kDL, dnnName, dnnOptions);; }; ; /**; ## Book Keras recurrent models; ; Book the different types of recurrent models in Keras (SimpleRNN, LSTM or GRU); ; **/; ; if (useKeras) {; ; for (int i = 0; i < 3; i++) {; ; if (use_rnn_type[i]) {; ; TString modelName = TString::Format(""model_%s.h5"", rnn_types[i].c_str());; TString trainedModelName = TString::Format(""trained_model_%s.h5"", rnn_types[i].c_str());; ; Info(""TMVA_RNN_Classification"", ""Building recurrent keras model using a %s layer"", rnn_types[i].c_str());; // create python script which can be executed; // create 2 conv2d layer + maxpool + dense; TMacro m;; m.AddLine(""import tensorflow"");; m.AddLine(""from tensorflow.keras.models import Sequential"");; m.AddLine(""from tensorflow.keras.optimizers import Adam"");; m.AddLine(""from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, SimpleRNN, GRU, LSTM, Reshape, ""; ""BatchNormalization"");; m.AddLine("""");; m.AddLine(""model = Sequential() "");; m.AddLine(""model.add(Reshape((10, 30), input_shape = (10*30, )))"");; // add recurrent neural network depending on type / Use option to return the full output; if (rnn_types[i] == ""LSTM""); m.AddLine(""model.add(LSTM(units=10, return_sequences=True) )"");; else if (rnn_types[i] == ""GRU""); m.AddLine(""model.add(GRU(units=10, return_sequences=True) )"");; else; m.AddLine(""model.add(SimpleRNN(units=10, return_sequences=True) )"");; ; // m.AddLine(""model.add(BatchNormalization())"");; m.AddLine(""model.add(Flatten())""); // needed if returning the full time output sequence; m.AddLine(""model.add(Dense(64, activation = 'tanh')) "");; m.AddLine(""model.add(Dense(2, activation = 'sigmoid')) "");; m.AddLine(; ""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metric",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:68692,optimiz,optimizers,68692,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['optimiz'],['optimizers']
Performance,""");; } else {; printf(""\nmultidimfit .............................................. fails case %d\n"",compare);; }; ; // We're done; delete fit;; delete [] xMin;; delete [] xMax;; return compare;; }; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; Riostream.h; TApplication.h; TBrowser.h; TCanvas.h; TFile.h; TH1.h; TMath.h; TMultiDimFit.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TVectorD.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TMultiDimFitMultidimensional Fits in ROOT.Definition TMultiDimFit.h:15; TMultiDimFit::kMonomials@ kMonomialsDefinition TMultiDimFit.h:19; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TVectorT< Double_t >; xDouble_t x[n]Definition legend1.C:17; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; outputstatic void output(); AuthorsRene Brun, Christian Holm Christensen ; Definition in file multidimfit.C. tutorialsfitmultidimfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/multidimfit_8C.html:12170,optimiz,optimizer,12170,doc/master/multidimfit_8C.html,https://root.cern,https://root.cern/doc/master/multidimfit_8C.html,1,['optimiz'],['optimizer']
Performance,"""++"" sign), for example ""x++sin(x)"" for fitting ""[0]*x+[1]*sin(x)"". This function finds a pointer to the TF1 object with name fname; and calls TH1::Fit(TF1 *f1,...). TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Double_t xmin = 0, Double_t xmax = 0); Fit histogram with function f1. Fit this histogram with function f1. The list of fit options is given in parameter option.; option = ""W"" Set all weights to 1 for non empty bins; ignore error bars; = ""WW"" Set all weights to 1 including empty bins; ignore error bars; = ""I"" Use integral of function in bin, normalized by the bin volume,; instead of value at bin center; = ""L"" Use Loglikelihood method (default is chisquare method); = ""WL"" Use Loglikelihood method and bin contents are not integer,; i.e. histogram is weighted (must have Sumw2() set); = ""P"" Use Pearson chi2 (using expected errors instead of observed errors); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" User defined parameter settings are used for predefined functions; like ""gaus"", ""expo"", ""poln"", ""landau"".; Use this option when you want to fix one or more parameters for these functions.; = ""M"" More. Improve fit results.; It uses the IMPROVE command of TMinuit (see TMinuit::mnimpr).; This algorithm attempts to improve the found local minimum by searching for a; better one.; = ""R"" Use the Range specified in the function range; = ""N"" Do not store the graphics function, do not draw; = ""0"" Do not plot the result of the fit. By default the fitted function; is drawn unless the option""N"" above is specified.; = ""+"" Add this new fitted function to the list of fitted functions; (by default, any previous function is deleted); = ""C"" In case of linear fitting, don't calculate the chisquare; (saves time); = ""F"" If fitting a polN, switch to minuit fitter; = ""S"" The result of the fit is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:78104,Perform,Perform,78104,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,1,['Perform'],['Perform']
Performance,""", ""Random seed used for weight initialization and batch shuffling"");; 192 ; 193 DeclareOptionRef(fNumValidationString = ""20%"", ""ValidationSize"", ""Part of the training data to use for validation. ""; 194 ""Specify as 0.2 or 20% to use a fifth of the data set as validation set. ""; 195 ""Specify as 100 to use exactly 100 events. (Default: 20%)"");; 196 ; 197 DeclareOptionRef(fArchitectureString = ""CPU"", ""Architecture"", ""Which architecture to perform the training on."");; 198 AddPreDefVal(TString(""STANDARD"")); // deprecated and not supported anymore; 199 AddPreDefVal(TString(""CPU""));; 200 AddPreDefVal(TString(""GPU""));; 201 AddPreDefVal(TString(""OPENCL"")); // not yet implemented; 202 AddPreDefVal(TString(""CUDNN"")); // not needed (by default GPU is now CUDNN if available); 203 ; 204 // define training strategy separated by a separator ""|""; 205 DeclareOptionRef(fTrainingStrategyString = ""LearningRate=1e-3,""; 206 ""Momentum=0.0,""; 207 ""ConvergenceSteps=100,""; 208 ""MaxEpochs=2000,""; 209 ""Optimizer=ADAM,""; 210 ""BatchSize=30,""; 211 ""TestRepetitions=1,""; 212 ""WeightDecay=0.0,""; 213 ""Regularization=None,""; 214 ""DropConfig=0.0"",; 215 ""TrainingStrategy"", ""Defines the training strategies."");; 216}; 217 ; 218////////////////////////////////////////////////////////////////////////////////; 219void MethodDL::ProcessOptions(); 220{; 221 ; 222 if (IgnoreEventsWithNegWeightsInTraining()) {; 223 Log() << kINFO << ""Will ignore negative events in training!"" << Endl;; 224 }; 225 ; 226 if (fArchitectureString == ""STANDARD"") {; 227 Log() << kWARNING << ""The STANDARD architecture is not supported anymore. ""; 228 ""Please use Architecture=CPU or Architecture=CPU.""; 229 ""See the TMVA Users' Guide for instructions if you ""; 230 ""encounter problems.""; 231 << Endl;; 232 Log() << kINFO << ""We will use instead the CPU architecture"" << Endl;; 233 fArchitectureString = ""CPU"";; 234 }; 235 if (fArchitectureString == ""OPENCL"") {; 236 Log() << kERROR << ""The OPENCL architecture has not been implemented yet. ""; 23",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:7653,Optimiz,Optimizer,7653,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['Optimiz'],['Optimizer']
Performance,""", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on conce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:33205,cache,cache,33205,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,9,['cache'],['cache']
Performance,""". ;  ; Pixmap_t CreatePixmap (Drawable_t wid, const char *bitmap, UInt_t width, UInt_t height, ULong_t foregroundColor, ULong_t backgroundColor, Int_t depth) override;  Creates a pixmap from bitmap data of the width, height, and depth you specified and returns a pixmap that identifies it. ;  ; Pixmap_t CreatePixmap (Drawable_t wid, UInt_t w, UInt_t h) override;  Creates a pixmap of the specified width and height and returns a pixmap ID that identifies it. ;  ; Pixmap_t CreatePixmapFromData (unsigned char *bits, UInt_t width, UInt_t height) override;  create pixmap from RGB data. ;  ; Region_t CreateRegion () override;  Creates a new empty region. ;  ; Window_t CreateWindow (Window_t parent, Int_t x, Int_t y, UInt_t w, UInt_t h, UInt_t border, Int_t depth, UInt_t clss, void *visual, SetWindowAttributes_t *attr, UInt_t wtype) override;  Creates an unmapped subwindow for a specified parent window and returns the created window. ;  ; void DeleteFont (FontStruct_t fs) override;  Explicitly deletes the font structure ""fs"" obtained via LoadQueryFont(). ;  ; void DeleteGC (GContext_t gc) override;  Deletes the specified GC ""gc"". ;  ; void DeleteImage (Drawable_t img) override;  Deallocates the memory associated with the image img. ;  ; void DeleteOpenGLContext (Int_t ctxID) override;  Deletes OpenGL context for window ""wid"". ;  ; void DeletePictureData (void *data) override;  Delete picture data created by the function ReadPictureDataFromFile. ;  ; void DeletePixmap (Pixmap_t pixmapID) override;  Explicitly deletes the pixmap resource ""pmap"". ;  ; void DeletePixmapAux (Pixmap_t pixmapID);  ; void DeleteProperty (Window_t, Atom_t &) override;  Deletes the specified property only if the property was defined on the specified window and causes the X server to generate a PropertyNotify event on the window unless the property does not exist. ;  ; void DestroyRegion (Region_t reg) override;  Destroys the region ""reg"". ;  ; void DestroySubwindows (Window_t wid) override;  The Destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:6909,Load,LoadQueryFont,6909,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,2,['Load'],['LoadQueryFont']
Performance,"""... and that's the one that will later on be used; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); special case: regression. void AddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0). MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"). void OptimizeAllMethodsForClassification(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void OptimizeAllMethodsForRegression(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void TrainAllMethodsForClassification( void ); { TrainAllMethods(); }. void TrainAllMethodsForRegression( void ); { TrainAllMethods(); }. Bool_t Verbose( void ); { return fVerbose; }. TDirectory* RootBaseDir(); { return (TDirectory*)fgTargetFile; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Factory.html:20522,Optimiz,OptimizeAllMethodsForClassification,20522,root/html534/TMVA__Factory.html,https://root.cern,https://root.cern/root/html534/TMVA__Factory.html,4,['Optimiz'],"['OptimizeAllMethods', 'OptimizeAllMethodsForClassification', 'OptimizeAllMethodsForRegression']"
Performance,"""; // ""ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,""; // ""MaxEpochs=20,WeightDecay=1e-4,Regularization=None,""; // ""Optimizer=SGD,DropConfig=0.0+0.0+0.0+0."");; ; TString trainingStrategyString (""TrainingStrategy="");; trainingStrategyString += training1; // + ""|"" + training2;; ; // General Options.; ; TString dnnOptions (""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=G:""; ""WeightInitialization=XAVIER"");; dnnOptions.Append ("":""); dnnOptions.Append (inputLayoutString);; dnnOptions.Append ("":""); dnnOptions.Append (batchLayoutString);; dnnOptions.Append ("":""); dnnOptions.Append (layoutString);; dnnOptions.Append ("":""); dnnOptions.Append (trainingStrategyString);; ; TString dnnMethodName = ""DNN_CPU"";; if (useDLGPU) {; dnnOptions += "":Architecture=GPU"";; dnnMethodName = ""DNN_GPU"";; } else {; dnnOptions += "":Architecture=CPU"";; }; ; factory.BookMethod(loader, TMVA::Types::kDL, dnnMethodName, dnnOptions);; }; ; // Keras deep learning; if (useKeras) {; ; Info(""TMVA_Higgs_Classification"", ""Building deep neural network with keras "");; // create python script which can be executed; // create 2 conv2d layer + maxpool + dense; TMacro m;; m.AddLine(""import tensorflow"");; m.AddLine(""from tensorflow.keras.models import Sequential"");; m.AddLine(""from tensorflow.keras.optimizers import Adam"");; m.AddLine(""from tensorflow.keras.layers import Input, Dense"");; m.AddLine("""");; m.AddLine(""model = Sequential() "");; m.AddLine(""model.add(Dense(64, activation='relu',input_dim=7))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(2, activation='sigmoid'))"");; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('Higgs_model.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_higgs_model.py"");; // execute; auto ret = (TString *)gROOT->Pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:67210,load,loader,67210,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['load'],['loader']
Performance,"""; 3#define CPYCPPYY_INTERNAL 1; 4#include ""CPyCppyy/API.h""; 5#undef CPYCPPYY_INTERNAL; 6 ; 7#include ""CPPInstance.h""; 8#include ""CPPOverload.h""; 9#include ""CPPScope.h""; 10#include ""ProxyWrappers.h""; 11#include ""PyStrings.h""; 12 ; 13// Standard; 14#include <stdio.h>; 15#include <iostream>; 16#include <string>; 17 ; 18//______________________________________________________________________________; 19// CPyCppyy API: Interpreter and Proxy Access; 20// ==========================================; 21//; 22// Access to cppyy Python objects from Cling and C++: allows conversion for; 23// instances and type checking for scopes, instances, etc.; 24// Adds a few convenience functions to call Python from Cling and expose Python; 25// classes to Cling for use in inheritance etc.; 26 ; 27 ; 28//- data ---------------------------------------------------------------------; 29static PyObject* gMainDict = nullptr;; 30 ; 31namespace CPyCppyy {; 32 extern PyObject* gThisModule;; 33}; 34 ; 35 ; 36//- private helpers ----------------------------------------------------------; 37namespace {; 38 ; 39static bool Initialize(); 40{; 41// Private initialization method: setup the python interpreter and load the; 42// cppyy module.; 43 static bool isInitialized = false;; 44 if (isInitialized); 45 return true;; 46 ; 47 if (!Py_IsInitialized()) {; 48 // this happens if Cling comes in first; 49#if PY_VERSION_HEX < 0x03020000; 50 PyEval_InitThreads();; 51#endif; 52#if PY_VERSION_HEX < 0x03080000; 53 Py_Initialize();; 54#else; 55 PyConfig config;; 56 PyConfig_InitPythonConfig(&config);; 57 PyConfig_SetString(&config, &config.program_name, L""cppyy"");; 58 Py_InitializeFromConfig(&config);; 59#endif; 60#if PY_VERSION_HEX >= 0x03020000; 61#if PY_VERSION_HEX < 0x03090000; 62 PyEval_InitThreads();; 63#endif; 64#endif; 65 ; 66 // try again to see if the interpreter is initialized; 67 if (!Py_IsInitialized()) {; 68 // give up ...; 69 std::cerr << ""Error: python has not been initialized; returning."" << std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:1422,load,load,1422,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['load'],['load']
Performance,"""; 33#include ""TOrdCollection.h""; 34#include ""TObject.h""; 35#include ""TInterpreter.h""; 36#include ""TRegexp.h""; 37#include ""TObjString.h""; 38#include ""TObjArray.h""; 39#include ""TError.h""; 40#include ""TPluginManager.h""; 41#include ""TUrl.h""; 42#include ""TVirtualMutex.h""; 43#include ""TVersionCheck.h""; 44#include ""compiledata.h""; 45#include ""RConfigure.h""; 46#include ""THashList.h""; 47#include ""ThreadLocalStorage.h""; 48 ; 49#include <functional>; 50#include <iostream>; 51#include <fstream>; 52#include <memory>; 53#include <sstream>; 54#include <string>; 55#include <sys/stat.h>; 56#include <set>; 57 ; 58#ifdef WIN32; 59#include <io.h>; 60#include ""Windows4Root.h""; 61#endif; 62 ; 63const char *gRootDir = nullptr;; 64const char *gProgName = nullptr;; 65const char *gProgPath = nullptr;; 66 ; 67TSystem *gSystem = nullptr;; 68TFileHandler *gXDisplay = nullptr; // Display server event handler, set in TGClient; 69 ; 70static Int_t *gLibraryVersion = nullptr; // Set in TVersionCheck, used in Load(); 71static Int_t gLibraryVersionIdx = 0; // Set in TVersionCheck, used in Load(); 72static Int_t gLibraryVersionMax = 256;; 73 ; 74// Pin vtable; 75ProcInfo_t::~ProcInfo_t() {}; 76ClassImp(TProcessEventTimer);; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create async event processor timer. Delay is in milliseconds.; 80 ; 81TProcessEventTimer::TProcessEventTimer(Long_t delay) : TTimer(delay, kFALSE); 82{; 83 gROOT->SetInterrupt(kFALSE);; 84 TurnOn();; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Process events if timer did time out. Returns kTRUE if interrupt; 89/// flag is set (by hitting a key in the canvas or selecting the; 90/// Interrupt menu item in canvas or some other action).; 91 ; 92Bool_t TProcessEventTimer::ProcessEvents(); 93{; 94 if (fTimeout) {; 95 if (gSystem->ProcessEvents()) {; 96 Remove();; 97 return kTRUE;; 98 } else {; 99 Reset();; 100 return kFALSE;; 101 }; 102 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:2359,Load,Load,2359,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['Load'],['Load']
Performance,"""; 93#include ""llvm/Support/Signals.h""; 94 ; 95#include ""RtypesCore.h""; 96#include ""TModuleGenerator.h""; 97#include ""TClassEdit.h""; 98#include ""TClingUtils.h""; 99#include ""RStl.h""; 100#include ""XMLReader.h""; 101#include ""LinkdefReader.h""; 102#include ""DictSelectionReader.h""; 103#include ""SelectionRules.h""; 104#include ""Scanner.h""; 105#include ""strlcpy.h""; 106 ; 107#include ""OptionParser.h""; 108 ; 109#ifdef WIN32; 110const std::string gLibraryExtension("".dll"");; 111#else; 112const std::string gLibraryExtension("".so""); // no dylib for the moment; 113#endif; 114const std::string gPathSeparator(ROOT::TMetaUtils::GetPathSeparator());; 115 ; 116#ifdef __APPLE__; 117#include <mach-o/dyld.h>; 118#endif; 119 ; 120#if defined(R__WIN32); 121#include ""cygpath.h""; 122#define strcasecmp _stricmp; 123#define strncasecmp _strnicmp; 124#else; 125#include <unistd.h>; 126#endif; 127 ; 128bool gBuildingROOT = false;; 129const ROOT::Internal::RootCling::DriverConfig* gDriverConfig = nullptr;; 130 ; 131#define rootclingStringify(s) rootclingStringifyx(s); 132#define rootclingStringifyx(s) #s; 133 ; 134// Maybe too ugly? let's see how it performs.; 135using HeadersDeclsMap_t = std::map<std::string, std::list<std::string>>;; 136 ; 137using namespace ROOT;; 138 ; 139using std::string, std::map, std::ifstream, std::ofstream, std::endl, std::ios, std::vector;; 140 ; 141namespace genreflex {; 142 bool verbose = false;; 143}; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146 ; 147static llvm::cl::OptionCategory gRootclingOptions(""rootcling common options"");; 148 ; 149 // FIXME: We should remove after removal of r flag.; 150static llvm::cl::opt<bool>; 151gOptIgnoreExistingDict(""r"",; 152 llvm::cl::desc(""Deprecated. Similar to -f but it ignores the dictionary generation. \; 153When -r is present rootcling becomes a tool to generate rootmaps (and capability files).""),; 154 llvm::cl::Hidden,; 155 llvm::cl::cat(gRootclingOptions));; 156 ; 157//////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:3837,perform,performs,3837,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['perform'],['performs']
Performance,"""A*fabs(x)+pow(x-B,2)"",; True,; False,; ""x:(A/2)*(pow(x.max(rangeName),2)+pow(x.min(rangeName),2))+(1./3)*(pow(x.max(rangeName)-B,3)-pow(x.min(rangeName)-B,3))"",; ); ; # Use instance of created class; # ---------------------------------------------------------; ; # Compile MyPdfV3 class; ROOT.gROOT.ProcessLineSync("".x MyPdfV3.cxx+""); ; # Creat instance of MyPdfV3 class; a = ROOT.RooRealVar(""a"", ""a"", 1); b = ROOT.RooRealVar(""b"", ""b"", 2, -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); pdf = ROOT.MyPdfV3(""pdf"", ""pdf"", y, a, b); ; # Generate toy data from pdf and plot data and pdf on frame; frame1 = y.frame(Title=""Compiled class MyPdfV3""); data = pdf.generate({y}, 1000); pdf.fitTo(data, PrintLevel=-1); data.plotOn(frame1); pdf.plotOn(frame1); ; # /; # C o m p i l e d v e r s i o n o f e x a m p l e r f 1 0 3 #; # /; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # The ROOT.RooClassFactory.makePdfInstance() function performs code writing, compiling, linking; # and object instantiation in one go and can serve as a straight; # replacement of ROOT.RooGenericPdf; ; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 5, 0.1, 10); genpdf = ROOT.RooClassFactory.makePdfInstance(""GenPdf"", ""(1+0.1*fabs(x)+sin(sqrt(fabs(x*alpha+0.1))))"", [x, alpha]); ; # Generate a toy dataset from the interpreted pdf; data2 = genpdf.generate({x}, 50000); ; # Fit the interpreted pdf to the generated data; genpdf.fitTo(data2, PrintLevel=-1); ; # Make a plot of the data and the pdf overlaid; frame2 = x.frame(Title=""Compiled version of pdf of rf103""); data2.plotOn(frame2); genpdf.plotOn(frame2); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf104_classfactory"", ""rf104_classfactory"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf104_classfactory.png""); (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8py.html:2542,perform,performs,2542,doc/master/rf104__classfactory_8py.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html,1,['perform'],['performs']
Performance,"""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7559,load,load,7559,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['load'],['load']
Performance,"""RECREATE"" and only before first write operation. These options are: . Name Description . SetUseSuffixes() suffix usage in column names (default - on) . SetArrayLimit() defines maximum array size, which can has column for each element (default 21) . SetTablesType() table type name in MySQL database (default ""InnoDB"") . SetUseIndexes() usage of indexes in database (default kIndexesBasic) . Normally these functions should be called immediately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT SQL commands are used before and after data storage. If TSQLFile detects any problems, ROLLBACK command will be used to restore previous state of data base. If transactions not supported by SQL server, they can be disabled by SetUseTransactions(kTransactionsOff). Or user can take responsibility to use transactions function himself. By default only indexes for basic tables are created. In most cases usage of indexes increase performance to data reading, but it also can increase time of writing data to database. There are several modes of index usage available in SetUseIndexes() method There is MakeSelectQuery(TClass*) method, which produces SELECT statement to get objects data of specified class. Difference from simple statement like: mysql> SELECT * FROM TH1I_ver1 that not only data for that class, but also data from parent classes will be extracted from other tables and combined in single result table. Such select query can be useful for external access to objects data.; Up to now MySQL 4.1 and Oracle 9i were tested. Some extra work is required for other SQL databases. Hopefully, this should be straightforward.; Known problems and open questions.; TTree is not supported by TSQLFile. There is independent development of TTreeSQL class, which allows to store trees directly in SQL database; TClonesArray is store objects in raw format, which can not be accessed outside ROOT. This will be changed later.; TDirectory cannot work. Hope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:4853,perform,performance,4853,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['perform'],['performance']
Performance,"""RECREATE""); factory = TMVA.Factory(; ""TMVA_Higgs_Classification"", outputFile, V=False, ROC=True, Silent=False, Color=True, AnalysisType=""Classification""; ); ; ; ## Setup Dataset(s); ; # Define now input data file and signal and background trees; ; inputFileName = ""Higgs_data.root""; inputFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59301,load,loader,59301,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"""TGraph.h""; 32#include ""TPluginManager.h""; 33#include ""TVirtualPadEditor.h""; 34#include ""TStopwatch.h""; 35 ; 36#include ""TPolyMarker3D.h""; 37 ; 38#include ""TGeoAtt.h""; 39#include ""TGeoVolume.h""; 40#include ""TGeoNode.h""; 41#include ""TGeoElement.h""; 42#include ""TGeoManager.h""; 43#include ""TGeoTrack.h""; 44#include ""TGeoOverlap.h""; 45#include ""TGeoChecker.h""; 46#include ""TGeoPhysicalNode.h""; 47#include ""TGeoPolygon.h""; 48#include ""TGeoCompositeShape.h""; 49#include ""TGeoShapeAssembly.h""; 50#include ""TGeoPainter.h""; 51#include ""TMath.h""; 52 ; 53#include ""X3DBuffer.h""; 54 ; 55#include ""TBuffer3D.h""; 56#include ""TBuffer3DTypes.h""; 57#include ""TVirtualViewer3D.h""; 58#include ""TVirtualX.h""; 59 ; 60ClassImp(TGeoPainter);; 61 ; 62////////////////////////////////////////////////////////////////////////////////; 63/// Default constructor.; 64 ; 65TGeoPainter::TGeoPainter(TGeoManager *manager) : TVirtualGeoPainter(manager); 66{; 67 TVirtualGeoPainter::SetPainter(this);; 68 if (manager); 69 fGeoManager = manager;; 70 else {; 71 Error(""ctor"", ""No geometry loaded"");; 72 return;; 73 }; 74 fNsegments = fGeoManager->GetNsegments();; 75 fNVisNodes = 0;; 76 fBombX = 1.3;; 77 fBombY = 1.3;; 78 fBombZ = 1.3;; 79 fBombR = 1.3;; 80 fVisLevel = fGeoManager->GetVisLevel();; 81 fVisOption = fGeoManager->GetVisOption();; 82 fExplodedView = fGeoManager->GetBombMode();; 83 fVisBranch = """";; 84 fVolInfo = """";; 85 fVisLock = kFALSE;; 86 fIsRaytracing = kFALSE;; 87 fTopVisible = kFALSE;; 88 fPaintingOverlaps = kFALSE;; 89 fPlugin = nullptr;; 90 fVisVolumes = new TObjArray();; 91 fOverlap = nullptr;; 92 fGlobal = new TGeoHMatrix();; 93 fBuffer = new TBuffer3D(TBuffer3DTypes::kGeneric, 20, 3 * 20, 0, 0, 0, 0);; 94 fClippingShape = nullptr;; 95 fLastVolume = nullptr;; 96 fTopVolume = nullptr;; 97 fIsPaintingShape = kFALSE;; 98 memset(&fCheckedBox[0], 0, 6 * sizeof(Double_t));; 99 ; 100 fCheckedNode = fGeoManager->GetTopNode();; 101 fChecker = new TGeoChecker(fGeoManager);; 102 fIsEditable = kFALSE;; 103 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:2214,load,loaded,2214,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['load'],['loaded']
Performance,"""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data()); ; ; # inputFileName = ""tmva_class_example.root""; ; ; # --- Register the training and test trees; ; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); ; nEventsSig = signalTree.GetEntries(); nEventsBkg = backgroundTree.GetEntries(); ; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; ; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; ## add event variables (image); ## use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = """" # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = """" # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader.PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # It is possible also to specify the number of training and testing events,; # note we disable the computation of the correlation matrix of the input variables; ; nTrainSig = 0.8 * nEventsSig; nTrainBkg = 0.8 * nEventsBkg; ; # build the string options for DataLoader::PrepareTrainingAndTestTree; ; loader.PrepareTrainingAndTestTree(; mycuts,; mycutb,; nTrain_Signal=nTrainSig,; nTrain_Background=nTrainBkg,; SplitMode=""Random",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:7985,load,loader,7985,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['load'],['loader']
Performance,"""WIDTH"" Scales the histogran bin content by the bin width (useful for variable bins histograms) . ""SERIAL"" Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique . ""MULTITHREAD"" Forces usage of multi-thread execution whenever possible . The default fitting of an histogram (when no option is given) is perfomed as following:; a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; the full range of the histogram is used;; the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; for linear functions (polN, chenbyshev or formula expressions combined using operator ++) a linear minimization is used.; only the status of the fit is returned;; the fit is performed in Multithread whenever is enabled in ROOT;; only the last fitted function is saved in the histogram;; the histogram is drawn after fitting overalyed with the resulting fitting function. Minimizer Configuration; The Fit is perfomed using the default Minimizer, defined in the ROOT::Math::MinimizerOptions class. It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling TH1::Fit):; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm) for changing the minmizer and/or the corresponding algorithm. For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS""); will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization The current defaults are (""Minuit"",""Migrad""). See the documentation of the ROOT::Math::MinimizerOptions for the available minimizers in ROOT and their corresponding algorithms.; ROOT::Math::MinimizerOptions::SetDefaultTolerance for setting a different tolerance value for the mi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:129608,perform,performed,129608,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['perform'],['performed']
Performance,"""arr1-Alt$(arr2,0)"");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specifying option=prof or option=profs.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5-D plot with GL. When the option ""gl5d"" is specified and the dimension of the query is 5; a 5-d plot is created using GL, eg; T->Draw(""x:y:z:u:w"","""",""gl5d""). Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:32187,load,loading,32187,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['load'],['loading']
Performance,"""http://root.cern/files/Higgs_data.root""; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); h1 = df1.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_sig"", """", 100, 0, 1),""DNN_Value""); ; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_bkg"", """", 100, 0, 1),""DNN_Value""); ; # run over the input data once, combining both RDataFrame graphs.; ROOT.RDF.RunGraphs([h1, h2]);; ; print(""Number of signal entries"",h1.GetEntries()); print(""Number of background entries"",h2.GetEntries()); ; h1.SetLineColor(ROOT.kRed); h2.SetLineColor(ROOT.kBlue); ; c1 = ROOT.TCanvas(); ROOT.gStyle.SetOptStat(0); ; h2.DrawClone(); h1.DrawClone(""SAME""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; //Code generated automatically by TMVA for Inference of Model file [Higgs_trained_model.h5] at [Tue Nov 5 09:33:48 2024] ; ; #ifndef ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; #define ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; ; #include <algorithm>; #include <vector>; #include <cmath>; #include ""TMVA/SOFIE_common.hxx""; #include <fstream>; ; namespace TMVA_SOFIE_Higgs_trained_model{; namespace BLAS{; extern ""C"" void sgemv_(const char * trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * Y, const int * incy);; extern ""C"" void sgemm_(const char * transa, const char * transb, const int * m, const int * n, const int * k,; const float * alpha, const float * A, const int * lda, const float * B, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html:2510,concurren,concurrently,2510,doc/master/TMVA__SOFIE__RDataFrame_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html,1,['concurren'],['concurrently']
Performance,"""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8py.html:3290,optimiz,optimization,3290,doc/master/rf603__multicpu_8py.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html,1,['optimiz'],['optimization']
Performance,"""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGFont.html:14420,Perform,Perform,14420,root/html530/TGFont.html,https://root.cern,https://root.cern/root/html530/TGFont.html,1,['Perform'],['Perform']
Performance,"""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFont.html:14420,Perform,Perform,14420,root/html532/TGFont.html,https://root.cern,https://root.cern/root/html532/TGFont.html,1,['Perform'],['Perform']
Performance,"""observables"", which list which variables should be considered; // parameters and observables by the users convention; //; // Variables appearing in sets _must_ live in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snapshot; std::unique_ptr<RooDataSet> refData{model.generate(x, 10000)};; model.fitTo(*refData, PrintLevel(-1));; ; // The true flag imports the values of the objects in (*params) into the workspace; // If not set, the present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", *params, true);; ; // Make another fit with the signal component forced to zero; // and save those parameters too; ; bkgfrac.setVal(1);; bkgfrac.setConstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8C.html:4391,load,loadSnapshot,4391,doc/master/rf510__wsnamedsets_8C.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html,1,['load'],['loadSnapshot']
Performance,"""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variable to 2 if your scripts include <vector>; 216 // and you execute your scripts multiple times.; 217 if (includes > 0) {; 218 TString code;; 219 code = ""#include <iostream>\n""; 220 ""#include <string>\n"" // for std::string std::iostream.; 221 ""#include <DllImport.h>\n"";// Defined R__EXTERN; 222 if (includes > 1) {; 223 code += ""#include <vector>\n""; 224 ""#include <utility>"";; 225 }; 226 ProcessLine(code, kTRUE);; 227 }; 228 }; 229 ; 230 // Load user functions; 231 const char *logon;; 232 logon = gEnv->GetValue(""Rint.Load"", (char*)nullptr);; 233 if (logon) {; 234 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 235 if (mac); 236 ProcessLine(Form("".L %s"",logon), kTRUE);; 237 delete [] mac;; 238 }; 239 ; 240 // E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:6975,load,loading,6975,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['load'],['loading']
Performance,"""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:141963,cache,cachefilepathbasedir,141963,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,7,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cachefilepath', 'cachefilepathbasedir']"
Performance,"# Running on a range of entries; 426It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; 427offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; 428actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; 429exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); 430hanging from another Range(). Here are some commented examples:; 431~~~{.cpp}; 432RDataFrame d(""myTree"", ""file.root"");; 433// Here we store a dataframe that loops over only the first 30 entries in a variable; 434auto d30 = d.Range(30);; 435// This is how you pick all entries from 15 onwards; 436auto d15on = d.Range(15, 0);; 437// We can specify a stride too, in this case we pick an event every 3; 438auto d15each3 = d.Range(0, 15, 3);; 439~~~; 440Note that ranges are not available when multi-threading is enabled. More information on ranges is available; 441[here](#ranges).; 442 ; 443### Executing multiple actions in the same event loop; 444As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; 445the filtered events.; 446By now, you should be able to easily understand what is happening:; 447~~~{.cpp}; 448RDataFrame d(""treeName"", ""file.root"");; 449auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; 450auto h2 = d.Histo1D(""pt_v"");; 451h1->Draw(); // event loop is run once here; 452h2->Draw(""SAME""); // no need to run the event loop again; 453~~~; 454RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; 455executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; 456accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:26881,multi-thread,multi-threading,26881,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"# Running on a range of entries; 430It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; 431offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; 432actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; 433exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); 434hanging from another Range(). Here are some commented examples:; 435~~~{.cpp}; 436RDataFrame d(""myTree"", ""file.root"");; 437// Here we store a dataframe that loops over only the first 30 entries in a variable; 438auto d30 = d.Range(30);; 439// This is how you pick all entries from 15 onwards; 440auto d15on = d.Range(15, 0);; 441// We can specify a stride too, in this case we pick an event every 3; 442auto d15each3 = d.Range(0, 15, 3);; 443~~~; 444Note that ranges are not available when multi-threading is enabled. More information on ranges is available; 445[here](#ranges).; 446 ; 447### Executing multiple actions in the same event loop; 448As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; 449the filtered events.; 450By now, you should be able to easily understand what is happening:; 451~~~{.cpp}; 452RDataFrame d(""treeName"", ""file.root"");; 453auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; 454auto h2 = d.Histo1D(""pt_v"");; 455h1->Draw(); // event loop is run once here; 456h2->Draw(""SAME""); // no need to run the event loop again; 457~~~; 458RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; 459executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; 460accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:27323,multi-thread,multi-threading,27323,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"#14329] - [RF] RDataFrameToRooFit - Clarification on returned object; [#14324] - Compatibility Issue with thisroot.sh and zsh; [#14320] - [RF] Wrong analytic integrals when using Gaussians with sigma depending on the observable; [#14303] - Test failure with nbconvert-7.14; [#14302] - The command “root –notebook” is not allowed on Windows 11; [#14277] - Cling triggers a huge number of openat calls when loading libraries; [#14263] - [tmva] When using DNN_USE_CBLAS, CMakeLists should link publicly to gsl instead of privately; [#14256] - TAxis::GetTicks and TAxis::SetTicks are inconsistent. Significantly so.; [#14244] - String comparison operators defined in TString.h should be defined as constexpr; [#14229] - [6.30] root-config –git-revision broken; [#14225] - [RF] Segmentation fault in ROOT 6.30 workspace creation; [#14223] - Extremely long startup time when loading dictionaries with pyroot; [#14219] - [cling] Use deduction guides for llvm::ArrayRef; [#14211] - Implement value printing for std::source_location; [#14205] - [cling] Replace llvm::Optional and llvm::None with std::optional; [#14199] - Memory hoarding triggered by the TPluginManager; [#14188] - cmake find_package ROOT 6.30 broken: it requires nlohmann-json; [#14163] - cmake find_package ROOT broken with 6.30, nlohmann and vdt are builtin but not found; [#14162] - RooFFTConvPdf is not working for ROOT 6.30/02; [#14157] - Minuit2 standalone build: StandAlone.cmake looks for the wrong path for VERSION_FILE; [#14113] - The find_package(root) command fails when using Root installed via Homebrew.; [#14101] - Missing documentation for RDataSetSpec; [#14097] - Cleaner stack traces in python; [#14085] - thisroot.sh does not recognize bash when running in qemu-x86_64; [#14084] - [ntuple] RRecordField creation crashes when TStreamerInfo has insufficient information; [#14075] - [FreeBSD] root.exe crash at end of compilation during modules.idx generation; [#14068] - ROOT 6.30/00 reports root-config --version as 6.30.00;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:30001,load,loading,30001,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['load'],['loading']
Performance,"#if PY_VERSION_HEX < 0x03020000; 50 PyEval_InitThreads();; 51#endif; 52#if PY_VERSION_HEX < 0x03080000; 53 Py_Initialize();; 54#else; 55 PyConfig config;; 56 PyConfig_InitPythonConfig(&config);; 57 PyConfig_SetString(&config, &config.program_name, L""cppyy"");; 58 Py_InitializeFromConfig(&config);; 59#endif; 60#if PY_VERSION_HEX >= 0x03020000; 61#if PY_VERSION_HEX < 0x03090000; 62 PyEval_InitThreads();; 63#endif; 64#endif; 65 ; 66 // try again to see if the interpreter is initialized; 67 if (!Py_IsInitialized()) {; 68 // give up ...; 69 std::cerr << ""Error: python has not been initialized; returning."" << std::endl;; 70 return false;; 71 }; 72 ; 73 // set the command line arguments on python's sys.argv; 74#if PY_VERSION_HEX < 0x03000000; 75 char* argv[] = {const_cast<char*>(""cppyy"")};; 76#elif PY_VERSION_HEX < 0x03080000; 77 wchar_t* argv[] = {const_cast<wchar_t*>(L""cppyy"")};; 78#endif; 79#if PY_VERSION_HEX < 0x03080000; 80 PySys_SetArgv(sizeof(argv)/sizeof(argv[0]), argv);; 81#endif; 82 ; 83 // force loading of the cppyy module; 84 PyRun_SimpleString(const_cast<char*>(""import cppyy""));; 85 }; 86 ; 87 if (!gMainDict) {; 88 // retrieve the main dictionary; 89 gMainDict = PyModule_GetDict(; 90 PyImport_AddModule(const_cast<char*>(""__main__"")));; 91 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; 92 // Like this, we avoid unexpectedly affecting how long __main__ is kept; 93 // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; 94 // which should not be called after __main__ is garbage collected anyway.; 95 }; 96 ; 97// declare success ...; 98 isInitialized = true;; 99 return true;; 100}; 101 ; 102} // unnamed namespace; 103 ; 104 ; 105//- C++ access to cppyy objects ---------------------------------------------; 106void* CPyCppyy::Instance_AsVoidPtr(PyObject* pyobject); 107{; 108// Extract the object pointer held by the CPPInstance pyobject.; 109 if (!Initialize()); 110 return nullptr;; 111 ; 112// check validity of cast; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:2627,load,loading,2627,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['load'],['loading']
Performance,"#include ""RooProdPdf.h""; #include ""RooMCStudy.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf804_mcstudy_constr(); {; // C r e a t e m o d e l w i t h p a r a m e t e r c o n s t r a i n t; // ---------------------------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -10, 10);; ; // Signal component; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 2, 0.1, 10);; RooGaussian g(""g"", ""g"", x, m, s);; ; // Background component; RooPolynomial p(""p"", ""p"", x);; ; // Composite model; RooRealVar f(""f"", ""f"", 0.4, 0., 1.);; RooAddPdf sum(""sum"", ""sum"", RooArgSet(g, p), f);; ; // Construct constraint on parameter f; RooGaussian fconstraint(""fconstraint"", ""fconstraint"", f, 0.7, 0.1);; ; // Multiply constraint with pdf; RooProdPdf sumc(""sumc"", ""sum with constraint"", RooArgSet(sum, fconstraint));; ; // S e t u p t o y s t u d y w i t h m o d e l; // ---------------------------------------------------; ; // Perform toy study with internal constraint on f; RooMCStudy mcs(sumc, x, Constrain(f), Silence(), Binned(), FitOptions(PrintLevel(-1)));; ; // Run 500 toys of 2000 events.; // Before each toy is generated, a value for the f is sampled from the constraint pdf and; // that value is used for the generation of that toy.; mcs.generateAndFit(500, 2000);; ; // Make plot of distribution of generated value of f parameter; TH1 *h_f_gen = mcs.fitParDataSet().createHistogram(""f_gen"", AutoBinning(40));; ; // Make plot of distribution of fitted value of f parameter; RooPlot *frame1 = mcs.plotParam(f, Bins(40));; frame1->SetTitle(""Distribution of fitted f values"");; ; // Make plot of pull distribution on f; RooPlot *frame2 = mcs.plotPull(f, Bins(40), FitGauss());; frame1->SetTitle(""Distribution of f pull values"");; ; TCanvas *c = new TCanvas(""rf804_mcstudy_constr"", ""rf804_mcstudy_constr"", 1200, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.15);; h_f_gen->GetYaxis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html:1465,Perform,Perform,1465,doc/master/rf804__mcstudy__constr_8C.html,https://root.cern,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html,1,['Perform'],['Perform']
Performance,"#include ""llvm/Support/raw_ostream.h""; 123#include ""llvm/Support/Path.h""; 124#include ""llvm/Support/Process.h""; 125#include ""llvm/Object/ELFObjectFile.h""; 126#include ""llvm/Object/ObjectFile.h""; 127#include ""llvm/Object/SymbolicFile.h""; 128#include ""llvm/Support/FileSystem.h""; 129 ; 130#include <algorithm>; 131#include <iostream>; 132#include <cassert>; 133#include <map>; 134#include <set>; 135#include <stdexcept>; 136#include <stdint.h>; 137#include <fstream>; 138#include <sstream>; 139#include <string>; 140#include <tuple>; 141#include <typeinfo>; 142#include <unordered_map>; 143#include <unordered_set>; 144#include <utility>; 145#include <vector>; 146#include <functional>; 147#include <optional>; 148 ; 149#ifndef R__WIN32; 150#include <cxxabi.h>; 151#define R__DLLEXPORT __attribute__ ((visibility (""default""))); 152#include <sys/stat.h>; 153#endif; 154#include <limits.h>; 155#include <stdio.h>; 156 ; 157#ifdef __APPLE__; 158#include <dlfcn.h>; 159#include <mach-o/dyld.h>; 160#include <mach-o/loader.h>; 161#endif // __APPLE__; 162 ; 163#ifdef R__UNIX; 164#include <dlfcn.h>; 165#endif; 166 ; 167#if defined(R__LINUX) || defined(R__FBSD); 168# ifndef _GNU_SOURCE; 169# define _GNU_SOURCE; 170# endif; 171# include <link.h> // dl_iterate_phdr(); 172#endif; 173 ; 174#if defined(__CYGWIN__); 175#include <sys/cygwin.h>; 176#define HMODULE void *; 177extern ""C"" {; 178 __declspec(dllimport) void * __stdcall GetCurrentProcess();; 179 __declspec(dllimport) bool __stdcall EnumProcessModules(void *, void **, unsigned long, unsigned long *);; 180 __declspec(dllimport) unsigned long __stdcall GetModuleFileNameExW(void *, void *, wchar_t *, unsigned long);; 181}; 182#endif; 183 ; 184// Fragment copied from LLVM's raw_ostream.cpp; 185#if defined(_MSC_VER); 186#ifndef STDIN_FILENO; 187# define STDIN_FILENO 0; 188#endif; 189#ifndef STDOUT_FILENO; 190# define STDOUT_FILENO 1; 191#endif; 192#ifndef STDERR_FILENO; 193# define STDERR_FILENO 2; 194#endif; 195#ifndef R__WIN32; 196//#if define",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:5198,load,loader,5198,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loader']
Performance,"#include <iostream>; ; auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; std::cout << ""myNTuple has "" << ntuple->GetNEntries() << "" entries\n"";; RNTupleReader.hxx; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::Experimental::RNTupleReader::Openstatic std::unique_ptr< RNTupleReader > Open(std::string_view ntupleName, std::string_view storage, const RNTupleReadOptions &options=RNTupleReadOptions())Open an RNTuple for reading.Definition RNTupleReader.cxx:94. Definition at line 71 of file RNTupleReader.hxx. Classes; class  RIterator;  . Public Member Functions;  ~RNTupleReader ();  ; RIterator begin ();  ; std::unique_ptr< RNTupleReader > Clone ();  ; void EnableMetrics ();  Enable performance measurements (decompression time, bytes read from storage, etc.) ;  ; RIterator end ();  ; RNTupleCollectionView GetCollectionView (DescriptorId_t fieldId);  ; RNTupleCollectionView GetCollectionView (std::string_view fieldName);  Raises an exception if: ;  ; const RNTupleDescriptor & GetDescriptor ();  Returns a cached copy of the page source descriptor. ;  ; template<typename T > ; RNTupleDirectAccessView< T > GetDirectAccessView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleDirectAccessView< T > GetDirectAccessView (std::string_view fieldName);  ; RNTupleGlobalRange GetEntryRange ();  Returns an iterator over the entry indices of the RNTuple. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel ();  ; NTupleSize_t GetNEntries () const;  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, std::shared_ptr< T > objPtr);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, T *rawPtr);  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName);  Provides access to an individual field that can conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:2018,cache,cached,2018,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['cache'],['cached']
Performance,"%d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the version number\n\; 1094 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1095 file->GetName(), GetName(), fClassVersion,file->GetName(),GetName(), GetName(), fClassVersion);; 1096 }; 1097 } else {; 1098 if (done) {; 1099 Warning(""BuildCheck"", ""\n\; 1100 The StreamerInfo for version %d of class %s\n\; 1101 has a different checksum than the previously loaded StreamerInfo.\n\; 1102 Reading objects of type %s\n\; 1103 (and potentially other files) might not work correctly.\n\; 1104 Most likely the version number of the class was not properly\n\; 1105 updated [See ClassDef(%s,%d)]."",; 1106 fClassVersion, GetName(), GetName(), GetName(), fClassVersion);; 1107 } else {; 1108 Warning(""BuildCheck"", ""\n\; 1109 The StreamerInfo does not match existing one (%s:%d)\n\; 1110 The existing one has not been used yet and will be discarded.\n\; 1111 Reading should work properly, however writing object of\n\; 1112 type %s will not work properly. Most likely the version number\n\; 1113 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1114 GetName(), fClassVersion, GetName(), GetName(), fClassVersion);; 1115 }; 1116 }; 1117 }; 1118 CompareContent(0,info,kTRUE,kTRUE,file);; 1119 fClass->SetBit(TClass::kWarned)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:41660,load,loaded,41660,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"%sMoment of order %d of %s w.r.t %s "",(central?""Central "":""""),order,GetName(),obs.GetName()) ;; 4038 ; 4039 if (order==1) return new RooFirstMoment(name.c_str(),title.c_str(),*this,obs,normObs,intNormObs) ;; 4040 if (order==2) return new RooSecondMoment(name.c_str(),title.c_str(),*this,obs,normObs,central,takeRoot,intNormObs) ;; 4041 return new RooMoment(name.c_str(),title.c_str(),*this,obs,normObs,order,central,takeRoot,intNormObs) ;; 4042}; 4043 ; 4044 ; 4045 ; 4046////////////////////////////////////////////////////////////////////////////////; 4047///; 4048/// Return value of x (in range xmin,xmax) at which function equals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:175551,Perform,Perform,175551,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['Perform'],['Perform']
Performance,& >;  CExpr;  CFabsUnary abs Operation Class ;  CFactoryFactory class holding static functions to create the interfaces like ROOT::Math::Minimizer via the Plugin Manager ;  CFastInverterFast Matrix Inverter class Class to specialize calls to Dinv ;  CFastInverter< 3 >3x3 direct matrix inversion using Cramer Rule use only for FastInverter ;  CFastInverter< 4 >4x4 matrix inversion using Cramers rule ;  CFastInverter< 5 >5x5 Matrix inversion using Cramers rule ;  CFunctorDocumentation for class Functor class ;  CFunctor1DFunctor1D class for one-dimensional functions ;  CFunctorGradHandlerFunctor Handler class for gradient functions where both callable objects are provided for the function evaluation (type Func) and for the gradient (type GradFunc) ;  CFunctorHandlerFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFunctorImplFunctorImpl is a base class for the functor handler implementation class ;  CGaussIntegratorUser class for performing function integration ;  CGaussLegendreIntegratorUser class for performing function integration ;  CGenAlgoOptionsClass implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs ;  CGeneralLinearFunctionDerivationAuxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar ;  CGeneralLinearFunctionDerivation< double >;  CGeneticMinimizerGeneticMinimizer ;  CGeneticMinimizerParameters;  CGenVector_exception;  CGlobalCoordinateSystemTagTag for identifying vectors based on a global coordinate system ;  CGoFTest;  CGradFunctorGradFunctor class for Multidimensional gradient functions ;  CGradFunctor1DGradFunctor1D class for one-dimensional gradient functions ;  CGSL1DMinimizerWrapperWrapper class for gsl_min_fminimizer structure ;  CGSLChebSeriesWrapper class for C struct gsl_cheb_series ;  CGSLDerivatorClass for computing numerical derivative of a function based on the GSL numerical algorithm This class is impl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:36603,perform,performing,36603,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['perform'],['performing']
Performance,& >;  CExpr;  CFabsUnary abs Operation Class ;  CFactoryFactory class holding static functions to create the interfaces like ROOT::Math::Minimizer via the Plugin Manager ;  CFastInverterFast Matrix Inverter class Class to specialize calls to Dinv ;  CFastInverter< 3 >3x3 direct matrix inversion using Cramer Rule use only for FastInverter ;  CFastInverter< 4 >4x4 matrix inversion using Cramers rule ;  CFastInverter< 5 >5x5 Matrix inversion using Cramers rule ;  CFunctorDocumentation for class Functor class ;  CFunctor1DFunctor1D class for one-dimensional functions ;  CFunctorGradHandlerFunctor Handler class for gradient functions where both callable objects are provided for the function evaluation (type Func) and for the gradient (type GradFunc) ;  CFunctorHandlerFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFunctorImplFunctorImpl is a base class for the functor handler implementation class ;  CGaussIntegratorUser class for performing function integration ;  CGaussLegendreIntegratorUser class for performing function integration ;  CGenAlgoOptionsClass implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs ;  CGeneticMinimizerGeneticMinimizer ;  CGeneticMinimizerParameters;  CGenVector_exception;  CGlobalCoordinateSystemTagTag for identifying vectors based on a global coordinate system ;  CGoFTest;  CGradFunctorGradFunctor class for Multidimensional gradient functions ;  CGradFunctor1DGradFunctor1D class for one-dimensional gradient functions ;  CGSL1DMinimizerWrapperWrapper class for gsl_min_fminimizer structure ;  CGSLChebSeriesWrapper class for C struct gsl_cheb_series ;  CGSLDerivatorClass for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ) ;  CGSLFunctionAdapterClass for adapting any C++ functor class to C functi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:29802,perform,performing,29802,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['perform'],['performing']
Performance,"& Destructor Documentation. ◆ TVirtualStreamerInfo() [1/3]. TVirtualStreamerInfo::TVirtualStreamerInfo ; (; const TVirtualStreamerInfo & ; info). protected . copy constructor ; Definition at line 52 of file TVirtualStreamerInfo.cxx. ◆ TVirtualStreamerInfo() [2/3]. TVirtualStreamerInfo::TVirtualStreamerInfo ; (; ). Default constructor. ; Definition at line 37 of file TVirtualStreamerInfo.cxx. ◆ TVirtualStreamerInfo() [3/3]. TVirtualStreamerInfo::TVirtualStreamerInfo ; (; TClass * ; cl). Default constructor. ; Definition at line 44 of file TVirtualStreamerInfo.cxx. ◆ ~TVirtualStreamerInfo(). TVirtualStreamerInfo::~TVirtualStreamerInfo ; (; ). virtual . Destructor. ; Definition at line 71 of file TVirtualStreamerInfo.cxx. Member Function Documentation. ◆ Build(). virtual void TVirtualStreamerInfo::Build ; (; Bool_t ; isTransient = kFALSE). pure virtual . Implemented in TStreamerInfo. ◆ BuildCheck(). virtual void TVirtualStreamerInfo::BuildCheck ; (; TFile * ; file = nullptr, . Bool_t ; load = kTRUE . ). pure virtual . Implemented in TStreamerInfo. ◆ BuildEmulated(). virtual void TVirtualStreamerInfo::BuildEmulated ; (; TFile * ; file). pure virtual . Implemented in TStreamerInfo. ◆ BuildFor(). virtual Bool_t TVirtualStreamerInfo::BuildFor ; (; const TClass * ; cl). pure virtual . Implemented in TStreamerInfo. ◆ BuildOld(). virtual void TVirtualStreamerInfo::BuildOld ; (; ). pure virtual . Implemented in TStreamerInfo. ◆ CallShowMembers(). virtual void TVirtualStreamerInfo::CallShowMembers ; (; const void * ; obj, . TMemberInspector & ; insp, . Bool_t ; isTransient . ); const. pure virtual . Implemented in TStreamerInfo. ◆ CanDelete(). Bool_t TVirtualStreamerInfo::CanDelete ; (; ). static . static function returning true if ReadBuffer can delete object ; Definition at line 78 of file TVirtualStreamerInfo.cxx. ◆ CanOptimize(). Bool_t TVirtualStreamerInfo::CanOptimize ; (; ). static . static function returning true if optimization can be on ; Definition at line 86 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:21384,load,load,21384,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['load'],['load']
Performance,"& GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len)) < 0) {; 2527 SetBit(kWriteError);; 2528 Error(""WriteBuffer"", ""error writing to cache"");; 2529 return 2;; 2530 }; 2531 if (st > 0) {; 2532 // fOffset might have been changed via TFileCacheWrite::WriteBuffer(), reset it; 2533 Seek(off + len);; 2534 return 1;; 2535 }; 2536 return 0;; 2537}; 2538 ; 2539////////////////////////////////////////////////////////////////////////////////; 2540/// Write FREE linked list on the file.; 2541/// The linked list of FREE segments (fFree) is written as a single data; 2542/// record.; 2543 ; 2544void TFile::WriteFree(); 2545{; 2546 //*-* Delete old record if it exists; 2547 if (fSeekFree != 0) {; 2548 MakeFree(fSeekFree, fSeekFree + fNbytesFree -1);; 2549 }; 2550 ; 255",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:89306,cache,cache,89306,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,['cache'],['cache']
Performance,"& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:14589,cache,cache,14589,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,1,['cache'],['cache']
Performance,"& func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:16529,perform,perform,16529,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['perform'],['perform']
Performance,"& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual~RooRealAnalytic(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t operator()(const Double_t* xvector) const; Evaluate our analytic integral at the specified values of the dependents. inline RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); { }. virtual ~RooRealAnalytic(); { }. » Last changed: Mon Dec 7 13:48:49 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealAnalytic.html:1576,load,loadValues,1576,root/html526/RooRealAnalytic.html,https://root.cern,https://root.cern/root/html526/RooRealAnalytic.html,1,['load'],['loadValues']
Performance,"& list, const RooArgList& plist); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnBinding.html:24119,cache,cache,24119,root/html602/RooTFnBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnBinding.html,2,['cache'],['cache']
Performance,"& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:71049,Perform,Perform,71049,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,6,['Perform'],['Perform']
Performance,"& nset, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:24364,cache,cache,24364,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,2,['cache'],['cache']
Performance,"& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddModel.html:23096,optimiz,optimizeCacheMode,23096,root/html530/RooAddModel.html,https://root.cern,https://root.cern/root/html530/RooAddModel.html,16,['optimiz'],['optimizeCacheMode']
Performance,"& other). Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). CacheMode canNodeBeCached() const; { return Always ; }. void setCacheAndTrackHints(RooArgSet& ); {}. Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:43864,optimiz,optimizeDirtyHook,43864,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"& other); Copy ctor. TGeoRotation(const TGeoMatrix& other); Copy ctor. TGeoRotation(const char* name); Named rotation constructor. TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); Default rotation constructor with Euler angles. Phi is the rotation angle about; Z axis and is done first, theta is the rotation about new Y and is done; second, psi is the rotation angle about new Z and is done third. All angles are in; degrees. TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Rotation constructor a la GEANT3. Angles theta(i), phi(i) are the polar and azimuthal; angles of the (i) axis of the rotated system with respect to the initial non-rotated; system.; Example : the identity matrix (no rotation) is composed by; theta1=90, phi1=0, theta2=90, phi2=90, theta3=0, phi3=0; SetBit(kGeoRotation);. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t IsValid() const; Perform orthogonality test for rotation. void Clear(Option_t* option = """"); reset data members. void FastRotZ(Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. Double_t GetPhiRotation(Bool_t fixX = kFALSE) const; --- Returns rotation angle about Z axis in degrees. If the rotation is a pure; rotation about Z, fixX parameter does not matter, otherwise its meaning is:; - fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; - fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees. void LocalToMaster(const Double_t* local, Double_t* master) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse. void MasterToLocal(const Double_t* master, Double_t* local) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RotateX(Double_t angle); Rotate about X axis o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoRotation.html:16274,Perform,Perform,16274,root/html528/TGeoRotation.html,https://root.cern,https://root.cern/root/html528/TGeoRotation.html,2,['Perform'],['Perform']
Performance,"& other); Copy ctor. TGeoRotation(const TGeoMatrix& other); Copy ctor. TGeoRotation(const char* name); Named rotation constructor. TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); Default rotation constructor with Euler angles. Phi is the rotation angle about; Z axis and is done first, theta is the rotation about new Y and is done; second, psi is the rotation angle about new Z and is done third. All angles are in; degrees. TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Rotation constructor a la GEANT3. Angles theta(i), phi(i) are the polar and azimuthal; angles of the (i) axis of the rotated system with respect to the initial non-rotated; system.; Example : the identity matrix (no rotation) is composed by; theta1=90, phi1=0, theta2=90, phi2=90, theta3=0, phi3=0; SetBit(kGeoRotation);. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t IsValid() const; Perform orthogonality test for rotation. void Clear(Option_t* option = """"); reset data members. void FastRotZ(const Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. Double_t GetPhiRotation(Bool_t fixX = kFALSE) const; --- Returns rotation angle about Z axis in degrees. If the rotation is a pure; rotation about Z, fixX parameter does not matter, otherwise its meaning is:; - fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; - fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees. void LocalToMaster(const Double_t* local, Double_t* master) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse. void MasterToLocal(const Double_t* master, Double_t* local) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RotateX(Double_t angle); Rotate about X ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoRotation.html:16380,Perform,Perform,16380,root/html532/TGeoRotation.html,https://root.cern,https://root.cern/root/html532/TGeoRotation.html,4,['Perform'],['Perform']
Performance,"& other, const RooArgSet& vars, const char* newname = 0); RooVectorDataStore(const RooVectorDataStore& other, const RooArgSet& vars, const char* newname = 0); RooVectorDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); RooVectorDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooVectorDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); const RooVectorDataStore*cache() const; virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidRooAbsDataStore::checkInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:1623,cache,cache,1623,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,1,['cache'],['cache']
Performance,"& other, const RooArgSet& vars, const char* newname = 0); RooVectorDataStore(const RooVectorDataStore& other, const RooArgSet& vars, const char* newname = 0); RooVectorDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); RooVectorDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooVectorDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); const RooVectorDataStore*cache() const; virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidRooAbsDataStore::checkInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:1623,cache,cache,1623,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,1,['cache'],['cache']
Performance,"& pdf2, Double_t cutOff = 0); Constructor with 2 PDFs (most frequent use case). The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOff parameter. If the running product is smaller than the; cutOff value, the product series is terminated and remaining PDFs; are not evaluated. There is no magic value of the cutOff, the user should experiment; to find the appropriate balance between speed and precision.; If a cutoff is specified, the PDFs most likely to be small should; be put first in the product. The default cutOff value is zero. RooProdPdf(const char* name, const char* title, const RooArgList& inPdfList, Double_t cutOff); Constructor from a list of PDFs. The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOff parameter. If the running product is smaller than the; cutOff value, the product series is terminated and remaining PDFs; are not evaluated. There is no magic value of the cutOff, the user should experiment; to find the appropriate balance between speed and precision.; If a cutoff is specified, the PDFs most likely to be small should; be put first in the product. The default cutOff value is zero. RooProdPdf(const char* name, const char* title, const RooArgSet& fullPdfSet, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Constructor from named argument list. fullPdf -- Set of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:43808,optimiz,optimization,43808,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['optimiz'],['optimization']
Performance,"& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooErrorVar.html:21858,optimiz,optimizeCacheMode,21858,root/html530/RooErrorVar.html,https://root.cern,https://root.cern/root/html530/RooErrorVar.html,6,['optimiz'],['optimizeCacheMode']
Performance,"&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:24024,optimiz,optimizeCacheMode,24024,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"&); TEveJetConeGL&operator=(const TEveJetConeGL&). Data Members; public:. enum TGLLogicalShape::ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TEveJetConeGL.h 35221 2010-09-10 11:46:37Z matevz $ » Last generated: 2010-10-25 12:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveJetConeGL.html:4144,cache,cache,4144,root/html528/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html528/TEveJetConeGL.html,1,['cache'],['cache']
Performance,"&); TEveJetConeGL&operator=(const TEveJetConeGL&). Data Members; public:. enum TGLLogicalShape::ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TEveJetConeGL.h 35221 2010-09-10 11:46:37Z matevz $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveJetConeGL.html:4144,cache,cache,4144,root/html530/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html530/TEveJetConeGL.html,1,['cache'],['cache']
Performance,"&); TEveJetConeGL&operator=(const TEveJetConeGL&). Data Members; public:. enum TGLLogicalShape::ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TEveJetConeGL.h 35221 2010-09-10 11:46:37Z matevz $ » Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveJetConeGL.html:4144,cache,cache,4144,root/html532/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html532/TEveJetConeGL.html,1,['cache'],['cache']
Performance,&); TFileCacheRead&operator=(const TFileCacheRead&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAsyncReading; Bool_tfBIsSorted; Bool_tfBIsTransferred; Int_t*fBLen; Int_tfBNb; Int_tfBNseek; Int_tfBNtot; Long64_t*fBPos; Long64_t*fBSeek; Int_t*fBSeekIndex; Int_t*fBSeekLen; Int_t*fBSeekPos; Int_tfBSeekSize; Long64_t*fBSeekSort; Int_t*fBSeekSortLen; char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferLenCurrent buffer length (<= fBufferSize); Int_tfBufferSizeAllocated size of fBuffer (at a given time); Int_tfBufferSizeMinOriginal size of fBuffer; Long64_tfBytesReadNumber of bytes read for this cache; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tfEnablePrefetchingreading by prefetching asynchronously ; TFile*fFilePointer to file; Bool_tfIsSortedTrue if fSeek array is sorted; Bool_tfIsTransferredTrue when fBuffer contains something valid; Int_t*fLen[fNb] Length of long buffers; Int_tfNbNumber of long buffers; Long64_tfNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tfNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tfNseekNumber of blocks to be prefetched; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; TFilePrefetch*fPrefetch!Object that does the asynchronous reading in another thread; Long64_tfPrefetchedBlocksNumber of blocks prefetched.; Int_tfReadCallsNumber of read calls for this cache; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheRead.html:7798,cache,cache,7798,root/html534/TFileCacheRead.html,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html,3,['cache'],"['cache', 'cached']"
Performance,"&); voidSetNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__FeldmanCousins.html:3712,perform,perform,3712,root/html534/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html534/RooStats__FeldmanCousins.html,2,['perform'],['perform']
Performance,"&C, RooAbsReal &delC, RooAbsReal &S, RooAbsReal &delS, const RooResolutionModel &model, DecayType type=DoubleSided);  ;  RooNonCPEigenDecay (const RooNonCPEigenDecay &other, const char *name=nullptr);  Copy constructor. ;  ;  RooNonCPEigenDecay (void);  ; TObject * clone (const char *newname) const override;  ; double coefAnalyticalIntegral (Int_t coef, Int_t code, const char *rangeName=nullptr) const override;  correct for the right/wrong charge... ;  ; double coefficient (Int_t basisIndex) const override;  ; void generateEvent (Int_t code) override;  Interface for generation of an event using the algorithm corresponding to the specified code. ;  ; Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Default implementation of function advertising integration capabilities. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; void initGenerator (Int_t code) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsAnaConvPdf;  RooAbsAnaConvPdf ();  Default constructor, required for persistence. ;  ;  RooAbsAnaConvPdf (const char *name, const char *title, const RooResolutionModel &model, RooRealVar &convVar);  Constructor. ;  ;  RooAbsAnaConvPdf (const RooAbsAnaConvPdf &other, const char *name=nullptr);  ;  ~RooAbsAnaConvPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral defined by gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCPEigenDecay.html:4406,Load,Load,4406,doc/master/classRooNonCPEigenDecay.html,https://root.cern,https://root.cern/doc/master/classRooNonCPEigenDecay.html,1,['Load'],['Load']
Performance,"&arg5={}) const;  As RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&) const. ;  ; virtual void generateEvent (Int_t code);  Interface for generation of an event using the algorithm corresponding to the specified code. ;  ; virtual RooFit::OwningPtr< RooDataSet > generateSimGlobal (const RooArgSet &whatVars, Int_t nEvents);  Special generator interface for generation of 'global observables' – for RooStats tools. ;  ; RooArgSet * getAllConstraints (const RooArgSet &observables, RooArgSet &constrainedParams, bool stripDisconnected=true, bool removeConstraintsFromPdf=false) const;  This helper function finds and collects all constraints terms of all component p.d.f.s and returns a RooArgSet with all those terms. ;  ; virtual RooArgSet * getConstraints (const RooArgSet &, RooArgSet &, bool, bool=false) const;  ; virtual Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; const RooNumGenConfig * getGeneratorConfig () const;  Return the numeric MC generator configuration used for this object. ;  ; void getLogProbabilities (std::span< const double > pdfValues, double *output) const;  ; virtual double getLogVal (const RooArgSet *set=nullptr) const;  Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:12865,Load,Load,12865,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['Load'],['Load']
Performance,"&b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void SetAddressImpl (void *addr, bool);  ; void SetSkipZip (bool skip=true);  ; Int_t WriteBasket (TBasket *basket, Int_t where);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; char * fAddress;  ! Address of 1st leaf (variable or object) ;  ; Int_t * fBasketBytes;  [fMaxBaskets] Length of baskets on file ;  ; Long64_t * fBasketEntry;  [fMaxBaskets] Table of first entry in each basket ;  ; TObjArray fBaskets;  -> List of baskets of this branch ;  ; Long64_t * fBasketSeek;  [fMaxBaskets] Addresses of baskets on file ;  ; Int_t fBasketSize;  Initial Size of Basket Buffer. ;  ; TObjArray fBranches;  -> List of Branches of this branch ;  ; TList * fBrowsables;  ! List of TVirtualBranchBrowsables used for Browse() ;  ; BulkObj fBulk;  ! Helper for performing bulk IO ;  ; CacheInfo_t fCacheInfo;  ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ;  ; Int_t fCompress;  Compression level and algorithm. ;  ; TBasket * fCurrentBasket;  ! Pointer to the current basket. ;  ; TDirectory * fDirectory;  ! Pointer to directory where this branch buffers are stored ;  ; Long64_t fEntries;  Number of entries. ;  ; TBuffer * fEntryBuffer;  ! Buffer used to directly pass the content without streaming ;  ; Long64_t fEntryNumber;  Current entry number (last one filled in this branch) ;  ; Int_t fEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TBasket * fExtraBasket;  ! Allocated basket not currently holding any data. ;  ; TString fFileName;  Name of file where buffers are stored ("""" if in same file as Tree header) ;  ; FillLeaves_t fFillLeaves;  ! Pointer to the FillLeaves implementation to use. ;  ; Long64_t fFirstBasketEntry;  ! First entry in the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:23056,perform,performing,23056,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,3,"['cache', 'perform']","['cache', 'performing']"
Performance,"&dataFile);  Prepare the file with the input data objects to be sent the master; the objects are taken from the dedicated list and / or the specified file. ;  ; Int_t RemoveWorkers (TList *wrks);  Used for shuting down the workres after a query is finished. ;  ; virtual void SaveWorkerInfo ();  Save information about the worker set in the file .workers in the working dir. ;  ; Int_t SendFile (const char *file, Int_t opt=(kBinary|kForward|kCp|kCpBin), const char *rfile=0, TSlave *sl=0);  Send a file to master or slave servers. ;  ; virtual void SendInputDataFile ();  Send the input data objects to the master; the objects are taken from the dedicated list and / or the specified file. ;  ; void SetDSet (TDSet *dset);  ; void SetFeedback (TString &opt, TString &optfb, Int_t action);  Extract from opt in optfb information about wanted feedback settings. ;  ; void SetPlayer (TVirtualProofPlayer *player);  Set a new PROOF player. ;  ; void SetupWorkersEnv (TList *wrks, Bool_t increasingpool=kFALSE);  Set up packages, loaded macros, include and lib paths ... ;  ; virtual Bool_t StartSlaves (Bool_t attach=kFALSE);  Start up PROOF slaves. ;  ; void UpdateDialog ();  Final update of the progress dialog. ;  ; virtual void ValidateDSet (TDSet *dset);  Validate a TDSet. ;  ; Int_t VerifyDataSetParallel (const char *uri, const char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static Int_t AssertDataSet (TDSet *dset, TList *input, TDataSetManager *mgr, TString &emsg);  Make sure that dataset is in the form to be processed. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:39658,load,loaded,39658,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['loaded']
Performance,"&dataFile);  Prepare the file with the input data objects to be sent the master; the objects are taken from the dedicated list and / or the specified file. ;  ; Int_t RemoveWorkers (TList *wrks);  Used for shuting down the workres after a query is finished. ;  ; virtual void SaveWorkerInfo ();  Save information about the worker set in the file .workers in the working dir. ;  ; Int_t SendFile (const char *file, Int_t opt=(kBinary|kForward|kCp|kCpBin), const char *rfile=0, TSlave *sl=0);  Send a file to master or slave servers. ;  ; virtual void SendInputDataFile ();  Send the input data objects to the master; the objects are taken from the dedicated list and / or the specified file. ;  ; void SetDSet (TDSet *dset);  ; void SetFeedback (TString &opt, TString &optfb, Int_t action);  Extract from opt in optfb information about wanted feedback settings. ;  ; void SetPlayer (TVirtualProofPlayer *player);  Set a new PROOF player. ;  ; void SetupWorkersEnv (TList *wrks, Bool_t increasingpool=kFALSE);  Set up packages, loaded macros, include and lib paths ... ;  ; void UpdateDialog ();  Final update of the progress dialog. ;  ; Int_t VerifyDataSetParallel (const char *uri, const char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Friends; class TProofPlayerSuperMaster;  . Additional Inherited Members;  Public Types inherited from TProof; enum  EProofClearData { kPurge = 0x1; , kUnregistered = 0x2; , kDataset = 0x4; , kForceClear = 0x8; };  ; enum  EQueryMode { kSync = 0; , kAsync = 1; };  ; enum  ERegisterOpt { kFailIfExists = 0; , kOverwriteIfExists = 1;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofSuperMaster.html:38004,load,loaded,38004,doc/master/classTProofSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofSuperMaster.html,1,['load'],['loaded']
Performance,"&dataFile);  Prepare the file with the input data objects to be sent the master; the objects are taken from the dedicated list and / or the specified file. ;  ; Int_t RemoveWorkers (TList *wrks);  Used for shuting down the workres after a query is finished. ;  ; virtual void SaveWorkerInfo ();  Save information about the worker set in the file .workers in the working dir. ;  ; Int_t SendFile (const char *file, Int_t opt=(kBinary|kForward|kCp|kCpBin), const char *rfile=0, TSlave *sl=0);  Send a file to master or slave servers. ;  ; virtual void SendInputDataFile ();  Send the input data objects to the master; the objects are taken from the dedicated list and / or the specified file. ;  ; void SetDSet (TDSet *dset);  ; void SetFeedback (TString &opt, TString &optfb, Int_t action);  Extract from opt in optfb information about wanted feedback settings. ;  ; void SetPlayer (TVirtualProofPlayer *player);  Set a new PROOF player. ;  ; void SetupWorkersEnv (TList *wrks, Bool_t increasingpool=kFALSE);  Set up packages, loaded macros, include and lib paths ... ;  ; void UpdateDialog ();  Final update of the progress dialog. ;  ; virtual void ValidateDSet (TDSet *dset);  Validate a TDSet. ;  ; Int_t VerifyDataSetParallel (const char *uri, const char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Private Attributes; TCondor * fCondor;  ; TTimer * fTimer;  . Friends; class TCondor;  . Additional Inherited Members;  Public Types inherited from TProof; enum  EProofClearData { kPurge = 0x1; , kUnregistered = 0x2; , kDataset = 0x4; , kForceClear = 0x8; };  ; enum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:38256,load,loaded,38256,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,1,['load'],['loaded']
Performance,"&paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf709_BarlowBeestonDefinition rf709_BarlowBeeston.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:12188,optimiz,optimization,12188,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,1,['optimiz'],['optimization']
Performance,"& ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCacheManager.cxx. ◆ optimizeCacheMode(). void RooObjCacheManager::optimizeCacheMode ; (; const RooArgSet & ; obs, . RooArgSet & ; optNodes, . RooLinkedList & ; processedNodes . ). overridevirtual . Intercept calls to perform automatic optimization of cache mode operation. ; Forward calls to existing cache elements and save configuration of cache mode optimization so that it can be applied on new cache elements upon insertion ; Reimplemented from RooAbsCache.; Definition at line 129 of file RooObjCacheManager.cxx. ◆ printCompactTreeHook(). void RooObjCacheManager::printCompactTreeHook ; (; std::ostream & ; os, . const char * ; indent . ). overridevirtual . Add details on cache contents when printing in tree mode. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 194 of file RooObjCacheManager.cxx. ◆ redirectServersHook(). bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9964,cache,cache,9964,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,2,['cache'],['cache']
Performance,"& ; other); const. pure virtual . Implemented in RooAbsCategory, RooAbsReal, and RooStringVar. ◆ operMode(). OperMode RooAbsArg::operMode ; (; ); const. inline . Query the operation mode of this node. ; Definition at line 456 of file RooAbsArg.h. ◆ operModeHook(). virtual void RooAbsArg::operModeHook ; (; ). inlineprotectedvirtual . Reimplemented in RooCachedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsArg.h. ◆ optimizeCacheMode() [1/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:78484,optimiz,optimizeCacheMode,78484,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['optimiz'],['optimizeCacheMode']
Performance,"& ; other, . const char * ; name = nullptr . ). inline . Definition at line 20 of file RooNumCdf.h. Member Function Documentation. ◆ Class(). static TClass * RooNumCdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumCdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumCdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 29 of file RooNumCdf.h. ◆ clone(). TObject * RooNumCdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 21 of file RooNumCdf.h. ◆ DeclFileName(). static const char * RooNumCdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 29 of file RooNumCdf.h. ◆ fillCacheObject(). void RooNumCdf::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Fill cache using running integral cache elements calculate() method with specification of cdf-specific boundary conditions. ; Implements RooAbsCachedReal.; Definition at line 53 of file RooNumCdf.cxx. ◆ IsA(). TClass * RooNumCdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedReal.; Definition at line 29 of file RooNumCdf.h. ◆ Streamer(). void RooNumCdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCachedReal. ◆ StreamerNVirtual(). void RooNumCdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 29 of file RooNumCdf.h. Libraries for RooNumCdf:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooNumCdf.h; roofit/roofitcore/src/RooNumCdf.cxx. RooNumCdf. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:65384,cache,cache,65384,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,2,['cache'],['cache']
Performance,"' into the read messages queue.; If 'msg' is defined it is also added as TString.; This is used, for example, with kPROOF_FATAL to force the main thread; to mark this socket as bad, avoiding race condition when a worker; dies while in processing state. Bool_t IsServProofd(); Return kTRUE if the remote server is a 'proofd'. Int_t GetInterrupt(Bool_t& forward); Get latest interrupt level and reset it; if the interrupt has to be; propagated to lower stages forward will be kTRUE after the call. Int_t Flush(); Flush the asynchronous queue.; Typically called when a kHardInterrupt is received.; Returns number of bytes in flushed buffers. Bool_t Create(Bool_t attach = kFALSE); This method sends a request for creation of (or attachment to) a remote; server application. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); Send a raw buffer of specified length.; Use opt = kDontBlock to ask xproofd to push the message into the proofsrv.; (by default is appended to a queue waiting for a request from proofsrv).; Returns the number of bytes sent or -1 in case of error. Bool_t Ping(const char* ord = 0); Ping functionality: contact the server to check its vitality.; If external, the server waits for a reply from the server; Returns kTRUE if OK or kFALSE in case of error. void RemoteTouch(); Remote touch functionality: contact the server to proof our vitality.; No reply from server is expected. void CtrlC(); Interrupt the remote protocol instance. Used to propagate Ctrl-C.; No reply from server is expected. Int_t PickUpReady(); Wait and pick-up next buffer from the asynchronous queue. TXSockBuf * PopUpSpare(Int_t sz); Pop-up a buffer of at least size bytes from the spare list; If none is found either one is reallocated or a new one; created. void PushBackSpare(); Release read buffer giving back to the spare list. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Int_t SendInterrupt(Int_t type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:16381,queue,queue,16381,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['queue'],['queue']
Performance,"' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:37365,Perform,Perform,37365,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['Perform'],['Perform']
Performance,"') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGHotString.html:8217,cache,cache,8217,root/html530/TGHotString.html,https://root.cern,https://root.cern/root/html530/TGHotString.html,2,['cache'],['cache']
Performance,"') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:14; This page has be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGHotString.html:8217,cache,cache,8217,root/html532/TGHotString.html,https://root.cern,https://root.cern/root/html532/TGHotString.html,2,['cache'],['cache']
Performance,"'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Member Functions; double evaluatePartition (std::size_t firstEvent, std::size_t lastEvent, std::size_t stepSize) const override;  Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize Throughout the calculation, we use Kahan's algorithm for summing to prevent loss of precision - this is a factor four more expensive than straight addition, but since evaluating the PDF is usually much more expensive than that, we tolerate the additional cost... ;  ;  Protected Member Functions inherited from RooAbsOptTestStatistic; virtual bool allowFunctionCache ();  ; void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true) override;  Driver function to propagate constant term optimizations in test statistic. ;  ; void initSlave (RooAbsReal &real, RooAbsData &indata, const RooArgSet &projDeps, const char *rangeName, const char *addCoefRangeName);  ; void optimizeCaching ();  This method changes the value caching logic for all nodes that depends on any of the observables as defined by the given dataset. ;  ; void optimizeConstantTerms (bool, bool=true);  Driver function to activate global constant term optimization. ;  ; void printCompactTreeHook (std::ostream &os, const char *indent="""") override;  Catch print hook function and forward to function clone. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Catch server redirect calls and forward to internal clone of function. ;  ; virtual RooArgSet requiredExtraObservables () const;  ; void runRecalculateCache (std::size_t firstEvent, std::size_t lastEvent, std::size_t stepSize) const override;  ; bool setDataSlave (RooAbsData &data, bool cloneData=true, bool ownNewDataAnyway=false) override;  Change dataset that is used to given one. ;  ;  Protected Member Functions inherited from RooAbsTestStatistic; do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:50670,optimiz,optimizeCaching,50670,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['optimiz'],['optimizeCaching']
Performance,"'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:40620,perform,performance,40620,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,7,['perform'],['performance']
Performance,"'t support = ATOMIC_FLAG_INIT;. ;  . #include <TROOT.h>. Inheritance diagram for TROOT:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ AListOfEnums_t. typedef std::atomic<TListOfEnums*> TROOT::AListOfEnums_t. protected . Definition at line 109 of file TROOT.h. ◆ FwdDeclArgsToKeepCollection_t. typedef std::vector<std::pair<std::string, int> > TROOT::FwdDeclArgsToKeepCollection_t. Definition at line 187 of file TROOT.h. Constructor & Destructor Documentation. ◆ TROOT() [1/3]. TROOT::TROOT ; (; const TROOT & ; ). privatedelete . ◆ TROOT() [2/3]. TROOT::TROOT ; (; ). protected . Only used by Dictionary. ; Default ctor. ; Definition at line 605 of file TROOT.cxx. ◆ TROOT() [3/3]. TROOT::TROOT ; (; const char * ; name, . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:40125,perform,performed,40125,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['perform'],['performed']
Performance,"( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; #; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # To also specify the number of testing events, use:; ; loader.PrepareTrainingAndTestTree(; mycuts, mycutb, nTrain_Signal=7000, nTrain_Background=7000, SplitMode=""Random"", NormMode=""NumEvents"", V=False; ); ; ## Booking Methods; ; # Here we book the TMVA methods. We book first a Likelihood based on KDE (Kernel Density Estimation), a Fischer discriminant, a BDT; # and a shallow neural network; # Likelihood (""naive Bayes estimator""); if useLikelihood:; factory.BookMethod(; loader,; TMVA.Types.kLikelihood,; ""Likelihood"",; H=True,; V=False,; TransformOutput=True,; PDFInterpol=""Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10"",; NSmooth=1,; NAvEvtPerBin=50,; ); ; # Use a kernel density estimator to approximate the PDFs; if useLikelihoodKDE:; factory.BookMethod(; loader,; TMVA.Types.kLikelihood,; ""LikelihoodKDE"",; H=False,; V=False,; TransformOutput=False,; PDFInterpol=""KDE"",; KDEtype=""Gauss"",; KDEiter=""Adaptive"",; KDEFineFactor=0.3,; KDEborder=None,; NAvEvtPerBin=50,; ); ; # Fisher discriminant (same as LD); if useFischer:; factory.BookMethod(; loader,; TMVA.Types.kFisher,; ""Fisher"",; H=True,; V=False,; Fisher=True,; VarTransform=None,; CreateMVAPdfs=True,; PDFInterpolMVAPdf=""Spline2"",; NbinsMVAPdf=50,; NsmoothMVAPdf=10,; ); ; # Boosted Decision Trees; if useBDT:; factory.BookMethod(; loader,; TMVA.Types.kBDT,; ""BDT"",; V=False,; NTrees=200,; MinNodeSize=""2.5%"",; MaxDepth=2,; BoostType=""AdaBoost"",; AdaBoostBeta=0.5,; UseBaggedBoost=True,; BaggedSamp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:61172,load,loader,61172,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"( Boost const & b ). Construct from a pure boost. { b.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostX const & bx ); { bx.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostY const & by ); { by.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostZ const & bz ); { bz.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( Rotation3D const & r ). Construct from a 3-D rotation (no space-time mixing). explicit LorentzRotation( AxisAngle const & a ). explicit LorentzRotation( EulerAngles const & e ). explicit LorentzRotation( Quaternion const & q ). explicit LorentzRotation( RotationX const & r ). explicit LorentzRotation( RotationY const & r ). explicit LorentzRotation( RotationZ const & r ). explicit LorentzRotation(const ForeignMatrix & m). Construct from a linear algebra matrix of size at least 4x4,; which must support operator()(i,j) to obtain elements (0,3) thru (3,3).; Precondition: The matrix is assumed to be orthosymplectic. NO checking; or re-adjusting is performed.; Note: (0,0) refers to the XX component; (3,3) refers to the TT component. { SetComponents(m); }. SetComponents(ROOT::Math::LorentzRotation::Scalar xx, ROOT::Math::LorentzRotation::Scalar xy, ROOT::Math::LorentzRotation::Scalar xz, ROOT::Math::LorentzRotation::Scalar xt, ROOT::Math::LorentzRotation::Scalar yx, ROOT::Math::LorentzRotation::Scalar yy, ROOT::Math::LorentzRotation::Scalar yz, ROOT::Math::LorentzRotation::Scalar yt, ROOT::Math::LorentzRotation::Scalar zx, ROOT::Math::LorentzRotation::Scalar zy, ROOT::Math::LorentzRotation::Scalar zz, ROOT::Math::LorentzRotation::Scalar zt, ROOT::Math::LorentzRotation::Scalar tx, ROOT::Math::LorentzRotation::Scalar ty, ROOT::Math::LorentzRotation::Scalar tz, ROOT::Math::LorentzRotation::Scalar tt). Assign from another LorentzRotation. SetComponents(ROOT::Math::LorentzRotation::Scalar xx, ROOT::Math::LorentzRotation::Scalar xy, ROOT::Math::LorentzRotation::Scalar xz, ROOT::Math::LorentzRotation::Scalar xt, ROOT::Math::Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzRotation.html:7953,perform,performed,7953,root/html528/ROOT__Math__LorentzRotation.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzRotation.html,4,['perform'],['performed']
Performance,"(!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3538 if (res == cling::DynamicLibraryManager::kLoadLibSuccess) {; 3539 UpdateListOfLoadedSharedLibraries();; 3540 }; 3541 switch (res) {; 3542 case cling::DynamicLibraryManager::kLoadLibSuccess: return 0;; 3543 case cling::DynamicLibraryManager::kLoadLibAlreadyLoaded: return 1;; 3544 default: break;; 3545 };; 3546 return -1;; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Load a macro file in cling's memory.; 3551 ; 3552void TCling::LoadMacro(const char* filen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:137187,load,loadLibrary,137187,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loadLibrary']
Performance,"(""MVA_DLGPU_signal"", ""MVA_DLGPU_signal"", nbin, 0., 1.1);; if (Use[""FDA_GA""]); histFDAGA_signal = new TH1F( ""MVA_FDA_GA_signal"", ""MVA_FDA_GA_signal"", nbin, 0., 1.1 );; if (Use[""PDEFoam""]); histPDEFoam_signal = new TH1F( ""MVA_PDEFoam_signal"", ""MVA_PDEFoam_signal"", nbin, 0., 1.1 );; ; ; TFile *input(0);; TString fname = ""./tmva_example_multiclass.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_multiclass_example.root"", ""CACHEREAD"");; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAMulticlassApp : Using input file: "" << input->GetName() << std::endl;; ; // prepare the tree; // - here the variable names have to corresponds to your tree; // - you can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; ; TTree* theTree = (TTree*)input->Get(""TreeS"");; std::cout << ""--- Select signal sample"" << std::endl;; theTree->SetBranchAddress( ""var1"", &var1 );; theTree->SetBranchAddress( ""var2"", &var2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; ; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; if (ievt%1000 == 0){; std::cout << ""--- ... Processing event: "" << ievt << std::endl;; }; theTree->GetEntry(ievt);; ; if (Use[""MLP""]); histMLP_signal->Fill((reader->EvaluateMulticlass( ""MLP method"" ))[0]);; if (Use[""BDTG""]); histBDTG_signal->Fill((reader->EvaluateMulticlass( ""BDTG method"" ))[0]);; if (Use[""DL_CPU""]); histDLCPU_signal->Fill((reader->EvaluateMulticlass(""DL_CPU method""))[0]);; if (Use[""DL_GPU""]); histDLGPU_signal->Fill((reader->EvaluateMulticlass(""DL_GPU method""))[0]);; if (Use[""FDA_GA""])",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlassApplication_8C.html:5941,CACHE,CACHEREAD,5941,doc/master/TMVAMulticlassApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlassApplication_8C.html,1,['CACHE'],['CACHEREAD']
Performance,"(""NewArray with placement"", ""This cannot happen!"");; 5392 }; 5393 ; 5394 return p;; 5395}; 5396 ; 5397////////////////////////////////////////////////////////////////////////////////; 5398/// Explicitly call destructor for object.; 5399 ; 5400void TClass::Destructor(void *obj, Bool_t dtorOnly); 5401{; 5402 // Do nothing if passed a null pointer.; 5403 if (obj == nullptr) return;; 5404 ; 5405 void* p = obj;; 5406 ; 5407 if (dtorOnly && fDestructor) {; 5408 // We have the destructor wrapper, use it.; 5409 fDestructor(p);; 5410 } else if ((!dtorOnly) && fDelete) {; 5411 // We have the delete wrapper, use it.; 5412 fDelete(p);; 5413 } else if (HasInterpreterInfo()) {; 5414 // We have the dictionary but do not have the; 5415 // destruct/delete wrapper, so the dictionary was; 5416 // not generated by rootcint (it could have been; 5417 // created by cint or by some external mechanism).; 5418 // Let's have the interpreter call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of a collection proxy,; 5430 // so this is an emulated STL class.; 5431 GetCollectionProxy()->Destructor(p, dtorOnly);; 5432 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info to approximate calling a; 5436 // destructor.; 5437 ; 5438 Bool_t inRepo = kTRUE;; 5439 Bool_t currentVersion = kFALSE;; 5440 ; 5441 // Was this object allocated through TClass?; 5442 Version_t objVer = -1;; 5443 {; 5444 R__LOCKGUARD2(fOVRMutex);; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:207093,load,loaded,207093,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"(""NewArray with placement"", ""This cannot happen!"");; 5459 }; 5460 ; 5461 return p;; 5462}; 5463 ; 5464////////////////////////////////////////////////////////////////////////////////; 5465/// Explicitly call destructor for object.; 5466 ; 5467void TClass::Destructor(void *obj, Bool_t dtorOnly); 5468{; 5469 // Do nothing if passed a null pointer.; 5470 if (obj == nullptr) return;; 5471 ; 5472 void* p = obj;; 5473 ; 5474 if (dtorOnly && fDestructor) {; 5475 // We have the destructor wrapper, use it.; 5476 fDestructor(p);; 5477 } else if ((!dtorOnly) && fDelete) {; 5478 // We have the delete wrapper, use it.; 5479 fDelete(p);; 5480 } else if (HasInterpreterInfo()) {; 5481 // We have the dictionary but do not have the; 5482 // destruct/delete wrapper, so the dictionary was; 5483 // not generated by rootcint (it could have been; 5484 // created by cint or by some external mechanism).; 5485 // Let's have the interpreter call the destructor,; 5486 // either the code will be in a loaded library,; 5487 // or it will be interpreted, otherwise we fail; 5488 // because there is no destructor code at all.; 5489 if (dtorOnly) {; 5490 gCling->ClassInfo_Destruct(fClassInfo,p);; 5491 } else {; 5492 gCling->ClassInfo_Delete(fClassInfo,p);; 5493 }; 5494 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5495 // There is no dictionary at all, so this is an emulated; 5496 // class; however we do have the services of a collection proxy,; 5497 // so this is an emulated STL class.; 5498 GetCollectionProxy()->Destructor(p, dtorOnly);; 5499 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5500 // There is no dictionary at all and we do not have; 5501 // the services of a collection proxy available, so; 5502 // use the streamer info to approximate calling a; 5503 // destructor.; 5504 ; 5505 Bool_t inRepo = kTRUE;; 5506 Bool_t currentVersion = kFALSE;; 5507 ; 5508 // Was this object allocated through TClass?; 5509 Version_t objVer = -1;; 5510 {; 5511 R__LOCKGUARD2(fOVRMutex);; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:209844,load,loaded,209844,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"(""f2"",fdm2,0.139,0.17,2);; f2->SetParameters(10000, 10);; h2->FitSlicesX(f2,0,-1,1,""qln"");; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; h2_1->GetXaxis()->SetTitle(""#tau[ps]"");; h2_1->SetMarkerStyle(21);; h2_1->Draw();; c2->Update();; TLine *line = new TLine(0,0,0,c2->GetUymax());; line->Draw();; ; // Have the number of entries on the first histogram (to cross check when running; // with entry lists); TPaveStats *psdmd = (TPaveStats *)hdmd->GetListOfFunctions()->FindObject(""stats"");; psdmd->SetOptStat(1110);; c1->Modified();; ; //save the entry list to a Root file if one was produced; if (fillList) {; if (!elist); elist = dynamic_cast<TEntryList*>(fOutput->FindObject(""elist""));; if (elist) {; Printf(""Entry list 'elist' created:"");; elist->Print();; TFile efile(""elist.root"",""recreate"");; elist->Write();; } else {; Error(""Terminate"", ""entry list requested but not found in output"");; }; }; // Notify the amount of processed events; if (!fInput) Info(""Terminate"", ""processed %lld events"", fProcessed);; }; ; void h1analysisTreeReader::SlaveTerminate(){; ; }; ; Bool_t h1analysisTreeReader::Notify() {; // called when loading a new file; // get branch pointers; ; Info(""Notify"",""processing file: %s"",myTreeReader.GetTree()->GetCurrentFile()->GetName());; ; if (elist && myTreeReader.GetTree()) {; if (fillList) {; elist->SetTree(myTreeReader.GetTree());; } else if (useList) {; myTreeReader.GetTree()->SetEntryList(elist);; }; }; return kTRUE;; }; f#define f(i)Definition RSha256.hxx:104; Bool_tbool Bool_tDefinition RtypesCore.h:63; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TFile.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TLine.h; TMath.h; TPaveStats.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Printfvoid ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:7478,load,loading,7478,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['load'],['loading']
Performance,"(""http:8080"");; root [2] TNamed* n1 = new TNamed(""obj"", ""title"");; root [3] serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 50331656,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. root.bin - binary data produced by object streaming with TBufferFile; root.json - ROOT JSON representation for object and objects members; root.xml - ROOT XML representation; root.png - PNG image (if object drawing implemented); root.gif - GIF image; root.jpeg - JPEG image; exe.json - method execution in the object; exe.bin - method execution, return result in binary form; cmd.json - command execution; item.json - item (object) properties, specified on the server; multi.json - perform several requests at once; multi.bin - perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.7.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: “title”.; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:10507,perform,perform,10507,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['perform'],['perform']
Performance,"(""matInit"",; ""MaterialsInitialisation"");; TTask *tracker = new MyTracker(""tracker"",""Tracker manager"");; TTask *tpc = new MyRecTPC(""tpc"",""TPC Reconstruction"");; TTask *its = new MyRecITS(""its"",""ITS Reconstruction"");; TTask *muon = new MyRecMUON(""muon"",""MUON Reconstruction"");; TTask *phos = new MyRecPHOS(""phos"",""PHOS Reconstruction"");; TTask *rich = new MyRecRICH(""rich"",""RICH Reconstruction"");; TTask *trd = new MyRecTRD(""trd"",""TRD Reconstruction"");; TTask *global = new MyRecGlobal(""global"",""Global Reconstruction"");. // Create a hierarchy by adding sub tasks; run->Add(geomInit);; run->Add(matInit);; run->Add(event);; event->Add(tracker);; event->Add(global);; tracker->Add(tpc);; tracker->Add(its);; tracker->Add(muon);; tracker->Add(phos);; tracker->Add(rich);; tracker->Add(trd);. // Add the top level task; gROOT->GetListOfTasks()->Add(run);. // Add the task to the browser; gROOT->GetListOfBrowsables()->Add(run);; new TBrowser;; }. Tasks in the ROOT browser. Note that the first line loads the class definitions in MyTasks.cxx with ACLiC. ACLiC builds a shared library and adds the classes to the Cling dictionary. See “Adding a Class with ACLiC”.; To execute a TTask, you call the ExecuteTask method. ExecuteTask will recursively call:. the TTask::Execmethod of the derived class;; the TTask::ExecuteTasks to execute for each task the list of its subtasks;. If the top level task is added to the list of ROOT browsable objects, the tree of tasks can be seen in the ROOT browser. To add it to the browser, get the list of browsable objects first and add it to the collection.; gROOT->GetListOfBrowsables()->Add(run);; The first parameter of the Add method is a pointer to a TTask, the second parameter is the string to show in the browser. If the string is left out, the name of the task is used.; After executing, the script above the browser will look like in this figure.; 10.5 Execute and Debug Tasks; The browser can be used to start a task, set break points at the beginning of a task ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:427483,load,loads,427483,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loads']
Performance,"(""myclass"",""myheader.h"");. To generate the dictionary from a Makefile, you can use the following rule to generate a dictionary for the headers $(HEADERS) and a library containing the dictionary and the compiled $(SOURCES):. MyDict.cxx: $(HEADERS) Linkdef.h; [TAB] rootcint -f $@ -c $(CXXFLAGS) -p $^. libMyLib.so: MyDict.cxx $(SOURCES); [TAB] g++ -shared -o$@ `root-config --ldflags` $(CXXFLAGS) -I$(ROOTSYS)/include $^. See Interacting with Shared Libraries: rootcint for more details. ; . How can I fix the problem leading to :Error: Can't call vector<...>::push_back . This usually indicates that some classes dictionary refer and/or use this particular instance of std::vector. To solve the problem, you will need to generate a dictionary for this particular instance. With ROOT v5.27/06 and above this can be done by executing:gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");. With older version of ROOT ; this can simply be done using ACLiC and a simple loader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry for details. ; . Can I integrate ROOT into my CMake bui",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:3717,load,loader,3717,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['load'],['loader']
Performance,"(""myfile.root"");); - T->MakeSelector(""myselect"");; where T is the name of the Tree in file myfile.root; and myselect.h, myselect.C the name of the files created by this function.; In a ROOT session, you can do:; root > T->Process(""myselect.C""). Bool_t MemoryFull(Int_t nbytes); Check if adding nbytes to memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:104675,optimiz,optimize,104675,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['optimiz'],['optimize']
Performance,"(""pickle"");; 216 // Import the file as a Python module.; 217 // return object is a new reference !; 218 fModulePickle = PyImport_Import(pName);; 219 if (!fModulePickle) {; 220 Log << kFATAL << ""Can't import pickle"" << Endl;; 221 Log << Endl;; 222 }; 223 PyObject *pDict = PyModule_GetDict(fModulePickle);; 224 // note the following return objects are borrowed references; 225 fPickleDumps = PyDict_GetItemString(pDict, ""dump"");; 226 fPickleLoads = PyDict_GetItemString(pDict, ""load"");; 227 if (fPickleDumps) Py_INCREF(fPickleDumps);; 228 if (fPickleLoads) Py_INCREF(fPickleLoads);; 229 ; 230 Py_DECREF(pName);; 231}; 232 ; 233///////////////////////////////////////////////////////////////////////////////; 234// Finalize Python interpreter; 235 ; 236void PyMethodBase::PyFinalize(); 237{; 238 if (fEval) Py_DECREF(fEval);; 239 if (fOpen) Py_DECREF(fOpen);; 240 if (fModuleBuiltin) Py_DECREF(fModuleBuiltin);; 241 if (fPickleDumps) Py_DECREF(fPickleDumps);; 242 if (fPickleLoads) Py_DECREF(fPickleLoads);; 243 if(fMain) Py_DECREF(fMain);//objects fGlobalNS and fLocalNS will be free here; 244 if (fGlobalNS) Py_DECREF(fGlobalNS);; 245 Py_Finalize();; 246}; 247 ; 248///////////////////////////////////////////////////////////////////////////////; 249/// Check Python interpreter initialization status; 250///; 251/// \return Boolean whether interpreter is initialized; 252 ; 253int PyMethodBase::PyIsInitialized(); 254{; 255 if (!Py_IsInitialized()) return kFALSE;; 256 if (!fEval) return kFALSE;; 257 if (!fModuleBuiltin) return kFALSE;; 258 if (!fPickleDumps) return kFALSE;; 259 if (!fPickleLoads) return kFALSE;; 260 return kTRUE;; 261}; 262 ; 263///////////////////////////////////////////////////////////////////////////////; 264/// Serialize Python object; 265///; 266/// \param[in] path Path where object is written to file; 267/// \param[in] obj Python object; 268///; 269/// The input Python object is serialized and written to a file. The Python; 270/// module `pickle` is used to do so.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/PyMethodBase_8cxx_source.html:7689,load,load,7689,doc/master/PyMethodBase_8cxx_source.html,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html,1,['load'],['load']
Performance,"() ; Definition at line 578 of file TUnfold.cxx. ◆ DeclFileName(). static const char * TUnfold::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 357 of file TUnfold.h. ◆ DeleteMatrix() [1/2]. void TUnfold::DeleteMatrix ; (; TMatrixD ** ; m). staticprotected . delete matrix and invalidate pointer ; Parameters. [in,out]mpointer to a matrix-pointer. if the matrix pointer os non-zero, thematrix id deleted. The matrox pointer is set to zero. ; Definition at line 188 of file TUnfold.cxx. ◆ DeleteMatrix() [2/2]. void TUnfold::DeleteMatrix ; (; TMatrixDSparse ** ; m). staticprotected . delete sparse matrix and invalidate pointer ; Parameters. [in,out]mpointer to a matrix-pointer. if the matrix pointer os non-zero, thematrix id deleted. The matrox pointer is set to zero. ; Definition at line 200 of file TUnfold.cxx. ◆ DoUnfold() [1/3]. Double_t TUnfold::DoUnfold ; (; Double_t ; tau). virtual . perform the unfolding for a given regularisation parameter tau ; Parameters. [in]tauregularisation parameter. this method sets tau and then calls the core unfolding algorithm ; Definition at line 2491 of file TUnfold.cxx. ◆ DoUnfold() [2/3]. Double_t TUnfold::DoUnfold ; (; Double_t ; tau_reg, . const TH1 * ; input, . Double_t ; scaleBias = 0.0 . ). perform the unfolding for a given input and regularisation ; Parameters. [in]tau_regregularisation parameter ; [in]inputinput distribution with uncertainties ; [in]scaleBias(default=0.0) scale factor applied to the bias. This is a shortcut for { SetInput(input,scaleBias); DoUnfold(tau); } ; Definition at line 2235 of file TUnfold.cxx. ◆ DoUnfold() [3/3]. Double_t TUnfold::DoUnfold ; (; void ; ). protectedvirtual . core unfolding algorithm ; Definition at line 246 of file TUnfold.cxx. ◆ ErrorMatrixToHist(). void TUnfold::ErrorMatrixToHist ; (; TH2 * ; ematrix, . const TMatrixDSparse * ; emat, . const Int_t * ; binMap, . Bool_t ; doClear . ); const. protected . add up an error mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:30288,perform,perform,30288,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['perform'],['perform']
Performance,"() ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Definition at line 3258 of file TBufferJSON.cxx. ◆ JsonWriteMember(). TString TBufferJSON::JsonWriteMember ; (; const void * ; ptr, . TDataMember * ; member, . TClass * ; memberClass, . Int_t ; arraylen . ). protected . Convert single data member to JSON structures Returns string with converted member. ; Definition at line 1007 of file TBufferJSON.cxx. ◆ JsonWriteObject(). void TBufferJSON::JsonWriteObject ; (; const void * ; obj, . const TClass * ; objClass, . Bool_t ; check_map = kTRUE . ). protected . Write object to buffer If object was written before, only pointer will be stored If check_map==kFALSE, object will be stored in any case and pointer will not be registered in the map. ; Definition at line 1323 of file TBufferJSON.cxx. ◆ PerformPostProcessing(). void TBufferJSON::PerformPostProcessing ; (; TJSONStackObj * ; stack, . const TClass * ; obj_cl = nullptr . ). protected . Function is converts TObject and TString structures to more compact representation. ; Definition at line 2331 of file TBufferJSON.cxx. ◆ PopStack(). TJSONStackObj * TBufferJSON::PopStack ; (; ). protected . remove one level from stack ; Definition at line 1145 of file TBufferJSON.cxx. ◆ PushStack(). TJSONStackObj * TBufferJSON::PushStack ; (; Int_t ; inclevel = 0, . void * ; readnode = nullptr . ). protected . add new level to the structures stack ; Definition at line 1127 of file TBufferJSON.cxx. ◆ ReadArray() [1/13]. Int_t TBufferJSON::ReadArray ; (; Bool_t *& ; b). finalvirtual . Read array of Bool_t from buffer. ; Implements TBuffer.; Definition at line 2533 of file TBufferJSON.cxx. ◆ ReadArray() [2/13]. Int_t TBufferJSON::ReadArray ; (; Char_t *& ; c). finalvirtual . Read array of Char_t from buffer. ; Implements TBuffer.; Definition at line 2541 of file TBufferJSON.cxx. ◆ ReadArray() [3/13]. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:69480,Perform,PerformPostProcessing,69480,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['Perform'],['PerformPostProcessing']
Performance,"() == ECONNRESET); 4541 return -5;; 4542 else; 4543 return -1;; 4544 }; 4545 }; 4546 if (once); 4547 return nrecv;; 4548 }; 4549 return n;; 4550}; 4551 ; 4552////////////////////////////////////////////////////////////////////////////////; 4553/// Send exactly length bytes from buffer. Returns -1 in case of error,; 4554/// otherwise number of sent bytes. Returns -4 in case of kNoBlock and; 4555/// errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; 4556/// (EPIPE || ECONNRESET).; 4557 ; 4558int TUnixSystem::UnixSend(int sock, const void *buffer, int length, int flag); 4559{; 4560 if (sock < 0) return -1;; 4561 ; 4562 int once = 0;; 4563 if (flag == -1) {; 4564 flag = 0;; 4565 once = 1;; 4566 }; 4567 ; 4568 int n, nsent = 0;; 4569 const char *buf = (const char *)buffer;; 4570 ; 4571 for (n = 0; n < length; n += nsent) {; 4572 if ((nsent = send(sock, buf+n, length-n, flag)) <= 0) {; 4573 if (nsent == 0); 4574 break;; 4575 if (GetErrno() == EWOULDBLOCK); 4576 return -4;; 4577 else {; 4578 if (GetErrno() != EINTR); 4579 ::SysError(""TUnixSystem::UnixSend"", ""send"");; 4580 if (GetErrno() == EPIPE || GetErrno() == ECONNRESET); 4581 return -5;; 4582 else; 4583 return -1;; 4584 }; 4585 }; 4586 if (once); 4587 return nsent;; 4588 }; 4589 return n;; 4590}; 4591 ; 4592//---- Dynamic Loading ---------------------------------------------------------; 4593 ; 4594////////////////////////////////////////////////////////////////////////////////; 4595/// Get shared library search path. Static utility function.; 4596 ; 4597static const char *DynamicPath(const char *newpath = nullptr, Bool_t reset = kFALSE); 4598{; 4599 static TString dynpath_full;; 4600 static std::atomic<bool> initialized(kFALSE);; 4601 static std::atomic<bool> seenCling(kFALSE);; 4602 ; 4603 // If we have not seen Cling but the result has been initialized and gCling; 4604 // is still nullptr, the result won't change.; 4605 if (newpath == nullptr && !reset && (seenCling || (initialized && gCling == nullptr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:146813,Load,Loading,146813,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['Load'],['Loading']
Performance,"() [3/3]. TQpLinSolverBase::TQpLinSolverBase ; (; const TQpLinSolverBase & ; another). Copy constructor. ; Definition at line 105 of file TQpLinSolverBase.cxx. ◆ ~TQpLinSolverBase(). TQpLinSolverBase::~TQpLinSolverBase ; (; ). inlineoverride . Definition at line 98 of file TQpLinSolverBase.h. Member Function Documentation. ◆ ComputeDiagonals(). void TQpLinSolverBase::ComputeDiagonals ; (; TVectorD & ; dd, . TVectorD & ; omega, . TVectorD & ; t, . TVectorD & ; lambda, . TVectorD & ; u, . TVectorD & ; pi, . TVectorD & ; v, . TVectorD & ; gamma, . TVectorD & ; w, . TVectorD & ; phi . ). virtual . Computes the diagonal matrices in the augmented system from the current set of variables. ; Definition at line 140 of file TQpLinSolverBase.cxx. ◆ Factor(). void TQpLinSolverBase::Factor ; (; TQpDataBase * ; prob, . TQpVar * ; vars . ). virtual . Sets up the matrix for the main linear system in ""augmented system"" form. ; The actual factorization is performed by a routine specific to either the sparse or dense case ; Reimplemented in TQpLinSolverDens, and TQpLinSolverSparse.; Definition at line 117 of file TQpLinSolverBase.cxx. ◆ JoinRHS(). void TQpLinSolverBase::JoinRHS ; (; TVectorD & ; rhs_out, . TVectorD & ; rhs1_in, . TVectorD & ; rhs2_in, . TVectorD & ; rhs3_in . ). virtual . Assembles a single vector object from three given vectors . ; rhs_out (output) final joined vector rhs1_in (input) first part of rhs rhs2_in (input) middle part of rhs rhs3_in (input) last part of rhs . ; Definition at line 288 of file TQpLinSolverBase.cxx. ◆ operator=(). TQpLinSolverBase & TQpLinSolverBase::operator= ; (; const TQpLinSolverBase & ; source). Assignment operator. ; Definition at line 312 of file TQpLinSolverBase.cxx. ◆ PutXDiagonal(). virtual void TQpLinSolverBase::PutXDiagonal ; (; TVectorD & ; xdiag). pure virtual . Implemented in TQpLinSolverDens, and TQpLinSolverSparse. ◆ PutZDiagonal(). virtual void TQpLinSolverBase::PutZDiagonal ; (; TVectorD & ; zdiag). pure virtual . Implement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQpLinSolverBase.html:12945,perform,performed,12945,doc/master/classTQpLinSolverBase.html,https://root.cern,https://root.cern/doc/master/classTQpLinSolverBase.html,1,['perform'],['performed']
Performance,"() call, and note how the AddressOf() function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutori",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073176,load,load,1073176,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,() const { return fDefCanvasName; }; 218 Bool_t GetEditHistograms() const { return fEditHistograms; }; 219 Int_t GetEditorMode() const { return fEditorMode; }; 220 Bool_t GetForceStyle() const { return fForceStyle; }; 221 Int_t GetBuiltDate() const { return fBuiltDate; }; 222 Int_t GetBuiltTime() const { return fBuiltTime; }; 223 const char *GetGitCommit() const { return fGitCommit; }; 224 const char *GetGitBranch() const { return fGitBranch; }; 225 const char *GetGitDate();; 226 Int_t GetVersionDate() const { return fVersionDate; }; 227 Int_t GetVersionTime() const { return fVersionTime; }; 228 Int_t GetVersionInt() const { return fVersionInt; }; 229 Int_t GetVersionCode() const { return fVersionCode; }; 230 const char *GetVersion() const { return fVersion; }; 231 TCollection *GetListOfClasses() const { return fClasses; }; 232 TSeqCollection *GetListOfColors() const { return fColors; }; 233 TCollection *GetListOfTypes(Bool_t load = kFALSE);; 234 TCollection *GetListOfGlobals(Bool_t load = kFALSE);; 235 TCollection *GetListOfGlobalFunctions(Bool_t load = kFALSE);; 236 TSeqCollection *GetListOfClosedObjects() const { return fClosedObjects; }; 237 TSeqCollection *GetListOfFiles() const { return fFiles; }; 238 TSeqCollection *GetListOfMappedFiles() const { return fMappedFiles; }; 239 TSeqCollection *GetListOfSockets() const { return fSockets; }; 240 TSeqCollection *GetListOfCanvases() const { return fCanvases; }; 241 TSeqCollection *GetListOfStyles() const { return fStyles; }; 242 TCollection *GetListOfFunctions() const { return fFunctions; }; 243 TCollection *GetListOfFunctionOverloads(const char* name) const;; 244 TSeqCollection *GetListOfGeometries() const { return fGeometries; }; 245 TSeqCollection *GetListOfBrowsers() const { return fBrowsers; }; 246 TSeqCollection *GetListOfSpecials() const { return fSpecials; }; 247 TSeqCollection *GetListOfTasks() const { return fTasks; }; 248 TSeqCollection *GetListOfCleanups() const { return fCleanups; }; 249 TSeqCollection *G,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:10921,load,load,10921,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['load'],['load']
Performance,"() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeIndex.html:13050,Load,LoadTree,13050,root/html534/TTreeIndex.html,https://root.cern,https://root.cern/root/html534/TTreeIndex.html,1,['Load'],['LoadTree']
Performance,"() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeIndex.html:13555,Load,LoadTree,13555,root/html604/TTreeIndex.html,https://root.cern,https://root.cern/root/html604/TTreeIndex.html,1,['Load'],['LoadTree']
Performance,"() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeIndex.html:13555,Load,LoadTree,13555,root/html602/TTreeIndex.html,https://root.cern,https://root.cern/root/html602/TTreeIndex.html,1,['Load'],['LoadTree']
Performance,"() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:6572,load,load,6572,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"() const; static voidLoadMacro(const char* name); static Bool_tMethodProxy_Check(PyObject* pyobject); static Bool_tMethodProxy_CheckExact(PyObject* pyobject); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname, Bool_t python_owns = kFALSE); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TPython(); TPython(const TPython&). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create Cling equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPython.html:3445,Load,LoadMacro,3445,root/html602/TPython.html,https://root.cern,https://root.cern/root/html602/TPython.html,1,['Load'],['LoadMacro']
Performance,"() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:2674,cache,cacheUniqueSuffix,2674,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:2238,cache,cacheUniqueSuffix,2238,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooSimultaneous::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:2639,cache,cacheUniqueSuffix,2639,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,1,['cache'],['cacheUniqueSuffix']
Performance,"() const; virtual TClass*IsA() const; Int_tMatch(const TString& s, UInt_t start = 0); Int_tNMatches() const; TStringoperator[](Int_t); virtual voidPrint(Option_t* option = """"); voidReset(const TString& s, const TString& opts = """", Int_t nMatchMax = -1); voidReset(const TString& s, UInt_t opts, Int_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector& insp); Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); TObjArray*TPRegexp::MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); voidTPRegexp::Optimize(); UInt_tTPRegexp::ParseMods(const TString& mods) const; Int_tTPRegexp::ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Int_tTPRegexp::SubstituteInternal(TString& s, const TString& replace, Int_t start, Int_t nMaxMatch0, Bool_t doDollarSubst). private:. TPMERegexp&operator=(const TPMERegexp&). Data Members; public:. enum TPRegexp::[unnamed] { kPCRE_GLOBAL; kPCRE_OPTIMIZE; kPCRE_DEBUG_MSGS; kPCRE_INTMASK; };. protected:. void*fAddressOfLastStringused for checking for change of TString in global match; Int_tfLastGlobalPositionend of last match when kPCRE_GLOBAL is set; TStringfLastStringMatchedcopy of the last TString matched; TArrayIfMarkerslast set of indexes of matches; Int_tfNMatchesnumber of matches returned from last pcre_exec call; Int_tfNMaxMatchesmaximum number of matches; UInt_tTPRegexp::fPCREOpts; TStringTPRegexp::fPattern; PCREPriv_t*TPRegexp::fPriv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPMERegexp.html:2049,Optimiz,Optimize,2049,root/html528/TPMERegexp.html,https://root.cern,https://root.cern/root/html528/TPMERegexp.html,3,['Optimiz'],['Optimize']
Performance,"() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:28674,cache,cache,28674,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,1,['cache'],['cache']
Performance,"() const;  ; virtual void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true)=0;  ; virtual void fillTreeBranch (TTree &t)=0;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual bool isValid () const;  WVE (08/21/01) Probably obsolete now. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; virtual void setTreeBranchStatus (TTree &t, bool active)=0;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; virtual void syncCache (const RooArgSet *nset=nullptr)=0;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:35463,optimiz,optimizeDirtyHook,35463,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"() const;  ; virtual void operModeHook (RooAbsArg::OperMode);  Interface for changes of operation mode. ;  ; virtual void optimizeCacheMode (const RooArgSet &obs, RooArgSet &optNodes, RooLinkedList &processedNodes);  Interface for cache optimization calls. ;  ; virtual void printCompactTreeHook (std::ostream &, const char *, Int_t curElem, Int_t totElem);  Hook function to print cache guts in tree printing mode of RooAbsArgs. ;  ; virtual bool redirectServersHook (const RooAbsCollection &, bool, bool, bool);  Interface for server redirect calls. ;  ; void setOwner (RooAbsArg *owner);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Public Attributes; std::unique_ptr< RooAbsReal > _norm;  . Additional Inherited Members;  Public Types inherited from RooAbsCacheElement; enum  Action { OperModeChange; , OptimizeCaching; , FindConstantNodes; };  ;  Static Public Member Functions inherited from RooAbsCacheElement; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Attributes inherited from RooAbsCacheElement; RooAbsArg * _owner;  ! Pointer to owning RooAbsArg ;  . #include <RooAbsPdf.h>. Inheritance diagram for RooAbsPdf::CacheElem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ CacheElem(). RooAbsPdf::CacheElem::CacheElem ; (; RooAbsReal & ; norm). inline . Definition at line 324 of file RooAbsPdf.h. ◆ ~CacheElem(). RooAbsPdf::CacheElem::~CacheElem ; (; ). override . Destructor of normalization cache element. ; If this element provides the 'current' normalization stored in RooAbsPdf::_norm zero _norm pointer here before object pointed to is deleted here ; Definition at line 2430 of file RooAbsPdf.cxx. Member Function Documentation. ◆ containedArgs(). RooArgList RooAbsPdf::CacheElem::containedArgs ; (; Action ; ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html:1702,Optimiz,OptimizeCaching,1702,doc/master/classRooAbsPdf_1_1CacheElem.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html,1,['Optimiz'],['OptimizeCaching']
Performance,"() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPerfStats.html:4032,latency,latency,4032,root/html528/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html528/TVirtualPerfStats.html,1,['latency'],['latency']
Performance,"() constTObjectvirtual; IsOnHeap() constTObjectinline; IsPathLocal(const char *path)TSystemvirtual; IsSortable() const overrideTNamedinlinevirtual; IsZombie() constTObjectinline; kBitMask enum valueTObject; kCanDelete enum valueTObject; kCannotPick enum valueTObject; kDebug enum valueTSystem; kDefault enum valueTSystem; kFlatBuildDir enum valueTSystem; kHasUUID enum valueTObject; kInconsistent enum valueTObject; kInvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOpt enum valueTSystem; kOverwrite enum valueTObject; kSingleKey enum valueTObject; kWriteDelete enum valueTObject; kZombie enum valueTObject; Link(const char *from, const char *to)TSystemvirtual; ListLibraries(const char *regexp="""")TSystemvirtual; ListSymbols(const char *module, const char *re="""")TSystemvirtual; Load(const char *module, const char *entry="""", Bool_t system=kFALSE)TSystemvirtual; LoadAllLibraries()TSystemvirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeDirectory(const char *name)TSystemvirtual; MakeZombie()TObjectinlineprotected; MayNotUse(const char *method) constTObject; mkdir(const char *name, Bool_t recursive=kFALSE)TSystemvirtual; NextTimeOut(Bool_t mode)TSystemvirtual; Notify()TObjectvirtual; NotifyApplicationCreated()TSystemvirtual; Now()TSystemvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")TSystemvirtual; OpenDirectory(const char *name)TSystemvirtual; Openlog(const char *name, Int_t options, ELogFacility facility)TSystemvirtual; OpenPipe(const char *command, const char *mode)TSystemvirtual; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem-members.html:10903,Load,Load,10903,doc/master/classTSystem-members.html,https://root.cern,https://root.cern/doc/master/classTSystem-members.html,1,['Load'],['Load']
Performance,"() constmax iterationsDefinition MinimizerOptions.h:180; ROOT::Math::MinimizerOptions::MaxFunctionCallsunsigned int MaxFunctionCalls() constmax number of function callsDefinition MinimizerOptions.h:177; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetErrorDefvoid SetErrorDef(double up)set scale for calculating the errorsDefinition Minimizer.h:347; ROOT::Math::Minimizer::SetValidErrorvoid SetValidError(bool on)flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)Definition Minimizer.h:350; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetStrategyvoid SetStrategy(int strategyLevel)set the strategyDefinition Minimizer.h:344; ROOT::Math::Minimizer::SetPrecisionvoid SetPrecision(double prec)set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer wi...Definition Minimizer.h:341; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::SetExtraOptionsvoid SetExtraOptions(const IOptions &extraOptions)set only the extra optionsDefinition Minimizer.h:358; Factory.h; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Fop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:17812,perform,perform,17812,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['perform'],['perform']
Performance,"() override;  ; void SetBufferDisplacement (Int_t skipped) override;  ; void SetPidOffset (UShort_t offset) override;  This offset is used when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-swap N primitive-elements in the buffer. ;  ; void DetachBuffer ();  ; void Expand (Int_t newsize, Bool_t copy=kTRUE);  Expand (or shrink) the I/O buffer to newsize bytes. ;  ; Int_t GetBufferVersion () const;  ; char * GetCurrent () const;  ; TObject * GetParent () const;  Return pointer to parent of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMessage.html:22794,cache,cacheReuse,22794,doc/master/classTMessage.html,https://root.cern,https://root.cern/doc/master/classTMessage.html,1,['cache'],['cacheReuse']
Performance,"() override;  Initialize module after attachment to RooMCStudy object. ;  ; bool initializeRun (Int_t) override;  Initialize module at beginning of RooCMStudy run. ;  ; TClass * IsA () const override;  ; bool processAfterFit (Int_t) override;  Bin dataset and calculate chi2 of p.d.f w.r.t binned dataset. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsMCStudyModule;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy constructor. ;  ; bool doInitializeInstance (RooMCStudy &);  Initializer method called upon attachment to given RooMCStudy object. ;  ; virtual bool processBeforeGen (Int_t);  Method called after resetting of generator parameters to initial values and before call to generator context Any modifications to generator parameters will affect next generation operation (only) ;  ; virtual bool processBetweenGenAndFit (Int_t);  Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2MCSModule.html:2260,perform,performed,2260,doc/master/classRooChi2MCSModule.html,https://root.cern,https://root.cern/doc/master/classRooChi2MCSModule.html,1,['perform'],['performed']
Performance,"()); 4445 if (auto base = static_cast<TBaseClass *>(item)->GetClassPointer()); 4446 if (TFunction* method = base->FindClassOrBaseMethodWithId(declId)); 4447 return static_cast<TMethod *>(method);; 4448 ; 4449 return nullptr;; 4450}; 4451 ; 4452////////////////////////////////////////////////////////////////////////////////; 4453/// Find the method with a given prototype. The proto string must be of the; 4454/// form: ""char*,int,double"". Returns 0 in case method is not found.; 4455 ; 4456TMethod *TClass::GetMethodWithPrototype(const char *method, const char *proto,; 4457 Bool_t objectIsConst /* = kFALSE */,; 4458 ROOT::EFunctionMatchMode mode /* = ROOT::kConversionMatch */); 4459{; 4460 if (fCanLoadClassInfo) LoadClassInfo();; 4461 if (!fClassInfo) return nullptr;; 4462 ; 4463 if (!gInterpreter); 4464 Fatal(""GetMethodWithPrototype"", ""gInterpreter not initialized"");; 4465 ; 4466 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(fClassInfo,; 4467 method, proto,; 4468 objectIsConst, mode);; 4469 ; 4470 if (!decl) return nullptr;; 4471 TMethod* f = FindClassOrBaseMethodWithId(decl);; 4472 if (f) return f;; 4473 Error(""GetMethodWithPrototype"",; 4474 ""\nDid not find matching TMethod <%s> with \""%s\"" %sfor %s"",; 4475 method,proto,objectIsConst ? ""const "" : """", GetName());; 4476 return nullptr;; 4477}; 4478 ; 4479////////////////////////////////////////////////////////////////////////////////; 4480/// Look for a method in this class that has the interface function; 4481/// address faddr.; 4482 ; 4483TMethod *TClass::GetClassMethod(Longptr_t faddr); 4484{; 4485 if (!HasInterpreterInfo()) return nullptr;; 4486 ; 4487 TMethod *m;; 4488 TIter next(GetListOfMethods());; 4489 while ((m = (TMethod *) next())) {; 4490 if (faddr == (Longptr_t)m->InterfaceMethod()); 4491 return m;; 4492 }; 4493 return nullptr;; 4494}; 4495 ; 4496////////////////////////////////////////////////////////////////////////////////; 4497/// Look for a method in this class that has the name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:168633,Load,LoadClassInfo,168633,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['LoadClassInfo']
Performance,"()); 4512 if (auto base = static_cast<TBaseClass *>(item)->GetClassPointer()); 4513 if (TFunction* method = base->FindClassOrBaseMethodWithId(declId)); 4514 return static_cast<TMethod *>(method);; 4515 ; 4516 return nullptr;; 4517}; 4518 ; 4519////////////////////////////////////////////////////////////////////////////////; 4520/// Find the method with a given prototype. The proto string must be of the; 4521/// form: ""char*,int,double"". Returns 0 in case method is not found.; 4522 ; 4523TMethod *TClass::GetMethodWithPrototype(const char *method, const char *proto,; 4524 Bool_t objectIsConst /* = kFALSE */,; 4525 ROOT::EFunctionMatchMode mode /* = ROOT::kConversionMatch */); 4526{; 4527 if (fCanLoadClassInfo) LoadClassInfo();; 4528 if (!fClassInfo) return nullptr;; 4529 ; 4530 if (!gInterpreter); 4531 Fatal(""GetMethodWithPrototype"", ""gInterpreter not initialized"");; 4532 ; 4533 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(fClassInfo,; 4534 method, proto,; 4535 objectIsConst, mode);; 4536 ; 4537 if (!decl) return nullptr;; 4538 TMethod* f = FindClassOrBaseMethodWithId(decl);; 4539 if (f) return f;; 4540 Error(""GetMethodWithPrototype"",; 4541 ""\nDid not find matching TMethod <%s> with \""%s\"" %sfor %s"",; 4542 method,proto,objectIsConst ? ""const "" : """", GetName());; 4543 return nullptr;; 4544}; 4545 ; 4546////////////////////////////////////////////////////////////////////////////////; 4547/// Look for a method in this class that has the interface function; 4548/// address faddr.; 4549 ; 4550TMethod *TClass::GetClassMethod(Longptr_t faddr); 4551{; 4552 if (!HasInterpreterInfo()) return nullptr;; 4553 ; 4554 TMethod *m;; 4555 TIter next(GetListOfMethods());; 4556 while ((m = (TMethod *) next())) {; 4557 if (faddr == (Longptr_t)m->InterfaceMethod()); 4558 return m;; 4559 }; 4560 return nullptr;; 4561}; 4562 ; 4563////////////////////////////////////////////////////////////////////////////////; 4564/// Look for a method in this class that has the name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:171384,Load,LoadClassInfo,171384,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['LoadClassInfo']
Performance,"(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:36584,perform,performed,36584,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,6,['perform'],['performed']
Performance,"()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->IncrementTotalBuffers(bk->GetBufferSize());; 9521 }; 9522 }; 9523 ; 9524 TBranch__SetTree(tree,*br->GetListOfBranches());; 9525 }; 9526}; 9527 ; 9528////////////////////////////////////////////////////////////////////////////////; 9529/// Set the fTree member for all friend elements.; 9530 ; 9531void TFriendElement__SetTree(TTree *tree, TList *frlist); 9532{; 9533 if (frlist) {; 9534 TObjLink *lnk = frlist->FirstLink();; 9535 while (lnk) {; 9536 TFriendElement *elem = (TFriendElement*)lnk->GetObject();; 9537 elem->fParentTree = tree;; 9538 lnk = lnk->Next();; 9539 }; 9540 }; 9541}; 9542 ; 9543////////////////////////////////////////////////////////////////////////////////; 9544/// Stream a class object.; 9545 ; 9546void TTree::Streamer(TBuffer& b); 9547{; 9548 if (b.IsReading()) {; 9549 UInt_t R__s, R__c;; 9550 if (fDirectory) {; 9551 fDirectory->Remove(this);; 9552 //delete the file cache if it points to this Tree; 9553 TFile *file = fDirectory->GetFile();; 9554 MoveReadCache(file,nullptr);; 9555 }; 9556 fDirectory = nullptr;; 9557 fCacheDoAutoInit = true;; 9558 fCacheUserSet = false;; 9559 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 9560 if (R__v > 4) {; 9561 b.ReadClassBuffer(TTree::Class(), this, R__v, R__s, R__c);; 9562 ; 9563 fBranches.SetOwner(true); // True needed only for R__v < 19 and most R__v == 19; 9564 ; 9565 if (fBranchRef) fBranchRef->SetTree(this);; 9566 TBranch__SetTree(this,fBranches);; 9567 TFriendElement__SetTree(this,fFriends);; 9568 ; 9569 if (fTreeIndex) {; 9570 fTreeIndex->SetTree(this);; 9571 }; 9572 if (fIndex.fN) {; 9573 Warning(""Streamer"", ""Old style index in this tree is deleted. Rebuild the index via TTree::BuildIndex"");; 9574 fIndex.Set(0);; 9575 fIndexValues.Set(0);; 9576 }; 9577 if (fEstimate <= 10000) {; 9578 fEstimate = 1000000;; 9579 }; 9580 ; 9581 if (fNClusterRange) {; 9582 // The I/O allocated just enough memory to hold the; 9583 // current set of ranges.; 9584 fMaxClusterRange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:366992,cache,cache,366992,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"(). Double_t TQpVar::GetMu ; (; ). virtual . compute complementarity gap, obtained by taking the inner product of the complementary vectors and dividing by the total number of components computes mu = (t'lambda +u'pi + v'gamma + w'phi)/(mclow+mcupp+nxlow+nxupp) ; Definition at line 192 of file TQpVar.cxx. ◆ InteriorPoint(). void TQpVar::InteriorPoint ; (; Double_t ; alpha, . Double_t ; beta . ). virtual . Sets components of (u,t,v,w) to alpha and of (lambda,pi,phi,gamma) to beta. ; Definition at line 534 of file TQpVar.cxx. ◆ IsInteriorPoint(). Bool_t TQpVar::IsInteriorPoint ; (; ). virtual . Is the current position an interior point ? ; Definition at line 375 of file TQpVar.cxx. ◆ MuStep(). Double_t TQpVar::MuStep ; (; TQpVar * ; step, . Double_t ; alpha . ). virtual . Compute the complementarity gap resulting from a step of length ""alpha"" along direction ""step"". ; Definition at line 211 of file TQpVar.cxx. ◆ Negate(). void TQpVar::Negate ; (; ). virtual . Perform a ""negate"" operation on all data vectors : x = -x. ; Definition at line 272 of file TQpVar.cxx. ◆ Norm1(). Double_t TQpVar::Norm1 ; (; ). virtual . Return the sum of the vector-norm1's. ; Definition at line 676 of file TQpVar.cxx. ◆ NormInf(). Double_t TQpVar::NormInf ; (; ). virtual . Return the sum of the vector-normInf's. ; Definition at line 700 of file TQpVar.cxx. ◆ operator=(). TQpVar & TQpVar::operator= ; (; const TQpVar & ; source). Assignment operator. ; Definition at line 772 of file TQpVar.cxx. ◆ Print(). void TQpVar::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print class members. ; Reimplemented from TObject.; Definition at line 639 of file TQpVar.cxx. ◆ Saxpy(). void TQpVar::Saxpy ; (; TQpVar * ; b, . Double_t ; alpha . ). virtual . Perform a ""saxpy"" operation on all data vectors : x += alpha*y. ; Definition at line 232 of file TQpVar.cxx. ◆ ShiftBoundVariables(). void TQpVar::ShiftBoundVariables ; (; Double_t ; alpha, . Double_t ; beta . ). virtual . Add alpha to component",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQpVar.html:17882,Perform,Perform,17882,doc/master/classTQpVar.html,https://root.cern,https://root.cern/doc/master/classTQpVar.html,1,['Perform'],['Perform']
Performance,"(). Longptr_t TMacro::Exec ; (; const char * ; params = nullptr, . Int_t * ; error = nullptr . ). virtual . Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine(). Returns the result of the macro (return value or value of the last expression), cast to a Long_t. ; Reimplemented in TEveMacro.; Definition at line 262 of file TMacro.cxx. ◆ GetLineWith(). TObjString * TMacro::GetLineWith ; (; const char * ; text); const. virtual . Search the first line containing text. ; Definition at line 297 of file TMacro.cxx. ◆ GetListOfLines(). TList * TMacro::GetListOfLines ; (; ); const. inline . Definition at line 51 of file TMacro.h. ◆ IsA(). TClass * TMacro::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 59 of file TMacro.h. ◆ Load(). Bool_t TMacro::Load ; (; ); const. virtual . Load the macro into the interpreter. ; Return true in case the loading was successful. ; Definition at line 244 of file TMacro.cxx. ◆ operator=(). TMacro & TMacro::operator= ; (; const TMacro & ; macro). Copy constructor. ; Definition at line 120 of file TMacro.cxx. ◆ Paint(). void TMacro::Paint ; (; Option_t * ; option = """"). overridevirtual . Execute this macro (called by TPad::Paint). ; Reimplemented from TObject.; Definition at line 311 of file TMacro.cxx. ◆ Print(). void TMacro::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print contents of this macro. ; Reimplemented from TObject.; Definition at line 319 of file TMacro.cxx. ◆ ReadFile(). Int_t TMacro::ReadFile ; (; const char * ; filename). virtual . Read lines in filename in this macro. ; Definition at line 329 of file TMacro.cxx. ◆ SavePrimitive(). void TMacro::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save macro source on stream out. ; Reimplemented from TObject.; Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:18473,Load,Load,18473,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['Load'],['Load']
Performance,"(). OperMode RooAbsArg::operMode ; (; ); const. inline . Query the operation mode of this node. ; Definition at line 456 of file RooAbsArg.h. ◆ operModeHook(). virtual void RooAbsArg::operModeHook ; (; ). inlineprotectedvirtual . Reimplemented in RooCachedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsArg.h. ◆ optimizeCacheMode() [1/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsArg.cxx. ◆ ownedComponents(). const RooArgSet * RooAbsArg::ownedComponents ; (; ); const. inline . Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:78599,optimiz,optimizedNodes,78599,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['optimiz'],['optimizedNodes']
Performance,"(). TClass * TSQLStructure::GetVersionClass ; (; ); const. return class for version tag if type is kSqlVersion ; Definition at line 496 of file TSQLStructure.cxx. ◆ IsNumericType(). Bool_t TSQLStructure::IsNumericType ; (; Int_t ; typ). static . defines if value is numeric and not requires quotes when writing ; Definition at line 729 of file TSQLStructure.cxx. ◆ LocateElementColumn(). Int_t TSQLStructure::LocateElementColumn ; (; TSQLFile * ; f, . TBufferSQL2 * ; buf, . TSQLObjectData * ; data . ). find column in TSQLObjectData object, which correspond to current element ; Definition at line 2107 of file TSQLStructure.cxx. ◆ MakeArrayIndex(). TString TSQLStructure::MakeArrayIndex ; (; TStreamerElement * ; elem, . Int_t ; n . ). static . produce string with complete index like [1][2][0] ; Definition at line 1493 of file TSQLStructure.cxx. ◆ NumChilds(). Int_t TSQLStructure::NumChilds ; (; ); const. number of child structures ; Definition at line 345 of file TSQLStructure.cxx. ◆ PerformConversion(). void TSQLStructure::PerformConversion ; (; TSqlRegistry * ; reg, . TSqlRawBuffer * ; blobs, . const char * ; topname, . Bool_t ; useblob = kFALSE . ). protected . perform conversion of structure to sql statements first tries convert it to normal form if fails, produces data for raw table ; Definition at line 1216 of file TSQLStructure.cxx. ◆ Print(). void TSQLStructure::Print ; (; Option_t * ; option = """"); const. overridevirtual . print content of complete structure ; Reimplemented from TObject.; Definition at line 667 of file TSQLStructure.cxx. ◆ PrintLevel(). void TSQLStructure::PrintLevel ; (; Int_t ; level); const. print content of current structure ; Definition at line 675 of file TSQLStructure.cxx. ◆ RecognizeTString(). Bool_t TSQLStructure::RecognizeTString ; (; const char *& ; value). protected . prove that structure contains TString data ; Definition at line 1870 of file TSQLStructure.cxx. ◆ SetArray(). void TSQLStructure::SetArray ; (; Int_t ; sz = -1). Set struc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLStructure.html:26379,Perform,PerformConversion,26379,doc/master/classTSQLStructure.html,https://root.cern,https://root.cern/doc/master/classTSQLStructure.html,1,['Perform'],['PerformConversion']
Performance,"(). int TCling::LoadFile ; (; const char * ; path); const. finalvirtual . Load a source file or library called path into the interpreter. ; Reimplemented from TInterpreter.; Definition at line 7500 of file TCling.cxx. ◆ LoadFunctionTemplates(). void TCling::LoadFunctionTemplates ; (; TClass * ; cl); const. finalvirtual . Create list of pointers to function templates for TClass cl. ; Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a class (autoload mechanism), see the AutoLoad() methods below. ; Implements TInterpreter.; Definition at line 5741 of file TCling.cxx. ◆ LoadMacro(). void TCling::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). finalvirtual . Load a macro file in cling's memory. ; Implements TInterpreter.; Definition at line 3552 of file TCling.cxx. ◆ LoadPCM(). void TCling::LoadPCM ; (; std::string ; pcmFileNameFullPath). private . Tries to load a rdict PCM, issues diagnostics if it fails. ; Definition at line 1811 of file TCling.cxx. ◆ LoadPCMImpl(). void TCling::LoadPCMImpl ; (; TFile & ; pcmFile). private . Tries to load a PCM from TFile; returns true on success. ; Definition at line 1696 of file TCling.cxx. ◆ LoadText(). Bool_t TCling::LoadText ; (; const char * ; text); const. finalvirtual . Load the declarations from text into the interpreter. ; Note that this cannot be (top level) statements; text must contain top level declarations. Returns true on success, false on failure. ; Reimplemented from TInterpreter.; Definition at line 7515 of file TCling.cxx. ◆ MakeInterpreterValue(). std::unique_ptr< TInterpreterValue > TCling::MakeInterprete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:114110,Load,LoadMacro,114110,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['LoadMacro']
Performance,"(). virtual Bool_t ROOT::v5::TFormula::IsLinear ; (; ); const. inlinevirtual . Definition at line 247 of file TFormula.h. ◆ IsNormalized(). virtual Bool_t ROOT::v5::TFormula::IsNormalized ; (; ); const. inlinevirtual . Definition at line 248 of file TFormula.h. ◆ IsString(). Bool_t TFormula::IsString ; (; Int_t ; oper); const. protectedvirtual . Return true if the expression at the index 'oper' has to be treated as a string. ; Reimplemented in TTreeFormula.; Definition at line 3269 of file TFormula_v5.cxx. ◆ MakePrimitive(). void TFormula::MakePrimitive ; (; const char * ; expr, . Int_t ; pos . ). protected . MakePrimitive find TFormulaPrimitive replacement for some operands. ; Definition at line 3746 of file TFormula_v5.cxx. ◆ operator=(). TFormula & TFormula::operator= ; (; const TFormula & ; rhs). Operator =. ; Definition at line 303 of file TFormula_v5.cxx. ◆ Optimize(). void TFormula::Optimize ; (; ). MI include. ; Optimize formula; Minimize the number of operands; several operands are glued together; some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); maximize number of standard calls minimizing number of jumps in Eval cases; variables, parameters and constants are mapped - using fOperOfssets0 Eval procedure use direct acces to data (only one corresponding case statement in eval procedure) pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:44280,Optimiz,Optimize,44280,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['Optimiz'],['Optimize']
Performance,(). virtual Long64_t TFile::GetBytesRead ; (; ); const. inlinevirtual . Definition at line 241 of file TFile.h. ◆ GetBytesReadExtra(). virtual Long64_t TFile::GetBytesReadExtra ; (; ); const. inlinevirtual . Definition at line 242 of file TFile.h. ◆ GetBytesToPrefetch(). Int_t TFile::GetBytesToPrefetch ; (; ); const. virtual . Max number of bytes to prefetch. ; By default this is 75% of the read cache size. But specific TFile implementations may need to change it ; Definition at line 5222 of file TFile.cxx. ◆ GetBytesWritten(). Long64_t TFile::GetBytesWritten ; (; ); const. virtual . Return the total number of bytes written so far to the file. ; Definition at line 4566 of file TFile.cxx. ◆ GetCacheFileDir(). const char * TFile::GetCacheFileDir ; (; ). static . Get the directory where to locally stage/cache remote files. ; Definition at line 4654 of file TFile.cxx. ◆ GetCacheRead(). TFileCacheRead * TFile::GetCacheRead ; (; const TObject * ; tree = nullptr); const. Return a pointer to the current read cache. ; Definition at line 1262 of file TFile.cxx. ◆ GetCacheWrite(). TFileCacheWrite * TFile::GetCacheWrite ; (; ); const. Return a pointer to the current write cache. ; Definition at line 1279 of file TFile.cxx. ◆ GetClassIndex(). TArrayC * TFile::GetClassIndex ; (; ); const. inline . Definition at line 226 of file TFile.h. ◆ GetCompressionAlgorithm(). Int_t TFile::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 385 of file TFile.h. ◆ GetCompressionFactor(). Float_t TFile::GetCompressionFactor ; (; ). Return the file compression factor. ; Add total number of compressed/uncompressed bytes for each key. Returns the ratio of the two. ; Definition at line 1202 of file TFile.cxx. ◆ GetCompressionLevel(). Int_t TFile::GetCompressionLevel ; (; ); const. inline . Definition at line 391 of file TFile.h. ◆ GetCompressionSettings(). Int_t TFile::GetCompressionSettings ; (; ); const. inline . Definition at line 397 of file TFile.h. ◆ GetEND(). virtual Long64_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:63370,cache,cache,63370,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,1,['cache'],['cache']
Performance,"(). virtual RooFit::OwningPtr< RooArgSet > RooAbsCachedReal::actualObservables ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooCachedReal, and RooNumRunningInt. ◆ actualParameters(). virtual RooFit::OwningPtr< RooArgSet > RooAbsCachedReal::actualParameters ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooCachedReal, and RooNumRunningInt. ◆ analyticalIntegralWN(). double RooAbsCachedReal::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Forward call to implementation in relevant RooHistFunc instance. ; Reimplemented from RooAbsReal.; Definition at line 320 of file RooAbsCachedReal.cxx. ◆ binningName(). virtual const char * RooAbsCachedReal::binningName ; (; ); const. inlineprotectedvirtual . Reimplemented in RooNumRunningInt.; Definition at line 96 of file RooAbsCachedReal.h. ◆ cacheNameSuffix(). TString RooAbsCachedReal::cacheNameSuffix ; (; const RooArgSet & ; nset); const. protected . Construct unique suffix name for cache p.d.f object. ; Definition at line 225 of file RooAbsCachedReal.cxx. ◆ Class(). static TClass * RooAbsCachedReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCachedReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCachedReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 120 of file RooAbsCachedReal.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooAbsCachedReal::createCache ; (; const RooArgSet * ; nset); const. protectedvirtual . Interface function to create an internal cache object that represent each cached function configuration. ; This interface allows to create and return a class derived from RooAbsCachedReal::FuncCacheElem so that a derived class fillCacheObject implementation can utilize extra functionality de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:63867,cache,cacheNameSuffix,63867,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['cache'],['cacheNameSuffix']
Performance,"(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:39765,Load,LoadTree,39765,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,1,['Load'],['LoadTree']
Performance,"(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:37559,Load,LoadTree,37559,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,2,['Load'],['LoadTree']
Performance,"(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");; ch.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:36963,Load,LoadTree,36963,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,1,['Load'],['LoadTree']
Performance,"(); Destructor. Bool_t IsStaged(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue a stage request for file defined by 'path'. The string 'opt'; defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for file defined by 'path'. The string 'opt'; defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". void GetPrefix(const char* url, TString& pfx); Isolate prefix in url. void Print(Option_t* option = """") const; Print basic info about this stager. Int_t Locate(const char* path, TString& endpath); Get actual end-point url for a path; Returns 0 in case of success and 1 if any error occured. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. A noop prepare command is; issued beforehand to fill redirector's cache, then Locate() is issued on; each file. Results are saved back to the input collection: when a file is; found, the staged bit is set to on, and its endpoint URL is added, if; different from the redirector's URL. If a file is not found, the staged; bit is set to off.; If addDummyUrl is kTRUE, in case file is not staged or redirector is; identical to endpoint URL, a dummy URL is prepended, respectively:; ""noop://redir"" and ""noop://none"".; If the collection contains URLs with ""anchors"" (i.e., #fileName.root),; they are ignored by xrootd.; The Locate() command preserves anchors, but needs single paths to be full; URLs beginning with root://.; Returns < 0 in case of errors, and the number of files processed in case; of success. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager.; Avoids multiple instantiations of the potentially the same TXNetSystem. TXNetFileStager(const char* stager = """"). Bool_t IsValid() const; { return (fSystem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFileStager.html:7984,cache,cache,7984,root/html602/TXNetFileStager.html,https://root.cern,https://root.cern/root/html602/TXNetFileStager.html,2,['cache'],['cache']
Performance,"(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:18288,optimiz,optimizeCacheMode,18288,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,1,['optimiz'],['optimizeCacheMode']
Performance,"(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:19219,optimiz,optimizeCacheMode,19219,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,12,['optimiz'],['optimizeCacheMode']
Performance,"(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsReal&operator=(const RooAbsReal&); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:18688,optimiz,optimizeCacheMode,18688,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,2,['optimiz'],['optimizeCacheMode']
Performance,"(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html:3555,cache,cache,3555,root/html528/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance,"(); Removes previously defined convolution window, reverting to convolution from -inf to +inf. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); Restrict convolution integral to finite range [ x - C - S*W, x - C + S*W ]; where x is current value of convolution variablem, C = centerParam, W=widthParam and S = widthScaleFactor; Inputs centerParam and withParam can be function expressions (RooAbsReal, RooFormulaVar) etc. void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig() const; { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvolution.html:38281,perform,performance,38281,root/html528/RooNumConvolution.html,https://root.cern,https://root.cern/root/html528/RooNumConvolution.html,6,['perform'],['performance']
Performance,"(); Removes previously defined convolution window, reverting to convolution from -inf to +inf. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); Restrict convolution integral to finite range [ x - C - S*W, x - C + S*W ]; where x is current value of convolution variablem, C = centerParam, W=widthParam and S = widthScaleFactor; Inputs centerParam and withParam can be function expressions (RooAbsReal, RooFormulaVar) etc. void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:38040,perform,performance,38040,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,1,['perform'],['performance']
Performance,"(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; Float_t*GetX(); virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitBranches(Long64_t entry); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); char*MakeX(Int_t nvars); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookTree.html:11140,Load,LoadBaskets,11140,root/html528/THbookTree.html,https://root.cern,https://root.cern/root/html528/THbookTree.html,1,['Load'],['LoadBaskets']
Performance,"(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; Float_t*GetX(); virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitBranches(Long64_t entry); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); char*MakeX(Int_t nvars); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THbookTree.html:11262,Load,LoadBaskets,11262,root/html530/THbookTree.html,https://root.cern,https://root.cern/root/html530/THbookTree.html,5,['Load'],['LoadBaskets']
Performance,"(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsSelfCachedReal&operator=(const RooAbsSelfCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedReal.html:20040,optimiz,optimizeCacheMode,20040,root/html602/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedReal.html,2,['optimiz'],['optimizeCacheMode']
Performance,"(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRecursiveFraction&operator=(const RooRecursiveFraction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRecursiveFraction.html:19404,optimiz,optimizeCacheMode,19404,root/html602/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html,2,['optimiz'],['optimizeCacheMode']
Performance,"(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(const Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:12492,cache,cacheDir,12492,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,2,['cache'],['cacheDir']
